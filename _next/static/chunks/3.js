(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[3],{

/***/ "./node_modules/jspdf/dist/jspdf.node.debug.js":
/*!*****************************************************!*\
  !*** ./node_modules/jspdf/dist/jspdf.node.debug.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_RESULT__;\n\n/** @license\r\n * jsPDF - PDF Document creation from JavaScript\r\n * Version 1.5.3 Built on 2018-12-27T14:11:50.068Z\r\n *                      CommitID d93d28db14\r\n *\r\n * Copyright (c) 2010-2016 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF\r\n *               2010 Aaron Spike, https://github.com/acspike\r\n *               2012 Willow Systems Corporation, willow-systems.com\r\n *               2012 Pablo Hess, https://github.com/pablohess\r\n *               2012 Florian Jenett, https://github.com/fjenett\r\n *               2013 Warren Weckesser, https://github.com/warrenweckesser\r\n *               2013 Youssef Beddad, https://github.com/lifof\r\n *               2013 Lee Driscoll, https://github.com/lsdriscoll\r\n *               2013 Stefan Slonevskiy, https://github.com/stefslon\r\n *               2013 Jeremy Morel, https://github.com/jmorel\r\n *               2013 Christoph Hartmann, https://github.com/chris-rock\r\n *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria\r\n *               2014 James Makes, https://github.com/dollaruw\r\n *               2014 Diego Casorran, https://github.com/diegocr\r\n *               2014 Steven Spungin, https://github.com/Flamenco\r\n *               2014 Kenneth Glassey, https://github.com/Gavvers\r\n *\r\n * Licensed under the MIT License\r\n *\r\n * Contributor(s):\r\n *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,\r\n *    kim3er, mfo, alnorth, Flamenco\r\n */\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n/**\n * Creates new jsPDF document object instance.\n * @name jsPDF\n * @class\n * @param orientation {string/Object} Orientation of the first page. Possible values are \"portrait\" or \"landscape\" (or shortcuts \"p\" (Default), \"l\").<br />\n * Can also be an options object.\n * @param unit {string}  Measurement unit to be used when coordinates are specified.<br />\n * Possible values are \"pt\" (points), \"mm\" (Default), \"cm\", \"in\" or \"px\".\n * @param format {string/Array} The format of the first page. Can be:<ul><li>a0 - a10</li><li>b0 - b10</li><li>c0 - c10</li><li>dl</li><li>letter</li><li>government-letter</li><li>legal</li><li>junior-legal</li><li>ledger</li><li>tabloid</li><li>credit-card</li></ul><br />\n * Default is \"a4\". If you want to use your own format just pass instead of one of the above predefined formats the size as an number-array, e.g. [595.28, 841.89]\n * @returns {jsPDF} jsPDF-instance\n * @description\n * If the first parameter (orientation) is an object, it will be interpreted as an object of named parameters\n * ```\n * {\n *  orientation: 'p',\n *  unit: 'mm',\n *  format: 'a4',\n *  hotfixes: [] // an array of hotfix strings to enable\n * }\n * ```\n */\nvar jsPDF = function (global) {\n  /**\n   * jsPDF's Internal PubSub Implementation.\n   * Backward compatible rewritten on 2014 by\n   * Diego Casorran, https://github.com/diegocr\n   *\n   * @class\n   * @name PubSub\n   * @ignore\n   */\n\n  function PubSub(context) {\n    if (_typeof(context) !== 'object') {\n      throw new Error('Invalid Context passed to initialize PubSub (jsPDF-module)');\n    }\n\n    var topics = {};\n\n    this.subscribe = function (topic, callback, once) {\n      once = once || false;\n\n      if (typeof topic !== 'string' || typeof callback !== 'function' || typeof once !== 'boolean') {\n        throw new Error('Invalid arguments passed to PubSub.subscribe (jsPDF-module)');\n      }\n\n      if (!topics.hasOwnProperty(topic)) {\n        topics[topic] = {};\n      }\n\n      var token = Math.random().toString(35);\n      topics[topic][token] = [callback, !!once];\n      return token;\n    };\n\n    this.unsubscribe = function (token) {\n      for (var topic in topics) {\n        if (topics[topic][token]) {\n          delete topics[topic][token];\n\n          if (Object.keys(topics[topic]).length === 0) {\n            delete topics[topic];\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    this.publish = function (topic) {\n      if (topics.hasOwnProperty(topic)) {\n        var args = Array.prototype.slice.call(arguments, 1),\n            tokens = [];\n\n        for (var token in topics[topic]) {\n          var sub = topics[topic][token];\n\n          try {\n            sub[0].apply(context, args);\n          } catch (ex) {\n            if (global.console) {\n              console.error('jsPDF PubSub Error', ex.message, ex);\n            }\n          }\n\n          if (sub[1]) tokens.push(token);\n        }\n\n        if (tokens.length) tokens.forEach(this.unsubscribe);\n      }\n    };\n\n    this.getTopics = function () {\n      return topics;\n    };\n  }\n  /**\n   * @constructor\n   * @private\n   */\n\n\n  function jsPDF(orientation, unit, format, compressPdf) {\n    var options = {};\n    var filters = [];\n    var userUnit = 1.0;\n\n    if (_typeof(orientation) === 'object') {\n      options = orientation;\n      orientation = options.orientation;\n      unit = options.unit || unit;\n      format = options.format || format;\n      compressPdf = options.compress || options.compressPdf || compressPdf;\n      filters = options.filters || (compressPdf === true ? ['FlateEncode'] : filters);\n      userUnit = typeof options.userUnit === \"number\" ? Math.abs(options.userUnit) : 1.0;\n    }\n\n    unit = unit || 'mm';\n    orientation = ('' + (orientation || 'P')).toLowerCase();\n    var putOnlyUsedFonts = options.putOnlyUsedFonts || true;\n    var usedFonts = {};\n    var API = {\n      internal: {},\n      __private__: {}\n    };\n    API.__private__.PubSub = PubSub;\n    var pdfVersion = '1.3';\n\n    var getPdfVersion = API.__private__.getPdfVersion = function () {\n      return pdfVersion;\n    };\n\n    var setPdfVersion = API.__private__.setPdfVersion = function (value) {\n      pdfVersion = value;\n    }; // Size in pt of various paper formats\n\n\n    var pageFormats = {\n      'a0': [2383.94, 3370.39],\n      'a1': [1683.78, 2383.94],\n      'a2': [1190.55, 1683.78],\n      'a3': [841.89, 1190.55],\n      'a4': [595.28, 841.89],\n      'a5': [419.53, 595.28],\n      'a6': [297.64, 419.53],\n      'a7': [209.76, 297.64],\n      'a8': [147.40, 209.76],\n      'a9': [104.88, 147.40],\n      'a10': [73.70, 104.88],\n      'b0': [2834.65, 4008.19],\n      'b1': [2004.09, 2834.65],\n      'b2': [1417.32, 2004.09],\n      'b3': [1000.63, 1417.32],\n      'b4': [708.66, 1000.63],\n      'b5': [498.90, 708.66],\n      'b6': [354.33, 498.90],\n      'b7': [249.45, 354.33],\n      'b8': [175.75, 249.45],\n      'b9': [124.72, 175.75],\n      'b10': [87.87, 124.72],\n      'c0': [2599.37, 3676.54],\n      'c1': [1836.85, 2599.37],\n      'c2': [1298.27, 1836.85],\n      'c3': [918.43, 1298.27],\n      'c4': [649.13, 918.43],\n      'c5': [459.21, 649.13],\n      'c6': [323.15, 459.21],\n      'c7': [229.61, 323.15],\n      'c8': [161.57, 229.61],\n      'c9': [113.39, 161.57],\n      'c10': [79.37, 113.39],\n      'dl': [311.81, 623.62],\n      'letter': [612, 792],\n      'government-letter': [576, 756],\n      'legal': [612, 1008],\n      'junior-legal': [576, 360],\n      'ledger': [1224, 792],\n      'tabloid': [792, 1224],\n      'credit-card': [153, 243]\n    };\n\n    var getPageFormats = API.__private__.getPageFormats = function () {\n      return pageFormats;\n    };\n\n    var getPageFormat = API.__private__.getPageFormat = function (value) {\n      return pageFormats[value];\n    };\n\n    if (typeof format === \"string\") {\n      format = getPageFormat(format);\n    }\n\n    format = format || getPageFormat('a4');\n\n    var f2 = API.f2 = API.__private__.f2 = function (number) {\n      if (isNaN(number)) {\n        throw new Error('Invalid argument passed to jsPDF.f2');\n      }\n\n      return number.toFixed(2); // Ie, %.2f\n    };\n\n    var f3 = API.__private__.f3 = function (number) {\n      if (isNaN(number)) {\n        throw new Error('Invalid argument passed to jsPDF.f3');\n      }\n\n      return number.toFixed(3); // Ie, %.3f\n    };\n\n    var fileId = '00000000000000000000000000000000';\n\n    var getFileId = API.__private__.getFileId = function () {\n      return fileId;\n    };\n\n    var setFileId = API.__private__.setFileId = function (value) {\n      value = value || \"12345678901234567890123456789012\".split('').map(function () {\n        return \"ABCDEF0123456789\".charAt(Math.floor(Math.random() * 16));\n      }).join('');\n      fileId = value;\n      return fileId;\n    };\n    /**\n     * @name setFileId\n     * @memberOf jsPDF\n     * @function\n     * @instance\n     * @param {string} value GUID.\n     * @returns {jsPDF}\n     */\n\n\n    API.setFileId = function (value) {\n      setFileId(value);\n      return this;\n    };\n    /**\n     * @name getFileId\n     * @memberOf jsPDF\n     * @function\n     * @instance\n     *\n     * @returns {string} GUID.\n     */\n\n\n    API.getFileId = function () {\n      return getFileId();\n    };\n\n    var creationDate;\n\n    var convertDateToPDFDate = API.__private__.convertDateToPDFDate = function (parmDate) {\n      var result = '';\n      var tzoffset = parmDate.getTimezoneOffset(),\n          tzsign = tzoffset < 0 ? '+' : '-',\n          tzhour = Math.floor(Math.abs(tzoffset / 60)),\n          tzmin = Math.abs(tzoffset % 60),\n          timeZoneString = [tzsign, padd2(tzhour), \"'\", padd2(tzmin), \"'\"].join('');\n      result = ['D:', parmDate.getFullYear(), padd2(parmDate.getMonth() + 1), padd2(parmDate.getDate()), padd2(parmDate.getHours()), padd2(parmDate.getMinutes()), padd2(parmDate.getSeconds()), timeZoneString].join('');\n      return result;\n    };\n\n    var convertPDFDateToDate = API.__private__.convertPDFDateToDate = function (parmPDFDate) {\n      var year = parseInt(parmPDFDate.substr(2, 4), 10);\n      var month = parseInt(parmPDFDate.substr(6, 2), 10) - 1;\n      var date = parseInt(parmPDFDate.substr(8, 2), 10);\n      var hour = parseInt(parmPDFDate.substr(10, 2), 10);\n      var minutes = parseInt(parmPDFDate.substr(12, 2), 10);\n      var seconds = parseInt(parmPDFDate.substr(14, 2), 10);\n      var timeZoneHour = parseInt(parmPDFDate.substr(16, 2), 10);\n      var timeZoneMinutes = parseInt(parmPDFDate.substr(20, 2), 10);\n      var resultingDate = new Date(year, month, date, hour, minutes, seconds, 0);\n      return resultingDate;\n    };\n\n    var setCreationDate = API.__private__.setCreationDate = function (date) {\n      var tmpCreationDateString;\n      var regexPDFCreationDate = /^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\\+0[0-9]|\\+1[0-4]|\\-0[0-9]|\\-1[0-1])\\'(0[0-9]|[1-5][0-9])\\'?$/;\n\n      if (typeof date === \"undefined\") {\n        date = new Date();\n      }\n\n      if (_typeof(date) === \"object\" && Object.prototype.toString.call(date) === \"[object Date]\") {\n        tmpCreationDateString = convertDateToPDFDate(date);\n      } else if (regexPDFCreationDate.test(date)) {\n        tmpCreationDateString = date;\n      } else {\n        throw new Error('Invalid argument passed to jsPDF.setCreationDate');\n      }\n\n      creationDate = tmpCreationDateString;\n      return creationDate;\n    };\n\n    var getCreationDate = API.__private__.getCreationDate = function (type) {\n      var result = creationDate;\n\n      if (type === \"jsDate\") {\n        result = convertPDFDateToDate(creationDate);\n      }\n\n      return result;\n    };\n    /**\n     * @name setCreationDate\n     * @memberOf jsPDF\n     * @function\n     * @instance\n     * @param {Object} date\n     * @returns {jsPDF}\n     */\n\n\n    API.setCreationDate = function (date) {\n      setCreationDate(date);\n      return this;\n    };\n    /**\n     * @name getCreationDate\n     * @memberOf jsPDF\n     * @function\n     * @instance\n     * @param {Object} type\n     * @returns {Object}\n     */\n\n\n    API.getCreationDate = function (type) {\n      return getCreationDate(type);\n    };\n\n    var padd2 = API.__private__.padd2 = function (number) {\n      return ('0' + parseInt(number)).slice(-2);\n    };\n\n    var outToPages = !1; // switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content\n\n    var pages = [];\n    var content = [];\n    var currentPage;\n    var content_length = 0;\n    var customOutputDestination;\n\n    var setOutputDestination = API.__private__.setCustomOutputDestination = function (destination) {\n      customOutputDestination = destination;\n    };\n\n    var resetOutputDestination = API.__private__.resetCustomOutputDestination = function (destination) {\n      customOutputDestination = undefined;\n    };\n\n    var out = API.__private__.out = function (string) {\n      var writeArray;\n      string = typeof string === \"string\" ? string : string.toString();\n\n      if (typeof customOutputDestination === \"undefined\") {\n        writeArray = outToPages ? pages[currentPage] : content;\n      } else {\n        writeArray = customOutputDestination;\n      }\n\n      writeArray.push(string);\n\n      if (!outToPages) {\n        content_length += string.length + 1;\n      }\n\n      return writeArray;\n    };\n\n    var write = API.__private__.write = function (value) {\n      return out(arguments.length === 1 ? value.toString() : Array.prototype.join.call(arguments, ' '));\n    };\n\n    var getArrayBuffer = API.__private__.getArrayBuffer = function (data) {\n      var len = data.length,\n          ab = new ArrayBuffer(len),\n          u8 = new Uint8Array(ab);\n\n      while (len--) {\n        u8[len] = data.charCodeAt(len);\n      }\n\n      return ab;\n    };\n\n    var standardFonts = [['Helvetica', \"helvetica\", \"normal\", 'WinAnsiEncoding'], ['Helvetica-Bold', \"helvetica\", \"bold\", 'WinAnsiEncoding'], ['Helvetica-Oblique', \"helvetica\", \"italic\", 'WinAnsiEncoding'], ['Helvetica-BoldOblique', \"helvetica\", \"bolditalic\", 'WinAnsiEncoding'], ['Courier', \"courier\", \"normal\", 'WinAnsiEncoding'], ['Courier-Bold', \"courier\", \"bold\", 'WinAnsiEncoding'], ['Courier-Oblique', \"courier\", \"italic\", 'WinAnsiEncoding'], ['Courier-BoldOblique', \"courier\", \"bolditalic\", 'WinAnsiEncoding'], ['Times-Roman', \"times\", \"normal\", 'WinAnsiEncoding'], ['Times-Bold', \"times\", \"bold\", 'WinAnsiEncoding'], ['Times-Italic', \"times\", \"italic\", 'WinAnsiEncoding'], ['Times-BoldItalic', \"times\", \"bolditalic\", 'WinAnsiEncoding'], ['ZapfDingbats', \"zapfdingbats\", \"normal\", null], ['Symbol', \"symbol\", \"normal\", null]];\n\n    var getStandardFonts = API.__private__.getStandardFonts = function (data) {\n      return standardFonts;\n    };\n\n    var activeFontSize = options.fontSize || 16;\n    /**\n     * Sets font size for upcoming text elements.\n     *\n     * @param {number} size Font size in points.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setFontSize\n     */\n\n    var setFontSize = API.__private__.setFontSize = API.setFontSize = function (size) {\n      activeFontSize = size;\n      return this;\n    };\n    /**\n     * Gets the fontsize for upcoming text elements.\n     *\n     * @function\n     * @instance\n     * @returns {number}\n     * @memberOf jsPDF\n     * @name getFontSize\n     */\n\n\n    var getFontSize = API.__private__.getFontSize = API.getFontSize = function () {\n      return activeFontSize;\n    };\n\n    var R2L = options.R2L || false;\n    /**\n     * Set value of R2L functionality.\n     *\n     * @param {boolean} value\n     * @function\n     * @instance\n     * @returns {jsPDF} jsPDF-instance\n     * @memberOf jsPDF\n     * @name setR2L\n     */\n\n    var setR2L = API.__private__.setR2L = API.setR2L = function (value) {\n      R2L = value;\n      return this;\n    };\n    /**\n     * Get value of R2L functionality.\n     *\n     * @function\n     * @instance\n     * @returns {boolean} jsPDF-instance\n     * @memberOf jsPDF\n     * @name getR2L\n     */\n\n\n    var getR2L = API.__private__.getR2L = API.getR2L = function (value) {\n      return R2L;\n    };\n\n    var zoomMode; // default: 1;\n\n    var setZoomMode = API.__private__.setZoomMode = function (zoom) {\n      var validZoomModes = [undefined, null, 'fullwidth', 'fullheight', 'fullpage', 'original'];\n\n      if (/^\\d*\\.?\\d*\\%$/.test(zoom)) {\n        zoomMode = zoom;\n      } else if (!isNaN(zoom)) {\n        zoomMode = parseInt(zoom, 10);\n      } else if (validZoomModes.indexOf(zoom) !== -1) {\n        zoomMode = zoom;\n      } else {\n        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. \"' + zoom + '\" is not recognized.');\n      }\n    };\n\n    var getZoomMode = API.__private__.getZoomMode = function () {\n      return zoomMode;\n    };\n\n    var pageMode; // default: 'UseOutlines';\n\n    var setPageMode = API.__private__.setPageMode = function (pmode) {\n      var validPageModes = [undefined, null, 'UseNone', 'UseOutlines', 'UseThumbs', 'FullScreen'];\n\n      if (validPageModes.indexOf(pmode) == -1) {\n        throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. \"' + pmode + '\" is not recognized.');\n      }\n\n      pageMode = pmode;\n    };\n\n    var getPageMode = API.__private__.getPageMode = function () {\n      return pageMode;\n    };\n\n    var layoutMode; // default: 'continuous';\n\n    var setLayoutMode = API.__private__.setLayoutMode = function (layout) {\n      var validLayoutModes = [undefined, null, 'continuous', 'single', 'twoleft', 'tworight', 'two'];\n\n      if (validLayoutModes.indexOf(layout) == -1) {\n        throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. \"' + layout + '\" is not recognized.');\n      }\n\n      layoutMode = layout;\n    };\n\n    var getLayoutMode = API.__private__.getLayoutMode = function () {\n      return layoutMode;\n    };\n    /**\n     * Set the display mode options of the page like zoom and layout.\n     *\n     * @name setDisplayMode\n     * @memberOf jsPDF\n     * @function \n     * @instance\n     * @param {integer|String} zoom   You can pass an integer or percentage as\n     * a string. 2 will scale the document up 2x, '200%' will scale up by the\n     * same amount. You can also set it to 'fullwidth', 'fullheight',\n     * 'fullpage', or 'original'.\n     *\n     * Only certain PDF readers support this, such as Adobe Acrobat.\n     *\n     * @param {string} layout Layout mode can be: 'continuous' - this is the\n     * default continuous scroll. 'single' - the single page mode only shows one\n     * page at a time. 'twoleft' - two column left mode, first page starts on\n     * the left, and 'tworight' - pages are laid out in two columns, with the\n     * first page on the right. This would be used for books.\n     * @param {string} pmode 'UseOutlines' - it shows the\n     * outline of the document on the left. 'UseThumbs' - shows thumbnails along\n     * the left. 'FullScreen' - prompts the user to enter fullscreen mode.\n     *\n     * @returns {jsPDF}\n     */\n\n\n    var setDisplayMode = API.__private__.setDisplayMode = API.setDisplayMode = function (zoom, layout, pmode) {\n      setZoomMode(zoom);\n      setLayoutMode(layout);\n      setPageMode(pmode);\n      return this;\n    };\n\n    var documentProperties = {\n      'title': '',\n      'subject': '',\n      'author': '',\n      'keywords': '',\n      'creator': ''\n    };\n\n    var getDocumentProperty = API.__private__.getDocumentProperty = function (key) {\n      if (Object.keys(documentProperties).indexOf(key) === -1) {\n        throw new Error('Invalid argument passed to jsPDF.getDocumentProperty');\n      }\n\n      return documentProperties[key];\n    };\n\n    var getDocumentProperties = API.__private__.getDocumentProperties = function (properties) {\n      return documentProperties;\n    };\n    /**\n     * Adds a properties to the PDF document.\n     *\n     * @param {Object} A property_name-to-property_value object structure.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setDocumentProperties\n     */\n\n\n    var setDocumentProperties = API.__private__.setDocumentProperties = API.setProperties = API.setDocumentProperties = function (properties) {\n      // copying only those properties we can render.\n      for (var property in documentProperties) {\n        if (documentProperties.hasOwnProperty(property) && properties[property]) {\n          documentProperties[property] = properties[property];\n        }\n      }\n\n      return this;\n    };\n\n    var setDocumentProperty = API.__private__.setDocumentProperty = function (key, value) {\n      if (Object.keys(documentProperties).indexOf(key) === -1) {\n        throw new Error('Invalid arguments passed to jsPDF.setDocumentProperty');\n      }\n\n      return documentProperties[key] = value;\n    };\n\n    var objectNumber = 0; // 'n' Current object number\n\n    var offsets = []; // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.\n\n    var fonts = {}; // collection of font objects, where key is fontKey - a dynamically created label for a given font.\n\n    var fontmap = {}; // mapping structure fontName > fontStyle > font key - performance layer. See addFont()\n\n    var activeFontKey; // will be string representing the KEY of the font as combination of fontName + fontStyle\n\n    var k; // Scale factor\n\n    var page = 0;\n    var pagesContext = [];\n    var additionalObjects = [];\n    var events = new PubSub(API);\n    var hotfixes = options.hotfixes || [];\n\n    var newObject = API.__private__.newObject = function () {\n      var oid = newObjectDeferred();\n      newObjectDeferredBegin(oid, true);\n      return oid;\n    }; // Does not output the object.  The caller must call newObjectDeferredBegin(oid) before outputing any data\n\n\n    var newObjectDeferred = API.__private__.newObjectDeferred = function () {\n      objectNumber++;\n\n      offsets[objectNumber] = function () {\n        return content_length;\n      };\n\n      return objectNumber;\n    };\n\n    var newObjectDeferredBegin = function newObjectDeferredBegin(oid, doOutput) {\n      doOutput = typeof doOutput === 'boolean' ? doOutput : false;\n      offsets[oid] = content_length;\n\n      if (doOutput) {\n        out(oid + ' 0 obj');\n      }\n\n      return oid;\n    }; // Does not output the object until after the pages have been output.\n    // Returns an object containing the objectId and content.\n    // All pages have been added so the object ID can be estimated to start right after.\n    // This does not modify the current objectNumber;  It must be updated after the newObjects are output.\n\n\n    var newAdditionalObject = API.__private__.newAdditionalObject = function () {\n      var objId = newObjectDeferred();\n      var obj = {\n        objId: objId,\n        content: ''\n      };\n      additionalObjects.push(obj);\n      return obj;\n    };\n\n    var rootDictionaryObjId = newObjectDeferred();\n    var resourceDictionaryObjId = newObjectDeferred(); /////////////////////\n    // Private functions\n    /////////////////////\n\n    var decodeColorString = API.__private__.decodeColorString = function (color) {\n      var colorEncoded = color.split(' ');\n\n      if (colorEncoded.length === 2 && (colorEncoded[1] === 'g' || colorEncoded[1] === 'G')) {\n        // convert grayscale value to rgb so that it can be converted to hex for consistency\n        var floatVal = parseFloat(colorEncoded[0]);\n        colorEncoded = [floatVal, floatVal, floatVal, 'r'];\n      }\n\n      var colorAsRGB = '#';\n\n      for (var i = 0; i < 3; i++) {\n        colorAsRGB += ('0' + Math.floor(parseFloat(colorEncoded[i]) * 255).toString(16)).slice(-2);\n      }\n\n      return colorAsRGB;\n    };\n\n    var encodeColorString = API.__private__.encodeColorString = function (options) {\n      var color;\n\n      if (typeof options === \"string\") {\n        options = {\n          ch1: options\n        };\n      }\n\n      var ch1 = options.ch1;\n      var ch2 = options.ch2;\n      var ch3 = options.ch3;\n      var ch4 = options.ch4;\n      var precision = options.precision;\n      var letterArray = options.pdfColorType === \"draw\" ? ['G', 'RG', 'K'] : ['g', 'rg', 'k'];\n\n      if (typeof ch1 === \"string\" && ch1.charAt(0) !== '#') {\n        var rgbColor = new RGBColor(ch1);\n\n        if (rgbColor.ok) {\n          ch1 = rgbColor.toHex();\n        } else if (!/^\\d*\\.?\\d*$/.test(ch1)) {\n          throw new Error('Invalid color \"' + ch1 + '\" passed to jsPDF.encodeColorString.');\n        }\n      } //convert short rgb to long form\n\n\n      if (typeof ch1 === \"string\" && /^#[0-9A-Fa-f]{3}$/.test(ch1)) {\n        ch1 = '#' + ch1[1] + ch1[1] + ch1[2] + ch1[2] + ch1[3] + ch1[3];\n      }\n\n      if (typeof ch1 === \"string\" && /^#[0-9A-Fa-f]{6}$/.test(ch1)) {\n        var hex = parseInt(ch1.substr(1), 16);\n        ch1 = hex >> 16 & 255;\n        ch2 = hex >> 8 & 255;\n        ch3 = hex & 255;\n      }\n\n      if (typeof ch2 === \"undefined\" || typeof ch4 === \"undefined\" && ch1 === ch2 && ch2 === ch3) {\n        // Gray color space.\n        if (typeof ch1 === \"string\") {\n          color = ch1 + \" \" + letterArray[0];\n        } else {\n          switch (options.precision) {\n            case 2:\n              color = f2(ch1 / 255) + \" \" + letterArray[0];\n              break;\n\n            case 3:\n            default:\n              color = f3(ch1 / 255) + \" \" + letterArray[0];\n          }\n        }\n      } else if (typeof ch4 === \"undefined\" || _typeof(ch4) === \"object\") {\n        // assume RGBA\n        if (ch4 && !isNaN(ch4.a)) {\n          //TODO Implement transparency.\n          //WORKAROUND use white for now, if transparent, otherwise handle as rgb\n          if (ch4.a === 0) {\n            color = ['1.000', '1.000', '1.000', letterArray[1]].join(\" \");\n            return color;\n          }\n        } // assume RGB\n\n\n        if (typeof ch1 === \"string\") {\n          color = [ch1, ch2, ch3, letterArray[1]].join(\" \");\n        } else {\n          switch (options.precision) {\n            case 2:\n              color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), letterArray[1]].join(\" \");\n              break;\n\n            default:\n            case 3:\n              color = [f3(ch1 / 255), f3(ch2 / 255), f3(ch3 / 255), letterArray[1]].join(\" \");\n          }\n        }\n      } else {\n        // assume CMYK\n        if (typeof ch1 === 'string') {\n          color = [ch1, ch2, ch3, ch4, letterArray[2]].join(\" \");\n        } else {\n          switch (options.precision) {\n            case 2:\n              color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), f2(ch4 / 255), letterArray[2]].join(\" \");\n              break;\n\n            case 3:\n            default:\n              color = [f3(ch1 / 255), f3(ch2 / 255), f3(ch3 / 255), f3(ch4 / 255), letterArray[2]].join(\" \");\n          }\n        }\n      }\n\n      return color;\n    };\n\n    var getFilters = API.__private__.getFilters = function () {\n      return filters;\n    };\n\n    var putStream = API.__private__.putStream = function (options) {\n      options = options || {};\n      var data = options.data || '';\n      var filters = options.filters || getFilters();\n      var alreadyAppliedFilters = options.alreadyAppliedFilters || [];\n      var addLength1 = options.addLength1 || false;\n      var valueOfLength1 = data.length;\n      var processedData = {};\n\n      if (filters === true) {\n        filters = ['FlateEncode'];\n      }\n\n      var keyValues = options.additionalKeyValues || [];\n\n      if (typeof jsPDF.API.processDataByFilters !== 'undefined') {\n        processedData = jsPDF.API.processDataByFilters(data, filters);\n      } else {\n        processedData = {\n          data: data,\n          reverseChain: []\n        };\n      }\n\n      var filterAsString = processedData.reverseChain + (Array.isArray(alreadyAppliedFilters) ? alreadyAppliedFilters.join(' ') : alreadyAppliedFilters.toString());\n\n      if (processedData.data.length !== 0) {\n        keyValues.push({\n          key: 'Length',\n          value: processedData.data.length\n        });\n\n        if (addLength1 === true) {\n          keyValues.push({\n            key: 'Length1',\n            value: valueOfLength1\n          });\n        }\n      }\n\n      if (filterAsString.length != 0) {\n        //if (filters.length === 0 && alreadyAppliedFilters.length === 1 && typeof alreadyAppliedFilters !== \"undefined\") {\n        if (filterAsString.split('/').length - 1 === 1) {\n          keyValues.push({\n            key: 'Filter',\n            value: filterAsString\n          });\n        } else {\n          keyValues.push({\n            key: 'Filter',\n            value: '[' + filterAsString + ']'\n          });\n        }\n      }\n\n      out('<<');\n\n      for (var i = 0; i < keyValues.length; i++) {\n        out('/' + keyValues[i].key + ' ' + keyValues[i].value);\n      }\n\n      out('>>');\n\n      if (processedData.data.length !== 0) {\n        out('stream');\n        out(processedData.data);\n        out('endstream');\n      }\n    };\n\n    var putPage = API.__private__.putPage = function (page) {\n      var mediaBox = page.mediaBox;\n      var pageNumber = page.number;\n      var data = page.data;\n      var pageObjectNumber = page.objId;\n      var pageContentsObjId = page.contentsObjId;\n      newObjectDeferredBegin(pageObjectNumber, true);\n      var wPt = pagesContext[currentPage].mediaBox.topRightX - pagesContext[currentPage].mediaBox.bottomLeftX;\n      var hPt = pagesContext[currentPage].mediaBox.topRightY - pagesContext[currentPage].mediaBox.bottomLeftY;\n      out('<</Type /Page');\n      out('/Parent ' + page.rootDictionaryObjId + ' 0 R');\n      out('/Resources ' + page.resourceDictionaryObjId + ' 0 R');\n      out('/MediaBox [' + parseFloat(f2(page.mediaBox.bottomLeftX)) + ' ' + parseFloat(f2(page.mediaBox.bottomLeftY)) + ' ' + f2(page.mediaBox.topRightX) + ' ' + f2(page.mediaBox.topRightY) + ']');\n\n      if (page.cropBox !== null) {\n        out('/CropBox [' + f2(page.cropBox.bottomLeftX) + ' ' + f2(page.cropBox.bottomLeftY) + ' ' + f2(page.cropBox.topRightX) + ' ' + f2(page.cropBox.topRightY) + ']');\n      }\n\n      if (page.bleedBox !== null) {\n        out('/BleedBox [' + f2(page.bleedBox.bottomLeftX) + ' ' + f2(page.bleedBox.bottomLeftY) + ' ' + f2(page.bleedBox.topRightX) + ' ' + f2(page.bleedBox.topRightY) + ']');\n      }\n\n      if (page.trimBox !== null) {\n        out('/TrimBox [' + f2(page.trimBox.bottomLeftX) + ' ' + f2(page.trimBox.bottomLeftY) + ' ' + f2(page.trimBox.topRightX) + ' ' + f2(page.trimBox.topRightY) + ']');\n      }\n\n      if (page.artBox !== null) {\n        out('/ArtBox [' + f2(page.artBox.bottomLeftX) + ' ' + f2(page.artBox.bottomLeftY) + ' ' + f2(page.artBox.topRightX) + ' ' + f2(page.artBox.topRightY) + ']');\n      }\n\n      if (typeof page.userUnit === \"number\" && page.userUnit !== 1.0) {\n        out('/UserUnit ' + page.userUnit);\n      }\n\n      events.publish('putPage', {\n        objId: pageObjectNumber,\n        pageContext: pagesContext[pageNumber],\n        pageNumber: pageNumber,\n        page: data\n      });\n      out('/Contents ' + pageContentsObjId + ' 0 R');\n      out('>>');\n      out('endobj'); // Page content\n\n      var pageContent = data.join('\\n');\n      newObjectDeferredBegin(pageContentsObjId, true);\n      putStream({\n        data: pageContent,\n        filters: getFilters()\n      });\n      out('endobj');\n      return pageObjectNumber;\n    };\n\n    var putPages = API.__private__.putPages = function () {\n      var n,\n          i,\n          pageObjectNumbers = [];\n\n      for (n = 1; n <= page; n++) {\n        pagesContext[n].objId = newObjectDeferred();\n        pagesContext[n].contentsObjId = newObjectDeferred();\n      }\n\n      for (n = 1; n <= page; n++) {\n        pageObjectNumbers.push(putPage({\n          number: n,\n          data: pages[n],\n          objId: pagesContext[n].objId,\n          contentsObjId: pagesContext[n].contentsObjId,\n          mediaBox: pagesContext[n].mediaBox,\n          cropBox: pagesContext[n].cropBox,\n          bleedBox: pagesContext[n].bleedBox,\n          trimBox: pagesContext[n].trimBox,\n          artBox: pagesContext[n].artBox,\n          userUnit: pagesContext[n].userUnit,\n          rootDictionaryObjId: rootDictionaryObjId,\n          resourceDictionaryObjId: resourceDictionaryObjId\n        }));\n      }\n\n      newObjectDeferredBegin(rootDictionaryObjId, true);\n      out('<</Type /Pages');\n      var kids = '/Kids [';\n\n      for (i = 0; i < page; i++) {\n        kids += pageObjectNumbers[i] + ' 0 R ';\n      }\n\n      out(kids + ']');\n      out('/Count ' + page);\n      out('>>');\n      out('endobj');\n      events.publish('postPutPages');\n    };\n\n    var putFont = function putFont(font) {\n      events.publish('putFont', {\n        font: font,\n        out: out,\n        newObject: newObject,\n        putStream: putStream\n      });\n\n      if (font.isAlreadyPutted !== true) {\n        font.objectNumber = newObject();\n        out('<<');\n        out('/Type /Font');\n        out('/BaseFont /' + font.postScriptName);\n        out('/Subtype /Type1');\n\n        if (typeof font.encoding === 'string') {\n          out('/Encoding /' + font.encoding);\n        }\n\n        out('/FirstChar 32');\n        out('/LastChar 255');\n        out('>>');\n        out('endobj');\n      }\n    };\n\n    var putFonts = function putFonts() {\n      for (var fontKey in fonts) {\n        if (fonts.hasOwnProperty(fontKey)) {\n          if (putOnlyUsedFonts === false || putOnlyUsedFonts === true && usedFonts.hasOwnProperty(fontKey)) {\n            putFont(fonts[fontKey]);\n          }\n        }\n      }\n    };\n\n    var putResourceDictionary = function putResourceDictionary() {\n      out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');\n      out('/Font <<'); // Do this for each font, the '1' bit is the index of the font\n\n      for (var fontKey in fonts) {\n        if (fonts.hasOwnProperty(fontKey)) {\n          if (putOnlyUsedFonts === false || putOnlyUsedFonts === true && usedFonts.hasOwnProperty(fontKey)) {\n            out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');\n          }\n        }\n      }\n\n      out('>>');\n      out('/XObject <<');\n      events.publish('putXobjectDict');\n      out('>>');\n    };\n\n    var putResources = function putResources() {\n      putFonts();\n      events.publish('putResources');\n      newObjectDeferredBegin(resourceDictionaryObjId, true);\n      out('<<');\n      putResourceDictionary();\n      out('>>');\n      out('endobj');\n      events.publish('postPutResources');\n    };\n\n    var putAdditionalObjects = function putAdditionalObjects() {\n      events.publish('putAdditionalObjects');\n\n      for (var i = 0; i < additionalObjects.length; i++) {\n        var obj = additionalObjects[i];\n        newObjectDeferredBegin(obj.objId, true);\n        out(obj.content);\n        out('endobj');\n      }\n\n      events.publish('postPutAdditionalObjects');\n    };\n\n    var addToFontDictionary = function addToFontDictionary(fontKey, fontName, fontStyle) {\n      // this is mapping structure for quick font key lookup.\n      // returns the KEY of the font (ex: \"F1\") for a given\n      // pair of font name and type (ex: \"Arial\". \"Italic\")\n      if (!fontmap.hasOwnProperty(fontName)) {\n        fontmap[fontName] = {};\n      }\n\n      fontmap[fontName][fontStyle] = fontKey;\n    };\n\n    var addFont = function addFont(postScriptName, fontName, fontStyle, encoding, isStandardFont) {\n      isStandardFont = isStandardFont || false;\n      var fontKey = 'F' + (Object.keys(fonts).length + 1).toString(10),\n          // This is FontObject\n      font = {\n        'id': fontKey,\n        'postScriptName': postScriptName,\n        'fontName': fontName,\n        'fontStyle': fontStyle,\n        'encoding': encoding,\n        'isStandardFont': isStandardFont,\n        'metadata': {}\n      };\n      var instance = this;\n      events.publish('addFont', {\n        font: font,\n        instance: instance\n      });\n\n      if (fontKey !== undefined) {\n        fonts[fontKey] = font;\n        addToFontDictionary(fontKey, fontName, fontStyle);\n      }\n\n      return fontKey;\n    };\n\n    var addFonts = function addFonts(arrayOfFonts) {\n      for (var i = 0, l = standardFonts.length; i < l; i++) {\n        var fontKey = addFont(arrayOfFonts[i][0], arrayOfFonts[i][1], arrayOfFonts[i][2], standardFonts[i][3], true);\n        usedFonts[fontKey] = true; // adding aliases for standard fonts, this time matching the capitalization\n\n        var parts = arrayOfFonts[i][0].split('-');\n        addToFontDictionary(fontKey, parts[0], parts[1] || '');\n      }\n\n      events.publish('addFonts', {\n        fonts: fonts,\n        dictionary: fontmap\n      });\n    };\n\n    var SAFE = function __safeCall(fn) {\n      fn.foo = function __safeCallWrapper() {\n        try {\n          return fn.apply(this, arguments);\n        } catch (e) {\n          var stack = e.stack || '';\n          if (~stack.indexOf(' at ')) stack = stack.split(\" at \")[1];\n          var m = \"Error in function \" + stack.split(\"\\n\")[0].split('<')[0] + \": \" + e.message;\n\n          if (global.console) {\n            global.console.error(m, e);\n            if (global.alert) alert(m);\n          } else {\n            throw new Error(m);\n          }\n        }\n      };\n\n      fn.foo.bar = fn;\n      return fn.foo;\n    };\n\n    var to8bitStream = function to8bitStream(text, flags) {\n      /**\n       * PDF 1.3 spec:\n       * \"For text strings encoded in Unicode, the first two bytes must be 254 followed by\n       * 255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts\n       * with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely\n       * to be a meaningful beginning of a word or phrase.) The remainder of the\n       * string consists of Unicode character codes, according to the UTF-16 encoding\n       * specified in the Unicode standard, version 2.0. Commonly used Unicode values\n       * are represented as 2 bytes per character, with the high-order byte appearing first\n       * in the string.\"\n       *\n       * In other words, if there are chars in a string with char code above 255, we\n       * recode the string to UCS2 BE - string doubles in length and BOM is prepended.\n       *\n       * HOWEVER!\n       * Actual *content* (body) text (as opposed to strings used in document properties etc)\n       * does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)\n       *\n       * Because of Adobe's focus on \"you subset your fonts!\" you are not supposed to have\n       * a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could\n       * fudge it with \"Identity-H\" encoding and custom CIDtoGID map that mimics Unicode\n       * code page. There, however, all characters in the stream are treated as GIDs,\n       * including BOM, which is the reason we need to skip BOM in content text (i.e. that\n       * that is tied to a font).\n       *\n       * To signal this \"special\" PDFEscape / to8bitStream handling mode,\n       * API.text() function sets (unless you overwrite it with manual values\n       * given to API.text(.., flags) )\n       * flags.autoencode = true\n       * flags.noBOM = true\n       *\n       * ===================================================================================\n       * `flags` properties relied upon:\n       *   .sourceEncoding = string with encoding label.\n       *                     \"Unicode\" by default. = encoding of the incoming text.\n       *                     pass some non-existing encoding name\n       *                     (ex: 'Do not touch my strings! I know what I am doing.')\n       *                     to make encoding code skip the encoding step.\n       *   .outputEncoding = Either valid PDF encoding name\n       *                     (must be supported by jsPDF font metrics, otherwise no encoding)\n       *                     or a JS object, where key = sourceCharCode, value = outputCharCode\n       *                     missing keys will be treated as: sourceCharCode === outputCharCode\n       *   .noBOM\n       *       See comment higher above for explanation for why this is important\n       *   .autoencode\n       *       See comment higher above for explanation for why this is important\n       */\n      var i, l, sourceEncoding, encodingBlock, outputEncoding, newtext, isUnicode, ch, bch;\n      flags = flags || {};\n      sourceEncoding = flags.sourceEncoding || 'Unicode';\n      outputEncoding = flags.outputEncoding; // This 'encoding' section relies on font metrics format\n      // attached to font objects by, among others,\n      // \"Willow Systems' standard_font_metrics plugin\"\n      // see jspdf.plugin.standard_font_metrics.js for format\n      // of the font.metadata.encoding Object.\n      // It should be something like\n      //   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}\n      //   .widths = {0:width, code:width, ..., 'fof':divisor}\n      //   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}\n\n      if ((flags.autoencode || outputEncoding) && fonts[activeFontKey].metadata && fonts[activeFontKey].metadata[sourceEncoding] && fonts[activeFontKey].metadata[sourceEncoding].encoding) {\n        encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding; // each font has default encoding. Some have it clearly defined.\n\n        if (!outputEncoding && fonts[activeFontKey].encoding) {\n          outputEncoding = fonts[activeFontKey].encoding;\n        } // Hmmm, the above did not work? Let's try again, in different place.\n\n\n        if (!outputEncoding && encodingBlock.codePages) {\n          outputEncoding = encodingBlock.codePages[0]; // let's say, first one is the default\n        }\n\n        if (typeof outputEncoding === 'string') {\n          outputEncoding = encodingBlock[outputEncoding];\n        } // we want output encoding to be a JS Object, where\n        // key = sourceEncoding's character code and\n        // value = outputEncoding's character code.\n\n\n        if (outputEncoding) {\n          isUnicode = false;\n          newtext = [];\n\n          for (i = 0, l = text.length; i < l; i++) {\n            ch = outputEncoding[text.charCodeAt(i)];\n\n            if (ch) {\n              newtext.push(String.fromCharCode(ch));\n            } else {\n              newtext.push(text[i]);\n            } // since we are looping over chars anyway, might as well\n            // check for residual unicodeness\n\n\n            if (newtext[i].charCodeAt(0) >> 8) {\n              /* more than 255 */\n              isUnicode = true;\n            }\n          }\n\n          text = newtext.join('');\n        }\n      }\n\n      i = text.length; // isUnicode may be set to false above. Hence the triple-equal to undefined\n\n      while (isUnicode === undefined && i !== 0) {\n        if (text.charCodeAt(i - 1) >> 8) {\n          /* more than 255 */\n          isUnicode = true;\n        }\n\n        i--;\n      }\n\n      if (!isUnicode) {\n        return text;\n      }\n\n      newtext = flags.noBOM ? [] : [254, 255];\n\n      for (i = 0, l = text.length; i < l; i++) {\n        ch = text.charCodeAt(i);\n        bch = ch >> 8; // divide by 256\n\n        if (bch >> 8) {\n          /* something left after dividing by 256 second time */\n          throw new Error(\"Character at position \" + i + \" of string '\" + text + \"' exceeds 16bits. Cannot be encoded into UCS-2 BE\");\n        }\n\n        newtext.push(bch);\n        newtext.push(ch - (bch << 8));\n      }\n\n      return String.fromCharCode.apply(undefined, newtext);\n    };\n\n    var pdfEscape = API.__private__.pdfEscape = API.pdfEscape = function (text, flags) {\n      /**\n       * Replace '/', '(', and ')' with pdf-safe versions\n       *\n       * Doing to8bitStream does NOT make this PDF display unicode text. For that\n       * we also need to reference a unicode font and embed it - royal pain in the rear.\n       *\n       * There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,\n       * which JavaScript Strings are happy to provide. So, while we still cannot display\n       * 2-byte characters property, at least CONDITIONALLY converting (entire string containing)\n       * 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF\n       * is still parseable.\n       * This will allow immediate support for unicode in document properties strings.\n       */\n      return to8bitStream(text, flags).replace(/\\\\/g, '\\\\\\\\').replace(/\\(/g, '\\\\(').replace(/\\)/g, '\\\\)');\n    };\n\n    var beginPage = API.__private__.beginPage = function (width, height) {\n      var tmp; // Dimensions are stored as user units and converted to points on output\n\n      var orientation = typeof height === 'string' && height.toLowerCase();\n\n      if (typeof width === 'string') {\n        if (tmp = getPageFormat(width.toLowerCase())) {\n          width = tmp[0];\n          height = tmp[1];\n        }\n      }\n\n      if (Array.isArray(width)) {\n        height = width[1];\n        width = width[0];\n      }\n\n      if (isNaN(width) || isNaN(height)) {\n        width = format[0];\n        height = format[1];\n      }\n\n      if (orientation) {\n        switch (orientation.substr(0, 1)) {\n          case 'l':\n            if (height > width) orientation = 's';\n            break;\n\n          case 'p':\n            if (width > height) orientation = 's';\n            break;\n        }\n\n        if (orientation === 's') {\n          tmp = width;\n          width = height;\n          height = tmp;\n        }\n      }\n\n      if (width > 14400 || height > 14400) {\n        console.warn('A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400');\n        width = Math.min(14400, width);\n        height = Math.min(14400, height);\n      }\n\n      format = [width, height];\n      outToPages = true;\n      pages[++page] = [];\n      pagesContext[page] = {\n        objId: 0,\n        contentsObjId: 0,\n        userUnit: Number(userUnit),\n        artBox: null,\n        bleedBox: null,\n        cropBox: null,\n        trimBox: null,\n        mediaBox: {\n          bottomLeftX: 0,\n          bottomLeftY: 0,\n          topRightX: Number(width),\n          topRightY: Number(height)\n        }\n      };\n\n      _setPage(page);\n    };\n\n    var _addPage = function _addPage() {\n      beginPage.apply(this, arguments); // Set line width\n\n      setLineWidth(lineWidth); // Set draw color\n\n      out(strokeColor); // resurrecting non-default line caps, joins\n\n      if (lineCapID !== 0) {\n        out(lineCapID + ' J');\n      }\n\n      if (lineJoinID !== 0) {\n        out(lineJoinID + ' j');\n      }\n\n      events.publish('addPage', {\n        pageNumber: page\n      });\n    };\n\n    var _deletePage = function _deletePage(n) {\n      if (n > 0 && n <= page) {\n        pages.splice(n, 1);\n        page--;\n\n        if (currentPage > page) {\n          currentPage = page;\n        }\n\n        this.setPage(currentPage);\n      }\n    };\n\n    var _setPage = function _setPage(n) {\n      if (n > 0 && n <= page) {\n        currentPage = n;\n      }\n    };\n\n    var getNumberOfPages = API.__private__.getNumberOfPages = API.getNumberOfPages = function () {\n      return pages.length - 1;\n    };\n    /**\n     * Returns a document-specific font key - a label assigned to a\n     * font name + font type combination at the time the font was added\n     * to the font inventory.\n     *\n     * Font key is used as label for the desired font for a block of text\n     * to be added to the PDF document stream.\n     * @private\n     * @function\n     * @param fontName {string} can be undefined on \"falthy\" to indicate \"use current\"\n     * @param fontStyle {string} can be undefined on \"falthy\" to indicate \"use current\"\n     * @returns {string} Font key.\n     * @ignore\n     */\n\n\n    var _getFont = function getFont(fontName, fontStyle, options) {\n      var key = undefined,\n          fontNameLowerCase;\n      options = options || {};\n      fontName = fontName !== undefined ? fontName : fonts[activeFontKey].fontName;\n      fontStyle = fontStyle !== undefined ? fontStyle : fonts[activeFontKey].fontStyle;\n      fontNameLowerCase = fontName.toLowerCase();\n\n      if (fontmap[fontNameLowerCase] !== undefined && fontmap[fontNameLowerCase][fontStyle] !== undefined) {\n        key = fontmap[fontNameLowerCase][fontStyle];\n      } else if (fontmap[fontName] !== undefined && fontmap[fontName][fontStyle] !== undefined) {\n        key = fontmap[fontName][fontStyle];\n      } else {\n        if (options.disableWarning === false) {\n          console.warn(\"Unable to look up font label for font '\" + fontName + \"', '\" + fontStyle + \"'. Refer to getFontList() for available fonts.\");\n        }\n      }\n\n      if (!key && !options.noFallback) {\n        key = fontmap['times'][fontStyle];\n\n        if (key == null) {\n          key = fontmap['times']['normal'];\n        }\n      }\n\n      return key;\n    };\n\n    var putInfo = API.__private__.putInfo = function () {\n      newObject();\n      out('<<');\n      out('/Producer (jsPDF ' + jsPDF.version + ')');\n\n      for (var key in documentProperties) {\n        if (documentProperties.hasOwnProperty(key) && documentProperties[key]) {\n          out('/' + key.substr(0, 1).toUpperCase() + key.substr(1) + ' (' + pdfEscape(documentProperties[key]) + ')');\n        }\n      }\n\n      out('/CreationDate (' + creationDate + ')');\n      out('>>');\n      out('endobj');\n    };\n\n    var putCatalog = API.__private__.putCatalog = function (options) {\n      options = options || {};\n      var tmpRootDictionaryObjId = options.rootDictionaryObjId || rootDictionaryObjId;\n      newObject();\n      out('<<');\n      out('/Type /Catalog');\n      out('/Pages ' + tmpRootDictionaryObjId + ' 0 R'); // PDF13ref Section 7.2.1\n\n      if (!zoomMode) zoomMode = 'fullwidth';\n\n      switch (zoomMode) {\n        case 'fullwidth':\n          out('/OpenAction [3 0 R /FitH null]');\n          break;\n\n        case 'fullheight':\n          out('/OpenAction [3 0 R /FitV null]');\n          break;\n\n        case 'fullpage':\n          out('/OpenAction [3 0 R /Fit]');\n          break;\n\n        case 'original':\n          out('/OpenAction [3 0 R /XYZ null null 1]');\n          break;\n\n        default:\n          var pcn = '' + zoomMode;\n          if (pcn.substr(pcn.length - 1) === '%') zoomMode = parseInt(zoomMode) / 100;\n\n          if (typeof zoomMode === 'number') {\n            out('/OpenAction [3 0 R /XYZ null null ' + f2(zoomMode) + ']');\n          }\n\n      }\n\n      if (!layoutMode) layoutMode = 'continuous';\n\n      switch (layoutMode) {\n        case 'continuous':\n          out('/PageLayout /OneColumn');\n          break;\n\n        case 'single':\n          out('/PageLayout /SinglePage');\n          break;\n\n        case 'two':\n        case 'twoleft':\n          out('/PageLayout /TwoColumnLeft');\n          break;\n\n        case 'tworight':\n          out('/PageLayout /TwoColumnRight');\n          break;\n      }\n\n      if (pageMode) {\n        /**\n         * A name object specifying how the document should be displayed when opened:\n         * UseNone      : Neither document outline nor thumbnail images visible -- DEFAULT\n         * UseOutlines  : Document outline visible\n         * UseThumbs    : Thumbnail images visible\n         * FullScreen   : Full-screen mode, with no menu bar, window controls, or any other window visible\n         */\n        out('/PageMode /' + pageMode);\n      }\n\n      events.publish('putCatalog');\n      out('>>');\n      out('endobj');\n    };\n\n    var putTrailer = API.__private__.putTrailer = function () {\n      out('trailer');\n      out('<<');\n      out('/Size ' + (objectNumber + 1));\n      out('/Root ' + objectNumber + ' 0 R');\n      out('/Info ' + (objectNumber - 1) + ' 0 R');\n      out(\"/ID [ <\" + fileId + \"> <\" + fileId + \"> ]\");\n      out('>>');\n    };\n\n    var putHeader = API.__private__.putHeader = function () {\n      out('%PDF-' + pdfVersion);\n      out(\"%\\xBA\\xDF\\xAC\\xE0\");\n    };\n\n    var putXRef = API.__private__.putXRef = function () {\n      var i = 1;\n      var p = \"0000000000\";\n      out('xref');\n      out('0 ' + (objectNumber + 1));\n      out('0000000000 65535 f ');\n\n      for (i = 1; i <= objectNumber; i++) {\n        var offset = offsets[i];\n\n        if (typeof offset === 'function') {\n          out((p + offsets[i]()).slice(-10) + ' 00000 n ');\n        } else {\n          if (typeof offsets[i] !== \"undefined\") {\n            out((p + offsets[i]).slice(-10) + ' 00000 n ');\n          } else {\n            out('0000000000 00000 n ');\n          }\n        }\n      }\n    };\n\n    var buildDocument = API.__private__.buildDocument = function () {\n      outToPages = false; // switches out() to content\n      //reset fields relevant for objectNumber generation and xref.\n\n      objectNumber = 0;\n      content_length = 0;\n      content = [];\n      offsets = [];\n      additionalObjects = [];\n      rootDictionaryObjId = newObjectDeferred();\n      resourceDictionaryObjId = newObjectDeferred();\n      events.publish('buildDocument');\n      putHeader();\n      putPages();\n      putAdditionalObjects();\n      putResources();\n      putInfo();\n      putCatalog();\n      var offsetOfXRef = content_length;\n      putXRef();\n      putTrailer();\n      out('startxref');\n      out('' + offsetOfXRef);\n      out('%%EOF');\n      outToPages = true;\n      return content.join('\\n');\n    };\n\n    var getBlob = API.__private__.getBlob = function (data) {\n      return new Blob([getArrayBuffer(data)], {\n        type: \"application/pdf\"\n      });\n    };\n    /**\n     * Generates the PDF document.\n     *\n     * If `type` argument is undefined, output is raw body of resulting PDF returned as a string.\n     *\n     * @param {string} type A string identifying one of the possible output types. Possible values are 'arraybuffer', 'blob', 'bloburi'/'bloburl', 'datauristring'/'dataurlstring', 'datauri'/'dataurl', 'dataurlnewwindow'.\n     * @param {Object} options An object providing some additional signalling to PDF generator. Possible options are 'filename'.\n     *\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name output\n     */\n\n\n    var output = API.output = API.__private__.output = SAFE(function output(type, options) {\n      options = options || {};\n      var pdfDocument = buildDocument();\n\n      if (typeof options === \"string\") {\n        options = {\n          filename: options\n        };\n      } else {\n        options.filename = options.filename || 'generated.pdf';\n      }\n\n      switch (type) {\n        case undefined:\n          return pdfDocument;\n\n        case 'save':\n          API.save(options.filename);\n          break;\n\n        case 'arraybuffer':\n          return getArrayBuffer(pdfDocument);\n\n        case 'blob':\n          return getBlob(pdfDocument);\n\n        case 'bloburi':\n        case 'bloburl':\n          // Developer is responsible of calling revokeObjectURL\n          if (typeof global.URL !== \"undefined\" && typeof global.URL.createObjectURL === \"function\") {\n            return global.URL && global.URL.createObjectURL(getBlob(pdfDocument)) || void 0;\n          } else {\n            console.warn('bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.');\n          }\n\n          break;\n\n        case 'datauristring':\n        case 'dataurlstring':\n          return 'data:application/pdf;filename=' + options.filename + ';base64,' + btoa(pdfDocument);\n\n        case 'dataurlnewwindow':\n          var htmlForNewWindow = '<html>' + '<style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style>' + '<body>' + '<iframe src=\"' + this.output('datauristring') + '\"></iframe>' + '</body></html>';\n          var nW = global.open();\n\n          if (nW !== null) {\n            nW.document.write(htmlForNewWindow);\n          }\n\n          if (nW || typeof safari === \"undefined\") return nW;\n\n        /* pass through */\n\n        case 'datauri':\n        case 'dataurl':\n          return global.document.location.href = 'data:application/pdf;filename=' + options.filename + ';base64,' + btoa(pdfDocument);\n\n        default:\n          return null;\n      }\n    });\n    /**\n     * Used to see if a supplied hotfix was requested when the pdf instance was created.\n     * @param {string} hotfixName - The name of the hotfix to check.\n     * @returns {boolean}\n     */\n\n    var hasHotfix = function hasHotfix(hotfixName) {\n      return Array.isArray(hotfixes) === true && hotfixes.indexOf(hotfixName) > -1;\n    };\n\n    switch (unit) {\n      case 'pt':\n        k = 1;\n        break;\n\n      case 'mm':\n        k = 72 / 25.4;\n        break;\n\n      case 'cm':\n        k = 72 / 2.54;\n        break;\n\n      case 'in':\n        k = 72;\n        break;\n\n      case 'px':\n        if (hasHotfix('px_scaling') == true) {\n          k = 72 / 96;\n        } else {\n          k = 96 / 72;\n        }\n\n        break;\n\n      case 'pc':\n        k = 12;\n        break;\n\n      case 'em':\n        k = 12;\n        break;\n\n      case 'ex':\n        k = 6;\n        break;\n\n      default:\n        throw new Error('Invalid unit: ' + unit);\n    }\n\n    setCreationDate();\n    setFileId(); //---------------------------------------\n    // Public API\n\n    var getPageInfo = API.__private__.getPageInfo = function (pageNumberOneBased) {\n      if (isNaN(pageNumberOneBased) || pageNumberOneBased % 1 !== 0) {\n        throw new Error('Invalid argument passed to jsPDF.getPageInfo');\n      }\n\n      var objId = pagesContext[pageNumberOneBased].objId;\n      return {\n        objId: objId,\n        pageNumber: pageNumberOneBased,\n        pageContext: pagesContext[pageNumberOneBased]\n      };\n    };\n\n    var getPageInfoByObjId = API.__private__.getPageInfoByObjId = function (objId) {\n\n      for (var pageNumber in pagesContext) {\n        if (pagesContext[pageNumber].objId === objId) {\n          break;\n        }\n      }\n\n      if (isNaN(objId) || objId % 1 !== 0) {\n        throw new Error('Invalid argument passed to jsPDF.getPageInfoByObjId');\n      }\n\n      return getPageInfo(pageNumber);\n    };\n\n    var getCurrentPageInfo = API.__private__.getCurrentPageInfo = function () {\n      return {\n        objId: pagesContext[currentPage].objId,\n        pageNumber: currentPage,\n        pageContext: pagesContext[currentPage]\n      };\n    };\n    /**\n     * Adds (and transfers the focus to) new page to the PDF document.\n     * @param format {String/Array} The format of the new page. Can be: <ul><li>a0 - a10</li><li>b0 - b10</li><li>c0 - c10</li><li>dl</li><li>letter</li><li>government-letter</li><li>legal</li><li>junior-legal</li><li>ledger</li><li>tabloid</li><li>credit-card</li></ul><br />\n     * Default is \"a4\". If you want to use your own format just pass instead of one of the above predefined formats the size as an number-array, e.g. [595.28, 841.89]\n     * @param orientation {string} Orientation of the new page. Possible values are \"portrait\" or \"landscape\" (or shortcuts \"p\" (Default), \"l\").\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     *\n     * @memberOf jsPDF\n     * @name addPage\n     */\n\n\n    API.addPage = function () {\n      _addPage.apply(this, arguments);\n\n      return this;\n    };\n    /**\n     * Adds (and transfers the focus to) new page to the PDF document.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     *\n     * @memberOf jsPDF\n     * @name setPage\n     * @param {number} page Switch the active page to the page number specified.\n     * @example\n     * doc = jsPDF()\n     * doc.addPage()\n     * doc.addPage()\n     * doc.text('I am on page 3', 10, 10)\n     * doc.setPage(1)\n     * doc.text('I am on page 1', 10, 10)\n     */\n\n\n    API.setPage = function () {\n      _setPage.apply(this, arguments);\n\n      return this;\n    };\n    /**\n     * @name insertPage\n     * @memberOf jsPDF\n     * \n     * @function \n     * @instance\n     * @param {Object} beforePage\n     * @returns {jsPDF}\n     */\n\n\n    API.insertPage = function (beforePage) {\n      this.addPage();\n      this.movePage(currentPage, beforePage);\n      return this;\n    };\n    /**\n     * @name movePage\n     * @memberOf jsPDF\n     * @function\n     * @instance\n     * @param {Object} targetPage\n     * @param {Object} beforePage\n     * @returns {jsPDF}\n     */\n\n\n    API.movePage = function (targetPage, beforePage) {\n      if (targetPage > beforePage) {\n        var tmpPages = pages[targetPage];\n        var tmpPagesContext = pagesContext[targetPage];\n\n        for (var i = targetPage; i > beforePage; i--) {\n          pages[i] = pages[i - 1];\n          pagesContext[i] = pagesContext[i - 1];\n        }\n\n        pages[beforePage] = tmpPages;\n        pagesContext[beforePage] = tmpPagesContext;\n        this.setPage(beforePage);\n      } else if (targetPage < beforePage) {\n        var tmpPages = pages[targetPage];\n        var tmpPagesContext = pagesContext[targetPage];\n\n        for (var i = targetPage; i < beforePage; i++) {\n          pages[i] = pages[i + 1];\n          pagesContext[i] = pagesContext[i + 1];\n        }\n\n        pages[beforePage] = tmpPages;\n        pagesContext[beforePage] = tmpPagesContext;\n        this.setPage(beforePage);\n      }\n\n      return this;\n    };\n    /**\n     * Deletes a page from the PDF.\n     * @name deletePage\n     * @memberOf jsPDF\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     */\n\n\n    API.deletePage = function () {\n      _deletePage.apply(this, arguments);\n\n      return this;\n    };\n    /**\n     * Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.\n     *\n     * @function\n     * @instance\n     * @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.\n     * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page.\n     * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n     * @param {Object} [options] - Collection of settings signaling how the text must be encoded.\n     * @param {string} [options.align=left] - The alignment of the text, possible values: left, center, right, justify.\n     * @param {string} [options.baseline=alphabetic] - Sets text baseline used when drawing the text, possible values: alphabetic, ideographic, bottom, top, middle.\n     * @param {string} [options.angle=0] - Rotate the text counterclockwise. Expects the angle in degree.\n     * @param {string} [options.charSpace=0] - The space between each letter.\n     * @param {string} [options.lineHeightFactor=1.15] - The lineheight of each line.\n     * @param {string} [options.flags] - Flags for to8bitStream.\n     * @param {string} [options.flags.noBOM=true] - Don't add BOM to Unicode-text.\n     * @param {string} [options.flags.autoencode=true] - Autoencode the Text.\n     * @param {string} [options.maxWidth=0] - Split the text by given width, 0 = no split.\n     * @param {string} [options.renderingMode=fill] - Set how the text should be rendered, possible values: fill, stroke, fillThenStroke, invisible, fillAndAddForClipping, strokeAndAddPathForClipping, fillThenStrokeAndAddToPathForClipping, addToPathForClipping.\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name text\n     */\n\n\n    var text = API.__private__.text = API.text = function (text, x, y, options) {\n      /**\n       * Inserts something like this into PDF\n       *   BT\n       *    /F1 16 Tf  % Font name + size\n       *    16 TL % How many units down for next line in multiline text\n       *    0 g % color\n       *    28.35 813.54 Td % position\n       *    (line one) Tj\n       *    T* (line two) Tj\n       *    T* (line three) Tj\n       *   ET\n       */\n      //backwardsCompatibility\n      var tmp; // Pre-August-2012 the order of arguments was function(x, y, text, flags)\n      // in effort to make all calls have similar signature like\n      //   function(data, coordinates... , miscellaneous)\n      // this method had its args flipped.\n      // code below allows backward compatibility with old arg order.\n\n      if (typeof text === 'number' && typeof x === 'number' && (typeof y === 'string' || Array.isArray(y))) {\n        tmp = y;\n        y = x;\n        x = text;\n        text = tmp;\n      }\n\n      var flags = arguments[3];\n      var angle = arguments[4];\n      var align = arguments[5];\n\n      if (_typeof(flags) !== \"object\" || flags === null) {\n        if (typeof angle === 'string') {\n          align = angle;\n          angle = null;\n        }\n\n        if (typeof flags === 'string') {\n          align = flags;\n          flags = null;\n        }\n\n        if (typeof flags === 'number') {\n          angle = flags;\n          flags = null;\n        }\n\n        options = {\n          flags: flags,\n          angle: angle,\n          align: align\n        };\n      }\n\n      flags = flags || {};\n      flags.noBOM = flags.noBOM || true;\n      flags.autoencode = flags.autoencode || true;\n\n      if (isNaN(x) || isNaN(y) || typeof text === \"undefined\" || text === null) {\n        throw new Error('Invalid arguments passed to jsPDF.text');\n      }\n\n      if (text.length === 0) {\n        return scope;\n      }\n\n      var xtra = '';\n      var isHex = false;\n      var lineHeight = typeof options.lineHeightFactor === 'number' ? options.lineHeightFactor : lineHeightFactor;\n      var scope = options.scope || this;\n\n      function ESC(s) {\n        s = s.split(\"\\t\").join(Array(options.TabLen || 9).join(\" \"));\n        return pdfEscape(s, flags);\n      }\n\n      function transformTextToSpecialArray(text) {\n        //we don't want to destroy original text array, so cloning it\n        var sa = text.concat();\n        var da = [];\n        var len = sa.length;\n        var curDa; //we do array.join('text that must not be PDFescaped\")\n        //thus, pdfEscape each component separately\n\n        while (len--) {\n          curDa = sa.shift();\n\n          if (typeof curDa === \"string\") {\n            da.push(curDa);\n          } else {\n            if (Array.isArray(text) && curDa.length === 1) {\n              da.push(curDa[0]);\n            } else {\n              da.push([curDa[0], curDa[1], curDa[2]]);\n            }\n          }\n        }\n\n        return da;\n      }\n\n      function processTextByFunction(text, processingFunction) {\n        var result;\n\n        if (typeof text === 'string') {\n          result = processingFunction(text)[0];\n        } else if (Array.isArray(text)) {\n          //we don't want to destroy original text array, so cloning it\n          var sa = text.concat();\n          var da = [];\n          var len = sa.length;\n          var curDa;\n          var tmpResult; //we do array.join('text that must not be PDFescaped\")\n          //thus, pdfEscape each component separately\n\n          while (len--) {\n            curDa = sa.shift();\n\n            if (typeof curDa === \"string\") {\n              da.push(processingFunction(curDa)[0]);\n            } else if (Array.isArray(curDa) && curDa[0] === \"string\") {\n              tmpResult = processingFunction(curDa[0], curDa[1], curDa[2]);\n              da.push([tmpResult[0], tmpResult[1], tmpResult[2]]);\n            }\n          }\n\n          result = da;\n        }\n\n        return result;\n      } //Check if text is of type String\n\n\n      var textIsOfTypeString = false;\n      var tmpTextIsOfTypeString = true;\n\n      if (typeof text === 'string') {\n        textIsOfTypeString = true;\n      } else if (Array.isArray(text)) {\n        //we don't want to destroy original text array, so cloning it\n        var sa = text.concat();\n        var da = [];\n        var len = sa.length;\n        var curDa; //we do array.join('text that must not be PDFescaped\")\n        //thus, pdfEscape each component separately\n\n        while (len--) {\n          curDa = sa.shift();\n\n          if (typeof curDa !== \"string\" || Array.isArray(curDa) && typeof curDa[0] !== \"string\") {\n            tmpTextIsOfTypeString = false;\n          }\n        }\n\n        textIsOfTypeString = tmpTextIsOfTypeString;\n      }\n\n      if (textIsOfTypeString === false) {\n        throw new Error('Type of text must be string or Array. \"' + text + '\" is not recognized.');\n      } //Escaping \n\n\n      var activeFontEncoding = fonts[activeFontKey].encoding;\n\n      if (activeFontEncoding === \"WinAnsiEncoding\" || activeFontEncoding === \"StandardEncoding\") {\n        text = processTextByFunction(text, function (text, posX, posY) {\n          return [ESC(text), posX, posY];\n        });\n      } //If there are any newlines in text, we assume\n      //the user wanted to print multiple lines, so break the\n      //text up into an array. If the text is already an array,\n      //we assume the user knows what they are doing.\n      //Convert text into an array anyway to simplify\n      //later code.\n\n\n      if (typeof text === 'string') {\n        if (text.match(/[\\r?\\n]/)) {\n          text = text.split(/\\r\\n|\\r|\\n/g);\n        } else {\n          text = [text];\n        }\n      } //baseline\n\n\n      var height = activeFontSize / scope.internal.scaleFactor;\n      var descent = height * (lineHeightFactor - 1);\n\n      switch (options.baseline) {\n        case 'bottom':\n          y -= descent;\n          break;\n\n        case 'top':\n          y += height - descent;\n          break;\n\n        case 'hanging':\n          y += height - 2 * descent;\n          break;\n\n        case 'middle':\n          y += height / 2 - descent;\n          break;\n\n        case 'ideographic':\n        case 'alphabetic':\n        default:\n          // do nothing, everything is fine\n          break;\n      } //multiline\n\n\n      var maxWidth = options.maxWidth || 0;\n\n      if (maxWidth > 0) {\n        if (typeof text === 'string') {\n          text = scope.splitTextToSize(text, maxWidth);\n        } else if (Object.prototype.toString.call(text) === '[object Array]') {\n          text = scope.splitTextToSize(text.join(\" \"), maxWidth);\n        }\n      } //creating Payload-Object to make text byRef\n\n\n      var payload = {\n        text: text,\n        x: x,\n        y: y,\n        options: options,\n        mutex: {\n          pdfEscape: pdfEscape,\n          activeFontKey: activeFontKey,\n          fonts: fonts,\n          activeFontSize: activeFontSize\n        }\n      };\n      events.publish('preProcessText', payload);\n      text = payload.text;\n      options = payload.options; //angle\n\n      var angle = options.angle;\n      var k = scope.internal.scaleFactor;\n      var transformationMatrix = [];\n\n      if (angle) {\n        angle *= Math.PI / 180;\n        var c = Math.cos(angle),\n            s = Math.sin(angle);\n        transformationMatrix = [f2(c), f2(s), f2(s * -1), f2(c)];\n      } //charSpace\n\n\n      var charSpace = options.charSpace;\n\n      if (typeof charSpace !== 'undefined') {\n        xtra += f3(charSpace * k) + \" Tc\\n\";\n      } //lang\n\n\n      var lang = options.lang;\n      var tmpRenderingMode = -1;\n      var parmRenderingMode = typeof options.renderingMode !== \"undefined\" ? options.renderingMode : options.stroke;\n      var pageContext = scope.internal.getCurrentPageInfo().pageContext;\n\n      switch (parmRenderingMode) {\n        case 0:\n        case false:\n        case 'fill':\n          tmpRenderingMode = 0;\n          break;\n\n        case 1:\n        case true:\n        case 'stroke':\n          tmpRenderingMode = 1;\n          break;\n\n        case 2:\n        case 'fillThenStroke':\n          tmpRenderingMode = 2;\n          break;\n\n        case 3:\n        case 'invisible':\n          tmpRenderingMode = 3;\n          break;\n\n        case 4:\n        case 'fillAndAddForClipping':\n          tmpRenderingMode = 4;\n          break;\n\n        case 5:\n        case 'strokeAndAddPathForClipping':\n          tmpRenderingMode = 5;\n          break;\n\n        case 6:\n        case 'fillThenStrokeAndAddToPathForClipping':\n          tmpRenderingMode = 6;\n          break;\n\n        case 7:\n        case 'addToPathForClipping':\n          tmpRenderingMode = 7;\n          break;\n      }\n\n      var usedRenderingMode = typeof pageContext.usedRenderingMode !== 'undefined' ? pageContext.usedRenderingMode : -1; //if the coder wrote it explicitly to use a specific \n      //renderingMode, then use it\n\n      if (tmpRenderingMode !== -1) {\n        xtra += tmpRenderingMode + \" Tr\\n\"; //otherwise check if we used the rendering Mode already\n        //if so then set the rendering Mode...\n      } else if (usedRenderingMode !== -1) {\n        xtra += \"0 Tr\\n\";\n      }\n\n      if (tmpRenderingMode !== -1) {\n        pageContext.usedRenderingMode = tmpRenderingMode;\n      } //align\n\n\n      var align = options.align || 'left';\n      var leading = activeFontSize * lineHeight;\n      var pageWidth = scope.internal.pageSize.getWidth();\n      var k = scope.internal.scaleFactor;\n      var activeFont = fonts[activeFontKey];\n      var charSpace = options.charSpace || activeCharSpace;\n      var maxWidth = options.maxWidth || 0;\n      var lineWidths;\n      var flags = {};\n      var wordSpacingPerLine = [];\n\n      if (Object.prototype.toString.call(text) === '[object Array]') {\n        var da = transformTextToSpecialArray(text);\n        var newY;\n        var maxLineLength;\n        var lineWidths;\n\n        if (align !== \"left\") {\n          lineWidths = da.map(function (v) {\n            return scope.getStringUnitWidth(v, {\n              font: activeFont,\n              charSpace: charSpace,\n              fontSize: activeFontSize\n            }) * activeFontSize / k;\n          });\n        }\n\n        var maxLineLength = Math.max.apply(Math, lineWidths); //The first line uses the \"main\" Td setting,\n        //and the subsequent lines are offset by the\n        //previous line's x coordinate.\n\n        var prevWidth = 0;\n        var delta;\n        var newX;\n\n        if (align === \"right\") {\n          x -= lineWidths[0];\n          text = [];\n\n          for (var i = 0, len = da.length; i < len; i++) {\n            delta = maxLineLength - lineWidths[i];\n\n            if (i === 0) {\n              newX = getHorizontalCoordinate(x);\n              newY = getVerticalCoordinate(y);\n            } else {\n              newX = (prevWidth - lineWidths[i]) * k;\n              newY = -leading;\n            }\n\n            text.push([da[i], newX, newY]);\n            prevWidth = lineWidths[i];\n          }\n        } else if (align === \"center\") {\n          x -= lineWidths[0] / 2;\n          text = [];\n\n          for (var i = 0, len = da.length; i < len; i++) {\n            delta = (maxLineLength - lineWidths[i]) / 2;\n\n            if (i === 0) {\n              newX = getHorizontalCoordinate(x);\n              newY = getVerticalCoordinate(y);\n            } else {\n              newX = (prevWidth - lineWidths[i]) / 2 * k;\n              newY = -leading;\n            }\n\n            text.push([da[i], newX, newY]);\n            prevWidth = lineWidths[i];\n          }\n        } else if (align === \"left\") {\n          text = [];\n\n          for (var i = 0, len = da.length; i < len; i++) {\n            newY = i === 0 ? getVerticalCoordinate(y) : -leading;\n            newX = i === 0 ? getHorizontalCoordinate(x) : 0; //text.push([da[i], newX, newY]);\n\n            text.push(da[i]);\n          }\n        } else if (align === \"justify\") {\n          text = [];\n          var maxWidth = maxWidth !== 0 ? maxWidth : pageWidth;\n\n          for (var i = 0, len = da.length; i < len; i++) {\n            newY = i === 0 ? getVerticalCoordinate(y) : -leading;\n            newX = i === 0 ? getHorizontalCoordinate(x) : 0;\n\n            if (i < len - 1) {\n              wordSpacingPerLine.push(((maxWidth - lineWidths[i]) / (da[i].split(\" \").length - 1) * k).toFixed(2));\n            }\n\n            text.push([da[i], newX, newY]);\n          }\n        } else {\n          throw new Error('Unrecognized alignment option, use \"left\", \"center\", \"right\" or \"justify\".');\n        }\n      } //R2L\n\n\n      var doReversing = typeof options.R2L === \"boolean\" ? options.R2L : R2L;\n\n      if (doReversing === true) {\n        text = processTextByFunction(text, function (text, posX, posY) {\n          return [text.split(\"\").reverse().join(\"\"), posX, posY];\n        });\n      } //creating Payload-Object to make text byRef\n\n\n      var payload = {\n        text: text,\n        x: x,\n        y: y,\n        options: options,\n        mutex: {\n          pdfEscape: pdfEscape,\n          activeFontKey: activeFontKey,\n          fonts: fonts,\n          activeFontSize: activeFontSize\n        }\n      };\n      events.publish('postProcessText', payload);\n      text = payload.text;\n      isHex = payload.mutex.isHex;\n      var da = transformTextToSpecialArray(text);\n      text = [];\n      var variant = 0;\n      var len = da.length;\n      var posX;\n      var posY;\n      var content;\n      var wordSpacing = '';\n\n      for (var i = 0; i < len; i++) {\n        wordSpacing = '';\n\n        if (!Array.isArray(da[i])) {\n          posX = getHorizontalCoordinate(x);\n          posY = getVerticalCoordinate(y);\n          content = (isHex ? \"<\" : \"(\") + da[i] + (isHex ? \">\" : \")\");\n        } else {\n          posX = parseFloat(da[i][1]);\n          posY = parseFloat(da[i][2]);\n          content = (isHex ? \"<\" : \"(\") + da[i][0] + (isHex ? \">\" : \")\");\n          variant = 1;\n        }\n\n        if (wordSpacingPerLine !== undefined && wordSpacingPerLine[i] !== undefined) {\n          wordSpacing = wordSpacingPerLine[i] + \" Tw\\n\";\n        }\n\n        if (transformationMatrix.length !== 0 && i === 0) {\n          text.push(wordSpacing + transformationMatrix.join(\" \") + \" \" + posX.toFixed(2) + \" \" + posY.toFixed(2) + \" Tm\\n\" + content);\n        } else if (variant === 1 || variant === 0 && i === 0) {\n          text.push(wordSpacing + posX.toFixed(2) + \" \" + posY.toFixed(2) + \" Td\\n\" + content);\n        } else {\n          text.push(wordSpacing + content);\n        }\n      }\n\n      if (variant === 0) {\n        text = text.join(\" Tj\\nT* \");\n      } else {\n        text = text.join(\" Tj\\n\");\n      }\n\n      text += \" Tj\\n\";\n      var result = 'BT\\n/' + activeFontKey + ' ' + activeFontSize + ' Tf\\n' + // font face, style, size\n      (activeFontSize * lineHeight).toFixed(2) + ' TL\\n' + // line spacing\n      textColor + '\\n';\n      result += xtra;\n      result += text;\n      result += \"ET\";\n      out(result);\n      usedFonts[activeFontKey] = true;\n      return scope;\n    };\n    /**\n     * Letter spacing method to print text with gaps\n     *\n     * @function\n     * @instance\n     * @param {String|Array} text String to be added to the page.\n     * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page\n     * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n     * @param {number} spacing Spacing (in units declared at inception)\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name lstext\n     * @deprecated We'll be removing this function. It doesn't take character width into account.\n     */\n\n\n    var lstext = API.__private__.lstext = API.lstext = function (text, x, y, charSpace) {\n      console.warn('jsPDF.lstext is deprecated');\n      return this.text(text, x, y, {\n        charSpace: charSpace\n      });\n    };\n    /**\n     * \n     * @name clip\n     * @function\n     * @instance\n     * @param {string} rule \n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @description All .clip() after calling drawing ops with a style argument of null.\n     */\n\n\n    var clip = API.__private__.clip = API.clip = function (rule) {\n      // Call .clip() after calling drawing ops with a style argument of null\n      // W is the PDF clipping op\n      if ('evenodd' === rule) {\n        out('W*');\n      } else {\n        out('W');\n      } // End the path object without filling or stroking it.\n      // This operator is a path-painting no-op, used primarily for the side effect of changing the current clipping path\n      // (see Section 4.4.3, “Clipping Path Operators”)\n\n\n      out('n');\n    };\n    /**\n     * This fixes the previous function clip(). Perhaps the 'stroke path' hack was due to the missing 'n' instruction?\n     * We introduce the fixed version so as to not break API.\n     * @param fillRule\n     * @ignore\n     */\n\n\n    var clip_fixed = API.__private__.clip_fixed = API.clip_fixed = function (rule) {\n      console.log(\"clip_fixed is deprecated\");\n      API.clip(rule);\n    };\n\n    var isValidStyle = API.__private__.isValidStyle = function (style) {\n      var validStyleVariants = [undefined, null, 'S', 'F', 'DF', 'FD', 'f', 'f*', 'B', 'B*'];\n      var result = false;\n\n      if (validStyleVariants.indexOf(style) !== -1) {\n        result = true;\n      }\n\n      return result;\n    };\n\n    var getStyle = API.__private__.getStyle = function (style) {\n      // see path-painting operators in PDF spec\n      var op = 'S'; // stroke\n\n      if (style === 'F') {\n        op = 'f'; // fill\n      } else if (style === 'FD' || style === 'DF') {\n        op = 'B'; // both\n      } else if (style === 'f' || style === 'f*' || style === 'B' || style === 'B*') {\n        /*\n         Allow direct use of these PDF path-painting operators:\n         - f    fill using nonzero winding number rule\n         - f*    fill using even-odd rule\n         - B    fill then stroke with fill using non-zero winding number rule\n         - B*    fill then stroke with fill using even-odd rule\n         */\n        op = style;\n      }\n\n      return op;\n    };\n    /**\n     * Draw a line on the current page.\n     *\n     * @name line\n     * @function \n     * @instance\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     */\n\n\n    var line = API.__private__.line = API.line = function (x1, y1, x2, y2) {\n      if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {\n        throw new Error('Invalid arguments passed to jsPDF.line');\n      }\n\n      return this.lines([[x2 - x1, y2 - y1]], x1, y1);\n    };\n    /**\n     * Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.\n     * All data points in `lines` are relative to last line origin.\n     * `x`, `y` become x1,y1 for first line / curve in the set.\n     * For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.\n     * For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.\n     *\n     * @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, [1,1], 'F', false) // line, line, bezier curve, line\n     * @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).\n     * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page.\n     * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n     * @param {number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.\n     * @param {string} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.\n     * @param {boolean} closed If true, the path is closed with a straight line from the end of the last curve to the starting point.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name lines\n     */\n\n\n    var lines = API.__private__.lines = API.lines = function (lines, x, y, scale, style, closed) {\n      var scalex, scaley, i, l, leg, x2, y2, x3, y3, x4, y4, tmp; // Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)\n      // in effort to make all calls have similar signature like\n      //   function(content, coordinateX, coordinateY , miscellaneous)\n      // this method had its args flipped.\n      // code below allows backward compatibility with old arg order.\n\n      if (typeof lines === 'number') {\n        tmp = y;\n        y = x;\n        x = lines;\n        lines = tmp;\n      }\n\n      scale = scale || [1, 1];\n      closed = closed || false;\n\n      if (isNaN(x) || isNaN(y) || !Array.isArray(lines) || !Array.isArray(scale) || !isValidStyle(style) || typeof closed !== 'boolean') {\n        throw new Error('Invalid arguments passed to jsPDF.lines');\n      } // starting point\n\n\n      out(f3(getHorizontalCoordinate(x)) + ' ' + f3(getVerticalCoordinate(y)) + ' m ');\n      scalex = scale[0];\n      scaley = scale[1];\n      l = lines.length; //, x2, y2 // bezier only. In page default measurement \"units\", *after* scaling\n      //, x3, y3 // bezier only. In page default measurement \"units\", *after* scaling\n      // ending point for all, lines and bezier. . In page default measurement \"units\", *after* scaling\n\n      x4 = x; // last / ending point = starting point for first item.\n\n      y4 = y; // last / ending point = starting point for first item.\n\n      for (i = 0; i < l; i++) {\n        leg = lines[i];\n\n        if (leg.length === 2) {\n          // simple line\n          x4 = leg[0] * scalex + x4; // here last x4 was prior ending point\n\n          y4 = leg[1] * scaley + y4; // here last y4 was prior ending point\n\n          out(f3(getHorizontalCoordinate(x4)) + ' ' + f3(getVerticalCoordinate(y4)) + ' l');\n        } else {\n          // bezier curve\n          x2 = leg[0] * scalex + x4; // here last x4 is prior ending point\n\n          y2 = leg[1] * scaley + y4; // here last y4 is prior ending point\n\n          x3 = leg[2] * scalex + x4; // here last x4 is prior ending point\n\n          y3 = leg[3] * scaley + y4; // here last y4 is prior ending point\n\n          x4 = leg[4] * scalex + x4; // here last x4 was prior ending point\n\n          y4 = leg[5] * scaley + y4; // here last y4 was prior ending point\n\n          out(f3(getHorizontalCoordinate(x2)) + ' ' + f3(getVerticalCoordinate(y2)) + ' ' + f3(getHorizontalCoordinate(x3)) + ' ' + f3(getVerticalCoordinate(y3)) + ' ' + f3(getHorizontalCoordinate(x4)) + ' ' + f3(getVerticalCoordinate(y4)) + ' c');\n        }\n      }\n\n      if (closed) {\n        out(' h');\n      } // stroking / filling / both the path\n\n\n      if (style !== null) {\n        out(getStyle(style));\n      }\n\n      return this;\n    };\n    /**\n     * Adds a rectangle to PDF.\n     *\n     * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page.\n     * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n     * @param {number} w Width (in units declared at inception of PDF document).\n     * @param {number} h Height (in units declared at inception of PDF document).\n     * @param {string} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name rect\n     */\n\n\n    var rect = API.__private__.rect = API.rect = function (x, y, w, h, style) {\n      if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h) || !isValidStyle(style)) {\n        throw new Error('Invalid arguments passed to jsPDF.rect');\n      }\n\n      out([f2(getHorizontalCoordinate(x)), f2(getVerticalCoordinate(y)), f2(w * k), f2(-h * k), 're'].join(' '));\n\n      if (style !== null) {\n        out(getStyle(style));\n      }\n\n      return this;\n    };\n    /**\n     * Adds a triangle to PDF.\n     *\n     * @param {number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page.\n     * @param {number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n     * @param {number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page.\n     * @param {number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n     * @param {number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page.\n     * @param {number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n     * @param {string} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name triangle\n     */\n\n\n    var triangle = API.__private__.triangle = API.triangle = function (x1, y1, x2, y2, x3, y3, style) {\n      if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2) || isNaN(x3) || isNaN(y3) || !isValidStyle(style)) {\n        throw new Error('Invalid arguments passed to jsPDF.triangle');\n      }\n\n      this.lines([[x2 - x1, y2 - y1], // vector to point 2\n      [x3 - x2, y3 - y2], // vector to point 3\n      [x1 - x3, y1 - y3] // closing vector back to point 1\n      ], x1, y1, // start of path\n      [1, 1], style, true);\n      return this;\n    };\n    /**\n     * Adds a rectangle with rounded corners to PDF.\n     *\n     * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page.\n     * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n     * @param {number} w Width (in units declared at inception of PDF document).\n     * @param {number} h Height (in units declared at inception of PDF document).\n     * @param {number} rx Radius along x axis (in units declared at inception of PDF document).\n     * @param {number} ry Radius along y axis (in units declared at inception of PDF document).\n     * @param {string} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name roundedRect\n     */\n\n\n    var roundedRect = API.__private__.roundedRect = API.roundedRect = function (x, y, w, h, rx, ry, style) {\n      if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h) || isNaN(rx) || isNaN(ry) || !isValidStyle(style)) {\n        throw new Error('Invalid arguments passed to jsPDF.roundedRect');\n      }\n\n      var MyArc = 4 / 3 * (Math.SQRT2 - 1);\n      this.lines([[w - 2 * rx, 0], [rx * MyArc, 0, rx, ry - ry * MyArc, rx, ry], [0, h - 2 * ry], [0, ry * MyArc, -(rx * MyArc), ry, -rx, ry], [-w + 2 * rx, 0], [-(rx * MyArc), 0, -rx, -(ry * MyArc), -rx, -ry], [0, -h + 2 * ry], [0, -(ry * MyArc), rx * MyArc, -ry, rx, -ry]], x + rx, y, // start of path\n      [1, 1], style);\n      return this;\n    };\n    /**\n     * Adds an ellipse to PDF.\n     *\n     * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page.\n     * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n     * @param {number} rx Radius along x axis (in units declared at inception of PDF document).\n     * @param {number} ry Radius along y axis (in units declared at inception of PDF document).\n     * @param {string} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name ellipse\n     */\n\n\n    var ellise = API.__private__.ellipse = API.ellipse = function (x, y, rx, ry, style) {\n      if (isNaN(x) || isNaN(y) || isNaN(rx) || isNaN(ry) || !isValidStyle(style)) {\n        throw new Error('Invalid arguments passed to jsPDF.ellipse');\n      }\n\n      var lx = 4 / 3 * (Math.SQRT2 - 1) * rx,\n          ly = 4 / 3 * (Math.SQRT2 - 1) * ry;\n      out([f2(getHorizontalCoordinate(x + rx)), f2(getVerticalCoordinate(y)), 'm', f2(getHorizontalCoordinate(x + rx)), f2(getVerticalCoordinate(y - ly)), f2(getHorizontalCoordinate(x + lx)), f2(getVerticalCoordinate(y - ry)), f2(getHorizontalCoordinate(x)), f2(getVerticalCoordinate(y - ry)), 'c'].join(' '));\n      out([f2(getHorizontalCoordinate(x - lx)), f2(getVerticalCoordinate(y - ry)), f2(getHorizontalCoordinate(x - rx)), f2(getVerticalCoordinate(y - ly)), f2(getHorizontalCoordinate(x - rx)), f2(getVerticalCoordinate(y)), 'c'].join(' '));\n      out([f2(getHorizontalCoordinate(x - rx)), f2(getVerticalCoordinate(y + ly)), f2(getHorizontalCoordinate(x - lx)), f2(getVerticalCoordinate(y + ry)), f2(getHorizontalCoordinate(x)), f2(getVerticalCoordinate(y + ry)), 'c'].join(' '));\n      out([f2(getHorizontalCoordinate(x + lx)), f2(getVerticalCoordinate(y + ry)), f2(getHorizontalCoordinate(x + rx)), f2(getVerticalCoordinate(y + ly)), f2(getHorizontalCoordinate(x + rx)), f2(getVerticalCoordinate(y)), 'c'].join(' '));\n\n      if (style !== null) {\n        out(getStyle(style));\n      }\n\n      return this;\n    };\n    /**\n     * Adds an circle to PDF.\n     *\n     * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page.\n     * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page.\n     * @param {number} r Radius (in units declared at inception of PDF document).\n     * @param {string} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name circle\n     */\n\n\n    var circle = API.__private__.circle = API.circle = function (x, y, r, style) {\n      if (isNaN(x) || isNaN(y) || isNaN(r) || !isValidStyle(style)) {\n        throw new Error('Invalid arguments passed to jsPDF.circle');\n      }\n\n      return this.ellipse(x, y, r, r, style);\n    };\n    /**\n     * Sets text font face, variant for upcoming text elements.\n     * See output of jsPDF.getFontList() for possible font names, styles.\n     *\n     * @param {string} fontName Font name or family. Example: \"times\".\n     * @param {string} fontStyle Font style or variant. Example: \"italic\".\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setFont\n     */\n\n\n    API.setFont = function (fontName, fontStyle) {\n      activeFontKey = _getFont(fontName, fontStyle, {\n        disableWarning: false\n      });\n      return this;\n    };\n    /**\n     * Switches font style or variant for upcoming text elements,\n     * while keeping the font face or family same.\n     * See output of jsPDF.getFontList() for possible font names, styles.\n     *\n     * @param {string} style Font style or variant. Example: \"italic\".\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setFontStyle\n     */\n\n\n    API.setFontStyle = API.setFontType = function (style) {\n      activeFontKey = _getFont(undefined, style); // if font is not found, the above line blows up and we never go further\n\n      return this;\n    };\n    /**\n     * Returns an object - a tree of fontName to fontStyle relationships available to\n     * active PDF document.\n     *\n     * @public\n     * @function\n     * @instance\n     * @returns {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }\n     * @memberOf jsPDF\n     * @name getFontList\n     */\n\n\n    var getFontList = API.__private__.getFontList = API.getFontList = function () {\n      // TODO: iterate over fonts array or return copy of fontmap instead in case more are ever added.\n      var list = {},\n          fontName,\n          fontStyle,\n          tmp;\n\n      for (fontName in fontmap) {\n        if (fontmap.hasOwnProperty(fontName)) {\n          list[fontName] = tmp = [];\n\n          for (fontStyle in fontmap[fontName]) {\n            if (fontmap[fontName].hasOwnProperty(fontStyle)) {\n              tmp.push(fontStyle);\n            }\n          }\n        }\n      }\n\n      return list;\n    };\n    /**\n     * Add a custom font to the current instance.\n     *\n     * @property {string} postScriptName PDF specification full name for the font.\n     * @property {string} id PDF-document-instance-specific label assinged to the font.\n     * @property {string} fontStyle Style of the Font.\n     * @property {Object} encoding Encoding_name-to-Font_metrics_object mapping.\n     * @function\n     * @instance\n     * @memberOf jsPDF\n     * @name addFont\n     */\n\n\n    API.addFont = function (postScriptName, fontName, fontStyle, encoding) {\n      encoding = encoding || 'Identity-H';\n      addFont.call(this, postScriptName, fontName, fontStyle, encoding);\n    };\n\n    var lineWidth = options.lineWidth || 0.200025; // 2mm\n\n    /**\n     * Sets line width for upcoming lines.\n     *\n     * @param {number} width Line width (in units declared at inception of PDF document).\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setLineWidth\n     */\n\n    var setLineWidth = API.__private__.setLineWidth = API.setLineWidth = function (width) {\n      out((width * k).toFixed(2) + ' w');\n      return this;\n    };\n    /**\n     * Sets the dash pattern for upcoming lines.\n     * \n     * To reset the settings simply call the method without any parameters.\n     * @param {array} dashArray The pattern of the line, expects numbers. \n     * @param {number} dashPhase The phase at which the dash pattern starts.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setLineDash\n     */\n\n\n    var setLineDash = API.__private__.setLineDash = jsPDF.API.setLineDash = function (dashArray, dashPhase) {\n      dashArray = dashArray || [];\n      dashPhase = dashPhase || 0;\n\n      if (isNaN(dashPhase) || !Array.isArray(dashArray)) {\n        throw new Error('Invalid arguments passed to jsPDF.setLineDash');\n      }\n\n      dashArray = dashArray.map(function (x) {\n        return (x * k).toFixed(3);\n      }).join(' ');\n      dashPhase = parseFloat((dashPhase * k).toFixed(3));\n      out('[' + dashArray + '] ' + dashPhase + ' d');\n      return this;\n    };\n\n    var lineHeightFactor;\n\n    var getLineHeight = API.__private__.getLineHeight = API.getLineHeight = function () {\n      return activeFontSize * lineHeightFactor;\n    };\n\n    var lineHeightFactor;\n\n    var getLineHeight = API.__private__.getLineHeight = API.getLineHeight = function () {\n      return activeFontSize * lineHeightFactor;\n    };\n    /**\n     * Sets the LineHeightFactor of proportion.\n     *\n     * @param {number} value LineHeightFactor value. Default: 1.15.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setLineHeightFactor\n     */\n\n\n    var setLineHeightFactor = API.__private__.setLineHeightFactor = API.setLineHeightFactor = function (value) {\n      value = value || 1.15;\n\n      if (typeof value === \"number\") {\n        lineHeightFactor = value;\n      }\n\n      return this;\n    };\n    /**\n     * Gets the LineHeightFactor, default: 1.15.\n     *\n     * @function\n     * @instance\n     * @returns {number} lineHeightFactor\n     * @memberOf jsPDF\n     * @name getLineHeightFactor\n     */\n\n\n    var getLineHeightFactor = API.__private__.getLineHeightFactor = API.getLineHeightFactor = function () {\n      return lineHeightFactor;\n    };\n\n    setLineHeightFactor(options.lineHeight);\n\n    var getHorizontalCoordinate = API.__private__.getHorizontalCoordinate = function (value) {\n      return value * k;\n    };\n\n    var getVerticalCoordinate = API.__private__.getVerticalCoordinate = function (value) {\n      return pagesContext[currentPage].mediaBox.topRightY - pagesContext[currentPage].mediaBox.bottomLeftY - value * k;\n    };\n\n    var getHorizontalCoordinateString = API.__private__.getHorizontalCoordinateString = function (value) {\n      return f2(value * k);\n    };\n\n    var getVerticalCoordinateString = API.__private__.getVerticalCoordinateString = function (value) {\n      return f2(pagesContext[currentPage].mediaBox.topRightY - pagesContext[currentPage].mediaBox.bottomLeftY - value * k);\n    };\n\n    var strokeColor = options.strokeColor || '0 G';\n    /**\n     *  Gets the stroke color for upcoming elements.\n     *\n     * @function\n     * @instance\n     * @returns {string} colorAsHex\n     * @memberOf jsPDF\n     * @name getDrawColor\n     */\n\n    var getStrokeColor = API.__private__.getStrokeColor = API.getDrawColor = function () {\n      return decodeColorString(strokeColor);\n    };\n    /**\n     * Sets the stroke color for upcoming elements.\n     *\n     * Depending on the number of arguments given, Gray, RGB, or CMYK\n     * color space is implied.\n     *\n     * When only ch1 is given, \"Gray\" color space is implied and it\n     * must be a value in the range from 0.00 (solid black) to to 1.00 (white)\n     * if values are communicated as String types, or in range from 0 (black)\n     * to 255 (white) if communicated as Number type.\n     * The RGB-like 0-255 range is provided for backward compatibility.\n     *\n     * When only ch1,ch2,ch3 are given, \"RGB\" color space is implied and each\n     * value must be in the range from 0.00 (minimum intensity) to to 1.00\n     * (max intensity) if values are communicated as String types, or\n     * from 0 (min intensity) to to 255 (max intensity) if values are communicated\n     * as Number types.\n     * The RGB-like 0-255 range is provided for backward compatibility.\n     *\n     * When ch1,ch2,ch3,ch4 are given, \"CMYK\" color space is implied and each\n     * value must be a in the range from 0.00 (0% concentration) to to\n     * 1.00 (100% concentration)\n     *\n     * Because JavaScript treats fixed point numbers badly (rounds to\n     * floating point nearest to binary representation) it is highly advised to\n     * communicate the fractional numbers as String types, not JavaScript Number type.\n     *\n     * @param {Number|String} ch1 Color channel value or {string} ch1 color value in hexadecimal, example: '#FFFFFF'.\n     * @param {Number|String} ch2 Color channel value.\n     * @param {Number|String} ch3 Color channel value.\n     * @param {Number|String} ch4 Color channel value.\n     *\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setDrawColor\n     */\n\n\n    var setStrokeColor = API.__private__.setStrokeColor = API.setDrawColor = function (ch1, ch2, ch3, ch4) {\n      var options = {\n        \"ch1\": ch1,\n        \"ch2\": ch2,\n        \"ch3\": ch3,\n        \"ch4\": ch4,\n        \"pdfColorType\": \"draw\",\n        \"precision\": 2\n      };\n      strokeColor = encodeColorString(options);\n      out(strokeColor);\n      return this;\n    };\n\n    var fillColor = options.fillColor || '0 g';\n    /**\n     * Gets the fill color for upcoming elements.\n     *\n     * @function\n     * @instance\n     * @returns {string} colorAsHex\n     * @memberOf jsPDF\n     * @name getFillColor\n     */\n\n    var getFillColor = API.__private__.getFillColor = API.getFillColor = function () {\n      return decodeColorString(fillColor);\n    };\n    /**\n     * Sets the fill color for upcoming elements.\n     *\n     * Depending on the number of arguments given, Gray, RGB, or CMYK\n     * color space is implied.\n     *\n     * When only ch1 is given, \"Gray\" color space is implied and it\n     * must be a value in the range from 0.00 (solid black) to to 1.00 (white)\n     * if values are communicated as String types, or in range from 0 (black)\n     * to 255 (white) if communicated as Number type.\n     * The RGB-like 0-255 range is provided for backward compatibility.\n     *\n     * When only ch1,ch2,ch3 are given, \"RGB\" color space is implied and each\n     * value must be in the range from 0.00 (minimum intensity) to to 1.00\n     * (max intensity) if values are communicated as String types, or\n     * from 0 (min intensity) to to 255 (max intensity) if values are communicated\n     * as Number types.\n     * The RGB-like 0-255 range is provided for backward compatibility.\n     *\n     * When ch1,ch2,ch3,ch4 are given, \"CMYK\" color space is implied and each\n     * value must be a in the range from 0.00 (0% concentration) to to\n     * 1.00 (100% concentration)\n     *\n     * Because JavaScript treats fixed point numbers badly (rounds to\n     * floating point nearest to binary representation) it is highly advised to\n     * communicate the fractional numbers as String types, not JavaScript Number type.\n     *\n     * @param {Number|String} ch1 Color channel value or {string} ch1 color value in hexadecimal, example: '#FFFFFF'.\n     * @param {Number|String} ch2 Color channel value.\n     * @param {Number|String} ch3 Color channel value.\n     * @param {Number|String} ch4 Color channel value.\n     *\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setFillColor\n     */\n\n\n    var setFillColor = API.__private__.setFillColor = API.setFillColor = function (ch1, ch2, ch3, ch4) {\n      var options = {\n        \"ch1\": ch1,\n        \"ch2\": ch2,\n        \"ch3\": ch3,\n        \"ch4\": ch4,\n        \"pdfColorType\": \"fill\",\n        \"precision\": 2\n      };\n      fillColor = encodeColorString(options);\n      out(fillColor);\n      return this;\n    };\n\n    var textColor = options.textColor || '0 g';\n    /**\n     * Gets the text color for upcoming elements.\n     *\n     * @function\n     * @instance\n     * @returns {string} colorAsHex\n     * @memberOf jsPDF\n     * @name getTextColor\n     */\n\n    var getTextColor = API.__private__.getTextColor = API.getTextColor = function () {\n      return decodeColorString(textColor);\n    };\n    /**\n     * Sets the text color for upcoming elements.\n     *\n     * Depending on the number of arguments given, Gray, RGB, or CMYK\n     * color space is implied.\n     *\n     * When only ch1 is given, \"Gray\" color space is implied and it\n     * must be a value in the range from 0.00 (solid black) to to 1.00 (white)\n     * if values are communicated as String types, or in range from 0 (black)\n     * to 255 (white) if communicated as Number type.\n     * The RGB-like 0-255 range is provided for backward compatibility.\n     *\n     * When only ch1,ch2,ch3 are given, \"RGB\" color space is implied and each\n     * value must be in the range from 0.00 (minimum intensity) to to 1.00\n     * (max intensity) if values are communicated as String types, or\n     * from 0 (min intensity) to to 255 (max intensity) if values are communicated\n     * as Number types.\n     * The RGB-like 0-255 range is provided for backward compatibility.\n     *\n     * When ch1,ch2,ch3,ch4 are given, \"CMYK\" color space is implied and each\n     * value must be a in the range from 0.00 (0% concentration) to to\n     * 1.00 (100% concentration)\n     *\n     * Because JavaScript treats fixed point numbers badly (rounds to\n     * floating point nearest to binary representation) it is highly advised to\n     * communicate the fractional numbers as String types, not JavaScript Number type.\n     *\n     * @param {Number|String} ch1 Color channel value or {string} ch1 color value in hexadecimal, example: '#FFFFFF'.\n     * @param {Number|String} ch2 Color channel value.\n     * @param {Number|String} ch3 Color channel value.\n     * @param {Number|String} ch4 Color channel value.\n     *\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setTextColor\n     */\n\n\n    var setTextColor = API.__private__.setTextColor = API.setTextColor = function (ch1, ch2, ch3, ch4) {\n      var options = {\n        \"ch1\": ch1,\n        \"ch2\": ch2,\n        \"ch3\": ch3,\n        \"ch4\": ch4,\n        \"pdfColorType\": \"text\",\n        \"precision\": 3\n      };\n      textColor = encodeColorString(options);\n      return this;\n    };\n\n    var activeCharSpace = options.charSpace || 0;\n    /**\n     * Get global value of CharSpace.\n     *\n     * @function\n     * @instance\n     * @returns {number} charSpace\n     * @memberOf jsPDF\n     * @name getCharSpace\n     */\n\n    var getCharSpace = API.__private__.getCharSpace = API.getCharSpace = function () {\n      return activeCharSpace;\n    };\n    /**\n     * Set global value of CharSpace.\n     *\n     * @param {number} charSpace\n     * @function\n     * @instance\n     * @returns {jsPDF} jsPDF-instance\n     * @memberOf jsPDF\n     * @name setCharSpace\n     */\n\n\n    var setCharSpace = API.__private__.setCharSpace = API.setCharSpace = function (charSpace) {\n      if (isNaN(charSpace)) {\n        throw new Error('Invalid argument passed to jsPDF.setCharSpace');\n      }\n\n      activeCharSpace = charSpace;\n      return this;\n    };\n\n    var lineCapID = 0;\n    /**\n     * Is an Object providing a mapping from human-readable to\n     * integer flag values designating the varieties of line cap\n     * and join styles.\n     *\n     * @memberOf jsPDF\n     * @name CapJoinStyles\n     */\n\n    API.CapJoinStyles = {\n      0: 0,\n      'butt': 0,\n      'but': 0,\n      'miter': 0,\n      1: 1,\n      'round': 1,\n      'rounded': 1,\n      'circle': 1,\n      2: 2,\n      'projecting': 2,\n      'project': 2,\n      'square': 2,\n      'bevel': 2\n    };\n    /**\n     * Sets the line cap styles.\n     * See {jsPDF.CapJoinStyles} for variants.\n     *\n     * @param {String|Number} style A string or number identifying the type of line cap.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setLineCap\n     */\n\n    var setLineCap = API.__private__.setLineCap = API.setLineCap = function (style) {\n      var id = API.CapJoinStyles[style];\n\n      if (id === undefined) {\n        throw new Error(\"Line cap style of '\" + style + \"' is not recognized. See or extend .CapJoinStyles property for valid styles\");\n      }\n\n      lineCapID = id;\n      out(id + ' J');\n      return this;\n    };\n\n    var lineJoinID = 0;\n    /**\n     * Sets the line join styles.\n     * See {jsPDF.CapJoinStyles} for variants.\n     *\n     * @param {String|Number} style A string or number identifying the type of line join.\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setLineJoin\n     */\n\n    var setLineJoin = API.__private__.setLineJoin = API.setLineJoin = function (style) {\n      var id = API.CapJoinStyles[style];\n\n      if (id === undefined) {\n        throw new Error(\"Line join style of '\" + style + \"' is not recognized. See or extend .CapJoinStyles property for valid styles\");\n      }\n\n      lineJoinID = id;\n      out(id + ' j');\n      return this;\n    };\n\n    var miterLimit;\n    /**\n     * Sets the miterLimit property, which effects the maximum miter length.\n     *\n     * @param {number} length The length of the miter\n     * @function\n     * @instance\n     * @returns {jsPDF}\n     * @memberOf jsPDF\n     * @name setMiterLimit\n     */\n\n    var setMiterLimit = API.__private__.setMiterLimit = API.setMiterLimit = function (length) {\n      length = length || 0;\n\n      if (isNaN(length)) {\n        throw new Error('Invalid argument passed to jsPDF.setMiterLimit');\n      }\n\n      miterLimit = parseFloat(f2(length * k));\n      out(miterLimit + ' M');\n      return this;\n    };\n    /**\n     * Saves as PDF document. An alias of jsPDF.output('save', 'filename.pdf').\n     * Uses FileSaver.js-method saveAs.\n     *\n     * @memberOf jsPDF\n     * @name save\n     * @function\n     * @instance\n     * @param  {string} filename The filename including extension.\n     * @param  {Object} options An Object with additional options, possible options: 'returnPromise'.\n     * @returns {jsPDF} jsPDF-instance\n     */\n\n\n    API.save = function (filename, options) {\n      filename = filename || 'generated.pdf';\n      options = options || {};\n      options.returnPromise = options.returnPromise || false;\n\n      if (options.returnPromise === false) {\n        saveAs(getBlob(buildDocument()), filename);\n\n        if (typeof saveAs.unload === 'function') {\n          if (global.setTimeout) {\n            setTimeout(saveAs.unload, 911);\n          }\n        }\n      } else {\n        return new Promise(function (resolve, reject) {\n          try {\n            var result = saveAs(getBlob(buildDocument()), filename);\n\n            if (typeof saveAs.unload === 'function') {\n              if (global.setTimeout) {\n                setTimeout(saveAs.unload, 911);\n              }\n            }\n\n            resolve(result);\n          } catch (e) {\n            reject(e.message);\n          }\n        });\n      }\n    }; // applying plugins (more methods) ON TOP of built-in API.\n    // this is intentional as we allow plugins to override\n    // built-ins\n\n\n    for (var plugin in jsPDF.API) {\n      if (jsPDF.API.hasOwnProperty(plugin)) {\n        if (plugin === 'events' && jsPDF.API.events.length) {\n          (function (events, newEvents) {\n            // jsPDF.API.events is a JS Array of Arrays\n            // where each Array is a pair of event name, handler\n            // Events were added by plugins to the jsPDF instantiator.\n            // These are always added to the new instance and some ran\n            // during instantiation.\n            var eventname, handler_and_args, i;\n\n            for (i = newEvents.length - 1; i !== -1; i--) {\n              // subscribe takes 3 args: 'topic', function, runonce_flag\n              // if undefined, runonce is false.\n              // users can attach callback directly,\n              // or they can attach an array with [callback, runonce_flag]\n              // that's what the \"apply\" magic is for below.\n              eventname = newEvents[i][0];\n              handler_and_args = newEvents[i][1];\n              events.subscribe.apply(events, [eventname].concat(typeof handler_and_args === 'function' ? [handler_and_args] : handler_and_args));\n            }\n          })(events, jsPDF.API.events);\n        } else {\n          API[plugin] = jsPDF.API[plugin];\n        }\n      }\n    }\n    /**\n     * Object exposing internal API to plugins\n     * @public\n     * @ignore\n     */\n\n\n    API.internal = {\n      'pdfEscape': pdfEscape,\n      'getStyle': getStyle,\n      'getFont': function getFont() {\n        return fonts[_getFont.apply(API, arguments)];\n      },\n      'getFontSize': getFontSize,\n      'getCharSpace': getCharSpace,\n      'getTextColor': getTextColor,\n      'getLineHeight': getLineHeight,\n      'getLineHeightFactor': getLineHeightFactor,\n      'write': write,\n      'getHorizontalCoordinate': getHorizontalCoordinate,\n      'getVerticalCoordinate': getVerticalCoordinate,\n      'getCoordinateString': getHorizontalCoordinateString,\n      'getVerticalCoordinateString': getVerticalCoordinateString,\n      'collections': {},\n      'newObject': newObject,\n      'newAdditionalObject': newAdditionalObject,\n      'newObjectDeferred': newObjectDeferred,\n      'newObjectDeferredBegin': newObjectDeferredBegin,\n      'getFilters': getFilters,\n      'putStream': putStream,\n      'events': events,\n      // ratio that you use in multiplication of a given \"size\" number to arrive to 'point'\n      // units of measurement.\n      // scaleFactor is set at initialization of the document and calculated against the stated\n      // default measurement units for the document.\n      // If default is \"mm\", k is the number that will turn number in 'mm' into 'points' number.\n      // through multiplication.\n      'scaleFactor': k,\n      'pageSize': {\n        getWidth: function getWidth() {\n          return (pagesContext[currentPage].mediaBox.topRightX - pagesContext[currentPage].mediaBox.bottomLeftX) / k;\n        },\n        setWidth: function setWidth(value) {\n          pagesContext[currentPage].mediaBox.topRightX = value * k + pagesContext[currentPage].mediaBox.bottomLeftX;\n        },\n        getHeight: function getHeight() {\n          return (pagesContext[currentPage].mediaBox.topRightY - pagesContext[currentPage].mediaBox.bottomLeftY) / k;\n        },\n        setHeight: function setHeight(value) {\n          pagesContext[currentPage].mediaBox.topRightY = value * k + pagesContext[currentPage].mediaBox.bottomLeftY;\n        }\n      },\n      'output': output,\n      'getNumberOfPages': getNumberOfPages,\n      'pages': pages,\n      'out': out,\n      'f2': f2,\n      'f3': f3,\n      'getPageInfo': getPageInfo,\n      'getPageInfoByObjId': getPageInfoByObjId,\n      'getCurrentPageInfo': getCurrentPageInfo,\n      'getPDFVersion': getPdfVersion,\n      'hasHotfix': hasHotfix //Expose the hasHotfix check so plugins can also check them.\n\n    };\n    Object.defineProperty(API.internal.pageSize, 'width', {\n      get: function get() {\n        return (pagesContext[currentPage].mediaBox.topRightX - pagesContext[currentPage].mediaBox.bottomLeftX) / k;\n      },\n      set: function set(value) {\n        pagesContext[currentPage].mediaBox.topRightX = value * k + pagesContext[currentPage].mediaBox.bottomLeftX;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(API.internal.pageSize, 'height', {\n      get: function get() {\n        return (pagesContext[currentPage].mediaBox.topRightY - pagesContext[currentPage].mediaBox.bottomLeftY) / k;\n      },\n      set: function set(value) {\n        pagesContext[currentPage].mediaBox.topRightY = value * k + pagesContext[currentPage].mediaBox.bottomLeftY;\n      },\n      enumerable: true,\n      configurable: true\n    }); //////////////////////////////////////////////////////\n    // continuing initialization of jsPDF Document object\n    //////////////////////////////////////////////////////\n    // Add the first page automatically\n\n    addFonts(standardFonts);\n    activeFontKey = 'F1';\n\n    _addPage(format, orientation);\n\n    events.publish('initialized');\n    return API;\n  }\n  /**\n   * jsPDF.API is a STATIC property of jsPDF class.\n   * jsPDF.API is an object you can add methods and properties to.\n   * The methods / properties you add will show up in new jsPDF objects.\n   *\n   * One property is prepopulated. It is the 'events' Object. Plugin authors can add topics,\n   * callbacks to this object. These will be reassigned to all new instances of jsPDF.\n   *\n   * @static\n   * @public\n   * @memberOf jsPDF\n   * @name API\n   *\n   * @example\n   * jsPDF.API.mymethod = function(){\n   *   // 'this' will be ref to internal API object. see jsPDF source\n   *   // , so you can refer to built-in methods like so:\n   *   //     this.line(....)\n   *   //     this.text(....)\n   * }\n   * var pdfdoc = new jsPDF()\n   * pdfdoc.mymethod() // <- !!!!!!\n   */\n\n\n  jsPDF.API = {\n    events: []\n  };\n  /**\n   * The version of jsPDF.\n   * @name version\n   * @type {string}\n   * @memberOf jsPDF\n   */\n\n  jsPDF.version = '1.5.3';\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jsPDF;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n  return jsPDF;\n}(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || Function('return typeof this === \"object\" && this.content')() || Function('return this')()); // `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\n/*rollup-keeper-start*/\n\n\nwindow.tmp = jsPDF;\n/*rollup-keeper-end*/\n\n/**\n * @license\n * Copyright (c) 2016 Alexander Weidt,\n * https://github.com/BiggA94\n * \n * Licensed under the MIT License. http://opensource.org/licenses/mit-license\n */\n\n/** \n* jsPDF AcroForm Plugin\n* @module AcroForm\n*/\n(function (jsPDFAPI, globalObj) {\n\n  var scope;\n  var scaleFactor = 1;\n\n  var pdfEscape = function pdfEscape(value) {\n    return value.replace(/\\\\/g, '\\\\\\\\').replace(/\\(/g, '\\\\(').replace(/\\)/g, '\\\\)');\n  };\n\n  var pdfUnescape = function pdfUnescape(value) {\n    return value.replace(/\\\\\\\\/g, '\\\\').replace(/\\\\\\(/g, '(').replace(/\\\\\\)/g, ')');\n  };\n\n  var f2 = function f2(number) {\n    if (isNaN(number)) {\n      throw new Error('Invalid argument passed to jsPDF.f2');\n    }\n\n    return number.toFixed(2); // Ie, %.2f\n  };\n\n  var f5 = function f5(number) {\n    if (isNaN(number)) {\n      throw new Error('Invalid argument passed to jsPDF.f2');\n    }\n\n    return number.toFixed(5); // Ie, %.2f\n  };\n\n  jsPDFAPI.__acroform__ = {};\n\n  var inherit = function inherit(child, parent) {\n\n    child.prototype = Object.create(parent.prototype);\n    child.prototype.constructor = child;\n  };\n\n  var scale = function scale(x) {\n    return x * scaleFactor;\n  };\n\n  var antiScale = function antiScale(x) {\n    return x / scaleFactor;\n  };\n\n  var createFormXObject = function createFormXObject(formObject) {\n    var xobj = new AcroFormXObject();\n    var height = AcroFormAppearance.internal.getHeight(formObject) || 0;\n    var width = AcroFormAppearance.internal.getWidth(formObject) || 0;\n    xobj.BBox = [0, 0, Number(f2(width)), Number(f2(height))];\n    return xobj;\n  };\n  /**\n  * Bit-Operations\n  */\n\n\n  var setBit = jsPDFAPI.__acroform__.setBit = function (number, bitPosition) {\n    number = number || 0;\n    bitPosition = bitPosition || 0;\n\n    if (isNaN(number) || isNaN(bitPosition)) {\n      throw new Error('Invalid arguments passed to jsPDF.API.__acroform__.setBit');\n    }\n\n    var bitMask = 1 << bitPosition;\n    number |= bitMask;\n    return number;\n  };\n\n  var clearBit = jsPDFAPI.__acroform__.clearBit = function (number, bitPosition) {\n    number = number || 0;\n    bitPosition = bitPosition || 0;\n\n    if (isNaN(number) || isNaN(bitPosition)) {\n      throw new Error('Invalid arguments passed to jsPDF.API.__acroform__.clearBit');\n    }\n\n    var bitMask = 1 << bitPosition;\n    number &= ~bitMask;\n    return number;\n  };\n\n  var getBit = jsPDFAPI.__acroform__.getBit = function (number, bitPosition) {\n    if (isNaN(number) || isNaN(bitPosition)) {\n      throw new Error('Invalid arguments passed to jsPDF.API.__acroform__.getBit');\n    }\n\n    return (number & 1 << bitPosition) === 0 ? 0 : 1;\n  };\n  /*\n  * Ff starts counting the bit position at 1 and not like javascript at 0\n  */\n\n\n  var getBitForPdf = jsPDFAPI.__acroform__.getBitForPdf = function (number, bitPosition) {\n    if (isNaN(number) || isNaN(bitPosition)) {\n      throw new Error('Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf');\n    }\n\n    return getBit(number, bitPosition - 1);\n  };\n\n  var setBitForPdf = jsPDFAPI.__acroform__.setBitForPdf = function (number, bitPosition) {\n    if (isNaN(number) || isNaN(bitPosition)) {\n      throw new Error('Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf');\n    }\n\n    return setBit(number, bitPosition - 1);\n  };\n\n  var clearBitForPdf = jsPDFAPI.__acroform__.clearBitForPdf = function (number, bitPosition, value) {\n    if (isNaN(number) || isNaN(bitPosition)) {\n      throw new Error('Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf');\n    }\n\n    return clearBit(number, bitPosition - 1);\n  };\n\n  var calculateCoordinates = jsPDFAPI.__acroform__.calculateCoordinates = function (args) {\n    var getHorizontalCoordinate = this.internal.getHorizontalCoordinate;\n    var getVerticalCoordinate = this.internal.getVerticalCoordinate;\n    var x = args[0];\n    var y = args[1];\n    var w = args[2];\n    var h = args[3];\n    var coordinates = {};\n    coordinates.lowerLeft_X = getHorizontalCoordinate(x) || 0;\n    coordinates.lowerLeft_Y = getVerticalCoordinate(y + h) || 0;\n    coordinates.upperRight_X = getHorizontalCoordinate(x + w) || 0;\n    coordinates.upperRight_Y = getVerticalCoordinate(y) || 0;\n    return [Number(f2(coordinates.lowerLeft_X)), Number(f2(coordinates.lowerLeft_Y)), Number(f2(coordinates.upperRight_X)), Number(f2(coordinates.upperRight_Y))];\n  };\n\n  var calculateAppearanceStream = function calculateAppearanceStream(formObject) {\n    if (formObject.appearanceStreamContent) {\n      return formObject.appearanceStreamContent;\n    }\n\n    if (!formObject.V && !formObject.DV) {\n      return;\n    } // else calculate it\n\n\n    var stream = [];\n    var text = formObject.V || formObject.DV;\n    var calcRes = calculateX(formObject, text);\n    var fontKey = scope.internal.getFont(formObject.fontName, formObject.fontStyle).id; //PDF 32000-1:2008, page 444\n\n    stream.push('/Tx BMC');\n    stream.push('q');\n    stream.push('BT'); // Begin Text\n\n    stream.push(scope.__private__.encodeColorString(formObject.color));\n    stream.push('/' + fontKey + ' ' + f2(calcRes.fontSize) + ' Tf');\n    stream.push('1 0 0 1 0 0 Tm'); // Transformation Matrix\n\n    stream.push(calcRes.text);\n    stream.push('ET'); // End Text    \n\n    stream.push('Q');\n    stream.push('EMC');\n    var appearanceStreamContent = new createFormXObject(formObject);\n    appearanceStreamContent.stream = stream.join(\"\\n\");\n    return appearanceStreamContent;\n  };\n\n  var calculateX = function calculateX(formObject, text) {\n    var maxFontSize = formObject.maxFontSize || 12;\n    var font = formObject.fontName;\n    var returnValue = {\n      text: \"\",\n      fontSize: \"\"\n    }; // Remove Brackets\n\n    text = text.substr(0, 1) == '(' ? text.substr(1) : text;\n    text = text.substr(text.length - 1) == ')' ? text.substr(0, text.length - 1) : text; // split into array of words\n\n    var textSplit = text.split(' ');\n\n    var color = scope.__private__.encodeColorString(formObject.color);\n\n    var fontSize = maxFontSize; // The Starting fontSize (The Maximum)\n\n    var lineSpacing = 2;\n    var borderPadding = 2;\n    var height = AcroFormAppearance.internal.getHeight(formObject) || 0;\n    height = height < 0 ? -height : height;\n    var width = AcroFormAppearance.internal.getWidth(formObject) || 0;\n    width = width < 0 ? -width : width;\n\n    var isSmallerThanWidth = function isSmallerThanWidth(i, lastLine, fontSize) {\n      if (i + 1 < textSplit.length) {\n        var tmp = lastLine + \" \" + textSplit[i + 1];\n        var TextWidth = calculateFontSpace(tmp, formObject, fontSize).width;\n        var FieldWidth = width - 2 * borderPadding;\n        return TextWidth <= FieldWidth;\n      } else {\n        return false;\n      }\n    };\n\n    fontSize++;\n\n    FontSize: while (true) {\n      var text = \"\";\n      fontSize--;\n      var textHeight = calculateFontSpace(\"3\", formObject, fontSize).height;\n      var startY = formObject.multiline ? height - fontSize : (height - textHeight) / 2;\n      startY += lineSpacing;\n      var startX = -borderPadding;\n      var lastY = startY;\n      var firstWordInLine = 0,\n          lastWordInLine = 0;\n      var lastLength = 0;\n\n      if (fontSize <= 0) {\n        // In case, the Text doesn't fit at all\n        fontSize = 12;\n        text = \"(...) Tj\\n\";\n        text += \"% Width of Text: \" + calculateFontSpace(text, formObject, fontSize).width + \", FieldWidth:\" + width + \"\\n\";\n        break;\n      }\n\n      lastLength = calculateFontSpace(textSplit[0] + \" \", formObject, fontSize).width;\n      var lastLine = \"\";\n      var lineCount = 0;\n\n      Line: for (var i in textSplit) {\n        if (textSplit.hasOwnProperty(i)) {\n          lastLine += textSplit[i] + \" \"; // Remove last blank\n\n          lastLine = lastLine.substr(lastLine.length - 1) == \" \" ? lastLine.substr(0, lastLine.length - 1) : lastLine;\n          var key = parseInt(i);\n          lastLength = calculateFontSpace(lastLine + \" \", formObject, fontSize).width;\n          var nextLineIsSmaller = isSmallerThanWidth(key, lastLine, fontSize);\n          var isLastWord = i >= textSplit.length - 1;\n\n          if (nextLineIsSmaller && !isLastWord) {\n            lastLine += \" \";\n            continue; // Line\n          } else if (!nextLineIsSmaller && !isLastWord) {\n            if (!formObject.multiline) {\n              continue FontSize;\n            } else {\n              if ((textHeight + lineSpacing) * (lineCount + 2) + lineSpacing > height) {\n                // If the Text is higher than the\n                // FieldObject\n                continue FontSize;\n              }\n\n              lastWordInLine = key; // go on\n            }\n          } else if (isLastWord) {\n            lastWordInLine = key;\n          } else {\n            if (formObject.multiline && (textHeight + lineSpacing) * (lineCount + 2) + lineSpacing > height) {\n              // If the Text is higher than the FieldObject\n              continue FontSize;\n            }\n          }\n\n          var line = '';\n\n          for (var x = firstWordInLine; x <= lastWordInLine; x++) {\n            line += textSplit[x] + ' ';\n          } // Remove last blank\n\n\n          line = line.substr(line.length - 1) == \" \" ? line.substr(0, line.length - 1) : line; // lastLength -= blankSpace.width;\n\n          lastLength = calculateFontSpace(line, formObject, fontSize).width; // Calculate startX\n\n          switch (formObject.textAlign) {\n            case 'right':\n              startX = width - lastLength - borderPadding;\n              break;\n\n            case 'center':\n              startX = (width - lastLength) / 2;\n              break;\n\n            case 'left':\n            default:\n              startX = borderPadding;\n              break;\n          }\n\n          text += f2(startX) + ' ' + f2(lastY) + ' Td\\n';\n          text += '(' + pdfEscape(line) + ') Tj\\n'; // reset X in PDF\n\n          text += -f2(startX) + ' 0 Td\\n'; // After a Line, adjust y position\n\n          lastY = -(fontSize + lineSpacing);\n\n          lastLength = 0;\n          firstWordInLine = lastWordInLine + 1;\n          lineCount++;\n          lastLine = \"\";\n          continue Line;\n        }\n      }\n\n      break;\n    }\n\n    returnValue.text = text;\n    returnValue.fontSize = fontSize;\n    return returnValue;\n  };\n  /**\n  * Small workaround for calculating the TextMetric approximately.\n  * \n  * @param text\n  * @param fontsize\n  * @returns {TextMetrics} (Has Height and Width)\n  */\n\n\n  var calculateFontSpace = function calculateFontSpace(text, formObject, fontSize) {\n    var font = scope.internal.getFont(formObject.fontName, formObject.fontStyle);\n    var width = scope.getStringUnitWidth(text, {\n      font: font,\n      fontSize: parseFloat(fontSize),\n      charSpace: 0\n    }) * parseFloat(fontSize);\n    var height = scope.getStringUnitWidth(\"3\", {\n      font: font,\n      fontSize: parseFloat(fontSize),\n      charSpace: 0\n    }) * parseFloat(fontSize) * 1.5;\n    return {\n      height: height,\n      width: width\n    };\n  };\n\n  var acroformPluginTemplate = {\n    fields: [],\n    xForms: [],\n\n    /**\n    * acroFormDictionaryRoot contains information about the AcroForm\n    * Dictionary 0: The Event-Token, the AcroFormDictionaryCallback has\n    * 1: The Object ID of the Root\n    */\n    acroFormDictionaryRoot: null,\n\n    /**\n    * After the PDF gets evaluated, the reference to the root has to be\n    * reset, this indicates, whether the root has already been printed\n    * out\n    */\n    printedOut: false,\n    internal: null,\n    isInitialized: false\n  };\n\n  var annotReferenceCallback = function annotReferenceCallback() {\n    //set objId to undefined and force it to get a new objId on buildDocument\n    scope.internal.acroformPlugin.acroFormDictionaryRoot.objId = undefined;\n    var fields = scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields;\n\n    for (var i in fields) {\n      if (fields.hasOwnProperty(i)) {\n        var formObject = fields[i]; //set objId to undefined and force it to get a new objId on buildDocument\n\n        formObject.objId = undefined; // add Annot Reference!\n\n        if (formObject.hasAnnotation) {\n          // If theres an Annotation Widget in the Form Object, put the\n          // Reference in the /Annot array\n          createAnnotationReference.call(scope, formObject);\n        }\n      }\n    }\n  };\n\n  var putForm = function putForm(formObject) {\n    if (scope.internal.acroformPlugin.printedOut) {\n      scope.internal.acroformPlugin.printedOut = false;\n      scope.internal.acroformPlugin.acroFormDictionaryRoot = null;\n    }\n\n    if (!scope.internal.acroformPlugin.acroFormDictionaryRoot) {\n      initializeAcroForm.call(scope);\n    }\n\n    scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(formObject);\n  };\n  /**\n  * Create the Reference to the widgetAnnotation, so that it gets referenced\n  * in the Annot[] int the+ (Requires the Annotation Plugin)\n  */\n\n\n  var createAnnotationReference = function createAnnotationReference(object) {\n    var options = {\n      type: 'reference',\n      object: object\n    };\n\n    var findEntry = function findEntry(entry) {\n      return entry.type === options.type && entry.object === options.object;\n    };\n\n    if (scope.internal.getPageInfo(object.page).pageContext.annotations.find(findEntry) === undefined) {\n      scope.internal.getPageInfo(object.page).pageContext.annotations.push(options);\n    }\n  }; // Callbacks\n\n\n  var putCatalogCallback = function putCatalogCallback() {\n    // Put reference to AcroForm to DocumentCatalog\n    if (typeof scope.internal.acroformPlugin.acroFormDictionaryRoot != 'undefined') {\n      // for safety, shouldn't normally be the case\n      scope.internal.write('/AcroForm ' + scope.internal.acroformPlugin.acroFormDictionaryRoot.objId + ' ' + 0 + ' R');\n    } else {\n      throw new Error('putCatalogCallback: Root missing.');\n    }\n  };\n  /**\n  * Adds /Acroform X 0 R to Document Catalog, and creates the AcroForm\n  * Dictionary\n  */\n\n\n  var AcroFormDictionaryCallback = function AcroFormDictionaryCallback() {\n    // Remove event\n    scope.internal.events.unsubscribe(scope.internal.acroformPlugin.acroFormDictionaryRoot._eventID);\n    delete scope.internal.acroformPlugin.acroFormDictionaryRoot._eventID;\n    scope.internal.acroformPlugin.printedOut = true;\n  };\n  /**\n  * Creates the single Fields and writes them into the Document\n  * \n  * If fieldArray is set, use the fields that are inside it instead of the\n  * fields from the AcroRoot (for the FormXObjects...)\n  */\n\n\n  var createFieldCallback = function createFieldCallback(fieldArray) {\n    var standardFields = !fieldArray;\n\n    if (!fieldArray) {\n      // in case there is no fieldArray specified, we want to print out\n      // the Fields of the AcroForm\n      // Print out Root\n      scope.internal.newObjectDeferredBegin(scope.internal.acroformPlugin.acroFormDictionaryRoot.objId, true);\n      scope.internal.acroformPlugin.acroFormDictionaryRoot.putStream();\n    }\n\n    var fieldArray = fieldArray || scope.internal.acroformPlugin.acroFormDictionaryRoot.Kids;\n\n    for (var i in fieldArray) {\n      if (fieldArray.hasOwnProperty(i)) {\n        var fieldObject = fieldArray[i];\n        var keyValueList = [];\n        var oldRect = fieldObject.Rect;\n\n        if (fieldObject.Rect) {\n          fieldObject.Rect = calculateCoordinates.call(this, fieldObject.Rect);\n        } // Start Writing the Object\n\n\n        scope.internal.newObjectDeferredBegin(fieldObject.objId, true);\n        fieldObject.DA = AcroFormAppearance.createDefaultAppearanceStream(fieldObject);\n\n        if (_typeof(fieldObject) === \"object\" && typeof fieldObject.getKeyValueListForStream === \"function\") {\n          keyValueList = fieldObject.getKeyValueListForStream();\n        }\n\n        fieldObject.Rect = oldRect;\n\n        if (fieldObject.hasAppearanceStream && !fieldObject.appearanceStreamContent) {\n          // Calculate Appearance\n          var appearance = calculateAppearanceStream.call(this, fieldObject);\n          keyValueList.push({\n            key: 'AP',\n            value: \"<</N \" + appearance + \">>\"\n          });\n          scope.internal.acroformPlugin.xForms.push(appearance);\n        } // Assume AppearanceStreamContent is a Array with N,R,D (at least\n        // one of them!)\n\n\n        if (fieldObject.appearanceStreamContent) {\n          var appearanceStreamString = \"\"; // Iterate over N,R and D\n\n          for (var k in fieldObject.appearanceStreamContent) {\n            if (fieldObject.appearanceStreamContent.hasOwnProperty(k)) {\n              var value = fieldObject.appearanceStreamContent[k];\n              appearanceStreamString += \"/\" + k + \" \";\n              appearanceStreamString += \"<<\";\n\n              if (Object.keys(value).length >= 1 || Array.isArray(value)) {\n                // appearanceStream is an Array or Object!\n                for (var i in value) {\n                  if (value.hasOwnProperty(i)) {\n                    var obj = value[i];\n\n                    if (typeof obj === 'function') {\n                      // if Function is referenced, call it in order\n                      // to get the FormXObject\n                      obj = obj.call(this, fieldObject);\n                    }\n\n                    appearanceStreamString += \"/\" + i + \" \" + obj + \" \"; // In case the XForm is already used, e.g. OffState\n                    // of CheckBoxes, don't add it\n\n                    if (!(scope.internal.acroformPlugin.xForms.indexOf(obj) >= 0)) scope.internal.acroformPlugin.xForms.push(obj);\n                  }\n                }\n              } else {\n                var obj = value;\n\n                if (typeof obj === 'function') {\n                  // if Function is referenced, call it in order to\n                  // get the FormXObject\n                  obj = obj.call(this, fieldObject);\n                }\n\n                appearanceStreamString += \"/\" + i + \" \" + obj;\n                if (!(scope.internal.acroformPlugin.xForms.indexOf(obj) >= 0)) scope.internal.acroformPlugin.xForms.push(obj);\n              }\n\n              appearanceStreamString += \">>\";\n            }\n          } // appearance stream is a normal Object..\n\n\n          keyValueList.push({\n            key: 'AP',\n            value: \"<<\\n\" + appearanceStreamString + \">>\"\n          });\n        }\n\n        scope.internal.putStream({\n          additionalKeyValues: keyValueList\n        });\n        scope.internal.out(\"endobj\");\n      }\n    }\n\n    if (standardFields) {\n      createXFormObjectCallback.call(this, scope.internal.acroformPlugin.xForms);\n    }\n  };\n\n  var createXFormObjectCallback = function createXFormObjectCallback(fieldArray) {\n    for (var i in fieldArray) {\n      if (fieldArray.hasOwnProperty(i)) {\n        var key = i;\n        var fieldObject = fieldArray[i]; // Start Writing the Object\n\n        scope.internal.newObjectDeferredBegin(fieldObject && fieldObject.objId, true);\n\n        if (_typeof(fieldObject) === \"object\" && typeof fieldObject.putStream === \"function\") {\n          fieldObject.putStream();\n        }\n\n        delete fieldArray[key];\n      }\n    }\n  };\n\n  var initializeAcroForm = function initializeAcroForm() {\n    if (this.internal !== undefined && (this.internal.acroformPlugin === undefined || this.internal.acroformPlugin.isInitialized === false)) {\n      scope = this;\n      AcroFormField.FieldNum = 0;\n      this.internal.acroformPlugin = JSON.parse(JSON.stringify(acroformPluginTemplate));\n\n      if (this.internal.acroformPlugin.acroFormDictionaryRoot) {\n        throw new Error(\"Exception while creating AcroformDictionary\");\n      }\n\n      scaleFactor = scope.internal.scaleFactor; // The Object Number of the AcroForm Dictionary\n\n      scope.internal.acroformPlugin.acroFormDictionaryRoot = new AcroFormDictionary(); // add Callback for creating the AcroForm Dictionary\n\n      scope.internal.acroformPlugin.acroFormDictionaryRoot._eventID = scope.internal.events.subscribe('postPutResources', AcroFormDictionaryCallback);\n      scope.internal.events.subscribe('buildDocument', annotReferenceCallback); // buildDocument\n      // Register event, that is triggered when the DocumentCatalog is\n      // written, in order to add /AcroForm\n\n      scope.internal.events.subscribe('putCatalog', putCatalogCallback); // Register event, that creates all Fields\n\n      scope.internal.events.subscribe('postPutPages', createFieldCallback);\n      scope.internal.acroformPlugin.isInitialized = true;\n    }\n  }; //PDF 32000-1:2008, page 26, 7.3.6\n\n\n  var arrayToPdfArray = jsPDFAPI.__acroform__.arrayToPdfArray = function (array) {\n    if (Array.isArray(array)) {\n      var content = '[';\n\n      for (var i = 0; i < array.length; i++) {\n        if (i !== 0) {\n          content += ' ';\n        }\n\n        switch (_typeof(array[i])) {\n          case 'boolean':\n          case 'number':\n          case 'object':\n            content += array[i].toString();\n            break;\n\n          case 'string':\n            if (array[i].substr(0, 1) !== '/') {\n              content += '(' + pdfEscape(array[i].toString()) + ')';\n            } else {\n              content += array[i].toString();\n            }\n\n            break;\n        }\n      }\n\n      content += ']';\n      return content;\n    }\n\n    throw new Error('Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray');\n  };\n\n  function getMatches(string, regex, index) {\n    index || (index = 1); // default to the first capturing group\n\n    var matches = [];\n    var match;\n\n    while (match = regex.exec(string)) {\n      matches.push(match[index]);\n    }\n\n    return matches;\n  }\n\n  var pdfArrayToStringArray = function pdfArrayToStringArray(array) {\n    var result = [];\n\n    if (typeof array === \"string\") {\n      result = getMatches(array, /\\((.*?)\\)/g);\n    }\n\n    return result;\n  };\n\n  var toPdfString = function toPdfString(string) {\n    string = string || \"\";\n    string.toString();\n    string = '(' + pdfEscape(string) + ')';\n    return string;\n  }; // ##########################\n  // Classes\n  // ##########################\n\n  /**\n  * @class AcroFormPDFObject\n  * @classdesc A AcroFormPDFObject\n  */\n\n\n  var AcroFormPDFObject = function AcroFormPDFObject() {\n    var _objId;\n    /**    *\n    * @name AcroFormPDFObject#objId\n    * @type {any}\n    */\n\n\n    Object.defineProperty(this, 'objId', {\n      configurable: true,\n      get: function get() {\n        if (!_objId) {\n          _objId = scope.internal.newObjectDeferred();\n        }\n\n        if (!_objId) {\n          throw new Error(\"AcroFormPDFObject: Couldn't create Object ID\");\n        }\n\n        return _objId;\n      },\n      set: function set(value) {\n        _objId = value;\n      }\n    });\n  };\n  /**\n  * @function AcroFormPDFObject.toString\n  */\n\n\n  AcroFormPDFObject.prototype.toString = function () {\n    return this.objId + \" 0 R\";\n  };\n\n  AcroFormPDFObject.prototype.putStream = function () {\n    var keyValueList = this.getKeyValueListForStream();\n    scope.internal.putStream({\n      data: this.stream,\n      additionalKeyValues: keyValueList\n    });\n    scope.internal.out(\"endobj\");\n  };\n  /**\n  * Returns an key-value-List of all non-configurable Variables from the Object\n  * \n  * @name getKeyValueListForStream\n  * @returns {string}\n  */\n\n\n  AcroFormPDFObject.prototype.getKeyValueListForStream = function () {\n    var createKeyValueListFromFieldObject = function createKeyValueListFromFieldObject(fieldObject) {\n      var keyValueList = [];\n      var keys = Object.getOwnPropertyNames(fieldObject).filter(function (key) {\n        return key != 'content' && key != 'appearanceStreamContent' && key.substring(0, 1) != \"_\";\n      });\n\n      for (var i in keys) {\n        if (Object.getOwnPropertyDescriptor(fieldObject, keys[i]).configurable === false) {\n          var key = keys[i];\n          var value = fieldObject[key];\n\n          if (value) {\n            if (Array.isArray(value)) {\n              keyValueList.push({\n                key: key,\n                value: arrayToPdfArray(value)\n              });\n            } else if (value instanceof AcroFormPDFObject) {\n              // In case it is a reference to another PDFObject,\n              // take the reference number\n              keyValueList.push({\n                key: key,\n                value: value.objId + \" 0 R\"\n              });\n            } else if (typeof value !== \"function\") {\n              keyValueList.push({\n                key: key,\n                value: value\n              });\n            }\n          }\n        }\n      }\n\n      return keyValueList;\n    };\n\n    return createKeyValueListFromFieldObject(this);\n  };\n\n  var AcroFormXObject = function AcroFormXObject() {\n    AcroFormPDFObject.call(this);\n    Object.defineProperty(this, 'Type', {\n      value: \"/XObject\",\n      configurable: false,\n      writeable: true\n    });\n    Object.defineProperty(this, 'Subtype', {\n      value: \"/Form\",\n      configurable: false,\n      writeable: true\n    });\n    Object.defineProperty(this, 'FormType', {\n      value: 1,\n      configurable: false,\n      writeable: true\n    });\n    var _BBox = [];\n    Object.defineProperty(this, 'BBox', {\n      configurable: false,\n      writeable: true,\n      get: function get() {\n        return _BBox;\n      },\n      set: function set(value) {\n        _BBox = value;\n      }\n    });\n    Object.defineProperty(this, 'Resources', {\n      value: \"2 0 R\",\n      configurable: false,\n      writeable: true\n    });\n\n    var _stream;\n\n    Object.defineProperty(this, 'stream', {\n      enumerable: false,\n      configurable: true,\n      set: function set(value) {\n        _stream = value.trim();\n      },\n      get: function get() {\n        if (_stream) {\n          return _stream;\n        } else {\n          return null;\n        }\n      }\n    });\n  };\n\n  inherit(AcroFormXObject, AcroFormPDFObject);\n\n  var AcroFormDictionary = function AcroFormDictionary() {\n    AcroFormPDFObject.call(this);\n    var _Kids = [];\n    Object.defineProperty(this, 'Kids', {\n      enumerable: false,\n      configurable: true,\n      get: function get() {\n        if (_Kids.length > 0) {\n          return _Kids;\n        } else {\n          return;\n        }\n      }\n    });\n    Object.defineProperty(this, 'Fields', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        return _Kids;\n      }\n    }); // Default Appearance\n\n    var _DA;\n\n    Object.defineProperty(this, 'DA', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        if (!_DA) {\n          return;\n        }\n\n        return '(' + _DA + ')';\n      },\n      set: function set(value) {\n        _DA = value;\n      }\n    });\n  };\n\n  inherit(AcroFormDictionary, AcroFormPDFObject);\n  /**\n  * The Field Object contains the Variables, that every Field needs\n  * \n  * @class AcroFormField\n  * @classdesc An AcroForm FieldObject\n  */\n\n  var AcroFormField = function AcroFormField() {\n    AcroFormPDFObject.call(this); //Annotation-Flag See Table 165\n\n    var _F = 4;\n    Object.defineProperty(this, 'F', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        return _F;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          _F = value;\n        } else {\n          throw new Error('Invalid value \"' + value + '\" for attribute F supplied.');\n        }\n      }\n    });\n    /**\n    * (PDF 1.2) If set, print the annotation when the page is printed. If clear, never print the annotation, regardless of wether is is displayed on the screen. \n    * NOTE 2 This can be useful for annotations representing interactive pushbuttons, which would serve no meaningful purpose on the printed page.\n    *\n    * @name AcroFormField#showWhenPrinted\n    * @default true\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'showWhenPrinted', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(_F, 3));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.F = setBitForPdf(_F, 3);\n        } else {\n          this.F = clearBitForPdf(_F, 3);\n        }\n      }\n    });\n    var _Ff = 0;\n    Object.defineProperty(this, 'Ff', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        return _Ff;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          _Ff = value;\n        } else {\n          throw new Error('Invalid value \"' + value + '\" for attribute Ff supplied.');\n        }\n      }\n    });\n    var _Rect = [];\n    Object.defineProperty(this, 'Rect', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        if (_Rect.length === 0) {\n          return;\n        }\n\n        return _Rect;\n      },\n      set: function set(value) {\n        if (typeof value !== \"undefined\") {\n          _Rect = value;\n        } else {\n          _Rect = [];\n        }\n      }\n    });\n    /**\n    * The x-position of the field.\n    *\n    * @name AcroFormField#x\n    * @default null\n    * @type {number}\n    */\n\n    Object.defineProperty(this, 'x', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        if (!_Rect || isNaN(_Rect[0])) {\n          return 0;\n        }\n\n        return antiScale(_Rect[0]);\n      },\n      set: function set(value) {\n        _Rect[0] = scale(value);\n      }\n    });\n    /**\n    * The y-position of the field.\n    *\n    * @name AcroFormField#y\n    * @default null\n    * @type {number}\n    */\n\n    Object.defineProperty(this, 'y', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        if (!_Rect || isNaN(_Rect[1])) {\n          return 0;\n        }\n\n        return antiScale(_Rect[1]);\n      },\n      set: function set(value) {\n        _Rect[1] = scale(value);\n      }\n    });\n    /**\n    * The width of the field.\n    *\n    * @name AcroFormField#width\n    * @default null\n    * @type {number}\n    */\n\n    Object.defineProperty(this, 'width', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        if (!_Rect || isNaN(_Rect[2])) {\n          return 0;\n        }\n\n        return antiScale(_Rect[2]);\n      },\n      set: function set(value) {\n        _Rect[2] = scale(value);\n      }\n    });\n    /**\n    * The height of the field.\n    *\n    * @name AcroFormField#height\n    * @default null\n    * @type {number}\n    */\n\n    Object.defineProperty(this, 'height', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        if (!_Rect || isNaN(_Rect[3])) {\n          return 0;\n        }\n\n        return antiScale(_Rect[3]);\n      },\n      set: function set(value) {\n        _Rect[3] = scale(value);\n      }\n    });\n    var _FT = \"\";\n    Object.defineProperty(this, 'FT', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        return _FT;\n      },\n      set: function set(value) {\n        switch (value) {\n          case '/Btn':\n          case '/Tx':\n          case '/Ch':\n          case '/Sig':\n            _FT = value;\n            break;\n\n          default:\n            throw new Error('Invalid value \"' + value + '\" for attribute FT supplied.');\n        }\n      }\n    });\n    var _T = null;\n    Object.defineProperty(this, 'T', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        if (!_T || _T.length < 1) {\n          // In case of a Child from a Radio´Group, you don't need a FieldName\n          if (this instanceof AcroFormChildClass) {\n            return;\n          }\n\n          _T = \"FieldObject\" + AcroFormField.FieldNum++;\n        }\n\n        return '(' + pdfEscape(_T) + ')';\n      },\n      set: function set(value) {\n        _T = value.toString();\n      }\n    });\n    /**\n    * (Optional) The partial field name (see 12.7.3.2, “Field Names”).\n    *\n    * @name AcroFormField#fieldName\n    * @default null\n    * @type {string}\n    */\n\n    Object.defineProperty(this, 'fieldName', {\n      configurable: true,\n      enumerable: true,\n      get: function get() {\n        return _T;\n      },\n      set: function set(value) {\n        _T = value;\n      }\n    });\n    var _fontName = 'helvetica';\n    /**\n    * The fontName of the font to be used.\n    *\n    * @name AcroFormField#fontName\n    * @default 'helvetica'\n    * @type {string}\n    */\n\n    Object.defineProperty(this, 'fontName', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _fontName;\n      },\n      set: function set(value) {\n        _fontName = value;\n      }\n    });\n    var _fontStyle = 'normal';\n    /**\n    * The fontStyle of the font to be used.\n    *\n    * @name AcroFormField#fontStyle\n    * @default 'normal'\n    * @type {string}\n    */\n\n    Object.defineProperty(this, 'fontStyle', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _fontStyle;\n      },\n      set: function set(value) {\n        _fontStyle = value;\n      }\n    });\n    var _fontSize = 0;\n    /**\n    * The fontSize of the font to be used.\n    *\n    * @name AcroFormField#fontSize\n    * @default 0 (for auto)\n    * @type {number}\n    */\n\n    Object.defineProperty(this, 'fontSize', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return antiScale(_fontSize);\n      },\n      set: function set(value) {\n        _fontSize = scale(value);\n      }\n    });\n    var _maxFontSize = 50;\n    /**\n    * The maximum fontSize of the font to be used.\n    *\n    * @name AcroFormField#maxFontSize\n    * @default 0 (for auto)\n    * @type {number}\n    */\n\n    Object.defineProperty(this, 'maxFontSize', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return antiScale(_maxFontSize);\n      },\n      set: function set(value) {\n        _maxFontSize = scale(value);\n      }\n    });\n    var _color = 'black';\n    /**\n    * The color of the text\n    *\n    * @name AcroFormField#color\n    * @default 'black'\n    * @type {string|rgba}\n    */\n\n    Object.defineProperty(this, 'color', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _color;\n      },\n      set: function set(value) {\n        _color = value;\n      }\n    });\n    var _DA = '/F1 0 Tf 0 g'; // Defines the default appearance (Needed for variable Text)\n\n    Object.defineProperty(this, 'DA', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        if (!_DA || this instanceof AcroFormChildClass || this instanceof AcroFormTextField) {\n          return;\n        }\n\n        return toPdfString(_DA);\n      },\n      set: function set(value) {\n        value = value.toString();\n        _DA = value;\n      }\n    });\n    var _DV = null;\n    Object.defineProperty(this, 'DV', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        if (!_DV) {\n          return;\n        }\n\n        if (this instanceof AcroFormButton === false) {\n          return toPdfString(_DV);\n        }\n\n        return _DV;\n      },\n      set: function set(value) {\n        value = value.toString();\n\n        if (this instanceof AcroFormButton === false) {\n          if (value.substr(0, 1) === '(') {\n            _DV = pdfUnescape(value.substr(1, value.length - 2));\n          } else {\n            _DV = pdfUnescape(value);\n          }\n        } else {\n          _DV = value;\n        }\n      }\n    });\n    /**\n    * (Optional; inheritable) The default value to which the field reverts when a reset-form action is executed (see 12.7.5.3, “Reset-Form Action”). The format of this value is the same as that of value. \n    *\n    * @name AcroFormField#defaultValue\n    * @default null\n    * @type {any}\n    */\n\n    Object.defineProperty(this, 'defaultValue', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        if (this instanceof AcroFormButton === true) {\n          return pdfUnescape(_DV.substr(1, _DV.length - 1));\n        } else {\n          return _DV;\n        }\n      },\n      set: function set(value) {\n        value = value.toString();\n\n        if (this instanceof AcroFormButton === true) {\n          _DV = '/' + value;\n        } else {\n          _DV = value;\n        }\n      }\n    });\n    var _V = null;\n    Object.defineProperty(this, 'V', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        if (!_V) {\n          return;\n        }\n\n        if (this instanceof AcroFormButton === false) {\n          return toPdfString(_V);\n        }\n\n        return _V;\n      },\n      set: function set(value) {\n        value = value.toString();\n\n        if (this instanceof AcroFormButton === false) {\n          if (value.substr(0, 1) === '(') {\n            _V = pdfUnescape(value.substr(1, value.length - 2));\n          } else {\n            _V = pdfUnescape(value);\n          }\n        } else {\n          _V = value;\n        }\n      }\n    });\n    /**\n    * (Optional; inheritable) The field’s value, whose format varies depending on the field type. See the descriptions of individual field types for further information. \n    *\n    * @name AcroFormField#value\n    * @default null\n    * @type {any}\n    */\n\n    Object.defineProperty(this, 'value', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        if (this instanceof AcroFormButton === true) {\n          return pdfUnescape(_V.substr(1, _V.length - 1));\n        } else {\n          return _V;\n        }\n      },\n      set: function set(value) {\n        value = value.toString();\n\n        if (this instanceof AcroFormButton === true) {\n          _V = '/' + value;\n        } else {\n          _V = value;\n        }\n      }\n    });\n    /**\n    * Check if field has annotations\n    *\n    * @name AcroFormField#hasAnnotation\n    * @readonly\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'hasAnnotation', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return this.Rect;\n      }\n    });\n    Object.defineProperty(this, 'Type', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        return this.hasAnnotation ? \"/Annot\" : null;\n      }\n    });\n    Object.defineProperty(this, 'Subtype', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        return this.hasAnnotation ? \"/Widget\" : null;\n      }\n    });\n    var _hasAppearanceStream = false;\n    /**\n    * true if field has an appearanceStream\n    *\n    * @name AcroFormField#hasAppearanceStream\n    * @readonly\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'hasAppearanceStream', {\n      enumerable: true,\n      configurable: true,\n      writeable: true,\n      get: function get() {\n        return _hasAppearanceStream;\n      },\n      set: function set(value) {\n        value = Boolean(value);\n        _hasAppearanceStream = value;\n      }\n    });\n    /**\n    * The page on which the AcroFormField is placed\n    *\n    * @name AcroFormField#page\n    * @type {number}\n    */\n\n    var _page;\n\n    Object.defineProperty(this, 'page', {\n      enumerable: true,\n      configurable: true,\n      writeable: true,\n      get: function get() {\n        if (!_page) {\n          return;\n        }\n\n        return _page;\n      },\n      set: function set(value) {\n        _page = value;\n      }\n    });\n    /**\n    * If set, the user may not change the value of the field. Any associated widget annotations will not interact with the user; that is, they will not respond to mouse clicks or change their appearance in response to mouse motions. This flag is useful for fields whose values are computed or imported from a database. \n    *\n    * @name AcroFormField#readOnly\n    * @default false\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'readOnly', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 1));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 1);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 1);\n        }\n      }\n    });\n    /**\n    * If set, the field shall have a value at the time it is exported by a submitform action (see 12.7.5.2, “Submit-Form Action”). \n    *\n    * @name AcroFormField#required\n    * @default false\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'required', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 2));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 2);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 2);\n        }\n      }\n    });\n    /**\n    * If set, the field shall not be exported by a submit-form action (see 12.7.5.2, “Submit-Form Action”)\n    *\n    * @name AcroFormField#noExport\n    * @default false\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'noExport', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 3));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 3);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 3);\n        }\n      }\n    });\n    var _Q = null;\n    Object.defineProperty(this, 'Q', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        if (_Q === null) {\n          return;\n        }\n\n        return _Q;\n      },\n      set: function set(value) {\n        if ([0, 1, 2].indexOf(value) !== -1) {\n          _Q = value;\n        } else {\n          throw new Error('Invalid value \"' + value + '\" for attribute Q supplied.');\n        }\n      }\n    });\n    /**\n    * (Optional; inheritable) A code specifying the form of quadding (justification) that shall be used in displaying the text:\n    * 'left', 'center', 'right'\n    *\n    * @name AcroFormField#textAlign\n    * @default 'left'\n    * @type {string}\n    */\n\n    Object.defineProperty(this, 'textAlign', {\n      get: function get() {\n        var result = 'left';\n\n        switch (_Q) {\n          case 0:\n          default:\n            result = 'left';\n            break;\n\n          case 1:\n            result = 'center';\n            break;\n\n          case 2:\n            result = 'right';\n            break;\n        }\n\n        return result;\n      },\n      configurable: true,\n      enumerable: true,\n      set: function set(value) {\n        switch (value) {\n          case 'right':\n          case 2:\n            _Q = 2;\n            break;\n\n          case 'center':\n          case 1:\n            _Q = 1;\n            break;\n\n          case 'left':\n          case 0:\n          default:\n            _Q = 0;\n        }\n      }\n    });\n  };\n\n  inherit(AcroFormField, AcroFormPDFObject);\n  /**\n  * @class AcroFormChoiceField\n  * @extends AcroFormField\n  */\n\n  var AcroFormChoiceField = function AcroFormChoiceField() {\n    AcroFormField.call(this); // Field Type = Choice Field\n\n    this.FT = \"/Ch\"; // options\n\n    this.V = '()';\n    this.fontName = 'zapfdingbats'; // Top Index\n\n    var _TI = 0;\n    Object.defineProperty(this, 'TI', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        return _TI;\n      },\n      set: function set(value) {\n        _TI = value;\n      }\n    });\n    /**\n    * (Optional) For scrollable list boxes, the top index (the index in the Opt array of the first option visible in the list). Default value: 0.\n    * \n    * @name AcroFormChoiceField#topIndex\n    * @default 0\n    * @type {number}\n    */\n\n    Object.defineProperty(this, 'topIndex', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _TI;\n      },\n      set: function set(value) {\n        _TI = value;\n      }\n    });\n    var _Opt = [];\n    Object.defineProperty(this, 'Opt', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        return arrayToPdfArray(_Opt);\n      },\n      set: function set(value) {\n        _Opt = pdfArrayToStringArray(value);\n      }\n    });\n    /**\n    * @memberof AcroFormChoiceField\n    * @name getOptions\n    * @function\n    * @instance\n    * @returns {array} array of Options\n    */\n\n    this.getOptions = function () {\n      return _Opt;\n    };\n    /**\n    * @memberof AcroFormChoiceField\n    * @name setOptions\n    * @function\n    * @instance\n    * @param {array} value\n    */\n\n\n    this.setOptions = function (value) {\n      _Opt = value;\n\n      if (this.sort) {\n        _Opt.sort();\n      }\n    };\n    /**\n    * @memberof AcroFormChoiceField\n    * @name addOption\n    * @function\n    * @instance\n    * @param {string} value\n    */\n\n\n    this.addOption = function (value) {\n      value = value || \"\";\n      value = value.toString();\n\n      _Opt.push(value);\n\n      if (this.sort) {\n        _Opt.sort();\n      }\n    };\n    /**\n    * @memberof AcroFormChoiceField\n    * @name removeOption\n    * @function\n    * @instance\n    * @param {string} value\n    * @param {boolean} allEntries (default: false)\n    */\n\n\n    this.removeOption = function (value, allEntries) {\n      allEntries = allEntries || false;\n      value = value || \"\";\n      value = value.toString();\n\n      while (_Opt.indexOf(value) !== -1) {\n        _Opt.splice(_Opt.indexOf(value), 1);\n\n        if (allEntries === false) {\n          break;\n        }\n      }\n    };\n    /**\n    * If set, the field is a combo box; if clear, the field is a list box. \n    *\n    * @name AcroFormChoiceField#combo\n    * @default false\n    * @type {boolean}\n    */\n\n\n    Object.defineProperty(this, 'combo', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 18));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 18);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 18);\n        }\n      }\n    });\n    /**\n    * If set, the combo box shall include an editable text box as well as a drop-down list; if clear, it shall include only a drop-down list. This flag shall be used only if the Combo flag is set. \n    *\n    * @name AcroFormChoiceField#edit\n    * @default false\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'edit', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 19));\n      },\n      set: function set(value) {\n        //PDF 32000-1:2008, page 444\n        if (this.combo === true) {\n          if (Boolean(value) === true) {\n            this.Ff = setBitForPdf(this.Ff, 19);\n          } else {\n            this.Ff = clearBitForPdf(this.Ff, 19);\n          }\n        }\n      }\n    });\n    /**\n    * If set, the field’s option items shall be sorted alphabetically. This flag is intended for use by writers, not by readers. Conforming readers shall display the options in the order in which they occur in the Opt array (see Table 231). \n    *\n    * @name AcroFormChoiceField#sort\n    * @default false\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'sort', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 20));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 20);\n\n          _Opt.sort();\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 20);\n        }\n      }\n    });\n    /**\n    * (PDF 1.4) If set, more than one of the field’s option items may be selected simultaneously; if clear, at most one item shall be selected \n    *\n    * @name AcroFormChoiceField#multiSelect\n    * @default false\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'multiSelect', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 22));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 22);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 22);\n        }\n      }\n    });\n    /**\n    * (PDF 1.4) If set, text entered in the field shall not be spellchecked. This flag shall not be used unless the Combo and Edit flags are both set. \n    *\n    * @name AcroFormChoiceField#doNotSpellCheck\n    * @default false\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'doNotSpellCheck', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 23));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 23);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 23);\n        }\n      }\n    });\n    /**\n    * (PDF 1.5) If set, the new value shall be committed as soon as a selection is made (commonly with the pointing device). In this case, supplying a value for a field involves three actions: selecting the field for fill-in, selecting a choice for the fill-in value, and leaving that field, which finalizes or “commits” the data choice and triggers any actions associated with the entry or changing of this data. If this flag is on, then processing does not wait for leaving the field action to occur, but immediately proceeds to the third step.\n    * This option enables applications to perform an action once a selection is made, without requiring the user to exit the field. If clear, the new value is not committed until the user exits the field.\n    *\n    * @name AcroFormChoiceField#commitOnSelChange\n    * @default false\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'commitOnSelChange', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 27));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 27);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 27);\n        }\n      }\n    });\n    this.hasAppearanceStream = false;\n  };\n\n  inherit(AcroFormChoiceField, AcroFormField);\n  /**\n  * @class AcroFormListBox\n  * @extends AcroFormChoiceField\n  * @extends AcroFormField\n  */\n\n  var AcroFormListBox = function AcroFormListBox() {\n    AcroFormChoiceField.call(this);\n    this.fontName = 'helvetica'; //PDF 32000-1:2008, page 444\n\n    this.combo = false;\n  };\n\n  inherit(AcroFormListBox, AcroFormChoiceField);\n  /**\n  * @class AcroFormComboBox \n  * @extends AcroFormListBox\n  * @extends AcroFormChoiceField\n  * @extends AcroFormField\n  */\n\n  var AcroFormComboBox = function AcroFormComboBox() {\n    AcroFormListBox.call(this);\n    this.combo = true;\n  };\n\n  inherit(AcroFormComboBox, AcroFormListBox);\n  /**\n  * @class AcroFormEditBox \n  * @extends AcroFormComboBox\n  * @extends AcroFormListBox\n  * @extends AcroFormChoiceField\n  * @extends AcroFormField\n  */\n\n  var AcroFormEditBox = function AcroFormEditBox() {\n    AcroFormComboBox.call(this);\n    this.edit = true;\n  };\n\n  inherit(AcroFormEditBox, AcroFormComboBox);\n  /**\n  * @class AcroFormButton\n  * @extends AcroFormField\n  */\n\n  var AcroFormButton = function AcroFormButton() {\n    AcroFormField.call(this);\n    this.FT = \"/Btn\";\n    /**\n    * (Radio buttons only) If set, exactly one radio button shall be selected at all times; selecting the currently selected button has no effect. If clear, clicking the selected button deselects it, leaving no button selected.\n    * \n    * @name AcroFormButton#noToggleToOff\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'noToggleToOff', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 15));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 15);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 15);\n        }\n      }\n    });\n    /**\n    * If set, the field is a set of radio buttons; if clear, the field is a checkbox. This flag may be set only if the Pushbutton flag is clear. \n    * \n    * @name AcroFormButton#radio\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'radio', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 16));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 16);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 16);\n        }\n      }\n    });\n    /**\n    * If set, the field is a pushbutton that does not retain a permanent value. \n    *\n    * @name AcroFormButton#pushButton\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'pushButton', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 17));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 17);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 17);\n        }\n      }\n    });\n    /**\n    * (PDF 1.5) If set, a group of radio buttons within a radio button field that use the same value for the on state will turn on and off in unison; that is if one is checked, they are all checked. If clear, the buttons are mutually exclusive (the same behavior as HTML radio buttons).\n    *\n    * @name AcroFormButton#radioIsUnison\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'radioIsUnison', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 26));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 26);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 26);\n        }\n      }\n    });\n    var _MK = {};\n    Object.defineProperty(this, 'MK', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        if (Object.keys(_MK).length !== 0) {\n          var result = [];\n          result.push('<<');\n          var key;\n\n          for (key in _MK) {\n            result.push('/' + key + ' (' + _MK[key] + ')');\n          }\n\n          result.push('>>');\n          return result.join('\\n');\n        }\n\n        return;\n      },\n      set: function set(value) {\n        if (_typeof(value) === \"object\") {\n          _MK = value;\n        }\n      }\n    });\n    /**\n    * From the PDF reference:\n    * (Optional, button fields only) The widget annotation's normal caption which shall be displayed when it is not interacting with the user. \n    * Unlike the remaining entries listed in this Table which apply only to widget annotations associated with pushbutton fields (see Pushbuttons in 12.7.4.2, \"Button Fields\"), the CA entry may be used with any type of button field, including check boxes (see Check Boxes in 12.7.4.2, \"Button Fields\") and radio buttons (Radio Buttons in 12.7.4.2, \"Button Fields\").\n    *\n    * - '8' = Cross, \n    * - 'l' =  Circle,\n    * - '' = nothing\n    * @name AcroFormButton#caption\n    * @type {string}\n    */\n\n    Object.defineProperty(this, 'caption', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _MK.CA || '';\n      },\n      set: function set(value) {\n        if (typeof value === \"string\") {\n          _MK.CA = value;\n        }\n      }\n    });\n\n    var _AS;\n\n    Object.defineProperty(this, 'AS', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        return _AS;\n      },\n      set: function set(value) {\n        _AS = value;\n      }\n    });\n    /**\n    * (Required if the appearance dictionary AP contains one or more subdictionaries; PDF 1.2) The annotation's appearance state, which selects the applicable appearance stream from an appearance subdictionary (see Section 12.5.5, \"Appearance Streams\")\n    *\n    * @name AcroFormButton#appearanceState\n    * @type {any}\n    */\n\n    Object.defineProperty(this, 'appearanceState', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _AS.substr(1, _AS.length - 1);\n      },\n      set: function set(value) {\n        _AS = '/' + value;\n      }\n    });\n  };\n\n  inherit(AcroFormButton, AcroFormField);\n  /**\n  * @class AcroFormPushButton\n  * @extends AcroFormButton\n  * @extends AcroFormField\n  */\n\n  var AcroFormPushButton = function AcroFormPushButton() {\n    AcroFormButton.call(this);\n    this.pushButton = true;\n  };\n\n  inherit(AcroFormPushButton, AcroFormButton);\n  /**\n  * @class AcroFormRadioButton\n  * @extends AcroFormButton\n  * @extends AcroFormField\n  */\n\n  var AcroFormRadioButton = function AcroFormRadioButton() {\n    AcroFormButton.call(this);\n    this.radio = true;\n    this.pushButton = false;\n    var _Kids = [];\n    Object.defineProperty(this, 'Kids', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        return _Kids;\n      },\n      set: function set(value) {\n        if (typeof value !== \"undefined\") {\n          _Kids = value;\n        } else {\n          _Kids = [];\n        }\n      }\n    });\n  };\n\n  inherit(AcroFormRadioButton, AcroFormButton);\n  /**\n  * The Child class of a RadioButton (the radioGroup) -> The single Buttons\n  * \n  * @class AcroFormChildClass\n  * @extends AcroFormField\n  * @ignore\n  */\n\n  var AcroFormChildClass = function AcroFormChildClass() {\n    AcroFormField.call(this);\n\n    var _parent;\n\n    Object.defineProperty(this, 'Parent', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        return _parent;\n      },\n      set: function set(value) {\n        _parent = value;\n      }\n    });\n\n    var _optionName;\n\n    Object.defineProperty(this, 'optionName', {\n      enumerable: false,\n      configurable: true,\n      get: function get() {\n        return _optionName;\n      },\n      set: function set(value) {\n        _optionName = value;\n      }\n    });\n    var _MK = {};\n    Object.defineProperty(this, 'MK', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        var result = [];\n        result.push('<<');\n        var key;\n\n        for (key in _MK) {\n          result.push('/' + key + ' (' + _MK[key] + ')');\n        }\n\n        result.push('>>');\n        return result.join('\\n');\n      },\n      set: function set(value) {\n        if (_typeof(value) === \"object\") {\n          _MK = value;\n        }\n      }\n    });\n    /**\n    * From the PDF reference:\n    * (Optional, button fields only) The widget annotation's normal caption which shall be displayed when it is not interacting with the user. \n    * Unlike the remaining entries listed in this Table which apply only to widget annotations associated with pushbutton fields (see Pushbuttons in 12.7.4.2, \"Button Fields\"), the CA entry may be used with any type of button field, including check boxes (see Check Boxes in 12.7.4.2, \"Button Fields\") and radio buttons (Radio Buttons in 12.7.4.2, \"Button Fields\").\n    *\n    * - '8' = Cross, \n    * - 'l' =  Circle,\n    * - '' = nothing\n    * @name AcroFormButton#caption\n    * @type {string}\n    */\n\n    Object.defineProperty(this, 'caption', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _MK.CA || '';\n      },\n      set: function set(value) {\n        if (typeof value === \"string\") {\n          _MK.CA = value;\n        }\n      }\n    });\n\n    var _AS;\n\n    Object.defineProperty(this, 'AS', {\n      enumerable: false,\n      configurable: false,\n      get: function get() {\n        return _AS;\n      },\n      set: function set(value) {\n        _AS = value;\n      }\n    });\n    /**\n    * (Required if the appearance dictionary AP contains one or more subdictionaries; PDF 1.2) The annotation's appearance state, which selects the applicable appearance stream from an appearance subdictionary (see Section 12.5.5, \"Appearance Streams\")\n    *\n    * @name AcroFormButton#appearanceState\n    * @type {any}\n    */\n\n    Object.defineProperty(this, 'appearanceState', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _AS.substr(1, _AS.length - 1);\n      },\n      set: function set(value) {\n        _AS = '/' + value;\n      }\n    });\n    this.optionName = name;\n    this.caption = 'l';\n    this.appearanceState = 'Off'; // todo: set AppearanceType as variable that can be set from the\n    // outside...\n\n    this._AppearanceType = AcroFormAppearance.RadioButton.Circle; // The Default appearanceType is the Circle\n\n    this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(name);\n  };\n\n  inherit(AcroFormChildClass, AcroFormField);\n\n  AcroFormRadioButton.prototype.setAppearance = function (appearance) {\n    if (!('createAppearanceStream' in appearance && 'getCA' in appearance)) {\n      throw new Error(\"Couldn't assign Appearance to RadioButton. Appearance was Invalid!\");\n      return;\n    }\n\n    for (var objId in this.Kids) {\n      if (this.Kids.hasOwnProperty(objId)) {\n        var child = this.Kids[objId];\n        child.appearanceStreamContent = appearance.createAppearanceStream(child.optionName);\n        child.caption = appearance.getCA();\n      }\n    }\n  };\n\n  AcroFormRadioButton.prototype.createOption = function (name) {\n    var kidCount = this.Kids.length; // Create new Child for RadioGroup\n\n    var child = new AcroFormChildClass();\n    child.Parent = this;\n    child.optionName = name; // Add to Parent\n\n    this.Kids.push(child);\n    addField.call(this, child);\n    return child;\n  };\n  /**\n  * @class AcroFormCheckBox\n  * @extends AcroFormButton\n  * @extends AcroFormField\n  */\n\n\n  var AcroFormCheckBox = function AcroFormCheckBox() {\n    AcroFormButton.call(this);\n    this.fontName = 'zapfdingbats';\n    this.caption = '3';\n    this.appearanceState = 'On';\n    this.value = \"On\";\n    this.textAlign = 'center';\n    this.appearanceStreamContent = AcroFormAppearance.CheckBox.createAppearanceStream();\n  };\n\n  inherit(AcroFormCheckBox, AcroFormButton);\n  /**\n  * @class AcroFormTextField\n  * @extends AcroFormField\n  */\n\n  var AcroFormTextField = function AcroFormTextField() {\n    AcroFormField.call(this);\n    this.FT = '/Tx';\n    /**\n    * If set, the field may contain multiple lines of text; if clear, the field’s text shall be restricted to a single line. \n    *\n    * @name AcroFormTextField#multiline\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'multiline', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 13));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 13);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 13);\n        }\n      }\n    });\n    /**\n    * (PDF 1.4) If set, the text entered in the field represents the pathname of a file whose contents shall be submitted as the value of the field. \n    * \n    * @name AcroFormTextField#fileSelect\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'fileSelect', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 21));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 21);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 21);\n        }\n      }\n    });\n    /**\n    * (PDF 1.4) If set, text entered in the field shall not be spell-checked. \n    *\n    * @name AcroFormTextField#doNotSpellCheck\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'doNotSpellCheck', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 23));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 23);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 23);\n        }\n      }\n    });\n    /**\n    * (PDF 1.4) If set, the field shall not scroll (horizontally for single-line fields, vertically for multiple-line fields) to accommodate more text than fits within its annotation rectangle. Once the field is full, no further text shall be accepted for interactive form filling; for noninteractive form filling, the filler should take care not to add more character than will visibly fit in the defined area. \n    * \n    * @name AcroFormTextField#doNotScroll\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'doNotScroll', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 24));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 24);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 24);\n        }\n      }\n    });\n    /**\n    * (PDF 1.5) May be set only if the MaxLen entry is present in the text field dictionary (see Table 229) and if the Multiline, Password, and FileSelect flags are clear. If set, the field shall be automatically divided into as many equally spaced positions, or combs, as the value of MaxLen, and the text is laid out into those combs.\n    * \n    * @name AcroFormTextField#comb\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'comb', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 25));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 25);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 25);\n        }\n      }\n    });\n    /**\n    * (PDF 1.5) If set, the value of this field shall be a rich text string (see 12.7.3.4, “Rich Text Strings”). If the field has a value, the RV entry of the field dictionary (Table 222) shall specify the rich text string.\n    * \n    * @name AcroFormTextField#richText\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'richText', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 26));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 26);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 26);\n        }\n      }\n    });\n    var _MaxLen = null;\n    Object.defineProperty(this, 'MaxLen', {\n      enumerable: true,\n      configurable: false,\n      get: function get() {\n        return _MaxLen;\n      },\n      set: function set(value) {\n        _MaxLen = value;\n      }\n    });\n    /**\n    * (Optional; inheritable) The maximum length of the field’s text, in characters. \n    *\n    * @name AcroFormTextField#maxLength\n    * @type {number}\n    */\n\n    Object.defineProperty(this, 'maxLength', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _MaxLen;\n      },\n      set: function set(value) {\n        if (Number.isInteger(value)) {\n          _MaxLen = value;\n        }\n      }\n    });\n    Object.defineProperty(this, 'hasAppearanceStream', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return this.V || this.DV;\n      }\n    });\n  };\n\n  inherit(AcroFormTextField, AcroFormField);\n  /**\n  * @class AcroFormPasswordField\n  * @extends AcroFormTextField\n  * @extends AcroFormField\n  */\n\n  var AcroFormPasswordField = function AcroFormPasswordField() {\n    AcroFormTextField.call(this);\n    /**\n    * If set, the field is intended for entering a secure password that should not be echoed visibly to the screen. Characters typed from the keyboard shall instead be echoed in some unreadable form, such as asterisks or bullet characters.\n    * NOTE To protect password confidentiality, readers should never store the value of the text field in the PDF file if this flag is set. \n    *\n    * @name AcroFormTextField#password\n    * @type {boolean}\n    */\n\n    Object.defineProperty(this, 'password', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return Boolean(getBitForPdf(this.Ff, 14));\n      },\n      set: function set(value) {\n        if (Boolean(value) === true) {\n          this.Ff = setBitForPdf(this.Ff, 14);\n        } else {\n          this.Ff = clearBitForPdf(this.Ff, 14);\n        }\n      }\n    });\n    this.password = true;\n  };\n\n  inherit(AcroFormPasswordField, AcroFormTextField); // Contains Methods for creating standard appearances\n\n  var AcroFormAppearance = {\n    CheckBox: {\n      createAppearanceStream: function createAppearanceStream() {\n        var appearance = {\n          N: {\n            On: AcroFormAppearance.CheckBox.YesNormal\n          },\n          D: {\n            On: AcroFormAppearance.CheckBox.YesPushDown,\n            Off: AcroFormAppearance.CheckBox.OffPushDown\n          }\n        };\n        return appearance;\n      },\n\n      /**\n        * Returns the standard On Appearance for a CheckBox\n        * \n        * @returns {AcroFormXObject}\n        */\n      YesPushDown: function YesPushDown(formObject) {\n        var xobj = createFormXObject(formObject);\n        var stream = [];\n        var fontKey = scope.internal.getFont(formObject.fontName, formObject.fontStyle).id;\n\n        var encodedColor = scope.__private__.encodeColorString(formObject.color);\n\n        var calcRes = calculateX(formObject, formObject.caption);\n        stream.push(\"0.749023 g\");\n        stream.push(\"0 0 \" + f2(AcroFormAppearance.internal.getWidth(formObject)) + \" \" + f2(AcroFormAppearance.internal.getHeight(formObject)) + \" re\");\n        stream.push(\"f\");\n        stream.push(\"BMC\");\n        stream.push(\"q\");\n        stream.push(\"0 0 1 rg\");\n        stream.push(\"/\" + fontKey + \" \" + f2(calcRes.fontSize) + \" Tf \" + encodedColor);\n        stream.push(\"BT\");\n        stream.push(calcRes.text);\n        stream.push(\"ET\");\n        stream.push(\"Q\");\n        stream.push(\"EMC\");\n        xobj.stream = stream.join(\"\\n\");\n        return xobj;\n      },\n      YesNormal: function YesNormal(formObject) {\n        var xobj = createFormXObject(formObject);\n        var fontKey = scope.internal.getFont(formObject.fontName, formObject.fontStyle).id;\n\n        var encodedColor = scope.__private__.encodeColorString(formObject.color);\n\n        var stream = [];\n        var height = AcroFormAppearance.internal.getHeight(formObject);\n        var width = AcroFormAppearance.internal.getWidth(formObject);\n        var calcRes = calculateX(formObject, formObject.caption);\n        stream.push(\"1 g\");\n        stream.push(\"0 0 \" + f2(width) + \" \" + f2(height) + \" re\");\n        stream.push(\"f\");\n        stream.push(\"q\");\n        stream.push(\"0 0 1 rg\");\n        stream.push(\"0 0 \" + f2(width - 1) + \" \" + f2(height - 1) + \" re\");\n        stream.push(\"W\");\n        stream.push(\"n\");\n        stream.push(\"0 g\");\n        stream.push(\"BT\");\n        stream.push(\"/\" + fontKey + \" \" + f2(calcRes.fontSize) + \" Tf \" + encodedColor);\n        stream.push(calcRes.text);\n        stream.push(\"ET\");\n        stream.push(\"Q\");\n        xobj.stream = stream.join(\"\\n\");\n        return xobj;\n      },\n\n      /**\n        * Returns the standard Off Appearance for a CheckBox\n        * \n        * @returns {AcroFormXObject}\n        */\n      OffPushDown: function OffPushDown(formObject) {\n        var xobj = createFormXObject(formObject);\n        var stream = [];\n        stream.push(\"0.749023 g\");\n        stream.push(\"0 0 \" + f2(AcroFormAppearance.internal.getWidth(formObject)) + \" \" + f2(AcroFormAppearance.internal.getHeight(formObject)) + \" re\");\n        stream.push(\"f\");\n        xobj.stream = stream.join(\"\\n\");\n        return xobj;\n      }\n    },\n    RadioButton: {\n      Circle: {\n        createAppearanceStream: function createAppearanceStream(name) {\n          var appearanceStreamContent = {\n            D: {\n              'Off': AcroFormAppearance.RadioButton.Circle.OffPushDown\n            },\n            N: {}\n          };\n          appearanceStreamContent.N[name] = AcroFormAppearance.RadioButton.Circle.YesNormal;\n          appearanceStreamContent.D[name] = AcroFormAppearance.RadioButton.Circle.YesPushDown;\n          return appearanceStreamContent;\n        },\n        getCA: function getCA() {\n          return 'l';\n        },\n        YesNormal: function YesNormal(formObject) {\n          var xobj = createFormXObject(formObject);\n          var stream = []; // Make the Radius of the Circle relative to min(height, width) of formObject\n\n          var DotRadius = AcroFormAppearance.internal.getWidth(formObject) <= AcroFormAppearance.internal.getHeight(formObject) ? AcroFormAppearance.internal.getWidth(formObject) / 4 : AcroFormAppearance.internal.getHeight(formObject) / 4; // The Borderpadding...\n\n          DotRadius = Number((DotRadius * 0.9).toFixed(5));\n          var c = AcroFormAppearance.internal.Bezier_C;\n          var DotRadiusBezier = Number((DotRadius * c).toFixed(5));\n          /*\n            * The Following is a Circle created with Bezier-Curves.\n            */\n\n          stream.push(\"q\");\n          stream.push(\"1 0 0 1 \" + f5(AcroFormAppearance.internal.getWidth(formObject) / 2) + \" \" + f5(AcroFormAppearance.internal.getHeight(formObject) / 2) + \" cm\");\n          stream.push(DotRadius + \" 0 m\");\n          stream.push(DotRadius + \" \" + DotRadiusBezier + \" \" + DotRadiusBezier + \" \" + DotRadius + \" 0 \" + DotRadius + \" c\");\n          stream.push(\"-\" + DotRadiusBezier + \" \" + DotRadius + \" -\" + DotRadius + \" \" + DotRadiusBezier + \" -\" + DotRadius + \" 0 c\");\n          stream.push(\"-\" + DotRadius + \" -\" + DotRadiusBezier + \" -\" + DotRadiusBezier + \" -\" + DotRadius + \" 0 -\" + DotRadius + \" c\");\n          stream.push(DotRadiusBezier + \" -\" + DotRadius + \" \" + DotRadius + \" -\" + DotRadiusBezier + \" \" + DotRadius + \" 0 c\");\n          stream.push(\"f\");\n          stream.push(\"Q\");\n          xobj.stream = stream.join(\"\\n\");\n          return xobj;\n        },\n        YesPushDown: function YesPushDown(formObject) {\n          var xobj = createFormXObject(formObject);\n          var stream = [];\n          var DotRadius = AcroFormAppearance.internal.getWidth(formObject) <= AcroFormAppearance.internal.getHeight(formObject) ? AcroFormAppearance.internal.getWidth(formObject) / 4 : AcroFormAppearance.internal.getHeight(formObject) / 4; // The Borderpadding...\n\n          var DotRadius = Number((DotRadius * 0.9).toFixed(5)); // Save results for later use; no need to waste\n          // processor ticks on doing math\n\n          var k = Number((DotRadius * 2).toFixed(5));\n          var kc = Number((k * AcroFormAppearance.internal.Bezier_C).toFixed(5));\n          var dc = Number((DotRadius * AcroFormAppearance.internal.Bezier_C).toFixed(5));\n          stream.push(\"0.749023 g\");\n          stream.push(\"q\");\n          stream.push(\"1 0 0 1 \" + f5(AcroFormAppearance.internal.getWidth(formObject) / 2) + \" \" + f5(AcroFormAppearance.internal.getHeight(formObject) / 2) + \" cm\");\n          stream.push(k + \" 0 m\");\n          stream.push(k + \" \" + kc + \" \" + kc + \" \" + k + \" 0 \" + k + \" c\");\n          stream.push(\"-\" + kc + \" \" + k + \" -\" + k + \" \" + kc + \" -\" + k + \" 0 c\");\n          stream.push(\"-\" + k + \" -\" + kc + \" -\" + kc + \" -\" + k + \" 0 -\" + k + \" c\");\n          stream.push(kc + \" -\" + k + \" \" + k + \" -\" + kc + \" \" + k + \" 0 c\");\n          stream.push(\"f\");\n          stream.push(\"Q\");\n          stream.push(\"0 g\");\n          stream.push(\"q\");\n          stream.push(\"1 0 0 1 \" + f5(AcroFormAppearance.internal.getWidth(formObject) / 2) + \" \" + f5(AcroFormAppearance.internal.getHeight(formObject) / 2) + \" cm\");\n          stream.push(DotRadius + \" 0 m\");\n          stream.push(\"\" + DotRadius + \" \" + dc + \" \" + dc + \" \" + DotRadius + \" 0 \" + DotRadius + \" c\");\n          stream.push(\"-\" + dc + \" \" + DotRadius + \" -\" + DotRadius + \" \" + dc + \" -\" + DotRadius + \" 0 c\");\n          stream.push(\"-\" + DotRadius + \" -\" + dc + \" -\" + dc + \" -\" + DotRadius + \" 0 -\" + DotRadius + \" c\");\n          stream.push(dc + \" -\" + DotRadius + \" \" + DotRadius + \" -\" + dc + \" \" + DotRadius + \" 0 c\");\n          stream.push(\"f\");\n          stream.push(\"Q\");\n          xobj.stream = stream.join(\"\\n\");\n          return xobj;\n        },\n        OffPushDown: function OffPushDown(formObject) {\n          var xobj = createFormXObject(formObject);\n          var stream = [];\n          var DotRadius = AcroFormAppearance.internal.getWidth(formObject) <= AcroFormAppearance.internal.getHeight(formObject) ? AcroFormAppearance.internal.getWidth(formObject) / 4 : AcroFormAppearance.internal.getHeight(formObject) / 4; // The Borderpadding...\n\n          var DotRadius = Number((DotRadius * 0.9).toFixed(5)); // Save results for later use; no need to waste\n          // processor ticks on doing math\n\n          var k = Number((DotRadius * 2).toFixed(5));\n          var kc = Number((k * AcroFormAppearance.internal.Bezier_C).toFixed(5));\n          stream.push(\"0.749023 g\");\n          stream.push(\"q\");\n          stream.push(\"1 0 0 1 \" + f5(AcroFormAppearance.internal.getWidth(formObject) / 2) + \" \" + f5(AcroFormAppearance.internal.getHeight(formObject) / 2) + \" cm\");\n          stream.push(k + \" 0 m\");\n          stream.push(k + \" \" + kc + \" \" + kc + \" \" + k + \" 0 \" + k + \" c\");\n          stream.push(\"-\" + kc + \" \" + k + \" -\" + k + \" \" + kc + \" -\" + k + \" 0 c\");\n          stream.push(\"-\" + k + \" -\" + kc + \" -\" + kc + \" -\" + k + \" 0 -\" + k + \" c\");\n          stream.push(kc + \" -\" + k + \" \" + k + \" -\" + kc + \" \" + k + \" 0 c\");\n          stream.push(\"f\");\n          stream.push(\"Q\");\n          xobj.stream = stream.join(\"\\n\");\n          return xobj;\n        }\n      },\n      Cross: {\n        /**\n          * Creates the Actual AppearanceDictionary-References\n          * \n          * @param {string} name\n          * @returns {Object}\n          * @ignore\n          */\n        createAppearanceStream: function createAppearanceStream(name) {\n          var appearanceStreamContent = {\n            D: {\n              'Off': AcroFormAppearance.RadioButton.Cross.OffPushDown\n            },\n            N: {}\n          };\n          appearanceStreamContent.N[name] = AcroFormAppearance.RadioButton.Cross.YesNormal;\n          appearanceStreamContent.D[name] = AcroFormAppearance.RadioButton.Cross.YesPushDown;\n          return appearanceStreamContent;\n        },\n        getCA: function getCA() {\n          return '8';\n        },\n        YesNormal: function YesNormal(formObject) {\n          var xobj = createFormXObject(formObject);\n          var stream = [];\n          var cross = AcroFormAppearance.internal.calculateCross(formObject);\n          stream.push(\"q\");\n          stream.push(\"1 1 \" + f2(AcroFormAppearance.internal.getWidth(formObject) - 2) + \" \" + f2(AcroFormAppearance.internal.getHeight(formObject) - 2) + \" re\");\n          stream.push(\"W\");\n          stream.push(\"n\");\n          stream.push(f2(cross.x1.x) + \" \" + f2(cross.x1.y) + \" m\");\n          stream.push(f2(cross.x2.x) + \" \" + f2(cross.x2.y) + \" l\");\n          stream.push(f2(cross.x4.x) + \" \" + f2(cross.x4.y) + \" m\");\n          stream.push(f2(cross.x3.x) + \" \" + f2(cross.x3.y) + \" l\");\n          stream.push(\"s\");\n          stream.push(\"Q\");\n          xobj.stream = stream.join(\"\\n\");\n          return xobj;\n        },\n        YesPushDown: function YesPushDown(formObject) {\n          var xobj = createFormXObject(formObject);\n          var cross = AcroFormAppearance.internal.calculateCross(formObject);\n          var stream = [];\n          stream.push(\"0.749023 g\");\n          stream.push(\"0 0 \" + f2(AcroFormAppearance.internal.getWidth(formObject)) + \" \" + f2(AcroFormAppearance.internal.getHeight(formObject)) + \" re\");\n          stream.push(\"f\");\n          stream.push(\"q\");\n          stream.push(\"1 1 \" + f2(AcroFormAppearance.internal.getWidth(formObject) - 2) + \" \" + f2(AcroFormAppearance.internal.getHeight(formObject) - 2) + \" re\");\n          stream.push(\"W\");\n          stream.push(\"n\");\n          stream.push(f2(cross.x1.x) + \" \" + f2(cross.x1.y) + \" m\");\n          stream.push(f2(cross.x2.x) + \" \" + f2(cross.x2.y) + \" l\");\n          stream.push(f2(cross.x4.x) + \" \" + f2(cross.x4.y) + \" m\");\n          stream.push(f2(cross.x3.x) + \" \" + f2(cross.x3.y) + \" l\");\n          stream.push(\"s\");\n          stream.push(\"Q\");\n          xobj.stream = stream.join(\"\\n\");\n          return xobj;\n        },\n        OffPushDown: function OffPushDown(formObject) {\n          var xobj = createFormXObject(formObject);\n          var stream = [];\n          stream.push(\"0.749023 g\");\n          stream.push(\"0 0 \" + f2(AcroFormAppearance.internal.getWidth(formObject)) + \" \" + f2(AcroFormAppearance.internal.getHeight(formObject)) + \" re\");\n          stream.push(\"f\");\n          xobj.stream = stream.join(\"\\n\");\n          return xobj;\n        }\n      }\n    },\n\n    /**\n      * Returns the standard Appearance\n      * \n      * @returns {AcroFormXObject}\n      */\n    createDefaultAppearanceStream: function createDefaultAppearanceStream(formObject) {\n      // Set Helvetica to Standard Font (size: auto)\n      // Color: Black\n      var fontKey = scope.internal.getFont(formObject.fontName, formObject.fontStyle).id;\n\n      var encodedColor = scope.__private__.encodeColorString(formObject.color);\n\n      var fontSize = formObject.fontSize;\n      var result = '/' + fontKey + ' ' + fontSize + ' Tf ' + encodedColor;\n      return result;\n    }\n  };\n  AcroFormAppearance.internal = {\n    Bezier_C: 0.551915024494,\n    calculateCross: function calculateCross(formObject) {\n      var width = AcroFormAppearance.internal.getWidth(formObject);\n      var height = AcroFormAppearance.internal.getHeight(formObject);\n      var a = Math.min(width, height);\n\n      var cross = {\n        x1: {\n          // upperLeft\n          x: (width - a) / 2,\n          y: (height - a) / 2 + a // height - borderPadding\n\n        },\n        x2: {\n          // lowerRight\n          x: (width - a) / 2 + a,\n          y: (height - a) / 2 // borderPadding\n\n        },\n        x3: {\n          // lowerLeft\n          x: (width - a) / 2,\n          y: (height - a) / 2 // borderPadding\n\n        },\n        x4: {\n          // upperRight\n          x: (width - a) / 2 + a,\n          y: (height - a) / 2 + a // height - borderPadding\n\n        }\n      };\n      return cross;\n    }\n  };\n\n  AcroFormAppearance.internal.getWidth = function (formObject) {\n    var result = 0;\n\n    if (_typeof(formObject) === \"object\") {\n      result = scale(formObject.Rect[2]);\n    }\n\n    return result;\n  };\n\n  AcroFormAppearance.internal.getHeight = function (formObject) {\n    var result = 0;\n\n    if (_typeof(formObject) === \"object\") {\n      result = scale(formObject.Rect[3]);\n    }\n\n    return result;\n  }; // Public:\n\n  /**\n  * Add an AcroForm-Field to the jsPDF-instance\n  *\n  * @name addField\n  * @function \n  * @instance\n  * @param {Object} fieldObject\n  * @returns {jsPDF}\n  */\n\n\n  var addField = jsPDFAPI.addField = function (fieldObject) {\n    initializeAcroForm.call(this);\n\n    if (fieldObject instanceof AcroFormField) {\n      putForm.call(this, fieldObject);\n    } else {\n      throw new Error('Invalid argument passed to jsPDF.addField.');\n    }\n\n    fieldObject.page = scope.internal.getCurrentPageInfo().pageNumber;\n    return this;\n  };\n  /**\n  * @name addButton\n  * @function\n  * @instance\n  * @param {AcroFormButton} options\n  * @returns {jsPDF}\n  * @deprecated\n  */\n\n\n  var addButton = jsPDFAPI.addButton = function (button) {\n    if (button instanceof AcroFormButton === false) {\n      throw new Error('Invalid argument passed to jsPDF.addButton.');\n    }\n\n    return addField.call(this, button);\n  };\n  /**\n  * @name addTextField\n  * @function\n  * @instance\n  * @param {AcroFormTextField} textField\n  * @returns {jsPDF}\n  * @deprecated\n  */\n\n\n  var addTextField = jsPDFAPI.addTextField = function (textField) {\n    if (textField instanceof AcroFormTextField === false) {\n      throw new Error('Invalid argument passed to jsPDF.addTextField.');\n    }\n\n    return addField.call(this, textField);\n  };\n  /**\n  * @name addChoiceField\n  * @function\n  * @instance\n  * @param {AcroFormChoiceField} \n  * @returns {jsPDF}\n  * @deprecated\n  */\n\n\n  var addChoiceField = jsPDFAPI.addChoiceField = function (choiceField) {\n    if (choiceField instanceof AcroFormChoiceField === false) {\n      throw new Error('Invalid argument passed to jsPDF.addChoiceField.');\n    }\n\n    return addField.call(this, choiceField);\n  };\n\n  if (_typeof(globalObj) == \"object\" && typeof globalObj[\"ChoiceField\"] === \"undefined\" && typeof globalObj[\"ListBox\"] === \"undefined\" && typeof globalObj[\"ComboBox\"] === \"undefined\" && typeof globalObj[\"EditBox\"] === \"undefined\" && typeof globalObj[\"Button\"] === \"undefined\" && typeof globalObj[\"PushButton\"] === \"undefined\" && typeof globalObj[\"RadioButton\"] === \"undefined\" && typeof globalObj[\"CheckBox\"] === \"undefined\" && typeof globalObj[\"TextField\"] === \"undefined\" && typeof globalObj[\"PasswordField\"] === \"undefined\") {\n    globalObj[\"ChoiceField\"] = AcroFormChoiceField;\n    globalObj[\"ListBox\"] = AcroFormListBox;\n    globalObj[\"ComboBox\"] = AcroFormComboBox;\n    globalObj[\"EditBox\"] = AcroFormEditBox;\n    globalObj[\"Button\"] = AcroFormButton;\n    globalObj[\"PushButton\"] = AcroFormPushButton;\n    globalObj[\"RadioButton\"] = AcroFormRadioButton;\n    globalObj[\"CheckBox\"] = AcroFormCheckBox;\n    globalObj[\"TextField\"] = AcroFormTextField;\n    globalObj[\"PasswordField\"] = AcroFormPasswordField; // backwardsCompatibility\n\n    globalObj[\"AcroForm\"] = {\n      Appearance: AcroFormAppearance\n    };\n  } else {\n    console.warn(\"AcroForm-Classes are not populated into global-namespace, because the class-Names exist already.\");\n  }\n\n  jsPDFAPI.AcroFormChoiceField = AcroFormChoiceField;\n  jsPDFAPI.AcroFormListBox = AcroFormListBox;\n  jsPDFAPI.AcroFormComboBox = AcroFormComboBox;\n  jsPDFAPI.AcroFormEditBox = AcroFormEditBox;\n  jsPDFAPI.AcroFormButton = AcroFormButton;\n  jsPDFAPI.AcroFormPushButton = AcroFormPushButton;\n  jsPDFAPI.AcroFormRadioButton = AcroFormRadioButton;\n  jsPDFAPI.AcroFormCheckBox = AcroFormCheckBox;\n  jsPDFAPI.AcroFormTextField = AcroFormTextField;\n  jsPDFAPI.AcroFormPasswordField = AcroFormPasswordField;\n  jsPDFAPI.AcroFormAppearance = AcroFormAppearance;\n  jsPDFAPI.AcroForm = {\n    ChoiceField: AcroFormChoiceField,\n    ListBox: AcroFormListBox,\n    ComboBox: AcroFormComboBox,\n    EditBox: AcroFormEditBox,\n    Button: AcroFormButton,\n    PushButton: AcroFormPushButton,\n    RadioButton: AcroFormRadioButton,\n    CheckBox: AcroFormCheckBox,\n    TextField: AcroFormTextField,\n    PasswordField: AcroFormPasswordField,\n    Appearance: AcroFormAppearance\n  };\n})(jsPDF.API, typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global);\n\n/** @license\n * jsPDF addImage plugin\n * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/\n *               2013 Chris Dowling, https://github.com/gingerchris\n *               2013 Trinh Ho, https://github.com/ineedfat\n *               2013 Edwin Alejandro Perez, https://github.com/eaparango\n *               2013 Norah Smith, https://github.com/burnburnrocket\n *               2014 Diego Casorran, https://github.com/diegocr\n *               2014 James Robb, https://github.com/jamesbrobb\n *\n * \n */\n\n/**\n* @name addImage\n* @module\n*/\n(function (jsPDFAPI) {\n\n  var namespace = 'addImage_';\n  var imageFileTypeHeaders = {\n    PNG: [[0x89, 0x50, 0x4e, 0x47]],\n    TIFF: [[0x4D, 0x4D, 0x00, 0x2A], //Motorola\n    [0x49, 0x49, 0x2A, 0x00] //Intel\n    ],\n    JPEG: [[0xFF, 0xD8, 0xFF, 0xE0, undefined, undefined, 0x4A, 0x46, 0x49, 0x46, 0x00], //JFIF\n    [0xFF, 0xD8, 0xFF, 0xE1, undefined, undefined, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00] //Exif\n    ],\n    JPEG2000: [[0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20]],\n    GIF87a: [[0x47, 0x49, 0x46, 0x38, 0x37, 0x61]],\n    GIF89a: [[0x47, 0x49, 0x46, 0x38, 0x39, 0x61]],\n    BMP: [[0x42, 0x4D], //BM - Windows 3.1x, 95, NT, ... etc.\n    [0x42, 0x41], //BA - OS/2 struct bitmap array\n    [0x43, 0x49], //CI - OS/2 struct color icon\n    [0x43, 0x50], //CP - OS/2 const color pointer\n    [0x49, 0x43], //IC - OS/2 struct icon\n    [0x50, 0x54] //PT - OS/2 pointer\n    ]\n  };\n  /**\n  * Recognize filetype of Image by magic-bytes\n  * \n  * https://en.wikipedia.org/wiki/List_of_file_signatures\n  *\n  * @name getImageFileTypeByImageData\n  * @public\n  * @function\n  * @param {string|arraybuffer} imageData imageData as binary String or arraybuffer\n  * @param {string} format format of file if filetype-recognition fails, e.g. 'JPEG'\n  * \n  * @returns {string} filetype of Image\n  */\n\n  var getImageFileTypeByImageData = jsPDFAPI.getImageFileTypeByImageData = function (imageData, fallbackFormat) {\n    fallbackFormat = fallbackFormat || 'UNKNOWN';\n    var i;\n    var j;\n    var result = 'UNKNOWN';\n    var headerSchemata;\n    var compareResult;\n    var fileType;\n\n    if (jsPDFAPI.isArrayBufferView(imageData)) {\n      imageData = jsPDFAPI.arrayBufferToBinaryString(imageData);\n    }\n\n    for (fileType in imageFileTypeHeaders) {\n      headerSchemata = imageFileTypeHeaders[fileType];\n\n      for (i = 0; i < headerSchemata.length; i += 1) {\n        compareResult = true;\n\n        for (j = 0; j < headerSchemata[i].length; j += 1) {\n          if (headerSchemata[i][j] === undefined) {\n            continue;\n          }\n\n          if (headerSchemata[i][j] !== imageData.charCodeAt(j)) {\n            compareResult = false;\n            break;\n          }\n        }\n\n        if (compareResult === true) {\n          result = fileType;\n          break;\n        }\n      }\n    }\n\n    if (result === 'UNKNOWN' && fallbackFormat !== 'UNKNOWN') {\n      console.warn('FileType of Image not recognized. Processing image as \"' + fallbackFormat + '\".');\n      result = fallbackFormat;\n    }\n\n    return result;\n  }; // Image functionality ported from pdf.js\n\n\n  var putImage = function putImage(img) {\n    var objectNumber = this.internal.newObject(),\n        out = this.internal.write,\n        putStream = this.internal.putStream,\n        getFilters = this.internal.getFilters;\n    var filters = getFilters();\n\n    while (filters.indexOf('FlateEncode') !== -1) {\n      filters.splice(filters.indexOf('FlateEncode'), 1);\n    }\n\n    img['n'] = objectNumber;\n    var additionalKeyValues = [];\n    additionalKeyValues.push({\n      key: 'Type',\n      value: '/XObject'\n    });\n    additionalKeyValues.push({\n      key: 'Subtype',\n      value: '/Image'\n    });\n    additionalKeyValues.push({\n      key: 'Width',\n      value: img['w']\n    });\n    additionalKeyValues.push({\n      key: 'Height',\n      value: img['h']\n    });\n\n    if (img['cs'] === this.color_spaces.INDEXED) {\n      additionalKeyValues.push({\n        key: 'ColorSpace',\n        value: '[/Indexed /DeviceRGB ' // if an indexed png defines more than one colour with transparency, we've created a smask\n        + (img['pal'].length / 3 - 1) + ' ' + ('smask' in img ? objectNumber + 2 : objectNumber + 1) + ' 0 R]'\n      });\n    } else {\n      additionalKeyValues.push({\n        key: 'ColorSpace',\n        value: '/' + img['cs']\n      });\n\n      if (img['cs'] === this.color_spaces.DEVICE_CMYK) {\n        additionalKeyValues.push({\n          key: 'Decode',\n          value: '[1 0 1 0 1 0 1 0]'\n        });\n      }\n    }\n\n    additionalKeyValues.push({\n      key: 'BitsPerComponent',\n      value: img['bpc']\n    });\n\n    if ('dp' in img) {\n      additionalKeyValues.push({\n        key: 'DecodeParms',\n        value: '<<' + img['dp'] + '>>'\n      });\n    }\n\n    if ('trns' in img && img['trns'].constructor == Array) {\n      var trns = '',\n          i = 0,\n          len = img['trns'].length;\n\n      for (; i < len; i++) {\n        trns += img['trns'][i] + ' ' + img['trns'][i] + ' ';\n      }\n\n      additionalKeyValues.push({\n        key: 'Mask',\n        value: '[' + trns + ']'\n      });\n    }\n\n    if ('smask' in img) {\n      additionalKeyValues.push({\n        key: 'SMask',\n        value: objectNumber + 1 + ' 0 R'\n      });\n    }\n\n    var alreadyAppliedFilters = typeof img['f'] !== \"undefined\" ? ['/' + img['f']] : undefined;\n    putStream({\n      data: img['data'],\n      additionalKeyValues: additionalKeyValues,\n      alreadyAppliedFilters: alreadyAppliedFilters\n    });\n    out('endobj'); // Soft mask\n\n    if ('smask' in img) {\n      var dp = '/Predictor ' + img['p'] + ' /Colors 1 /BitsPerComponent ' + img['bpc'] + ' /Columns ' + img['w'];\n      var smask = {\n        'w': img['w'],\n        'h': img['h'],\n        'cs': 'DeviceGray',\n        'bpc': img['bpc'],\n        'dp': dp,\n        'data': img['smask']\n      };\n      if ('f' in img) smask.f = img['f'];\n      putImage.call(this, smask);\n    } //Palette\n\n\n    if (img['cs'] === this.color_spaces.INDEXED) {\n      this.internal.newObject(); //out('<< /Filter / ' + img['f'] +' /Length ' + img['pal'].length + '>>');\n      //putStream(zlib.compress(img['pal']));\n\n      putStream({\n        data: this.arrayBufferToBinaryString(new Uint8Array(img['pal']))\n      });\n      out('endobj');\n    }\n  },\n      putResourcesCallback = function putResourcesCallback() {\n    var images = this.internal.collections[namespace + 'images'];\n\n    for (var i in images) {\n      putImage.call(this, images[i]);\n    }\n  },\n      putXObjectsDictCallback = function putXObjectsDictCallback() {\n    var images = this.internal.collections[namespace + 'images'],\n        out = this.internal.write,\n        image;\n\n    for (var i in images) {\n      image = images[i];\n      out('/I' + image['i'], image['n'], '0', 'R');\n    }\n  },\n      checkCompressValue = function checkCompressValue(value) {\n    if (value && typeof value === 'string') value = value.toUpperCase();\n    return value in jsPDFAPI.image_compression ? value : jsPDFAPI.image_compression.NONE;\n  },\n      getImages = function getImages() {\n    var images = this.internal.collections[namespace + 'images']; //first run, so initialise stuff\n\n    if (!images) {\n      this.internal.collections[namespace + 'images'] = images = {};\n      this.internal.events.subscribe('putResources', putResourcesCallback);\n      this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback);\n    }\n\n    return images;\n  },\n      getImageIndex = function getImageIndex(images) {\n    var imageIndex = 0;\n\n    if (images) {\n      // this is NOT the first time this method is ran on this instance of jsPDF object.\n      imageIndex = Object.keys ? Object.keys(images).length : function (o) {\n        var i = 0;\n\n        for (var e in o) {\n          if (o.hasOwnProperty(e)) {\n            i++;\n          }\n        }\n\n        return i;\n      }(images);\n    }\n\n    return imageIndex;\n  },\n      notDefined = function notDefined(value) {\n    return typeof value === 'undefined' || value === null || value.length === 0;\n  },\n      generateAliasFromImageData = function generateAliasFromImageData(imageData) {\n    if (typeof imageData === 'string') {\n      return jsPDFAPI.sHashCode(imageData);\n    }\n\n    if (jsPDFAPI.isArrayBufferView(imageData)) {\n      return jsPDFAPI.sHashCode(jsPDFAPI.arrayBufferToBinaryString(imageData));\n    }\n\n    return null;\n  },\n      isImageTypeSupported = function isImageTypeSupported(type) {\n    return typeof jsPDFAPI[\"process\" + type.toUpperCase()] === \"function\";\n  },\n      isDOMElement = function isDOMElement(object) {\n    return _typeof(object) === 'object' && object.nodeType === 1;\n  },\n      createDataURIFromElement = function createDataURIFromElement(element, format) {\n    //if element is an image which uses data url definition, just return the dataurl\n    if (element.nodeName === 'IMG' && element.hasAttribute('src')) {\n      var src = '' + element.getAttribute('src'); //is base64 encoded dataUrl, directly process it\n\n      if (src.indexOf('data:image/') === 0) {\n        return unescape(src);\n      } //it is probably an url, try to load it\n\n\n      var tmpImageData = jsPDFAPI.loadFile(src);\n\n      if (tmpImageData !== undefined) {\n        return btoa(tmpImageData);\n      }\n    }\n\n    if (element.nodeName === 'CANVAS') {\n      var canvas = element;\n      return element.toDataURL('image/jpeg', 1.0);\n    } //absolute fallback method\n\n\n    var canvas = document.createElement('canvas');\n    canvas.width = element.clientWidth || element.width;\n    canvas.height = element.clientHeight || element.height;\n    var ctx = canvas.getContext('2d');\n\n    if (!ctx) {\n      throw 'addImage requires canvas to be supported by browser.';\n    }\n\n    ctx.drawImage(element, 0, 0, canvas.width, canvas.height);\n    return canvas.toDataURL(('' + format).toLowerCase() == 'png' ? 'image/png' : 'image/jpeg');\n  },\n      checkImagesForAlias = function checkImagesForAlias(alias, images) {\n    var cached_info;\n\n    if (images) {\n      for (var e in images) {\n        if (alias === images[e].alias) {\n          cached_info = images[e];\n          break;\n        }\n      }\n    }\n\n    return cached_info;\n  },\n      determineWidthAndHeight = function determineWidthAndHeight(w, h, info) {\n    if (!w && !h) {\n      w = -96;\n      h = -96;\n    }\n\n    if (w < 0) {\n      w = -1 * info['w'] * 72 / w / this.internal.scaleFactor;\n    }\n\n    if (h < 0) {\n      h = -1 * info['h'] * 72 / h / this.internal.scaleFactor;\n    }\n\n    if (w === 0) {\n      w = h * info['w'] / info['h'];\n    }\n\n    if (h === 0) {\n      h = w * info['h'] / info['w'];\n    }\n\n    return [w, h];\n  },\n      writeImageToPDF = function writeImageToPDF(x, y, w, h, info, index, images, rotation) {\n    var dims = determineWidthAndHeight.call(this, w, h, info),\n        coord = this.internal.getCoordinateString,\n        vcoord = this.internal.getVerticalCoordinateString;\n    w = dims[0];\n    h = dims[1];\n    images[index] = info;\n\n    if (rotation) {\n      rotation *= Math.PI / 180;\n      var c = Math.cos(rotation);\n      var s = Math.sin(rotation); //like in pdf Reference do it 4 digits instead of 2\n\n      var f4 = function f4(number) {\n        return number.toFixed(4);\n      };\n\n      var rotationTransformationMatrix = [f4(c), f4(s), f4(s * -1), f4(c), 0, 0, 'cm'];\n    }\n\n    this.internal.write('q'); //Save graphics state\n\n    if (rotation) {\n      this.internal.write([1, '0', '0', 1, coord(x), vcoord(y + h), 'cm'].join(' ')); //Translate\n\n      this.internal.write(rotationTransformationMatrix.join(' ')); //Rotate\n\n      this.internal.write([coord(w), '0', '0', coord(h), '0', '0', 'cm'].join(' ')); //Scale\n    } else {\n      this.internal.write([coord(w), '0', '0', coord(h), coord(x), vcoord(y + h), 'cm'].join(' ')); //Translate and Scale\n    }\n\n    this.internal.write('/I' + info['i'] + ' Do'); //Paint Image\n\n    this.internal.write('Q'); //Restore graphics state\n  };\n  /**\n   * COLOR SPACES\n   */\n\n\n  jsPDFAPI.color_spaces = {\n    DEVICE_RGB: 'DeviceRGB',\n    DEVICE_GRAY: 'DeviceGray',\n    DEVICE_CMYK: 'DeviceCMYK',\n    CAL_GREY: 'CalGray',\n    CAL_RGB: 'CalRGB',\n    LAB: 'Lab',\n    ICC_BASED: 'ICCBased',\n    INDEXED: 'Indexed',\n    PATTERN: 'Pattern',\n    SEPARATION: 'Separation',\n    DEVICE_N: 'DeviceN'\n  };\n  /**\n   * DECODE METHODS\n   */\n\n  jsPDFAPI.decode = {\n    DCT_DECODE: 'DCTDecode',\n    FLATE_DECODE: 'FlateDecode',\n    LZW_DECODE: 'LZWDecode',\n    JPX_DECODE: 'JPXDecode',\n    JBIG2_DECODE: 'JBIG2Decode',\n    ASCII85_DECODE: 'ASCII85Decode',\n    ASCII_HEX_DECODE: 'ASCIIHexDecode',\n    RUN_LENGTH_DECODE: 'RunLengthDecode',\n    CCITT_FAX_DECODE: 'CCITTFaxDecode'\n  };\n  /**\n   * IMAGE COMPRESSION TYPES\n   */\n\n  jsPDFAPI.image_compression = {\n    NONE: 'NONE',\n    FAST: 'FAST',\n    MEDIUM: 'MEDIUM',\n    SLOW: 'SLOW'\n  };\n  /**\n  * @name sHashCode\n  * @function \n  * @param {string} str\n  * @returns {string} \n  */\n\n  jsPDFAPI.sHashCode = function (str) {\n    str = str || \"\";\n    var hash = 0,\n        i,\n        chr;\n    if (str.length === 0) return hash;\n\n    for (i = 0; i < str.length; i++) {\n      chr = str.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return hash;\n  };\n  /**\n  * @name isString\n  * @function\n  * @param {any} object\n  * @returns {boolean} \n  */\n\n\n  jsPDFAPI.isString = function (object) {\n    return typeof object === 'string';\n  };\n  /**\n  * Validates if given String is a valid Base64-String\n  *\n  * @name validateStringAsBase64\n  * @public\n  * @function\n  * @param {String} possible Base64-String\n  * \n  * @returns {boolean}\n  */\n\n\n  jsPDFAPI.validateStringAsBase64 = function (possibleBase64String) {\n    possibleBase64String = possibleBase64String || '';\n    possibleBase64String.toString().trim();\n    var result = true;\n\n    if (possibleBase64String.length === 0) {\n      result = false;\n    }\n\n    if (possibleBase64String.length % 4 !== 0) {\n      result = false;\n    }\n\n    if (/^[A-Za-z0-9+\\/]+$/.test(possibleBase64String.substr(0, possibleBase64String.length - 2)) === false) {\n      result = false;\n    }\n\n    if (/^[A-Za-z0-9\\/][A-Za-z0-9+\\/]|[A-Za-z0-9+\\/]=|==$/.test(possibleBase64String.substr(-2)) === false) {\n      result = false;\n    }\n\n    return result;\n  };\n  /**\n   * Strips out and returns info from a valid base64 data URI\n   *\n   * @name extractInfoFromBase64DataURI\n   * @function \n   * @param {string} dataUrl a valid data URI of format 'data:[<MIME-type>][;base64],<data>'\n   * @returns {Array}an Array containing the following\n   * [0] the complete data URI\n   * [1] <MIME-type>\n   * [2] format - the second part of the mime-type i.e 'png' in 'image/png'\n   * [4] <data>\n   */\n\n\n  jsPDFAPI.extractInfoFromBase64DataURI = function (dataURI) {\n    return /^data:([\\w]+?\\/([\\w]+?));\\S*;*base64,(.+)$/g.exec(dataURI);\n  };\n  /**\n   * Strips out and returns info from a valid base64 data URI\n   *\n   * @name extractImageFromDataUrl\n   * @function \n   * @param {string} dataUrl a valid data URI of format 'data:[<MIME-type>][;base64],<data>'\n   * @returns {Array}an Array containing the following\n   * [0] the complete data URI\n   * [1] <MIME-type>\n   * [2] format - the second part of the mime-type i.e 'png' in 'image/png'\n   * [4] <data>\n   */\n\n\n  jsPDFAPI.extractImageFromDataUrl = function (dataUrl) {\n    dataUrl = dataUrl || '';\n    var dataUrlParts = dataUrl.split('base64,');\n    var result = null;\n\n    if (dataUrlParts.length === 2) {\n      var extractedInfo = /^data:(\\w*\\/\\w*);*(charset=[\\w=-]*)*;*$/.exec(dataUrlParts[0]);\n\n      if (Array.isArray(extractedInfo)) {\n        result = {\n          mimeType: extractedInfo[1],\n          charset: extractedInfo[2],\n          data: dataUrlParts[1]\n        };\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Check to see if ArrayBuffer is supported\n   * \n   * @name supportsArrayBuffer\n   * @function\n   * @returns {boolean}\n   */\n\n\n  jsPDFAPI.supportsArrayBuffer = function () {\n    return typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';\n  };\n  /**\n   * Tests supplied object to determine if ArrayBuffer\n   *\n   * @name isArrayBuffer\n   * @function \n   * @param {Object} object an Object\n   * \n   * @returns {boolean}\n   */\n\n\n  jsPDFAPI.isArrayBuffer = function (object) {\n    if (!this.supportsArrayBuffer()) return false;\n    return object instanceof ArrayBuffer;\n  };\n  /**\n   * Tests supplied object to determine if it implements the ArrayBufferView (TypedArray) interface\n   *\n   * @name isArrayBufferView\n   * @function \n   * @param {Object} object an Object\n   * @returns {boolean}\n   */\n\n\n  jsPDFAPI.isArrayBufferView = function (object) {\n    if (!this.supportsArrayBuffer()) return false;\n    if (typeof Uint32Array === 'undefined') return false;\n    return object instanceof Int8Array || object instanceof Uint8Array || typeof Uint8ClampedArray !== 'undefined' && object instanceof Uint8ClampedArray || object instanceof Int16Array || object instanceof Uint16Array || object instanceof Int32Array || object instanceof Uint32Array || object instanceof Float32Array || object instanceof Float64Array;\n  };\n  /**\n  * Convert the Buffer to a Binary String\n  *\n  * @name binaryStringToUint8Array\n  * @public\n  * @function\n  * @param {ArrayBuffer} BinaryString with ImageData\n  * \n  * @returns {Uint8Array}\n  */\n\n\n  jsPDFAPI.binaryStringToUint8Array = function (binary_string) {\n    /*\n     * not sure how efficient this will be will bigger files. Is there a native method?\n     */\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      bytes[i] = binary_string.charCodeAt(i);\n    }\n\n    return bytes;\n  };\n  /**\n  * Convert the Buffer to a Binary String\n  *\n  * @name arrayBufferToBinaryString\n  * @public\n  * @function\n  * @param {ArrayBuffer} ArrayBuffer with ImageData\n  * \n  * @returns {String}\n  */\n\n\n  jsPDFAPI.arrayBufferToBinaryString = function (buffer) {\n    // if (typeof Uint8Array !== 'undefined' && typeof Uint8Array.prototype.reduce !== 'undefined') {\n    // return new Uint8Array(buffer).reduce(function (data, byte) {\n    // return data.push(String.fromCharCode(byte)), data;\n    // }, []).join('');\n    // }\n    if (typeof atob === \"function\") {\n      return atob(this.arrayBufferToBase64(buffer));\n    }\n  };\n  /**\n  * Converts an ArrayBuffer directly to base64\n  *\n  * Taken from  http://jsperf.com/encoding-xhr-image-data/31\n  *\n  * Need to test if this is a better solution for larger files\n  *\n  * @name arrayBufferToBase64\n  * @param {arraybuffer} arrayBuffer\n  * @public\n  * @function\n  * \n  * @returns {string}\n  */\n\n\n  jsPDFAPI.arrayBufferToBase64 = function (arrayBuffer) {\n    var base64 = '';\n    var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var bytes = new Uint8Array(arrayBuffer);\n    var byteLength = bytes.byteLength;\n    var byteRemainder = byteLength % 3;\n    var mainLength = byteLength - byteRemainder;\n    var a, b, c, d;\n    var chunk; // Main loop deals with bytes in chunks of 3\n\n    for (var i = 0; i < mainLength; i = i + 3) {\n      // Combine the three bytes into a single integer\n      chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2]; // Use bitmasks to extract 6-bit segments from the triplet\n\n      a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n\n      b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n\n      c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n\n      d = chunk & 63; // 63       = 2^6 - 1\n      // Convert the raw binary segments to the appropriate ASCII encoding\n\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n    } // Deal with the remaining bytes and padding\n\n\n    if (byteRemainder == 1) {\n      chunk = bytes[mainLength];\n      a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n      // Set the 4 least significant bits to zero\n\n      b = (chunk & 3) << 4; // 3   = 2^2 - 1\n\n      base64 += encodings[a] + encodings[b] + '==';\n    } else if (byteRemainder == 2) {\n      chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];\n      a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n\n      b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n      // Set the 2 least significant bits to zero\n\n      c = (chunk & 15) << 2; // 15    = 2^4 - 1\n\n      base64 += encodings[a] + encodings[b] + encodings[c] + '=';\n    }\n\n    return base64;\n  };\n  /**\n  * \n  * @name createImageInfo\n  * @param {Object} data \n  * @param {number} wd width\n  * @param {number} ht height\n  * @param {Object} cs colorSpace\n  * @param {number} bpc bits per channel\n  * @param {any} f \n  * @param {number} imageIndex\n  * @param {string} alias\n  * @param {any} dp\n  * @param {any} trns\n  * @param {any} pal\n  * @param {any} smask\n  * @param {any} p\n  * @public\n  * @function\n  * \n  * @returns {Object}\n  */\n\n\n  jsPDFAPI.createImageInfo = function (data, wd, ht, cs, bpc, f, imageIndex, alias, dp, trns, pal, smask, p) {\n    var info = {\n      alias: alias,\n      w: wd,\n      h: ht,\n      cs: cs,\n      bpc: bpc,\n      i: imageIndex,\n      data: data // n: objectNumber will be added by putImage code\n\n    };\n    if (f) info.f = f;\n    if (dp) info.dp = dp;\n    if (trns) info.trns = trns;\n    if (pal) info.pal = pal;\n    if (smask) info.smask = smask;\n    if (p) info.p = p; // predictor parameter for PNG compression\n\n    return info;\n  };\n  /**\n  * Adds an Image to the PDF.\n  *\n  * @name addImage\n  * @public\n  * @function\n  * @param {string/Image-Element/Canvas-Element/Uint8Array} imageData imageData as base64 encoded DataUrl or Image-HTMLElement or Canvas-HTMLElement\n  * @param {string} format format of file if filetype-recognition fails, e.g. 'JPEG'\n  * @param {number} x x Coordinate (in units declared at inception of PDF document) against left edge of the page\n  * @param {number} y y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n  * @param {number} width width of the image (in units declared at inception of PDF document)\n  * @param {number} height height of the Image (in units declared at inception of PDF document)\n  * @param {string} alias alias of the image (if used multiple times)\n  * @param {string} compression compression of the generated JPEG, can have the values 'NONE', 'FAST', 'MEDIUM' and 'SLOW'\n  * @param {number} rotation rotation of the image in degrees (0-359)\n  * \n  * @returns jsPDF\n  */\n\n\n  jsPDFAPI.addImage = function (imageData, format, x, y, w, h, alias, compression, rotation) {\n\n    var tmpImageData = '';\n\n    if (typeof format !== 'string') {\n      var tmp = h;\n      h = w;\n      w = y;\n      y = x;\n      x = format;\n      format = tmp;\n    }\n\n    if (_typeof(imageData) === 'object' && !isDOMElement(imageData) && \"imageData\" in imageData) {\n      var options = imageData;\n      imageData = options.imageData;\n      format = options.format || format || 'UNKNOWN';\n      x = options.x || x || 0;\n      y = options.y || y || 0;\n      w = options.w || w;\n      h = options.h || h;\n      alias = options.alias || alias;\n      compression = options.compression || compression;\n      rotation = options.rotation || options.angle || rotation;\n    } //If compression is not explicitly set, determine if we should use compression\n\n\n    var filters = this.internal.getFilters();\n\n    if (compression === undefined && filters.indexOf('FlateEncode') !== -1) {\n      compression = 'SLOW';\n    }\n\n    if (typeof imageData === \"string\") {\n      imageData = unescape(imageData);\n    }\n\n    if (isNaN(x) || isNaN(y)) {\n      console.error('jsPDF.addImage: Invalid coordinates', arguments);\n      throw new Error('Invalid coordinates passed to jsPDF.addImage');\n    }\n\n    var images = getImages.call(this),\n        info,\n        dataAsBinaryString;\n\n    if (!(info = checkImagesForAlias(imageData, images))) {\n      if (isDOMElement(imageData)) imageData = createDataURIFromElement(imageData, format);\n      if (notDefined(alias)) alias = generateAliasFromImageData(imageData);\n\n      if (!(info = checkImagesForAlias(alias, images))) {\n        if (this.isString(imageData)) {\n          tmpImageData = this.convertStringToImageData(imageData);\n\n          if (tmpImageData !== '') {\n            imageData = tmpImageData;\n          } else {\n            tmpImageData = jsPDFAPI.loadFile(imageData);\n\n            if (tmpImageData !== undefined) {\n              imageData = tmpImageData;\n            }\n          }\n        }\n\n        format = this.getImageFileTypeByImageData(imageData, format);\n        if (!isImageTypeSupported(format)) throw new Error('addImage does not support files of type \\'' + format + '\\', please ensure that a plugin for \\'' + format + '\\' support is added.');\n        /**\n         * need to test if it's more efficient to convert all binary strings\n         * to TypedArray - or should we just leave and process as string?\n         */\n\n        if (this.supportsArrayBuffer()) {\n          // no need to convert if imageData is already uint8array\n          if (!(imageData instanceof Uint8Array)) {\n            dataAsBinaryString = imageData;\n            imageData = this.binaryStringToUint8Array(imageData);\n          }\n        }\n\n        info = this['process' + format.toUpperCase()](imageData, getImageIndex(images), alias, checkCompressValue(compression), dataAsBinaryString);\n\n        if (!info) {\n          throw new Error('An unknown error occurred whilst processing the image');\n        }\n      }\n    }\n\n    writeImageToPDF.call(this, x, y, w, h, info, info.i, images, rotation);\n    return this;\n  };\n  /**\n  * @name convertStringToImageData\n  * @function\n  * @param {string} stringData\n  * @returns {string} binary data\n  */\n\n\n  jsPDFAPI.convertStringToImageData = function (stringData) {\n    var base64Info;\n    var imageData = '';\n    var rawData;\n\n    if (this.isString(stringData)) {\n      var base64Info = this.extractImageFromDataUrl(stringData);\n      rawData = base64Info !== null ? base64Info.data : stringData;\n\n      try {\n        imageData = atob(rawData);\n      } catch (e) {\n        if (!jsPDFAPI.validateStringAsBase64(rawData)) {\n          throw new Error('Supplied Data is not a valid base64-String jsPDF.convertStringToImageData ');\n        } else {\n          throw new Error('atob-Error in jsPDF.convertStringToImageData ' + e.message);\n        }\n      }\n    }\n\n    return imageData;\n  };\n  /**\n   * JPEG SUPPORT\n   **/\n  //takes a string imgData containing the raw bytes of\n  //a jpeg image and returns [width, height]\n  //Algorithm from: http://www.64lines.com/jpeg-width-height\n\n\n  var getJpegSize = function getJpegSize(imgData) {\n\n    var width, height, numcomponents; // Verify we have a valid jpeg header 0xff,0xd8,0xff,0xe0,?,?,'J','F','I','F',0x00\n\n    if (getImageFileTypeByImageData(imgData) !== 'JPEG') {\n      throw new Error('getJpegSize requires a binary string jpeg file');\n    }\n\n    var blockLength = imgData.charCodeAt(4) * 256 + imgData.charCodeAt(5);\n    var i = 4,\n        len = imgData.length;\n\n    while (i < len) {\n      i += blockLength;\n\n      if (imgData.charCodeAt(i) !== 0xff) {\n        throw new Error('getJpegSize could not find the size of the image');\n      }\n\n      if (imgData.charCodeAt(i + 1) === 0xc0 || //(SOF) Huffman  - Baseline DCT\n      imgData.charCodeAt(i + 1) === 0xc1 || //(SOF) Huffman  - Extended sequential DCT\n      imgData.charCodeAt(i + 1) === 0xc2 || // Progressive DCT (SOF2)\n      imgData.charCodeAt(i + 1) === 0xc3 || // Spatial (sequential) lossless (SOF3)\n      imgData.charCodeAt(i + 1) === 0xc4 || // Differential sequential DCT (SOF5)\n      imgData.charCodeAt(i + 1) === 0xc5 || // Differential progressive DCT (SOF6)\n      imgData.charCodeAt(i + 1) === 0xc6 || // Differential spatial (SOF7)\n      imgData.charCodeAt(i + 1) === 0xc7) {\n        height = imgData.charCodeAt(i + 5) * 256 + imgData.charCodeAt(i + 6);\n        width = imgData.charCodeAt(i + 7) * 256 + imgData.charCodeAt(i + 8);\n        numcomponents = imgData.charCodeAt(i + 9);\n        return [width, height, numcomponents];\n      } else {\n        i += 2;\n        blockLength = imgData.charCodeAt(i) * 256 + imgData.charCodeAt(i + 1);\n      }\n    }\n  },\n      getJpegSizeFromBytes = function getJpegSizeFromBytes(data) {\n    var hdr = data[0] << 8 | data[1];\n    if (hdr !== 0xFFD8) throw new Error('Supplied data is not a JPEG');\n    var len = data.length,\n        block = (data[4] << 8) + data[5],\n        pos = 4,\n        bytes,\n        width,\n        height,\n        numcomponents;\n\n    while (pos < len) {\n      pos += block;\n      bytes = readBytes(data, pos);\n      block = (bytes[2] << 8) + bytes[3];\n\n      if ((bytes[1] === 0xC0 || bytes[1] === 0xC2) && bytes[0] === 0xFF && block > 7) {\n        bytes = readBytes(data, pos + 5);\n        width = (bytes[2] << 8) + bytes[3];\n        height = (bytes[0] << 8) + bytes[1];\n        numcomponents = bytes[4];\n        return {\n          width: width,\n          height: height,\n          numcomponents: numcomponents\n        };\n      }\n\n      pos += 2;\n    }\n\n    throw new Error('getJpegSizeFromBytes could not find the size of the image');\n  },\n      readBytes = function readBytes(data, offset) {\n    return data.subarray(offset, offset + 5);\n  };\n  /**\n  * @ignore\n  */\n\n\n  jsPDFAPI.processJPEG = function (data, index, alias, compression, dataAsBinaryString, colorSpace) {\n\n    var filter = this.decode.DCT_DECODE,\n        bpc = 8,\n        dims;\n\n    if (!this.isString(data) && !this.isArrayBuffer(data) && !this.isArrayBufferView(data)) {\n      return null;\n    }\n\n    if (this.isString(data)) {\n      dims = getJpegSize(data);\n    }\n\n    if (this.isArrayBuffer(data)) {\n      data = new Uint8Array(data);\n    }\n\n    if (this.isArrayBufferView(data)) {\n      dims = getJpegSizeFromBytes(data); // if we already have a stored binary string rep use that\n\n      data = dataAsBinaryString || this.arrayBufferToBinaryString(data);\n    }\n\n    if (colorSpace === undefined) {\n      switch (dims.numcomponents) {\n        case 1:\n          colorSpace = this.color_spaces.DEVICE_GRAY;\n          break;\n\n        case 4:\n          colorSpace = this.color_spaces.DEVICE_CMYK;\n          break;\n\n        default:\n        case 3:\n          colorSpace = this.color_spaces.DEVICE_RGB;\n          break;\n      }\n    }\n\n    return this.createImageInfo(data, dims.width, dims.height, colorSpace, bpc, filter, index, alias);\n  };\n  /**\n  * @ignore\n  */\n\n\n  jsPDFAPI.processJPG = function ()\n  /*data, index, alias, compression, dataAsBinaryString*/\n  {\n    return this.processJPEG.apply(this, arguments);\n  };\n  /**\n  * @name getImageProperties\n  * @function\n  * @param {Object} imageData\n  * @returns {Object}\n  */\n\n\n  jsPDFAPI.getImageProperties = function (imageData) {\n    var info;\n    var tmpImageData = '';\n    var format;\n\n    if (isDOMElement(imageData)) {\n      imageData = createDataURIFromElement(imageData);\n    }\n\n    if (this.isString(imageData)) {\n      tmpImageData = this.convertStringToImageData(imageData);\n\n      if (tmpImageData !== '') {\n        imageData = tmpImageData;\n      } else {\n        tmpImageData = jsPDFAPI.loadFile(imageData);\n\n        if (tmpImageData !== undefined) {\n          imageData = tmpImageData;\n        }\n      }\n    }\n\n    format = this.getImageFileTypeByImageData(imageData);\n\n    if (!isImageTypeSupported(format)) {\n      throw new Error('addImage does not support files of type \\'' + format + '\\', please ensure that a plugin for \\'' + format + '\\' support is added.');\n    }\n    /**\n     * need to test if it's more efficient to convert all binary strings\n     * to TypedArray - or should we just leave and process as string?\n     */\n\n\n    if (this.supportsArrayBuffer()) {\n      // no need to convert if imageData is already uint8array\n      if (!(imageData instanceof Uint8Array)) {\n        imageData = this.binaryStringToUint8Array(imageData);\n      }\n    }\n\n    info = this['process' + format.toUpperCase()](imageData);\n\n    if (!info) {\n      throw new Error('An unknown error occurred whilst processing the image');\n    }\n\n    return {\n      fileType: format,\n      width: info.w,\n      height: info.h,\n      colorSpace: info.cs,\n      compressionMode: info.f,\n      bitsPerComponent: info.bpc\n    };\n  };\n})(jsPDF.API);\n\n/**\n * @license\n * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv\n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * jsPDF Annotations PlugIn\n *\n * There are many types of annotations in a PDF document. Annotations are placed\n * on a page at a particular location. They are not 'attached' to an object.\n * <br />\n * This plugin current supports <br />\n * <li> Goto Page (set pageNumber and top in options)\n * <li> Goto Name (set name and top in options)\n * <li> Goto URL (set url in options)\n * <p>\n * \tThe destination magnification factor can also be specified when goto is a page number or a named destination. (see documentation below)\n *  (set magFactor in options).  XYZ is the default.\n * </p>\n * <p>\n *  Links, Text, Popup, and FreeText are supported.\n * </p>\n * <p>\n * Options In PDF spec Not Implemented Yet\n * <li> link border\n * <li> named target\n * <li> page coordinates\n * <li> destination page scaling and layout\n * <li> actions other than URL and GotoPage\n * <li> background / hover actions\n * </p>\n * @name annotations\n * @module\n */\n\n/*\n    Destination Magnification Factors\n    See PDF 1.3 Page 386 for meanings and options\n\n    [supported]\n\tXYZ (options; left top zoom)\n\tFit (no options)\n\tFitH (options: top)\n\tFitV (options: left)\n\n\t[not supported]\n\tFitR\n\tFitB\n\tFitBH\n\tFitBV\n */\n(function (jsPDFAPI) {\n\n  jsPDF.API.events.push(['addPage', function (addPageData) {\n    var pageInfo = this.internal.getPageInfo(addPageData.pageNumber);\n    pageInfo.pageContext.annotations = [];\n  }]);\n  jsPDFAPI.events.push(['putPage', function (putPageData) {\n    var pageInfo = this.internal.getPageInfoByObjId(putPageData.objId);\n    var pageAnnos = putPageData.pageContext.annotations;\n\n    var notEmpty = function notEmpty(obj) {\n      if (typeof obj != 'undefined') {\n        if (obj != '') {\n          return true;\n        }\n      }\n    };\n\n    var found = false;\n\n    for (var a = 0; a < pageAnnos.length && !found; a++) {\n      var anno = pageAnnos[a];\n\n      switch (anno.type) {\n        case 'link':\n          if (notEmpty(anno.options.url) || notEmpty(anno.options.pageNumber)) {\n            found = true;\n            break;\n          }\n\n        case 'reference':\n        case 'text':\n        case 'freetext':\n          found = true;\n          break;\n      }\n    }\n\n    if (found == false) {\n      return;\n    }\n\n    this.internal.write(\"/Annots [\");\n    var pageHeight = this.internal.pageSize.height;\n    var getHorizontalCoordinateString = this.internal.getCoordinateString;\n    var getVerticalCoordinateString = this.internal.getVerticalCoordinateString;\n\n    for (var a = 0; a < pageAnnos.length; a++) {\n      var anno = pageAnnos[a];\n\n      switch (anno.type) {\n        case 'reference':\n          // References to Widget Annotations (for AcroForm Fields)\n          this.internal.write(' ' + anno.object.objId + ' 0 R ');\n          break;\n\n        case 'text':\n          // Create a an object for both the text and the popup\n          var objText = this.internal.newAdditionalObject();\n          var objPopup = this.internal.newAdditionalObject();\n          var title = anno.title || 'Note';\n          var rect = \"/Rect [\" + getHorizontalCoordinateString(anno.bounds.x) + \" \" + getVerticalCoordinateString(anno.bounds.y + anno.bounds.h) + \" \" + getHorizontalCoordinateString(anno.bounds.x + anno.bounds.w) + \" \" + getVerticalCoordinateString(anno.bounds.y) + \"] \";\n          line = '<</Type /Annot /Subtype /' + 'Text' + ' ' + rect + '/Contents (' + anno.contents + ')';\n          line += ' /Popup ' + objPopup.objId + \" 0 R\";\n          line += ' /P ' + pageInfo.objId + \" 0 R\";\n          line += ' /T (' + title + ') >>';\n          objText.content = line;\n          var parent = objText.objId + ' 0 R';\n          var popoff = 30;\n          var rect = \"/Rect [\" + getHorizontalCoordinateString(anno.bounds.x + popoff) + \" \" + getVerticalCoordinateString(anno.bounds.y + anno.bounds.h) + \" \" + getHorizontalCoordinateString(anno.bounds.x + anno.bounds.w + popoff) + \" \" + getVerticalCoordinateString(anno.bounds.y) + \"] \";\n          line = '<</Type /Annot /Subtype /' + 'Popup' + ' ' + rect + ' /Parent ' + parent;\n\n          if (anno.open) {\n            line += ' /Open true';\n          }\n\n          line += ' >>';\n          objPopup.content = line;\n          this.internal.write(objText.objId, '0 R', objPopup.objId, '0 R');\n          break;\n\n        case 'freetext':\n          var rect = \"/Rect [\" + getHorizontalCoordinateString(anno.bounds.x) + \" \" + getVerticalCoordinateString(anno.bounds.y) + \" \" + getHorizontalCoordinateString(anno.bounds.x + anno.bounds.w) + \" \" + getVerticalCoordinateString(anno.bounds.y + anno.bounds.h) + \"] \";\n          var color = anno.color || '#000000';\n          line = '<</Type /Annot /Subtype /' + 'FreeText' + ' ' + rect + '/Contents (' + anno.contents + ')';\n          line += ' /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#' + color + ')';\n          line += ' /Border [0 0 0]';\n          line += ' >>';\n          this.internal.write(line);\n          break;\n\n        case 'link':\n          if (anno.options.name) {\n            var loc = this.annotations._nameMap[anno.options.name];\n            anno.options.pageNumber = loc.page;\n            anno.options.top = loc.y;\n          } else {\n            if (!anno.options.top) {\n              anno.options.top = 0;\n            }\n          }\n\n          var rect = \"/Rect [\" + getHorizontalCoordinateString(anno.x) + \" \" + getVerticalCoordinateString(anno.y) + \" \" + getHorizontalCoordinateString(anno.x + anno.w) + \" \" + getVerticalCoordinateString(anno.y + anno.h) + \"] \";\n          var line = '';\n\n          if (anno.options.url) {\n            line = '<</Type /Annot /Subtype /Link ' + rect + '/Border [0 0 0] /A <</S /URI /URI (' + anno.options.url + ') >>';\n          } else if (anno.options.pageNumber) {\n            // first page is 0\n            var info = this.internal.getPageInfo(anno.options.pageNumber);\n            line = '<</Type /Annot /Subtype /Link ' + rect + '/Border [0 0 0] /Dest [' + info.objId + \" 0 R\";\n            anno.options.magFactor = anno.options.magFactor || \"XYZ\";\n\n            switch (anno.options.magFactor) {\n              case 'Fit':\n                line += ' /Fit]';\n                break;\n\n              case 'FitH':\n                line += ' /FitH ' + anno.options.top + ']';\n                break;\n\n              case 'FitV':\n                anno.options.left = anno.options.left || 0;\n                line += ' /FitV ' + anno.options.left + ']';\n                break;\n\n              case 'XYZ':\n              default:\n                var top = getVerticalCoordinateString(anno.options.top);\n                anno.options.left = anno.options.left || 0; // 0 or null zoom will not change zoom factor\n\n                if (typeof anno.options.zoom === 'undefined') {\n                  anno.options.zoom = 0;\n                }\n\n                line += ' /XYZ ' + anno.options.left + ' ' + top + ' ' + anno.options.zoom + ']';\n                break;\n            }\n          }\n\n          if (line != '') {\n            line += \" >>\";\n            this.internal.write(line);\n          }\n\n          break;\n      }\n    }\n\n    this.internal.write(\"]\");\n  }]);\n  /**\n  * @name createAnnotation\n  * @function\n  * @param {Object} options \n  */\n\n  jsPDFAPI.createAnnotation = function (options) {\n    var pageInfo = this.internal.getCurrentPageInfo();\n\n    switch (options.type) {\n      case 'link':\n        this.link(options.bounds.x, options.bounds.y, options.bounds.w, options.bounds.h, options);\n        break;\n\n      case 'text':\n      case 'freetext':\n        pageInfo.pageContext.annotations.push(options);\n        break;\n    }\n  };\n  /**\n   * Create a link\n   *\n   * valid options\n   * <li> pageNumber or url [required]\n   * <p>If pageNumber is specified, top and zoom may also be specified</p>\n   * @name link\n   * @function\n   * @param {number} x\n   * @param {number} y\n   * @param {number} w\n   * @param {number} h\n   * @param {Object} options\n   */\n\n\n  jsPDFAPI.link = function (x, y, w, h, options) {\n    var pageInfo = this.internal.getCurrentPageInfo();\n    pageInfo.pageContext.annotations.push({\n      x: x,\n      y: y,\n      w: w,\n      h: h,\n      options: options,\n      type: 'link'\n    });\n  };\n  /**\n   * Currently only supports single line text.\n   * Returns the width of the text/link\n   *\n   * @name textWithLink\n   * @function\n   * @param {string} text\n   * @param {number} x\n   * @param {number} y\n   * @param {Object} options\n   * @returns {number} width the width of the text/link\n   */\n\n\n  jsPDFAPI.textWithLink = function (text, x, y, options) {\n    var width = this.getTextWidth(text);\n    var height = this.internal.getLineHeight() / this.internal.scaleFactor;\n    this.text(text, x, y); //TODO We really need the text baseline height to do this correctly.\n    // Or ability to draw text on top, bottom, center, or baseline.\n\n    y += height * .2;\n    this.link(x, y - height, width, height, options);\n    return width;\n  }; //TODO move into external library\n\n  /**\n  * @name getTextWidth\n  * @function\n  * @param {string} text\n  * @returns {number} txtWidth\n  */\n\n\n  jsPDFAPI.getTextWidth = function (text) {\n    var fontSize = this.internal.getFontSize();\n    var txtWidth = this.getStringUnitWidth(text) * fontSize / this.internal.scaleFactor;\n    return txtWidth;\n  };\n\n  return this;\n})(jsPDF.API);\n\n/**\n * @license\n * Copyright (c) 2017 Aras Abbasi \n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n* jsPDF arabic parser PlugIn\n*\n* @name arabic\n* @module\n*/\n(function (jsPDFAPI) {\n  /**\n   * Arabic shape substitutions: char code => (isolated, final, initial, medial).\n   * Arabic Substition A\n   */\n\n  var arabicSubstitionA = {\n    0x0621: [0xFE80],\n    // ARABIC LETTER HAMZA \n    0x0622: [0xFE81, 0xFE82],\n    // ARABIC LETTER ALEF WITH MADDA ABOVE\n    0x0623: [0xFE83, 0xFE84],\n    // ARABIC LETTER ALEF WITH HAMZA ABOVE\n    0x0624: [0xFE85, 0xFE86],\n    // ARABIC LETTER WAW WITH HAMZA ABOVE\n    0x0625: [0xFE87, 0xFE88],\n    // ARABIC LETTER ALEF WITH HAMZA BELOW\n    0x0626: [0xFE89, 0xFE8A, 0xFE8B, 0xFE8C],\n    // ARABIC LETTER YEH WITH HAMZA ABOVE \n    0x0627: [0xFE8D, 0xFE8E],\n    // ARABIC LETTER ALEF\n    0x0628: [0xFE8F, 0xFE90, 0xFE91, 0xFE92],\n    // ARABIC LETTER BEH\n    0x0629: [0xFE93, 0xFE94],\n    // ARABIC LETTER TEH MARBUTA \n    0x062A: [0xFE95, 0xFE96, 0xFE97, 0xFE98],\n    // ARABIC LETTER TEH\n    0x062B: [0xFE99, 0xFE9A, 0xFE9B, 0xFE9C],\n    // ARABIC LETTER THEH\n    0x062C: [0xFE9D, 0xFE9E, 0xFE9F, 0xFEA0],\n    // ARABIC LETTER JEEM\n    0x062D: [0xFEA1, 0xFEA2, 0xFEA3, 0xFEA4],\n    // ARABIC LETTER HAH\n    0x062E: [0xFEA5, 0xFEA6, 0xFEA7, 0xFEA8],\n    // ARABIC LETTER KHAH\n    0x062F: [0xFEA9, 0xFEAA],\n    // ARABIC LETTER DAL\n    0x0630: [0xFEAB, 0xFEAC],\n    // ARABIC LETTER THAL\n    0x0631: [0xFEAD, 0xFEAE],\n    // ARABIC LETTER REH\n    0x0632: [0xFEAF, 0xFEB0],\n    // ARABIC LETTER ZAIN\n    0x0633: [0xFEB1, 0xFEB2, 0xFEB3, 0xFEB4],\n    // ARABIC LETTER SEEN\n    0x0634: [0xFEB5, 0xFEB6, 0xFEB7, 0xFEB8],\n    // ARABIC LETTER SHEEN \n    0x0635: [0xFEB9, 0xFEBA, 0xFEBB, 0xFEBC],\n    // ARABIC LETTER SAD\n    0x0636: [0xFEBD, 0xFEBE, 0xFEBF, 0xFEC0],\n    // ARABIC LETTER DAD\n    0x0637: [0xFEC1, 0xFEC2, 0xFEC3, 0xFEC4],\n    // ARABIC LETTER TAH\n    0x0638: [0xFEC5, 0xFEC6, 0xFEC7, 0xFEC8],\n    // ARABIC LETTER ZAH\n    0x0639: [0xFEC9, 0xFECA, 0xFECB, 0xFECC],\n    // ARABIC LETTER AIN\n    0x063A: [0xFECD, 0xFECE, 0xFECF, 0xFED0],\n    // ARABIC LETTER GHAIN \n    0x0641: [0xFED1, 0xFED2, 0xFED3, 0xFED4],\n    // ARABIC LETTER FEH\n    0x0642: [0xFED5, 0xFED6, 0xFED7, 0xFED8],\n    // ARABIC LETTER QAF\n    0x0643: [0xFED9, 0xFEDA, 0xFEDB, 0xFEDC],\n    // ARABIC LETTER KAF\n    0x0644: [0xFEDD, 0xFEDE, 0xFEDF, 0xFEE0],\n    // ARABIC LETTER LAM\n    0x0645: [0xFEE1, 0xFEE2, 0xFEE3, 0xFEE4],\n    // ARABIC LETTER MEEM\n    0x0646: [0xFEE5, 0xFEE6, 0xFEE7, 0xFEE8],\n    // ARABIC LETTER NOON \n    0x0647: [0xFEE9, 0xFEEA, 0xFEEB, 0xFEEC],\n    // ARABIC LETTER HEH\n    0x0648: [0xFEED, 0xFEEE],\n    // ARABIC LETTER WAW\n    0x0649: [0xFEEF, 0xFEF0, 64488, 64489],\n    // ARABIC LETTER ALEF MAKSURA \n    0x064A: [0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4],\n    // ARABIC LETTER YEH\n    0x0671: [0xFB50, 0xFB51],\n    // ARABIC LETTER ALEF WASLA\n    0x0677: [0xFBDD],\n    // ARABIC LETTER U WITH HAMZA ABOVE\n    0x0679: [0xFB66, 0xFB67, 0xFB68, 0xFB69],\n    // ARABIC LETTER TTEH\n    0x067A: [0xFB5E, 0xFB5F, 0xFB60, 0xFB61],\n    // ARABIC LETTER TTEHEH\n    0x067B: [0xFB52, 0xFB53, 0xFB54, 0xFB55],\n    // ARABIC LETTER BEEH\n    0x067E: [0xFB56, 0xFB57, 0xFB58, 0xFB59],\n    // ARABIC LETTER PEH \n    0x067F: [0xFB62, 0xFB63, 0xFB64, 0xFB65],\n    // ARABIC LETTER TEHEH\n    0x0680: [0xFB5A, 0xFB5B, 0xFB5C, 0xFB5D],\n    // ARABIC LETTER BEHEH\n    0x0683: [0xFB76, 0xFB77, 0xFB78, 0xFB79],\n    // ARABIC LETTER NYEH\n    0x0684: [0xFB72, 0xFB73, 0xFB74, 0xFB75],\n    // ARABIC LETTER DYEH\n    0x0686: [0xFB7A, 0xFB7B, 0xFB7C, 0xFB7D],\n    // ARABIC LETTER TCHEH\n    0x0687: [0xFB7E, 0xFB7F, 0xFB80, 0xFB81],\n    // ARABIC LETTER TCHEHEH\n    0x0688: [0xFB88, 0xFB89],\n    // ARABIC LETTER DDAL\n    0x068C: [0xFB84, 0xFB85],\n    // ARABIC LETTER DAHAL\n    0x068D: [0xFB82, 0xFB83],\n    // ARABIC LETTER DDAHAL\n    0x068E: [0xFB86, 0xFB87],\n    // ARABIC LETTER DUL \n    0x0691: [0xFB8C, 0xFB8D],\n    // ARABIC LETTER RREH\n    0x0698: [0xFB8A, 0xFB8B],\n    // ARABIC LETTER JEH\n    0x06A4: [0xFB6A, 0xFB6B, 0xFB6C, 0xFB6D],\n    // ARABIC LETTER VEH\n    0x06A6: [0xFB6E, 0xFB6F, 0xFB70, 0xFB71],\n    // ARABIC LETTER PEHEH\n    0x06A9: [0xFB8E, 0xFB8F, 0xFB90, 0xFB91],\n    // ARABIC LETTER KEHEH\n    0x06AD: [0xFBD3, 0xFBD4, 0xFBD5, 0xFBD6],\n    // ARABIC LETTER NG\n    0x06AF: [0xFB92, 0xFB93, 0xFB94, 0xFB95],\n    // ARABIC LETTER GAF\n    0x06B1: [0xFB9A, 0xFB9B, 0xFB9C, 0xFB9D],\n    // ARABIC LETTER NGOEH\n    0x06B3: [0xFB96, 0xFB97, 0xFB98, 0xFB99],\n    // ARABIC LETTER GUEH\n    0x06BA: [0xFB9E, 0xFB9F],\n    // ARABIC LETTER NOON GHUNNA\n    0x06BB: [0xFBA0, 0xFBA1, 0xFBA2, 0xFBA3],\n    // ARABIC LETTER RNOON\n    0x06BE: [0xFBAA, 0xFBAB, 0xFBAC, 0xFBAD],\n    // ARABIC LETTER HEH DOACHASHMEE\n    0x06C0: [0xFBA4, 0xFBA5],\n    // ARABIC LETTER HEH WITH YEH ABOVE\n    0x06C1: [0xFBA6, 0xFBA7, 0xFBA8, 0xFBA9],\n    // ARABIC LETTER HEH GOAL\n    0x06C5: [0xFBE0, 0xFBE1],\n    // ARABIC LETTER KIRGHIZ OE\n    0x06C6: [0xFBD9, 0xFBDA],\n    // ARABIC LETTER OE\n    0x06C7: [0xFBD7, 0xFBD8],\n    // ARABIC LETTER U\n    0x06C8: [0xFBDB, 0xFBDC],\n    // ARABIC LETTER YU\n    0x06C9: [0xFBE2, 0xFBE3],\n    // ARABIC LETTER KIRGHIZ YU\n    0x06CB: [0xFBDE, 0xFBDF],\n    // ARABIC LETTER VE\n    0x06CC: [0xFBFC, 0xFBFD, 0xFBFE, 0xFBFF],\n    // ARABIC LETTER FARSI YEH\n    0x06D0: [0xFBE4, 0xFBE5, 0xFBE6, 0xFBE7],\n    //ARABIC LETTER E\n    0x06D2: [0xFBAE, 0xFBAF],\n    // ARABIC LETTER YEH BARREE\n    0x06D3: [0xFBB0, 0xFBB1] // ARABIC LETTER YEH BARREE WITH HAMZA ABOVE\n\n  };\n  var ligatures = {\n    0xFEDF: {\n      0xFE82: 0xFEF5,\n      // ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE ISOLATED FORM\n      0xFE84: 0xFEF7,\n      // ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE ISOLATED FORM\n      0xFE88: 0xFEF9,\n      // ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW ISOLATED FORM\n      0xFE8E: 0xFEFB // ARABIC LIGATURE LAM WITH ALEF ISOLATED FORM\n\n    },\n    0xFEE0: {\n      0xFE82: 0xFEF6,\n      // ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE FINAL FORM\n      0xFE84: 0xFEF8,\n      // ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE FINAL FORM\n      0xFE88: 0xFEFA,\n      // ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW FINAL FORM\n      0xFE8E: 0xFEFC // ARABIC LIGATURE LAM WITH ALEF FINAL FORM\n\n    },\n    0xFE8D: {\n      0xFEDF: {\n        0xFEE0: {\n          0xFEEA: 0xFDF2\n        }\n      }\n    },\n    // ALLAH\n    0x0651: {\n      0x064C: 0xFC5E,\n      // Shadda + Dammatan\n      0x064D: 0xFC5F,\n      // Shadda + Kasratan\n      0x064E: 0xFC60,\n      // Shadda + Fatha\n      0x064F: 0xFC61,\n      // Shadda + Damma\n      0x0650: 0xFC62 // Shadda + Kasra\n\n    }\n  };\n  var arabic_diacritics = {\n    1612: 64606,\n    // Shadda + Dammatan\n    1613: 64607,\n    // Shadda + Kasratan\n    1614: 64608,\n    // Shadda + Fatha\n    1615: 64609,\n    // Shadda + Damma\n    1616: 64610 // Shadda + Kasra\n\n  };\n  var alfletter = [1570, 1571, 1573, 1575];\n  var noChangeInForm = -1;\n  var isolatedForm = 0;\n  var finalForm = 1;\n  var initialForm = 2;\n  var medialForm = 3;\n  jsPDFAPI.__arabicParser__ = {}; //private\n\n  var isInArabicSubstitutionA = jsPDFAPI.__arabicParser__.isInArabicSubstitutionA = function (letter) {\n    return typeof arabicSubstitionA[letter.charCodeAt(0)] !== \"undefined\";\n  };\n\n  var isArabicLetter = jsPDFAPI.__arabicParser__.isArabicLetter = function (letter) {\n    return typeof letter === \"string\" && /^[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]+$/.test(letter);\n  };\n\n  var isArabicEndLetter = jsPDFAPI.__arabicParser__.isArabicEndLetter = function (letter) {\n    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length <= 2;\n  };\n\n  var isArabicAlfLetter = jsPDFAPI.__arabicParser__.isArabicAlfLetter = function (letter) {\n    return isArabicLetter(letter) && alfletter.indexOf(letter.charCodeAt(0)) >= 0;\n  };\n\n  var arabicLetterHasIsolatedForm = jsPDFAPI.__arabicParser__.arabicLetterHasIsolatedForm = function (letter) {\n    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length >= 1;\n  };\n\n  var arabicLetterHasFinalForm = jsPDFAPI.__arabicParser__.arabicLetterHasFinalForm = function (letter) {\n    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length >= 2;\n  };\n\n  var arabicLetterHasInitialForm = jsPDFAPI.__arabicParser__.arabicLetterHasInitialForm = function (letter) {\n    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length >= 3;\n  };\n\n  var arabicLetterHasMedialForm = jsPDFAPI.__arabicParser__.arabicLetterHasMedialForm = function (letter) {\n    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length == 4;\n  };\n\n  var resolveLigatures = jsPDFAPI.__arabicParser__.resolveLigatures = function (letters) {\n    var i = 0;\n    var tmpLigatures = ligatures;\n    var position = isolatedForm;\n    var result = '';\n    var effectedLetters = 0;\n\n    for (i = 0; i < letters.length; i += 1) {\n      if (typeof tmpLigatures[letters.charCodeAt(i)] !== \"undefined\") {\n        effectedLetters++;\n        tmpLigatures = tmpLigatures[letters.charCodeAt(i)];\n\n        if (typeof tmpLigatures === \"number\") {\n          position = getCorrectForm(letters.charAt(i), letters.charAt(i - effectedLetters), letters.charAt(i + 1));\n          position = position !== -1 ? position : 0;\n          result += String.fromCharCode(tmpLigatures);\n          tmpLigatures = ligatures;\n          effectedLetters = 0;\n        }\n\n        if (i === letters.length - 1) {\n          tmpLigatures = ligatures;\n          result += letters.charAt(i - (effectedLetters - 1));\n          i = i - (effectedLetters - 1);\n          effectedLetters = 0;\n        }\n      } else {\n        tmpLigatures = ligatures;\n        result += letters.charAt(i - effectedLetters);\n        i = i - effectedLetters;\n        effectedLetters = 0;\n      }\n    }\n\n    return result;\n  };\n\n  var isArabicDiacritic = jsPDFAPI.__arabicParser__.isArabicDiacritic = function (letter) {\n    return letter !== undefined && arabic_diacritics[letter.charCodeAt(0)] !== undefined;\n  };\n\n  var getCorrectForm = jsPDFAPI.__arabicParser__.getCorrectForm = function (currentChar, beforeChar, nextChar) {\n\n    if (!isArabicLetter(currentChar)) {\n      return -1;\n    }\n\n    if (isInArabicSubstitutionA(currentChar) === false) {\n      return noChangeInForm;\n    }\n\n    if (!arabicLetterHasFinalForm(currentChar) || !isArabicLetter(beforeChar) && !isArabicLetter(nextChar) || !isArabicLetter(nextChar) && isArabicEndLetter(beforeChar) || isArabicEndLetter(currentChar) && !isArabicLetter(beforeChar) || isArabicEndLetter(currentChar) && isArabicAlfLetter(beforeChar) || isArabicEndLetter(currentChar) && isArabicEndLetter(beforeChar)) {\n      return isolatedForm;\n    }\n\n    if (arabicLetterHasMedialForm(currentChar) && isArabicLetter(beforeChar) && !isArabicEndLetter(beforeChar) && isArabicLetter(nextChar) && arabicLetterHasFinalForm(nextChar)) {\n      return medialForm;\n    }\n\n    if (isArabicEndLetter(currentChar) || !isArabicLetter(nextChar)) {\n      return finalForm;\n    }\n\n    return initialForm;\n  };\n  /**\n  * @name processArabic\n  * @function\n  * @param {string} text\n  * @param {boolean} reverse\n  * @returns {string}\n  */\n\n\n  var processArabic = jsPDFAPI.__arabicParser__.processArabic = jsPDFAPI.processArabic = function (text) {\n    text = text || \"\";\n    var result = \"\";\n    var i = 0;\n    var j = 0;\n    var position = 0;\n    var currentLetter = \"\";\n    var prevLetter = \"\";\n    var nextLetter = \"\";\n    var words = text.split(\"\\\\s+\");\n    var newWords = [];\n\n    for (i = 0; i < words.length; i += 1) {\n      newWords.push('');\n\n      for (j = 0; j < words[i].length; j += 1) {\n        currentLetter = words[i][j];\n        prevLetter = words[i][j - 1];\n        nextLetter = words[i][j + 1];\n\n        if (isArabicLetter(currentLetter)) {\n          position = getCorrectForm(currentLetter, prevLetter, nextLetter);\n\n          if (position !== -1) {\n            newWords[i] += String.fromCharCode(arabicSubstitionA[currentLetter.charCodeAt(0)][position]);\n          } else {\n            newWords[i] += currentLetter;\n          }\n        } else {\n          newWords[i] += currentLetter;\n        }\n      }\n\n      newWords[i] = resolveLigatures(newWords[i]);\n    }\n\n    result = newWords.join(' ');\n    return result;\n  };\n\n  var arabicParserFunction = function arabicParserFunction(args) {\n    var text = args.text;\n    var x = args.x;\n    var y = args.y;\n    var options = args.options || {};\n    var mutex = args.mutex || {};\n    var lang = options.lang;\n    var tmpText = [];\n\n    if (Object.prototype.toString.call(text) === '[object Array]') {\n      var i = 0;\n      tmpText = [];\n\n      for (i = 0; i < text.length; i += 1) {\n        if (Object.prototype.toString.call(text[i]) === '[object Array]') {\n          tmpText.push([processArabic(text[i][0]), text[i][1], text[i][2]]);\n        } else {\n          tmpText.push([processArabic(text[i])]);\n        }\n      }\n\n      args.text = tmpText;\n    } else {\n      args.text = processArabic(text);\n    }\n  };\n\n  jsPDFAPI.events.push(['preProcessText', arabicParserFunction]);\n})(jsPDF.API);\n\n/** @license\n * jsPDF Autoprint Plugin\n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n* @name autoprint\n* @module\n*/\n(function (jsPDFAPI) {\n  /**\n  * Makes the PDF automatically print. This works in Chrome, Firefox, Acrobat\n  * Reader.\n  *\n  * @name autoPrint\n  * @function\n  * @param {Object} options (optional) Set the attribute variant to 'non-conform' (default) or 'javascript' to activate different methods of automatic printing when opening in a PDF-viewer .\n  * @returns {jsPDF}\n  * @example\n  * var doc = new jsPDF();\n  * doc.text(10, 10, 'This is a test');\n  * doc.autoPrint({variant: 'non-conform'});\n  * doc.save('autoprint.pdf');\n  */\n\n  jsPDFAPI.autoPrint = function (options) {\n\n    var refAutoPrintTag;\n    options = options || {};\n    options.variant = options.variant || 'non-conform';\n\n    switch (options.variant) {\n      case 'javascript':\n        //https://github.com/Rob--W/pdf.js/commit/c676ecb5a0f54677b9f3340c3ef2cf42225453bb\n        this.addJS('print({});');\n        break;\n\n      case 'non-conform':\n      default:\n        this.internal.events.subscribe('postPutResources', function () {\n          refAutoPrintTag = this.internal.newObject();\n          this.internal.out(\"<<\");\n          this.internal.out(\"/S /Named\");\n          this.internal.out(\"/Type /Action\");\n          this.internal.out(\"/N /Print\");\n          this.internal.out(\">>\");\n          this.internal.out(\"endobj\");\n        });\n        this.internal.events.subscribe(\"putCatalog\", function () {\n          this.internal.out(\"/OpenAction \" + refAutoPrintTag + \" 0 R\");\n        });\n        break;\n    }\n\n    return this;\n  };\n})(jsPDF.API);\n\n/**\n * @license\n * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv\n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * jsPDF Canvas PlugIn\n * This plugin mimics the HTML5 Canvas\n * \n * The goal is to provide a way for current canvas users to print directly to a PDF.\n * @name canvas\n * @module\n */\n(function (jsPDFAPI) {\n  /**\n  * @class Canvas\n  * @classdesc A Canvas Wrapper for jsPDF\n  */\n\n  var Canvas = function Canvas() {\n    var jsPdfInstance = undefined;\n    Object.defineProperty(this, 'pdf', {\n      get: function get() {\n        return jsPdfInstance;\n      },\n      set: function set(value) {\n        jsPdfInstance = value;\n      }\n    });\n    var _width = 150;\n    /**\n    * The height property is a positive integer reflecting the height HTML attribute of the <canvas> element interpreted in CSS pixels. When the attribute is not specified, or if it is set to an invalid value, like a negative, the default value of 150 is used.\n    * This is one of the two properties, the other being width, that controls the size of the canvas.\n    *\n    * @name width\n    */\n\n    Object.defineProperty(this, 'width', {\n      get: function get() {\n        return _width;\n      },\n      set: function set(value) {\n        if (isNaN(value) || Number.isInteger(value) === false || value < 0) {\n          _width = 150;\n        } else {\n          _width = value;\n        }\n\n        if (this.getContext('2d').pageWrapXEnabled) {\n          this.getContext('2d').pageWrapX = _width + 1;\n        }\n      }\n    });\n    var _height = 300;\n    /**\n    * The width property is a positive integer reflecting the width HTML attribute of the <canvas> element interpreted in CSS pixels. When the attribute is not specified, or if it is set to an invalid value, like a negative, the default value of 300 is used.\n    * This is one of the two properties, the other being height, that controls the size of the canvas.\n    *\n    * @name height\n    */\n\n    Object.defineProperty(this, 'height', {\n      get: function get() {\n        return _height;\n      },\n      set: function set(value) {\n        if (isNaN(value) || Number.isInteger(value) === false || value < 0) {\n          _height = 300;\n        } else {\n          _height = value;\n        }\n\n        if (this.getContext('2d').pageWrapYEnabled) {\n          this.getContext('2d').pageWrapY = _height + 1;\n        }\n      }\n    });\n    var _childNodes = [];\n    Object.defineProperty(this, 'childNodes', {\n      get: function get() {\n        return _childNodes;\n      },\n      set: function set(value) {\n        _childNodes = value;\n      }\n    });\n    var _style = {};\n    Object.defineProperty(this, 'style', {\n      get: function get() {\n        return _style;\n      },\n      set: function set(value) {\n        _style = value;\n      }\n    });\n    Object.defineProperty(this, 'parentNode', {\n      get: function get() {\n        return false;\n      }\n    });\n  };\n  /**\n  * The getContext() method returns a drawing context on the canvas, or null if the context identifier is not supported.\n  * \n  * @name getContext\n  * @function\n  * @param {string} contextType Is a String containing the context identifier defining the drawing context associated to the canvas. Possible value is \"2d\", leading to the creation of a Context2D object representing a two-dimensional rendering context.\n  * @param {object} contextAttributes\n  */\n\n\n  Canvas.prototype.getContext = function (contextType, contextAttributes) {\n    contextType = contextType || '2d';\n    var key;\n\n    if (contextType !== '2d') {\n      return null;\n    }\n\n    for (key in contextAttributes) {\n      if (this.pdf.context2d.hasOwnProperty(key)) {\n        this.pdf.context2d[key] = contextAttributes[key];\n      }\n    }\n\n    this.pdf.context2d._canvas = this;\n    return this.pdf.context2d;\n  };\n  /**\n  * The toDataURL() method is just a stub to throw an error if accidently called.\n  * \n  * @name toDataURL\n  * @function\n  */\n\n\n  Canvas.prototype.toDataURL = function () {\n    throw new Error('toDataURL is not implemented.');\n  };\n\n  jsPDFAPI.events.push(['initialized', function () {\n    this.canvas = new Canvas();\n    this.canvas.pdf = this;\n  }]);\n  return this;\n})(jsPDF.API);\n\n/** \n * @license\n * ====================================================================\n * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com\n *               2013 Eduardo Menezes de Morais, eduardo.morais@usp.br\n *               2013 Lee Driscoll, https://github.com/lsdriscoll\n *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria\n *               2014 James Hall, james@parall.ax\n *               2014 Diego Casorran, https://github.com/diegocr\n *\n * \n * ====================================================================\n */\n\n/**\n* @name cell\n* @module\n*/\n(function (jsPDFAPI) {\n  /*jslint browser:true */\n\n  /*global document: false, jsPDF */\n\n  var padding = 3,\n      margin = 13,\n      headerFunction,\n      lastCellPos = {\n    x: undefined,\n    y: undefined,\n    w: undefined,\n    h: undefined,\n    ln: undefined\n  },\n      pages = 1,\n      setLastCellPosition = function setLastCellPosition(x, y, w, h, ln) {\n    lastCellPos = {\n      'x': x,\n      'y': y,\n      'w': w,\n      'h': h,\n      'ln': ln\n    };\n  },\n      getLastCellPosition = function getLastCellPosition() {\n    return lastCellPos;\n  },\n      NO_MARGINS = {\n    left: 0,\n    top: 0,\n    bottom: 0\n  };\n  /**\n  * @name setHeaderFunction\n  * @function\n  * @param {function} func\n  */\n\n\n  jsPDFAPI.setHeaderFunction = function (func) {\n    headerFunction = func;\n  };\n  /**\n  * @name getTextDimensions\n  * @function\n  * @param {string} txt\n  * @returns {Object} dimensions\n  */\n\n\n  jsPDFAPI.getTextDimensions = function (text, options) {\n    var fontSize = this.table_font_size || this.internal.getFontSize();\n    var fontStyle = this.internal.getFont().fontStyle;\n    options = options || {};\n    var scaleFactor = options.scaleFactor || this.internal.scaleFactor;\n    var width = 0;\n    var amountOfLines = 0;\n    var height = 0;\n    var tempWidth = 0;\n\n    if (typeof text === 'string') {\n      width = this.getStringUnitWidth(text) * fontSize;\n\n      if (width !== 0) {\n        amountOfLines = 1;\n      }\n    } else if (Object.prototype.toString.call(text) === '[object Array]') {\n      for (var i = 0; i < text.length; i++) {\n        tempWidth = this.getStringUnitWidth(text[i]) * fontSize;\n\n        if (width < tempWidth) {\n          width = tempWidth;\n        }\n      }\n\n      if (width !== 0) {\n        amountOfLines = text.length;\n      }\n    } else {\n      throw new Error('getTextDimensions expects text-parameter to be of type String or an Array of Strings.');\n    }\n\n    width = width / scaleFactor;\n    height = Math.max((amountOfLines * fontSize * this.getLineHeightFactor() - fontSize * (this.getLineHeightFactor() - 1)) / scaleFactor, 0);\n    return {\n      w: width,\n      h: height\n    };\n  };\n  /**\n  * @name cellAddPage\n  * @function\n  */\n\n\n  jsPDFAPI.cellAddPage = function () {\n    var margins = this.margins || NO_MARGINS;\n    this.addPage();\n    setLastCellPosition(margins.left, margins.top, undefined, undefined); //setLastCellPosition(undefined, undefined, undefined, undefined, undefined);\n\n    pages += 1;\n  };\n  /**\n  * @name cellInitialize\n  * @function\n  */\n\n\n  jsPDFAPI.cellInitialize = function () {\n    lastCellPos = {\n      x: undefined,\n      y: undefined,\n      w: undefined,\n      h: undefined,\n      ln: undefined\n    };\n    pages = 1;\n  };\n  /**\n  * @name cell\n  * @function\n  * @param {number} x\n  * @param {number} y\n  * @param {number} w\n  * @param {number} h\n  * @param {string} txt\n  * @param {number} ln lineNumber\n  * @param {string} align\n  * @return {jsPDF} jsPDF-instance\n  */\n\n\n  jsPDFAPI.cell = function (x, y, w, h, txt, ln, align) {\n    var curCell = getLastCellPosition();\n    var pgAdded = false; // If this is not the first cell, we must change its position\n\n    if (curCell.ln !== undefined) {\n      if (curCell.ln === ln) {\n        //Same line\n        x = curCell.x + curCell.w;\n        y = curCell.y;\n      } else {\n        //New line\n        var margins = this.margins || NO_MARGINS;\n\n        if (curCell.y + curCell.h + h + margin >= this.internal.pageSize.getHeight() - margins.bottom) {\n          this.cellAddPage();\n          pgAdded = true;\n\n          if (this.printHeaders && this.tableHeaderRow) {\n            this.printHeaderRow(ln, true);\n          }\n        } //We ignore the passed y: the lines may have different heights\n\n\n        y = getLastCellPosition().y + getLastCellPosition().h;\n        if (pgAdded) y = margin + 10;\n      }\n    }\n\n    if (txt[0] !== undefined) {\n      if (this.printingHeaderRow) {\n        this.rect(x, y, w, h, 'FD');\n      } else {\n        this.rect(x, y, w, h);\n      }\n\n      if (align === 'right') {\n        if (!(txt instanceof Array)) {\n          txt = [txt];\n        }\n\n        for (var i = 0; i < txt.length; i++) {\n          var currentLine = txt[i];\n          var textSize = this.getStringUnitWidth(currentLine) * this.internal.getFontSize() / this.internal.scaleFactor;\n          this.text(currentLine, x + w - textSize - padding, y + this.internal.getLineHeight() * (i + 1));\n        }\n      } else {\n        this.text(txt, x + padding, y + this.internal.getLineHeight());\n      }\n    }\n\n    setLastCellPosition(x, y, w, h, ln);\n    return this;\n  };\n  /**\n   * Return the maximum value from an array\n   * \n   * @name arrayMax\n   * @function \n   * @param {Array} array\n   * @param comparisonFn\n   * @returns {number}\n   */\n\n\n  jsPDFAPI.arrayMax = function (array, comparisonFn) {\n    var max = array[0],\n        i,\n        ln,\n        item;\n\n    for (i = 0, ln = array.length; i < ln; i += 1) {\n      item = array[i];\n\n      if (comparisonFn) {\n        if (comparisonFn(max, item) === -1) {\n          max = item;\n        }\n      } else {\n        if (item > max) {\n          max = item;\n        }\n      }\n    }\n\n    return max;\n  };\n  /**\n   * Create a table from a set of data.\n   * @name table\n   * @function\n   * @param {Integer} [x] : left-position for top-left corner of table\n   * @param {Integer} [y] top-position for top-left corner of table\n   * @param {Object[]} [data] As array of objects containing key-value pairs corresponding to a row of data.\n   * @param {String[]} [headers] Omit or null to auto-generate headers at a performance cost\n    * @param {Object} [config.printHeaders] True to print column headers at the top of every page\n   * @param {Object} [config.autoSize] True to dynamically set the column widths to match the widest cell value\n   * @param {Object} [config.margins] margin values for left, top, bottom, and width\n   * @param {Object} [config.fontSize] Integer fontSize to use (optional)\n   * @returns {jsPDF} jsPDF-instance\n   */\n\n\n  jsPDFAPI.table = function (x, y, data, headers, config) {\n    if (!data) {\n      throw 'No data for PDF table';\n    }\n\n    var headerNames = [],\n        headerPrompts = [],\n        header,\n        i,\n        ln,\n        cln,\n        columnMatrix = {},\n        columnWidths = {},\n        columnData,\n        column,\n        columnMinWidths = [],\n        j,\n        tableHeaderConfigs = [],\n        model,\n        jln,\n        func,\n        //set up defaults. If a value is provided in config, defaults will be overwritten:\n    autoSize = false,\n        printHeaders = true,\n        fontSize = 12,\n        margins = NO_MARGINS;\n    margins.width = this.internal.pageSize.getWidth();\n\n    if (config) {\n      //override config defaults if the user has specified non-default behavior:\n      if (config.autoSize === true) {\n        autoSize = true;\n      }\n\n      if (config.printHeaders === false) {\n        printHeaders = false;\n      }\n\n      if (config.fontSize) {\n        fontSize = config.fontSize;\n      }\n\n      if (config.css && typeof config.css['font-size'] !== \"undefined\") {\n        fontSize = config.css['font-size'] * 16;\n      }\n\n      if (config.margins) {\n        margins = config.margins;\n      }\n    }\n    /**\n     * @property {Number} lnMod\n     * Keep track of the current line number modifier used when creating cells\n     */\n\n\n    this.lnMod = 0;\n    lastCellPos = {\n      x: undefined,\n      y: undefined,\n      w: undefined,\n      h: undefined,\n      ln: undefined\n    }, pages = 1;\n    this.printHeaders = printHeaders;\n    this.margins = margins;\n    this.setFontSize(fontSize);\n    this.table_font_size = fontSize; // Set header values\n\n    if (headers === undefined || headers === null) {\n      // No headers defined so we derive from data\n      headerNames = Object.keys(data[0]);\n    } else if (headers[0] && typeof headers[0] !== 'string') {\n      var px2pt = 0.264583 * 72 / 25.4; // Split header configs into names and prompts\n\n      for (i = 0, ln = headers.length; i < ln; i += 1) {\n        header = headers[i];\n        headerNames.push(header.name);\n        headerPrompts.push(header.prompt);\n        columnWidths[header.name] = header.width * px2pt;\n      }\n    } else {\n      headerNames = headers;\n    }\n\n    if (autoSize) {\n      // Create a matrix of columns e.g., {column_title: [row1_Record, row2_Record]}\n      func = function func(rec) {\n        return rec[header];\n      };\n\n      for (i = 0, ln = headerNames.length; i < ln; i += 1) {\n        header = headerNames[i];\n        columnMatrix[header] = data.map(func); // get header width\n\n        columnMinWidths.push(this.getTextDimensions(headerPrompts[i] || header, {\n          scaleFactor: 1\n        }).w);\n        column = columnMatrix[header]; // get cell widths\n\n        for (j = 0, cln = column.length; j < cln; j += 1) {\n          columnData = column[j];\n          columnMinWidths.push(this.getTextDimensions(columnData, {\n            scaleFactor: 1\n          }).w);\n        } // get final column width\n\n\n        columnWidths[header] = jsPDFAPI.arrayMax(columnMinWidths); //have to reset\n\n        columnMinWidths = [];\n      }\n    } // -- Construct the table\n\n\n    if (printHeaders) {\n      var lineHeight = this.calculateLineHeight(headerNames, columnWidths, headerPrompts.length ? headerPrompts : headerNames); // Construct the header row\n\n      for (i = 0, ln = headerNames.length; i < ln; i += 1) {\n        header = headerNames[i];\n        tableHeaderConfigs.push([x, y, columnWidths[header], lineHeight, String(headerPrompts.length ? headerPrompts[i] : header)]);\n      } // Store the table header config\n\n\n      this.setTableHeaderRow(tableHeaderConfigs); // Print the header for the start of the table\n\n      this.printHeaderRow(1, false);\n    } // Construct the data rows\n\n\n    for (i = 0, ln = data.length; i < ln; i += 1) {\n      var lineHeight;\n      model = data[i];\n      lineHeight = this.calculateLineHeight(headerNames, columnWidths, model);\n\n      for (j = 0, jln = headerNames.length; j < jln; j += 1) {\n        header = headerNames[j];\n        this.cell(x, y, columnWidths[header], lineHeight, model[header], i + 2, header.align);\n      }\n    }\n\n    this.lastCellPos = lastCellPos;\n    this.table_x = x;\n    this.table_y = y;\n    return this;\n  };\n  /**\n   * Calculate the height for containing the highest column\n   *\n   * @name calculateLineHeight\n   * @function\n   * @param {String[]} headerNames is the header, used as keys to the data\n   * @param {Integer[]} columnWidths is size of each column\n   * @param {Object[]} model is the line of data we want to calculate the height of\n   * @returns {number} lineHeight\n   */\n\n\n  jsPDFAPI.calculateLineHeight = function (headerNames, columnWidths, model) {\n    var header,\n        lineHeight = 0;\n\n    for (var j = 0; j < headerNames.length; j++) {\n      header = headerNames[j];\n      model[header] = this.splitTextToSize(String(model[header]), columnWidths[header] - padding);\n      var h = this.internal.getLineHeight() * model[header].length + padding;\n      if (h > lineHeight) lineHeight = h;\n    }\n\n    return lineHeight;\n  };\n  /**\n   * Store the config for outputting a table header\n   *\n   * @name setTableHeaderRow\n   * @function\n   * @param {Object[]} config\n   * An array of cell configs that would define a header row: Each config matches the config used by jsPDFAPI.cell\n   * except the ln parameter is excluded\n   */\n\n\n  jsPDFAPI.setTableHeaderRow = function (config) {\n    this.tableHeaderRow = config;\n  };\n  /**\n   * Output the store header row\n   * \n   * @name printHeaderRow\n   * @function\n   * @param {number} lineNumber The line number to output the header at\n   * @param {boolean} new_page \n   */\n\n\n  jsPDFAPI.printHeaderRow = function (lineNumber, new_page) {\n    if (!this.tableHeaderRow) {\n      throw 'Property tableHeaderRow does not exist.';\n    }\n\n    var tableHeaderCell, tmpArray, i, ln;\n    this.printingHeaderRow = true;\n\n    if (headerFunction !== undefined) {\n      var position = headerFunction(this, pages);\n      setLastCellPosition(position[0], position[1], position[2], position[3], -1);\n    }\n\n    this.setFontStyle('bold');\n    var tempHeaderConf = [];\n\n    for (i = 0, ln = this.tableHeaderRow.length; i < ln; i += 1) {\n      this.setFillColor(200, 200, 200);\n      tableHeaderCell = this.tableHeaderRow[i];\n\n      if (new_page) {\n        this.margins.top = margin;\n        tableHeaderCell[1] = this.margins && this.margins.top || 0;\n        tempHeaderConf.push(tableHeaderCell);\n      }\n\n      tmpArray = [].concat(tableHeaderCell);\n      this.cell.apply(this, tmpArray.concat(lineNumber));\n    }\n\n    if (tempHeaderConf.length > 0) {\n      this.setTableHeaderRow(tempHeaderConf);\n    }\n\n    this.setFontStyle('normal');\n    this.printingHeaderRow = false;\n  };\n})(jsPDF.API);\n\n/**\n * jsPDF Context2D PlugIn Copyright (c) 2014 Steven Spungin (TwelveTone LLC) steven@twelvetone.tv\n *\n * Licensed under the MIT License. http://opensource.org/licenses/mit-license\n */\n\n/**\n* This plugin mimics the HTML5 CanvasRenderingContext2D.\n*\n* The goal is to provide a way for current canvas implementations to print directly to a PDF.\n*\n* @name context2d\n* @module\n*/\n(function (jsPDFAPI, globalObj) {\n\n  var ContextLayer = function ContextLayer(ctx) {\n    ctx = ctx || {};\n    this.isStrokeTransparent = ctx.isStrokeTransparent || false;\n    this.strokeOpacity = ctx.strokeOpacity || 1;\n    this.strokeStyle = ctx.strokeStyle || '#000000';\n    this.fillStyle = ctx.fillStyle || '#000000';\n    this.isFillTransparent = ctx.isFillTransparent || false;\n    this.fillOpacity = ctx.fillOpacity || 1;\n    this.font = ctx.font || '10px sans-serif';\n    this.textBaseline = ctx.textBaseline || 'alphabetic';\n    this.textAlign = ctx.textAlign || 'left';\n    this.lineWidth = ctx.lineWidth || 1;\n    this.lineJoin = ctx.lineJoin || 'miter';\n    this.lineCap = ctx.lineCap || 'butt';\n    this.path = ctx.path || [];\n    this.transform = typeof ctx.transform !== 'undefined' ? ctx.transform.clone() : new Matrix();\n    this.globalCompositeOperation = ctx.globalCompositeOperation || 'normal';\n    this.globalAlpha = ctx.globalAlpha || 1.0;\n    this.clip_path = ctx.clip_path || [];\n    this.currentPoint = ctx.currentPoint || new Point();\n    this.miterLimit = ctx.miterLimit || 10.0;\n    this.lastPoint = ctx.lastPoint || new Point();\n    this.ignoreClearRect = typeof ctx.ignoreClearRect === \"boolean\" ? ctx.ignoreClearRect : true;\n    return this;\n  }; //stub\n\n\n  var f2, f3, getHorizontalCoordinateString, getVerticalCoordinateString, getHorizontalCoordinate, getVerticalCoordinate;\n  jsPDFAPI.events.push(['initialized', function () {\n    this.context2d = new Context2D(this);\n    f2 = this.internal.f2;\n    f3 = this.internal.f3;\n    getHorizontalCoordinateString = this.internal.getCoordinateString;\n    getVerticalCoordinateString = this.internal.getVerticalCoordinateString;\n    getHorizontalCoordinate = this.internal.getHorizontalCoordinate;\n    getVerticalCoordinate = this.internal.getVerticalCoordinate;\n  }]);\n\n  var Context2D = function Context2D(pdf) {\n    Object.defineProperty(this, 'canvas', {\n      get: function get() {\n        return {\n          parentNode: false,\n          style: false\n        };\n      }\n    });\n    Object.defineProperty(this, 'pdf', {\n      get: function get() {\n        return pdf;\n      }\n    });\n    var _pageWrapXEnabled = false;\n    /**\n    * @name pageWrapXEnabled\n    * @type {boolean}\n    * @default false\n    */\n\n    Object.defineProperty(this, 'pageWrapXEnabled', {\n      get: function get() {\n        return _pageWrapXEnabled;\n      },\n      set: function set(value) {\n        _pageWrapXEnabled = Boolean(value);\n      }\n    });\n    var _pageWrapYEnabled = false;\n    /**\n    * @name pageWrapYEnabled\n    * @type {boolean}\n    * @default true\n    */\n\n    Object.defineProperty(this, 'pageWrapYEnabled', {\n      get: function get() {\n        return _pageWrapYEnabled;\n      },\n      set: function set(value) {\n        _pageWrapYEnabled = Boolean(value);\n      }\n    });\n    var _posX = 0;\n    /**\n    * @name posX\n    * @type {number}\n    * @default 0\n    */\n\n    Object.defineProperty(this, 'posX', {\n      get: function get() {\n        return _posX;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          _posX = value;\n        }\n      }\n    });\n    var _posY = 0;\n    /**\n    * @name posY\n    * @type {number}\n    * @default 0\n    */\n\n    Object.defineProperty(this, 'posY', {\n      get: function get() {\n        return _posY;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          _posY = value;\n        }\n      }\n    });\n    var _autoPaging = false;\n    /**\n    * @name autoPaging\n    * @type {boolean}\n    * @default true\n    */\n\n    Object.defineProperty(this, 'autoPaging', {\n      get: function get() {\n        return _autoPaging;\n      },\n      set: function set(value) {\n        _autoPaging = Boolean(value);\n      }\n    });\n    var lastBreak = 0;\n    /**\n    * @name lastBreak\n    * @type {number}\n    * @default 0\n    */\n\n    Object.defineProperty(this, 'lastBreak', {\n      get: function get() {\n        return lastBreak;\n      },\n      set: function set(value) {\n        lastBreak = value;\n      }\n    });\n    var pageBreaks = [];\n    /**\n    * Y Position of page breaks.\n    * @name pageBreaks\n    * @type {number}\n    * @default 0\n    */\n\n    Object.defineProperty(this, 'pageBreaks', {\n      get: function get() {\n        return pageBreaks;\n      },\n      set: function set(value) {\n        pageBreaks = value;\n      }\n    });\n\n    var _ctx = new ContextLayer();\n    /**\n    * @name ctx\n    * @type {object}\n    * @default {}\n    */\n\n\n    Object.defineProperty(this, 'ctx', {\n      get: function get() {\n        return _ctx;\n      },\n      set: function set(value) {\n        if (value instanceof ContextLayer) {\n          _ctx = value;\n        }\n      }\n    });\n    /**\n    * @name path\n    * @type {array}\n    * @default []\n    */\n\n    Object.defineProperty(this, 'path', {\n      get: function get() {\n        return _ctx.path;\n      },\n      set: function set(value) {\n        _ctx.path = value;\n      }\n    });\n    /**\n    * @name ctxStack\n    * @type {array}\n    * @default []\n    */\n\n    var _ctxStack = [];\n    Object.defineProperty(this, 'ctxStack', {\n      get: function get() {\n        return _ctxStack;\n      },\n      set: function set(value) {\n        _ctxStack = value;\n      }\n    });\n    /**\n    * Sets or returns the color, gradient, or pattern used to fill the drawing\n    *\n    * @name fillStyle\n    * @default #000000\n    * @property {(color|gradient|pattern)} value The color of the drawing. Default value is #000000<br />\n    * A gradient object (linear or radial) used to fill the drawing (not supported by context2d)<br />\n    * A pattern object to use to fill the drawing (not supported by context2d)\n    */\n\n    Object.defineProperty(this, 'fillStyle', {\n      get: function get() {\n        return this.ctx.fillStyle;\n      },\n      set: function set(value) {\n        var rgba;\n        rgba = getRGBA(value);\n        this.ctx.fillStyle = rgba.style;\n        this.ctx.isFillTransparent = rgba.a === 0;\n        this.ctx.fillOpacity = rgba.a;\n        this.pdf.setFillColor(rgba.r, rgba.g, rgba.b, {\n          a: rgba.a\n        });\n        this.pdf.setTextColor(rgba.r, rgba.g, rgba.b, {\n          a: rgba.a\n        });\n      }\n    });\n    /**\n    * Sets or returns the color, gradient, or pattern used for strokes\n    *\n    * @name strokeStyle\n    * @default #000000\n    * @property {color} color A CSS color value that indicates the stroke color of the drawing. Default value is #000000 (not supported by context2d)\n    * @property {gradient} gradient A gradient object (linear or radial) used to create a gradient stroke (not supported by context2d)\n    * @property {pattern} pattern A pattern object used to create a pattern stroke (not supported by context2d)\n    */\n\n    Object.defineProperty(this, 'strokeStyle', {\n      get: function get() {\n        return this.ctx.strokeStyle;\n      },\n      set: function set(value) {\n        var rgba = getRGBA(value);\n        this.ctx.strokeStyle = rgba.style;\n        this.ctx.isStrokeTransparent = rgba.a === 0;\n        this.ctx.strokeOpacity = rgba.a;\n\n        if (rgba.a === 0) {\n          this.pdf.setDrawColor(255, 255, 255);\n        } else if (rgba.a === 1) {\n          this.pdf.setDrawColor(rgba.r, rgba.g, rgba.b);\n        } else {\n          this.pdf.setDrawColor(rgba.r, rgba.g, rgba.b);\n        }\n      }\n    });\n    /**\n    * Sets or returns the style of the end caps for a line\n    *\n    * @name lineCap\n    * @default butt\n    * @property {(butt|round|square)} lineCap butt A flat edge is added to each end of the line <br/>\n    * round A rounded end cap is added to each end of the line<br/>\n    * square A square end cap is added to each end of the line<br/>\n    */\n\n    Object.defineProperty(this, 'lineCap', {\n      get: function get() {\n        return this.ctx.lineCap;\n      },\n      set: function set(value) {\n        if (['butt', 'round', 'square'].indexOf(value) !== -1) {\n          this.ctx.lineCap = value;\n          this.pdf.setLineCap(value);\n        }\n      }\n    });\n    /**\n    * Sets or returns the current line width\n    *\n    * @name lineWidth\n    * @default 1\n    * @property {number} lineWidth The current line width, in pixels\n    */\n\n    Object.defineProperty(this, 'lineWidth', {\n      get: function get() {\n        return this.ctx.lineWidth;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          this.ctx.lineWidth = value;\n          this.pdf.setLineWidth(value);\n        }\n      }\n    });\n    /**\n    * Sets or returns the type of corner created, when two lines meet\n    */\n\n    Object.defineProperty(this, 'lineJoin', {\n      get: function get() {\n        return this.ctx.lineJoin;\n      },\n      set: function set(value) {\n        if (['bevel', 'round', 'miter'].indexOf(value) !== -1) {\n          this.ctx.lineJoin = value;\n          this.pdf.setLineJoin(value);\n        }\n      }\n    });\n    /**\n    * A number specifying the miter limit ratio in coordinate space units. Zero, negative, Infinity, and NaN values are ignored. The default value is 10.0.\n    *\n    * @name miterLimit\n    * @default 10\n    */\n\n    Object.defineProperty(this, 'miterLimit', {\n      get: function get() {\n        return this.ctx.miterLimit;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          this.ctx.miterLimit = value;\n          this.pdf.setMiterLimit(value);\n        }\n      }\n    });\n    Object.defineProperty(this, 'textBaseline', {\n      get: function get() {\n        return this.ctx.textBaseline;\n      },\n      set: function set(value) {\n        this.ctx.textBaseline = value;\n      }\n    });\n    Object.defineProperty(this, 'textAlign', {\n      get: function get() {\n        return this.ctx.textAlign;\n      },\n      set: function set(value) {\n        if (['right', 'end', 'center', 'left', 'start'].indexOf(value) !== -1) {\n          this.ctx.textAlign = value;\n        }\n      }\n    });\n    Object.defineProperty(this, 'font', {\n      get: function get() {\n        return this.ctx.font;\n      },\n      set: function set(value) {\n        this.ctx.font = value;\n        var rx, matches; //source: https://stackoverflow.com/a/10136041\n\n        rx = /^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))(?:\\s*\\/\\s*(normal|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])))?\\s*([-_,\\\"\\'\\sa-z]+?)\\s*$/i;\n        matches = rx.exec(value);\n\n        if (matches !== null) {\n          var fontStyle = matches[1];\n          var fontVariant = matches[2];\n          var fontWeight = matches[3];\n          var fontSize = matches[4];\n          var fontSizeUnit = matches[5];\n          var fontFamily = matches[6];\n        } else {\n          return;\n        }\n\n        if ('px' === fontSizeUnit) {\n          fontSize = Math.floor(parseFloat(fontSize));\n        } else if ('em' === fontSizeUnit) {\n          fontSize = Math.floor(parseFloat(fontSize) * this.pdf.getFontSize());\n        } else {\n          fontSize = Math.floor(parseFloat(fontSize));\n        }\n\n        this.pdf.setFontSize(fontSize);\n        var style = '';\n\n        if (fontWeight === 'bold' || parseInt(fontWeight, 10) >= 700 || fontStyle === 'bold') {\n          style = 'bold';\n        }\n\n        if (fontStyle === 'italic') {\n          style += 'italic';\n        }\n\n        if (style.length === 0) {\n          style = 'normal';\n        }\n\n        var jsPdfFontName = '';\n        var parts = fontFamily.toLowerCase().replace(/\"|'/g, '').split(/\\s*,\\s*/);\n        var fallbackFonts = {\n          arial: 'Helvetica',\n          verdana: 'Helvetica',\n          helvetica: 'Helvetica',\n          'sans-serif': 'Helvetica',\n          fixed: 'Courier',\n          monospace: 'Courier',\n          terminal: 'Courier',\n          courier: 'Courier',\n          times: 'Times',\n          cursive: 'Times',\n          fantasy: 'Times',\n          serif: 'Times'\n        };\n\n        for (var i = 0; i < parts.length; i++) {\n          if (this.pdf.internal.getFont(parts[i], style, {\n            noFallback: true,\n            disableWarning: true\n          }) !== undefined) {\n            jsPdfFontName = parts[i];\n            break;\n          } else if (style === 'bolditalic' && this.pdf.internal.getFont(parts[i], 'bold', {\n            noFallback: true,\n            disableWarning: true\n          }) !== undefined) {\n            jsPdfFontName = parts[i];\n            style = 'bold';\n          } else if (this.pdf.internal.getFont(parts[i], 'normal', {\n            noFallback: true,\n            disableWarning: true\n          }) !== undefined) {\n            jsPdfFontName = parts[i];\n            style = 'normal';\n            break;\n          }\n        }\n\n        if (jsPdfFontName === '') {\n          for (var i = 0; i < parts.length; i++) {\n            if (fallbackFonts[parts[i]]) {\n              jsPdfFontName = fallbackFonts[parts[i]];\n              break;\n            }\n          }\n        }\n\n        jsPdfFontName = jsPdfFontName === '' ? 'Times' : jsPdfFontName;\n        this.pdf.setFont(jsPdfFontName, style);\n      }\n    });\n    Object.defineProperty(this, 'globalCompositeOperation', {\n      get: function get() {\n        return this.ctx.globalCompositeOperation;\n      },\n      set: function set(value) {\n        this.ctx.globalCompositeOperation = value;\n      }\n    });\n    Object.defineProperty(this, 'globalAlpha', {\n      get: function get() {\n        return this.ctx.globalAlpha;\n      },\n      set: function set(value) {\n        this.ctx.globalAlpha = value;\n      }\n    }); // Not HTML API\n\n    Object.defineProperty(this, 'ignoreClearRect', {\n      get: function get() {\n        return this.ctx.ignoreClearRect;\n      },\n      set: function set(value) {\n        this.ctx.ignoreClearRect = Boolean(value);\n      }\n    });\n  };\n\n  Context2D.prototype.fill = function () {\n    pathPreProcess.call(this, 'fill', false);\n  };\n  /**\n  * Actually draws the path you have defined\n  *\n  * @name stroke\n  * @function\n  * @description The stroke() method actually draws the path you have defined with all those moveTo() and lineTo() methods. The default color is black.\n  */\n\n\n  Context2D.prototype.stroke = function () {\n    pathPreProcess.call(this, 'stroke', false);\n  };\n  /**\n  * Begins a path, or resets the current \n  *\n  * @name beginPath\n  * @function \n  * @description The beginPath() method begins a path, or resets the current path.\n  */\n\n\n  Context2D.prototype.beginPath = function () {\n    this.path = [{\n      type: 'begin'\n    }];\n  };\n  /**\n  * Moves the path to the specified point in the canvas, without creating a line\n  * \n  * @name moveTo\n  * @function\n  * @param x {Number} The x-coordinate of where to move the path to\n  * @param y {Number} The y-coordinate of where to move the path to\n  */\n\n\n  Context2D.prototype.moveTo = function (x, y) {\n    if (isNaN(x) || isNaN(y)) {\n      console.error('jsPDF.context2d.moveTo: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.moveTo');\n    }\n\n    var pt = this.ctx.transform.applyToPoint(new Point(x, y));\n    this.path.push({\n      type: 'mt',\n      x: pt.x,\n      y: pt.y\n    });\n    this.ctx.lastPoint = new Point(x, y);\n  };\n  /**\n  * Creates a path from the current point back to the starting point\n  * \n  * @name closePath\n  * @function\n  * @description The closePath() method creates a path from the current point back to the starting point.\n  */\n\n\n  Context2D.prototype.closePath = function () {\n    var pathBegin = new Point(0, 0);\n    var i = 0;\n\n    for (i = this.path.length - 1; i !== -1; i--) {\n      if (this.path[i].type === 'begin') {\n        if (_typeof(this.path[i + 1]) === 'object' && typeof this.path[i + 1].x === 'number') {\n          pathBegin = new Point(this.path[i + 1].x, this.path[i + 1].y);\n          this.path.push({\n            type: 'lt',\n            x: pathBegin.x,\n            y: pathBegin.y\n          });\n          break;\n        }\n      }\n    }\n\n    if (_typeof(this.path[i + 2]) === 'object' && typeof this.path[i + 2].x === 'number') {\n      this.path.push(JSON.parse(JSON.stringify(this.path[i + 2])));\n    }\n\n    this.path.push({\n      type: 'close'\n    });\n    this.ctx.lastPoint = new Point(pathBegin.x, pathBegin.y);\n  };\n  /**\n  * Adds a new point and creates a line to that point from the last specified point in the canvas\n  * \n  * @name lineTo\n  * @function\n  * @param x The x-coordinate of where to create the line to\n  * @param y The y-coordinate of where to create the line to\n  * @description The lineTo() method adds a new point and creates a line TO that point FROM the last specified point in the canvas (this method does not draw the line).\n  */\n\n\n  Context2D.prototype.lineTo = function (x, y) {\n    if (isNaN(x) || isNaN(y)) {\n      console.error('jsPDF.context2d.lineTo: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.lineTo');\n    }\n\n    var pt = this.ctx.transform.applyToPoint(new Point(x, y));\n    this.path.push({\n      type: 'lt',\n      x: pt.x,\n      y: pt.y\n    });\n    this.ctx.lastPoint = new Point(pt.x, pt.y);\n  };\n  /**\n  * Clips a region of any shape and size from the original canvas\n  * \n  * @name clip\n  * @function\n  * @description The clip() method clips a region of any shape and size from the original canvas.\n  */\n\n\n  Context2D.prototype.clip = function () {\n    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path));\n    pathPreProcess.call(this, null, true);\n  };\n  /**\n  * Creates a cubic Bézier curve\n  *\n  * @name quadraticCurveTo\n  * @function\n  * @param cpx {Number} The x-coordinate of the Bézier control point\n  * @param cpy {Number} The y-coordinate of the Bézier control point\n  * @param x {Number} The x-coordinate of the ending point\n  * @param y {Number} The y-coordinate of the ending point\n  * @description The quadraticCurveTo() method adds a point to the current path by using the specified control points that represent a quadratic Bézier curve.<br /><br /> A quadratic Bézier curve requires two points. The first point is a control point that is used in the quadratic Bézier calculation and the second point is the ending point for the curve. The starting point for the curve is the last point in the current path. If a path does not exist, use the beginPath() and moveTo() methods to define a starting point.\n  */\n\n\n  Context2D.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n    if (isNaN(x) || isNaN(y) || isNaN(cpx) || isNaN(cpy)) {\n      console.error('jsPDF.context2d.quadraticCurveTo: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.quadraticCurveTo');\n    }\n\n    var pt0 = this.ctx.transform.applyToPoint(new Point(x, y));\n    var pt1 = this.ctx.transform.applyToPoint(new Point(cpx, cpy));\n    this.path.push({\n      type: 'qct',\n      x1: pt1.x,\n      y1: pt1.y,\n      x: pt0.x,\n      y: pt0.y\n    });\n    this.ctx.lastPoint = new Point(pt0.x, pt0.y);\n  };\n  /**\n  * Creates a cubic Bézier curve\n  *\n  * @name bezierCurveTo\n  * @function\n  * @param cp1x {Number} The x-coordinate of the first Bézier control point\n  * @param cp1y {Number} The y-coordinate of the first Bézier control point\n  * @param cp2x {Number} The x-coordinate of the second Bézier control point\n  * @param cp2y {Number} The y-coordinate of the second Bézier control point\n  * @param x {Number} The x-coordinate of the ending point\n  * @param y {Number} The y-coordinate of the ending point\n  * @description The bezierCurveTo() method adds a point to the current path by using the specified control points that represent a cubic Bézier curve. <br /><br />A cubic bezier curve requires three points. The first two points are control points that are used in the cubic Bézier calculation and the last point is the ending point for the curve.  The starting point for the curve is the last point in the current path. If a path does not exist, use the beginPath() and moveTo() methods to define a starting point.\n  */\n\n\n  Context2D.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    if (isNaN(x) || isNaN(y) || isNaN(cp1x) || isNaN(cp1y) || isNaN(cp2x) || isNaN(cp2y)) {\n      console.error('jsPDF.context2d.bezierCurveTo: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.bezierCurveTo');\n    }\n\n    var pt0 = this.ctx.transform.applyToPoint(new Point(x, y));\n    var pt1 = this.ctx.transform.applyToPoint(new Point(cp1x, cp1y));\n    var pt2 = this.ctx.transform.applyToPoint(new Point(cp2x, cp2y));\n    this.path.push({\n      type: 'bct',\n      x1: pt1.x,\n      y1: pt1.y,\n      x2: pt2.x,\n      y2: pt2.y,\n      x: pt0.x,\n      y: pt0.y\n    });\n    this.ctx.lastPoint = new Point(pt0.x, pt0.y);\n  };\n  /**\n  * Creates an arc/curve (used to create circles, or parts of circles)\n  *\n  * @name arc\n  * @function\n  * @param x {Number} The x-coordinate of the center of the circle\n  * @param y {Number} The y-coordinate of the center of the circle\n  * @param radius {Number} The radius of the circle\n  * @param startAngle {Number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)\n  * @param endAngle {Number} The ending angle, in radians\n  * @param counterclockwise {Boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.\n  * @description The arc() method creates an arc/curve (used to create circles, or parts of circles).\n  */\n\n\n  Context2D.prototype.arc = function (x, y, radius, startAngle, endAngle, counterclockwise) {\n    if (isNaN(x) || isNaN(y) || isNaN(radius) || isNaN(startAngle) || isNaN(endAngle)) {\n      console.error('jsPDF.context2d.arc: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.arc');\n    }\n\n    counterclockwise = Boolean(counterclockwise);\n\n    if (!this.ctx.transform.isIdentity) {\n      var xpt = this.ctx.transform.applyToPoint(new Point(x, y));\n      x = xpt.x;\n      y = xpt.y;\n      var x_radPt = this.ctx.transform.applyToPoint(new Point(0, radius));\n      var x_radPt0 = this.ctx.transform.applyToPoint(new Point(0, 0));\n      radius = Math.sqrt(Math.pow(x_radPt.x - x_radPt0.x, 2) + Math.pow(x_radPt.y - x_radPt0.y, 2));\n    }\n\n    if (Math.abs(endAngle - startAngle) >= 2 * Math.PI) {\n      startAngle = 0;\n      endAngle = 2 * Math.PI;\n    }\n\n    this.path.push({\n      type: 'arc',\n      x: x,\n      y: y,\n      radius: radius,\n      startAngle: startAngle,\n      endAngle: endAngle,\n      counterclockwise: counterclockwise\n    }); // this.ctx.lastPoint(new Point(pt.x,pt.y));\n  };\n  /**\n  * Creates an arc/curve between two tangents\n  * \n  * @name arcTo\n  * @function\n  * @param x1 {Number} The x-coordinate of the first tangent\n  * @param y1 {Number} The y-coordinate of the first tangent\n  * @param x2 {Number} The x-coordinate of the second tangent\n  * @param y2 {Number} The y-coordinate of the second tangent\n  * @param radius The radius of the arc\n  * @description The arcTo() method creates an arc/curve between two tangents on the canvas.\n  */\n\n\n  Context2D.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n    throw new Error('arcTo not implemented.');\n  };\n  /**\n  * Creates a rectangle\n  *\n  * @name rect\n  * @function\n  * @param x {Number} The x-coordinate of the upper-left corner of the rectangle\n  * @param y {Number} The y-coordinate of the upper-left corner of the rectangle\n  * @param w {Number} The width of the rectangle, in pixels\n  * @param h {Number} The height of the rectangle, in pixels\n  * @description The rect() method creates a rectangle.\n  */\n\n\n  Context2D.prototype.rect = function (x, y, w, h) {\n    if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h)) {\n      console.error('jsPDF.context2d.rect: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.rect');\n    }\n\n    this.moveTo(x, y);\n    this.lineTo(x + w, y);\n    this.lineTo(x + w, y + h);\n    this.lineTo(x, y + h);\n    this.lineTo(x, y);\n    this.lineTo(x + w, y);\n    this.lineTo(x, y);\n  };\n  /**\n  * Draws a \"filled\" rectangle\n  *\n  * @name fillRect\n  * @function\n  * @param x {Number} The x-coordinate of the upper-left corner of the rectangle\n  * @param y {Number} The y-coordinate of the upper-left corner of the rectangle\n  * @param w {Number} The width of the rectangle, in pixels\n  * @param h {Number} The height of the rectangle, in pixels\n  * @description The fillRect() method draws a \"filled\" rectangle. The default color of the fill is black.\n  */\n\n\n  Context2D.prototype.fillRect = function (x, y, w, h) {\n    if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h)) {\n      console.error('jsPDF.context2d.fillRect: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.fillRect');\n    }\n\n    if (isFillTransparent.call(this)) {\n      return;\n    }\n\n    var tmp = {};\n\n    if (this.lineCap !== 'butt') {\n      tmp.lineCap = this.lineCap;\n      this.lineCap = 'butt';\n    }\n\n    if (this.lineJoin !== 'miter') {\n      tmp.lineJoin = this.lineJoin;\n      this.lineJoin = 'miter';\n    }\n\n    this.beginPath();\n    this.rect(x, y, w, h);\n    this.fill();\n\n    if (tmp.hasOwnProperty('lineCap')) {\n      this.lineCap = tmp.lineCap;\n    }\n\n    if (tmp.hasOwnProperty('lineJoin')) {\n      this.lineJoin = tmp.lineJoin;\n    }\n  };\n  /**\n  *     Draws a rectangle (no fill)\n  *\n  * @name strokeRect\n  * @function\n  * @param x {Number} The x-coordinate of the upper-left corner of the rectangle\n  * @param y {Number} The y-coordinate of the upper-left corner of the rectangle\n  * @param w {Number} The width of the rectangle, in pixels\n  * @param h {Number} The height of the rectangle, in pixels\n  * @description The strokeRect() method draws a rectangle (no fill). The default color of the stroke is black.\n  */\n\n\n  Context2D.prototype.strokeRect = function strokeRect(x, y, w, h) {\n    if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h)) {\n      console.error('jsPDF.context2d.strokeRect: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.strokeRect');\n    }\n\n    if (isStrokeTransparent.call(this)) {\n      return;\n    }\n\n    this.beginPath();\n    this.rect(x, y, w, h);\n    this.stroke();\n  };\n  /**\n  * Clears the specified pixels within a given rectangle\n  *\n  * @name clearRect\n  * @function\n  * @param x {Number} The x-coordinate of the upper-left corner of the rectangle\n  * @param y {Number} The y-coordinate of the upper-left corner of the rectangle\n  * @param w {Number} The width of the rectangle to clear, in pixels\n  * @param h {Number} The height of the rectangle to clear, in pixels\n  * @description We cannot clear PDF commands that were already written to PDF, so we use white instead. <br />\n  * As a special case, read a special flag (ignoreClearRect) and do nothing if it is set.\n  * This results in all calls to clearRect() to do nothing, and keep the canvas transparent.\n  * This flag is stored in the save/restore context and is managed the same way as other drawing states.\n  *\n  */\n\n\n  Context2D.prototype.clearRect = function (x, y, w, h) {\n    if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h)) {\n      console.error('jsPDF.context2d.clearRect: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.clearRect');\n    }\n\n    if (this.ignoreClearRect) {\n      return;\n    }\n\n    this.fillStyle = '#ffffff';\n    this.fillRect(x, y, w, h);\n  };\n  /**\n  * Saves the state of the current context\n  * \n  * @name save\n  * @function\n  */\n\n\n  Context2D.prototype.save = function (doStackPush) {\n    doStackPush = typeof doStackPush === 'boolean' ? doStackPush : true;\n    var tmpPageNumber = this.pdf.internal.getCurrentPageInfo().pageNumber;\n\n    for (var i = 0; i < this.pdf.internal.getNumberOfPages(); i++) {\n      this.pdf.setPage(i + 1);\n      this.pdf.internal.out('q');\n    }\n\n    this.pdf.setPage(tmpPageNumber);\n\n    if (doStackPush) {\n      this.ctx.fontSize = this.pdf.internal.getFontSize();\n      var ctx = new ContextLayer(this.ctx);\n      this.ctxStack.push(this.ctx);\n      this.ctx = ctx;\n    }\n  };\n  /**\n  * Returns previously saved path state and attributes\n  * \n  * @name restore\n  * @function\n  */\n\n\n  Context2D.prototype.restore = function (doStackPop) {\n    doStackPop = typeof doStackPop === 'boolean' ? doStackPop : true;\n    var tmpPageNumber = this.pdf.internal.getCurrentPageInfo().pageNumber;\n\n    for (var i = 0; i < this.pdf.internal.getNumberOfPages(); i++) {\n      this.pdf.setPage(i + 1);\n      this.pdf.internal.out('Q');\n    }\n\n    this.pdf.setPage(tmpPageNumber);\n\n    if (doStackPop && this.ctxStack.length !== 0) {\n      this.ctx = this.ctxStack.pop();\n      this.fillStyle = this.ctx.fillStyle;\n      this.strokeStyle = this.ctx.strokeStyle;\n      this.font = this.ctx.font;\n      this.lineCap = this.ctx.lineCap;\n      this.lineWidth = this.ctx.lineWidth;\n      this.lineJoin = this.ctx.lineJoin;\n    }\n  };\n  /** \n  * @name toDataURL\n  * @function\n  */\n\n\n  Context2D.prototype.toDataURL = function () {\n    throw new Error('toDataUrl not implemented.');\n  }; //helper functions\n\n  /**\n  * Get the decimal values of r, g, b and a\n  *\n  * @name getRGBA\n  * @function\n  * @private\n  * @ignore\n  */\n\n\n  var getRGBA = function getRGBA(style) {\n    var rxRgb = /rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/;\n    var rxRgba = /rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d\\.]+)\\s*\\)/;\n    var rxTransparent = /transparent|rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*0+\\s*\\)/;\n    var r, g, b, a;\n\n    if (style.isCanvasGradient === true) {\n      style = style.getColor();\n    }\n\n    if (!style) {\n      return {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0,\n        style: style\n      };\n    }\n\n    if (rxTransparent.test(style)) {\n      r = 0;\n      g = 0;\n      b = 0;\n      a = 0;\n    } else {\n      var matches = rxRgb.exec(style);\n\n      if (matches !== null) {\n        r = parseInt(matches[1]);\n        g = parseInt(matches[2]);\n        b = parseInt(matches[3]);\n        a = 1;\n      } else {\n        matches = rxRgba.exec(style);\n\n        if (matches !== null) {\n          r = parseInt(matches[1]);\n          g = parseInt(matches[2]);\n          b = parseInt(matches[3]);\n          a = parseFloat(matches[4]);\n        } else {\n          a = 1;\n\n          if (typeof style === \"string\" && style.charAt(0) !== '#') {\n            var rgbColor = new RGBColor(style);\n\n            if (rgbColor.ok) {\n              style = rgbColor.toHex();\n            } else {\n              style = '#000000';\n            }\n          }\n\n          if (style.length === 4) {\n            r = style.substring(1, 2);\n            r += r;\n            g = style.substring(2, 3);\n            g += g;\n            b = style.substring(3, 4);\n            b += b;\n          } else {\n            r = style.substring(1, 3);\n            g = style.substring(3, 5);\n            b = style.substring(5, 7);\n          }\n\n          r = parseInt(r, 16);\n          g = parseInt(g, 16);\n          b = parseInt(b, 16);\n        }\n      }\n    }\n\n    return {\n      r: r,\n      g: g,\n      b: b,\n      a: a,\n      style: style\n    };\n  };\n  /**\n  * @name isFillTransparent\n  * @function \n  * @private\n  * @ignore\n  * @returns {Boolean}\n  */\n\n\n  var isFillTransparent = function isFillTransparent() {\n    return this.ctx.isFillTransparent || this.globalAlpha == 0;\n  };\n  /**\n  * @name isStrokeTransparent\n  * @function \n  * @private\n  * @ignore\n  * @returns {Boolean}\n  */\n\n\n  var isStrokeTransparent = function isStrokeTransparent() {\n    return Boolean(this.ctx.isStrokeTransparent || this.globalAlpha == 0);\n  };\n  /**\n  * Draws \"filled\" text on the canvas\n  * \n  * @name fillText\n  * @function\n  * @param text {String} Specifies the text that will be written on the canvas\n  * @param x {Number} The x coordinate where to start painting the text (relative to the canvas)\n  * @param y {Number} The y coordinate where to start painting the text (relative to the canvas)\n  * @param maxWidth {Number} Optional. The maximum allowed width of the text, in pixels\n  * @description The fillText() method draws filled text on the canvas. The default color of the text is black.\n  */\n\n\n  Context2D.prototype.fillText = function (text, x, y, maxWidth) {\n    if (isNaN(x) || isNaN(y) || typeof text !== 'string') {\n      console.error('jsPDF.context2d.fillText: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.fillText');\n    }\n\n    maxWidth = isNaN(maxWidth) ? undefined : maxWidth;\n\n    if (isFillTransparent.call(this)) {\n      return;\n    }\n\n    y = getBaseline.call(this, y);\n    var degs = rad2deg(this.ctx.transform.rotation); // We only use X axis as scale hint \n\n    var scale = this.ctx.transform.scaleX;\n    putText.call(this, {\n      text: text,\n      x: x,\n      y: y,\n      scale: scale,\n      angle: degs,\n      align: this.textAlign,\n      maxWidth: maxWidth\n    });\n  };\n  /**\n  * Draws text on the canvas (no fill)\n  * \n  * @name strokeText\n  * @function\n  * @param text {String} Specifies the text that will be written on the canvas\n  * @param x {Number} The x coordinate where to start painting the text (relative to the canvas)\n  * @param y {Number} The y coordinate where to start painting the text (relative to the canvas)\n  * @param maxWidth {Number} Optional. The maximum allowed width of the text, in pixels\n  * @description The strokeText() method draws text (with no fill) on the canvas. The default color of the text is black.\n  */\n\n\n  Context2D.prototype.strokeText = function (text, x, y, maxWidth) {\n    if (isNaN(x) || isNaN(y) || typeof text !== 'string') {\n      console.error('jsPDF.context2d.strokeText: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.strokeText');\n    }\n\n    if (isStrokeTransparent.call(this)) {\n      return;\n    }\n\n    maxWidth = isNaN(maxWidth) ? undefined : maxWidth;\n    y = getBaseline.call(this, y);\n    var degs = rad2deg(this.ctx.transform.rotation);\n    var scale = this.ctx.transform.scaleX;\n    putText.call(this, {\n      text: text,\n      x: x,\n      y: y,\n      scale: scale,\n      renderingMode: 'stroke',\n      angle: degs,\n      align: this.textAlign,\n      maxWidth: maxWidth\n    });\n  };\n  /**\n  * Returns an object that contains the width of the specified text\n  *\n  * @name measureText\n  * @function \n  * @param text {String} The text to be measured\n  * @description The measureText() method returns an object that contains the width of the specified text, in pixels.\n  * @returns {Number}\n  */\n\n\n  Context2D.prototype.measureText = function (text) {\n    if (typeof text !== 'string') {\n      console.error('jsPDF.context2d.measureText: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.measureText');\n    }\n\n    var pdf = this.pdf;\n    var k = this.pdf.internal.scaleFactor;\n    var fontSize = pdf.internal.getFontSize();\n    var txtWidth = pdf.getStringUnitWidth(text) * fontSize / pdf.internal.scaleFactor;\n    txtWidth *= Math.round(k * 96 / 72 * 10000) / 10000;\n\n    var TextMetrics = function TextMetrics(options) {\n      options = options || {};\n\n      var _width = options.width || 0;\n\n      Object.defineProperty(this, 'width', {\n        get: function get() {\n          return _width;\n        }\n      });\n      return this;\n    };\n\n    return new TextMetrics({\n      width: txtWidth\n    });\n  }; //Transformations\n\n  /**\n  * Scales the current drawing bigger or smaller\n  * \n  * @name scale \n  * @function\n  * @param scalewidth {Number} Scales the width of the current drawing (1=100%, 0.5=50%, 2=200%, etc.)\n  * @param scaleheight {Number} Scales the height of the current drawing (1=100%, 0.5=50%, 2=200%, etc.)\n  * @description The scale() method scales the current drawing, bigger or smaller.\n  */\n\n\n  Context2D.prototype.scale = function (scalewidth, scaleheight) {\n    if (isNaN(scalewidth) || isNaN(scaleheight)) {\n      console.error('jsPDF.context2d.scale: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.scale');\n    }\n\n    var matrix = new Matrix(scalewidth, 0.0, 0.0, scaleheight, 0.0, 0.0);\n    this.ctx.transform = this.ctx.transform.multiply(matrix);\n  };\n  /**\n  * Rotates the current drawing\n  * \n  * @name rotate\n  * @function\n  * @param angle {Number} The rotation angle, in radians.\n  * @description To calculate from degrees to radians: degrees*Math.PI/180. <br />\n  * Example: to rotate 5 degrees, specify the following: 5*Math.PI/180\n  */\n\n\n  Context2D.prototype.rotate = function (angle) {\n    if (isNaN(angle)) {\n      console.error('jsPDF.context2d.rotate: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.rotate');\n    }\n\n    var matrix = new Matrix(Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0.0, 0.0);\n    this.ctx.transform = this.ctx.transform.multiply(matrix);\n  };\n  /**\n  * Remaps the (0,0) position on the canvas\n  * \n  * @name translate\n  * @function\n  * @param x {Number} The value to add to horizontal (x) coordinates\n  * @param y {Number} The value to add to vertical (y) coordinates\n  * @description The translate() method remaps the (0,0) position on the canvas.\n  */\n\n\n  Context2D.prototype.translate = function (x, y) {\n    if (isNaN(x) || isNaN(y)) {\n      console.error('jsPDF.context2d.translate: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.translate');\n    }\n\n    var matrix = new Matrix(1.0, 0.0, 0.0, 1.0, x, y);\n    this.ctx.transform = this.ctx.transform.multiply(matrix);\n  };\n  /**\n  * Replaces the current transformation matrix for the drawing\n  * \n  * @name transform\n  * @function\n  * @param a {Number} Horizontal scaling\n  * @param b {Number} Horizontal skewing\n  * @param c {Number} Vertical skewing\n  * @param d {Number} Vertical scaling\n  * @param e {Number} Horizontal moving\n  * @param f {Number} Vertical moving\n  * @description Each object on the canvas has a current transformation matrix.<br /><br />The transform() method replaces the current transformation matrix. It multiplies the current transformation matrix with the matrix described by:<br /><br /><br /><br />a    c    e<br /><br />b    d    f<br /><br />0    0    1<br /><br />In other words, the transform() method lets you scale, rotate, move, and skew the current context.\n  */\n\n\n  Context2D.prototype.transform = function (a, b, c, d, e, f) {\n    if (isNaN(a) || isNaN(b) || isNaN(c) || isNaN(d) || isNaN(e) || isNaN(f)) {\n      console.error('jsPDF.context2d.transform: Invalid arguments', arguments);\n      throw new Error('Invalid arguments passed to jsPDF.context2d.transform');\n    }\n\n    var matrix = new Matrix(a, b, c, d, e, f);\n    this.ctx.transform = this.ctx.transform.multiply(matrix);\n  };\n  /**\n  * Resets the current transform to the identity matrix. Then runs transform()\n  * \n  * @name setTransform\n  * @function\n  * @param a {Number} Horizontal scaling\n  * @param b {Number} Horizontal skewing\n  * @param c {Number} Vertical skewing\n  * @param d {Number} Vertical scaling\n  * @param e {Number} Horizontal moving\n  * @param f {Number} Vertical moving\n  * @description Each object on the canvas has a current transformation matrix. <br /><br />The setTransform() method resets the current transform to the identity matrix, and then runs transform() with the same arguments.<br /><br />In other words, the setTransform() method lets you scale, rotate, move, and skew the current context.\n  */\n\n\n  Context2D.prototype.setTransform = function (a, b, c, d, e, f) {\n    a = isNaN(a) ? 1 : a;\n    b = isNaN(b) ? 0 : b;\n    c = isNaN(c) ? 0 : c;\n    d = isNaN(d) ? 1 : d;\n    e = isNaN(e) ? 0 : e;\n    f = isNaN(f) ? 0 : f;\n    this.ctx.transform = new Matrix(a, b, c, d, e, f);\n  };\n  /**\n  * Draws an image, canvas, or video onto the canvas\n  * \n  * @function \n  * @param img {} Specifies the image, canvas, or video element to use\n  * @param sx {Number} Optional. The x coordinate where to start clipping\n  * @param sy {Number} Optional. The y coordinate where to start clipping\n  * @param swidth {Number} Optional. The width of the clipped image\n  * @param sheight {Number} Optional. The height of the clipped image\n  * @param x {Number} The x coordinate where to place the image on the canvas\n  * @param y {Number} The y coordinate where to place the image on the canvas\n  * @param width {Number} Optional. The width of the image to use (stretch or reduce the image)\n  * @param height {Number} Optional. The height of the image to use (stretch or reduce the image)\n  */\n\n\n  Context2D.prototype.drawImage = function (img, sx, sy, swidth, sheight, x, y, width, height) {\n    var imageProperties = this.pdf.getImageProperties(img);\n    var factorX = 1;\n    var factorY = 1;\n    var clipFactorX = 1;\n    var clipFactorY = 1;\n    var scaleFactorX = 1;\n\n    if (typeof swidth !== 'undefined' && typeof width !== 'undefined') {\n      clipFactorX = width / swidth;\n      clipFactorY = height / sheight;\n      factorX = imageProperties.width / swidth * width / swidth;\n      factorY = imageProperties.height / sheight * height / sheight;\n    } //is sx and sy are set and x and y not, set x and y with values of sx and sy\n\n\n    if (typeof x === 'undefined') {\n      x = sx;\n      y = sy;\n      sx = 0;\n      sy = 0;\n    }\n\n    if (typeof swidth !== 'undefined' && typeof width === 'undefined') {\n      width = swidth;\n      height = sheight;\n    }\n\n    if (typeof swidth === 'undefined' && typeof width === 'undefined') {\n      width = imageProperties.width;\n      height = imageProperties.height;\n    }\n\n    var decomposedTransformationMatrix = this.ctx.transform.decompose();\n    var angle = rad2deg(decomposedTransformationMatrix.rotate.shx);\n    scaleFactorX = decomposedTransformationMatrix.scale.sx;\n    scaleFactorX = decomposedTransformationMatrix.scale.sy;\n    var matrix = new Matrix();\n    matrix = matrix.multiply(decomposedTransformationMatrix.translate);\n    matrix = matrix.multiply(decomposedTransformationMatrix.skew);\n    matrix = matrix.multiply(decomposedTransformationMatrix.scale);\n    var mP = matrix.applyToPoint(new Point(width, height));\n    var xRect = matrix.applyToRectangle(new Rectangle(x - sx * clipFactorX, y - sy * clipFactorY, swidth * factorX, sheight * factorY));\n    var pageArray = getPagesByPath.call(this, xRect);\n    var pages = [];\n\n    for (var ii = 0; ii < pageArray.length; ii += 1) {\n      if (pages.indexOf(pageArray[ii]) === -1) {\n        pages.push(pageArray[ii]);\n      }\n    }\n\n    pages.sort();\n    var clipPath;\n\n    if (this.autoPaging) {\n      var min = pages[0];\n      var max = pages[pages.length - 1];\n\n      for (var i = min; i < max + 1; i++) {\n        this.pdf.setPage(i);\n\n        if (this.ctx.clip_path.length !== 0) {\n          var tmpPaths = this.path;\n          clipPath = JSON.parse(JSON.stringify(this.ctx.clip_path));\n          this.path = pathPositionRedo(clipPath, this.posX, -1 * this.pdf.internal.pageSize.height * (i - 1) + this.posY);\n          drawPaths.call(this, 'fill', true);\n          this.path = tmpPaths;\n        }\n\n        var tmpRect = JSON.parse(JSON.stringify(xRect));\n        tmpRect = pathPositionRedo([tmpRect], this.posX, -1 * this.pdf.internal.pageSize.height * (i - 1) + this.posY)[0];\n        this.pdf.addImage(img, 'jpg', tmpRect.x, tmpRect.y, tmpRect.w, tmpRect.h, null, null, angle);\n      }\n    } else {\n      this.pdf.addImage(img, 'jpg', xRect.x, xRect.y, xRect.w, xRect.h, null, null, angle);\n    }\n  };\n\n  var getPagesByPath = function getPagesByPath(path, pageWrapX, pageWrapY) {\n    var result = [];\n    pageWrapX = pageWrapX || this.pdf.internal.pageSize.width;\n    pageWrapY = pageWrapY || this.pdf.internal.pageSize.height;\n\n    switch (path.type) {\n      default:\n      case 'mt':\n      case 'lt':\n        result.push(Math.floor((path.y + this.posY) / pageWrapY) + 1);\n        break;\n\n      case 'arc':\n        result.push(Math.floor((path.y + this.posY - path.radius) / pageWrapY) + 1);\n        result.push(Math.floor((path.y + this.posY + path.radius) / pageWrapY) + 1);\n        break;\n\n      case 'qct':\n        var rectOfQuadraticCurve = getQuadraticCurveBoundary(this.ctx.lastPoint.x, this.ctx.lastPoint.y, path.x1, path.y1, path.x, path.y);\n        result.push(Math.floor(rectOfQuadraticCurve.y / pageWrapY) + 1);\n        result.push(Math.floor((rectOfQuadraticCurve.y + rectOfQuadraticCurve.h) / pageWrapY) + 1);\n        break;\n\n      case 'bct':\n        var rectOfBezierCurve = getBezierCurveBoundary(this.ctx.lastPoint.x, this.ctx.lastPoint.y, path.x1, path.y1, path.x2, path.y2, path.x, path.y);\n        result.push(Math.floor(rectOfBezierCurve.y / pageWrapY) + 1);\n        result.push(Math.floor((rectOfBezierCurve.y + rectOfBezierCurve.h) / pageWrapY) + 1);\n        break;\n\n      case 'rect':\n        result.push(Math.floor((path.y + this.posY) / pageWrapY) + 1);\n        result.push(Math.floor((path.y + path.h + this.posY) / pageWrapY) + 1);\n    }\n\n    for (var i = 0; i < result.length; i += 1) {\n      while (this.pdf.internal.getNumberOfPages() < result[i]) {\n        addPage.call(this);\n      }\n    }\n\n    return result;\n  };\n\n  var addPage = function addPage() {\n    var fillStyle = this.fillStyle;\n    var strokeStyle = this.strokeStyle;\n    var font = this.font;\n    var lineCap = this.lineCap;\n    var lineWidth = this.lineWidth;\n    var lineJoin = this.lineJoin;\n    this.pdf.addPage();\n    this.fillStyle = fillStyle;\n    this.strokeStyle = strokeStyle;\n    this.font = font;\n    this.lineCap = lineCap;\n    this.lineWidth = lineWidth;\n    this.lineJoin = lineJoin;\n  };\n\n  var pathPositionRedo = function pathPositionRedo(paths, x, y) {\n    for (var i = 0; i < paths.length; i++) {\n      switch (paths[i].type) {\n        case 'bct':\n          paths[i].x2 += x;\n          paths[i].y2 += y;\n\n        case 'qct':\n          paths[i].x1 += x;\n          paths[i].y1 += y;\n\n        case 'mt':\n        case 'lt':\n        case 'arc':\n        default:\n          paths[i].x += x;\n          paths[i].y += y;\n      }\n    }\n\n    return paths;\n  };\n\n  var pathPreProcess = function pathPreProcess(rule, isClip) {\n    var fillStyle = this.fillStyle;\n    var strokeStyle = this.strokeStyle;\n    var font = this.font;\n    var lineCap = this.lineCap;\n    var lineWidth = this.lineWidth;\n    var lineJoin = this.lineJoin;\n    var origPath = JSON.parse(JSON.stringify(this.path));\n    var xPath = JSON.parse(JSON.stringify(this.path));\n    var clipPath;\n    var tmpPath;\n    var pages = [];\n\n    for (var i = 0; i < xPath.length; i++) {\n      if (typeof xPath[i].x !== \"undefined\") {\n        var page = getPagesByPath.call(this, xPath[i]);\n\n        for (var ii = 0; ii < page.length; ii += 1) {\n          if (pages.indexOf(page[ii]) === -1) {\n            pages.push(page[ii]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0; i < pages.length; i++) {\n      while (this.pdf.internal.getNumberOfPages() < pages[i]) {\n        addPage.call(this);\n      }\n    }\n\n    pages.sort();\n\n    if (this.autoPaging) {\n      var min = pages[0];\n      var max = pages[pages.length - 1];\n\n      for (var i = min; i < max + 1; i++) {\n        this.pdf.setPage(i);\n        this.fillStyle = fillStyle;\n        this.strokeStyle = strokeStyle;\n        this.lineCap = lineCap;\n        this.lineWidth = lineWidth;\n        this.lineJoin = lineJoin;\n\n        if (this.ctx.clip_path.length !== 0) {\n          var tmpPaths = this.path;\n          clipPath = JSON.parse(JSON.stringify(this.ctx.clip_path));\n          this.path = pathPositionRedo(clipPath, this.posX, -1 * this.pdf.internal.pageSize.height * (i - 1) + this.posY);\n          drawPaths.call(this, rule, true);\n          this.path = tmpPaths;\n        }\n\n        tmpPath = JSON.parse(JSON.stringify(origPath));\n        this.path = pathPositionRedo(tmpPath, this.posX, -1 * this.pdf.internal.pageSize.height * (i - 1) + this.posY);\n\n        if (isClip === false || i === 0) {\n          drawPaths.call(this, rule, isClip);\n        }\n      }\n    } else {\n      drawPaths.call(this, rule, isClip);\n    }\n\n    this.path = origPath;\n  };\n  /**\n  * Processes the paths\n  *\n  * @function \n  * @param rule {String}\n  * @param isClip {Boolean}\n  * @private\n  * @ignore\n  */\n\n\n  var drawPaths = function drawPaths(rule, isClip) {\n    if (rule === 'stroke' && !isClip && isStrokeTransparent.call(this)) {\n      return;\n    }\n\n    if (rule !== 'stroke' && !isClip && isFillTransparent.call(this)) {\n      return;\n    }\n\n    var moves = [];\n    var alpha = this.ctx.globalAlpha;\n\n    if (this.ctx.fillOpacity < 1) {\n      alpha = this.ctx.fillOpacity;\n    }\n\n    var xPath = this.path;\n\n    for (var i = 0; i < xPath.length; i++) {\n      var pt = xPath[i];\n\n      switch (pt.type) {\n        case 'begin':\n          moves.push({\n            begin: true\n          });\n          break;\n\n        case 'close':\n          moves.push({\n            close: true\n          });\n          break;\n\n        case 'mt':\n          moves.push({\n            start: pt,\n            deltas: [],\n            abs: []\n          });\n          break;\n\n        case 'lt':\n          var iii = moves.length;\n\n          if (!isNaN(xPath[i - 1].x)) {\n            var delta = [pt.x - xPath[i - 1].x, pt.y - xPath[i - 1].y];\n\n            if (iii > 0) {\n              for (iii; iii >= 0; iii--) {\n                if (moves[iii - 1].close !== true && moves[iii - 1].begin !== true) {\n                  moves[iii - 1].deltas.push(delta);\n                  moves[iii - 1].abs.push(pt);\n                  break;\n                }\n              }\n            }\n          }\n\n          break;\n\n        case 'bct':\n          var delta = [pt.x1 - xPath[i - 1].x, pt.y1 - xPath[i - 1].y, pt.x2 - xPath[i - 1].x, pt.y2 - xPath[i - 1].y, pt.x - xPath[i - 1].x, pt.y - xPath[i - 1].y];\n          moves[moves.length - 1].deltas.push(delta);\n          break;\n\n        case 'qct':\n          var x1 = xPath[i - 1].x + 2.0 / 3.0 * (pt.x1 - xPath[i - 1].x);\n          var y1 = xPath[i - 1].y + 2.0 / 3.0 * (pt.y1 - xPath[i - 1].y);\n          var x2 = pt.x + 2.0 / 3.0 * (pt.x1 - pt.x);\n          var y2 = pt.y + 2.0 / 3.0 * (pt.y1 - pt.y);\n          var x3 = pt.x;\n          var y3 = pt.y;\n          var delta = [x1 - xPath[i - 1].x, y1 - xPath[i - 1].y, x2 - xPath[i - 1].x, y2 - xPath[i - 1].y, x3 - xPath[i - 1].x, y3 - xPath[i - 1].y];\n          moves[moves.length - 1].deltas.push(delta);\n          break;\n\n        case 'arc':\n          moves.push({\n            deltas: [],\n            abs: [],\n            arc: true\n          });\n\n          if (Array.isArray(moves[moves.length - 1].abs)) {\n            moves[moves.length - 1].abs.push(pt);\n          }\n\n          break;\n      }\n    }\n\n    var style;\n\n    if (!isClip) {\n      if (rule === 'stroke') {\n        style = 'stroke';\n      } else {\n        style = 'fill';\n      }\n    } else {\n      style = null;\n    }\n\n    for (var i = 0; i < moves.length; i++) {\n      if (moves[i].arc) {\n        var arcs = moves[i].abs;\n\n        for (var ii = 0; ii < arcs.length; ii++) {\n          var arc = arcs[ii];\n\n          if (typeof arc.startAngle !== 'undefined') {\n            var start = rad2deg(arc.startAngle);\n            var end = rad2deg(arc.endAngle);\n            var x = arc.x;\n            var y = arc.y;\n            drawArc.call(this, x, y, arc.radius, start, end, arc.counterclockwise, style, isClip);\n          } else {\n            drawLine.call(this, arc.x, arc.y);\n          }\n        }\n      }\n\n      if (!moves[i].arc) {\n        if (moves[i].close !== true && moves[i].begin !== true) {\n          var x = moves[i].start.x;\n          var y = moves[i].start.y;\n          drawLines.call(this, moves[i].deltas, x, y, null, null);\n        }\n      }\n    }\n\n    if (style) {\n      putStyle.call(this, style);\n    }\n\n    if (isClip) {\n      doClip.call(this);\n    }\n  };\n\n  var getBaseline = function getBaseline(y) {\n    var height = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor;\n    var descent = height * (this.pdf.internal.getLineHeightFactor() - 1);\n\n    switch (this.ctx.textBaseline) {\n      case 'bottom':\n        return y - descent;\n\n      case 'top':\n        return y + height - descent;\n\n      case 'hanging':\n        return y + height - 2 * descent;\n\n      case 'middle':\n        return y + height / 2 - descent;\n\n      case 'ideographic':\n        // TODO not implemented\n        return y;\n\n      case 'alphabetic':\n      default:\n        return y;\n    }\n  };\n\n  Context2D.prototype.createLinearGradient = function createLinearGradient() {\n    var canvasGradient = function canvasGradient() {};\n\n    canvasGradient.colorStops = [];\n\n    canvasGradient.addColorStop = function (offset, color) {\n      this.colorStops.push([offset, color]);\n    };\n\n    canvasGradient.getColor = function () {\n      if (this.colorStops.length === 0) {\n        return '#000000';\n      }\n\n      return this.colorStops[0][1];\n    };\n\n    canvasGradient.isCanvasGradient = true;\n    return canvasGradient;\n  };\n\n  Context2D.prototype.createPattern = function createPattern() {\n    return this.createLinearGradient();\n  };\n\n  Context2D.prototype.createRadialGradient = function createRadialGradient() {\n    return this.createLinearGradient();\n  };\n  /**\n  *\n  * @param x Edge point X\n  * @param y Edge point Y\n  * @param r Radius\n  * @param a1 start angle\n  * @param a2 end angle\n  * @param counterclockwise\n  * @param style\n  * @param isClip\n  */\n\n\n  var drawArc = function drawArc(x, y, r, a1, a2, counterclockwise, style, isClip) {\n    var k = this.pdf.internal.scaleFactor;\n    var a1r = deg2rad(a1);\n    var a2r = deg2rad(a2);\n    var curves = createArc.call(this, r, a1r, a2r, counterclockwise);\n\n    for (var i = 0; i < curves.length; i++) {\n      var curve = curves[i];\n\n      if (i === 0) {\n        doMove.call(this, curve.x1 + x, curve.y1 + y);\n      }\n      drawCurve.call(this, x, y, curve.x2, curve.y2, curve.x3, curve.y3, curve.x4, curve.y4);\n    }\n\n    if (!isClip) {\n      putStyle.call(this, style);\n    } else {\n      doClip.call(this);\n    }\n  };\n\n  var putStyle = function putStyle(style) {\n    switch (style) {\n      case 'stroke':\n        this.pdf.internal.out('S');\n        break;\n\n      case 'fill':\n        this.pdf.internal.out('f');\n        break;\n    }\n  };\n\n  var doClip = function doClip() {\n    this.pdf.clip();\n  };\n\n  var doMove = function doMove(x, y) {\n    this.pdf.internal.out(getHorizontalCoordinateString(x) + ' ' + getVerticalCoordinateString(y) + ' m');\n  };\n\n  var putText = function putText(options) {\n    var textAlign;\n\n    switch (options.align) {\n      case 'right':\n      case 'end':\n        textAlign = 'right';\n        break;\n\n      case 'center':\n        textAlign = 'center';\n        break;\n\n      case 'left':\n      case 'start':\n      default:\n        textAlign = 'left';\n        break;\n    }\n\n    var pt = this.ctx.transform.applyToPoint(new Point(options.x, options.y));\n    var decomposedTransformationMatrix = this.ctx.transform.decompose();\n    var matrix = new Matrix();\n    matrix = matrix.multiply(decomposedTransformationMatrix.translate);\n    matrix = matrix.multiply(decomposedTransformationMatrix.skew);\n    matrix = matrix.multiply(decomposedTransformationMatrix.scale);\n    var textDimensions = this.pdf.getTextDimensions(options.text);\n    var textRect = this.ctx.transform.applyToRectangle(new Rectangle(options.x, options.y, textDimensions.w, textDimensions.h));\n    var textXRect = matrix.applyToRectangle(new Rectangle(options.x, options.y - textDimensions.h, textDimensions.w, textDimensions.h));\n    var pageArray = getPagesByPath.call(this, textXRect);\n    var pages = [];\n\n    for (var ii = 0; ii < pageArray.length; ii += 1) {\n      if (pages.indexOf(pageArray[ii]) === -1) {\n        pages.push(pageArray[ii]);\n      }\n    }\n\n    pages.sort();\n    var clipPath;\n\n    if (this.autoPaging === true) {\n      var min = pages[0];\n      var max = pages[pages.length - 1];\n\n      for (var i = min; i < max + 1; i++) {\n        this.pdf.setPage(i);\n\n        if (this.ctx.clip_path.length !== 0) {\n          var tmpPaths = this.path;\n          clipPath = JSON.parse(JSON.stringify(this.ctx.clip_path));\n          this.path = pathPositionRedo(clipPath, this.posX, -1 * this.pdf.internal.pageSize.height * (i - 1) + this.posY);\n          drawPaths.call(this, 'fill', true);\n          this.path = tmpPaths;\n        }\n\n        var tmpRect = JSON.parse(JSON.stringify(textRect));\n        tmpRect = pathPositionRedo([tmpRect], this.posX, -1 * this.pdf.internal.pageSize.height * (i - 1) + this.posY)[0];\n\n        if (options.scale >= 0.01) {\n          var oldSize = this.pdf.internal.getFontSize();\n          this.pdf.setFontSize(oldSize * options.scale);\n        }\n\n        this.pdf.text(options.text, tmpRect.x, tmpRect.y, {\n          angle: options.angle,\n          align: textAlign,\n          renderingMode: options.renderingMode,\n          maxWidth: options.maxWidth\n        });\n\n        if (options.scale >= 0.01) {\n          this.pdf.setFontSize(oldSize);\n        }\n      }\n    } else {\n      if (options.scale >= 0.01) {\n        var oldSize = this.pdf.internal.getFontSize();\n        this.pdf.setFontSize(oldSize * options.scale);\n      }\n\n      this.pdf.text(options.text, pt.x + this.posX, pt.y + this.posY, {\n        angle: options.angle,\n        align: textAlign,\n        renderingMode: options.renderingMode,\n        maxWidth: options.maxWidth\n      });\n\n      if (options.scale >= 0.01) {\n        this.pdf.setFontSize(oldSize);\n      }\n    }\n  };\n\n  var drawLine = function drawLine(x, y, prevX, prevY) {\n    prevX = prevX || 0;\n    prevY = prevY || 0;\n    this.pdf.internal.out(getHorizontalCoordinateString(x + prevX) + ' ' + getVerticalCoordinateString(y + prevY) + ' l');\n  };\n\n  var drawLines = function drawLines(lines, x, y) {\n    return this.pdf.lines(lines, x, y, null, null);\n  };\n\n  var drawCurve = function drawCurve(x, y, x1, y1, x2, y2, x3, y3) {\n    this.pdf.internal.out([f2(getHorizontalCoordinate(x1 + x)), f2(getVerticalCoordinate(y1 + y)), f2(getHorizontalCoordinate(x2 + x)), f2(getVerticalCoordinate(y2 + y)), f2(getHorizontalCoordinate(x3 + x)), f2(getVerticalCoordinate(y3 + y)), 'c'].join(' '));\n  };\n  /**\n  * Return a array of objects that represent bezier curves which approximate the circular arc centered at the origin, from startAngle to endAngle (radians) with the specified radius.\n  *\n  * Each bezier curve is an object with four points, where x1,y1 and x4,y4 are the arc's end points and x2,y2 and x3,y3 are the cubic bezier's control points.\n  * @function createArc\n  */\n\n\n  var createArc = function createArc(radius, startAngle, endAngle, anticlockwise) {\n    var EPSILON = 0.00001; // Roughly 1/1000th of a degree, see below        // normalize startAngle, endAngle to [-2PI, 2PI]\n\n    var twoPI = Math.PI * 2;\n    var startAngleN = startAngle;\n\n    if (startAngleN < twoPI || startAngleN > twoPI) {\n      startAngleN = startAngleN % twoPI;\n    }\n\n    var endAngleN = endAngle;\n\n    if (endAngleN < twoPI || endAngleN > twoPI) {\n      endAngleN = endAngleN % twoPI;\n    } // Compute the sequence of arc curves, up to PI/2 at a time.        // Total arc angle is less than 2PI.\n\n\n    var curves = [];\n    var piOverTwo = Math.PI / 2.0; //var sgn = (startAngle < endAngle) ? +1 : -1; // clockwise or counterclockwise\n\n    var sgn = anticlockwise ? -1 : +1;\n    var a1 = startAngle;\n\n    for (var totalAngle = Math.min(twoPI, Math.abs(endAngleN - startAngleN)); totalAngle > EPSILON;) {\n      var a2 = a1 + sgn * Math.min(totalAngle, piOverTwo);\n      curves.push(createSmallArc.call(this, radius, a1, a2));\n      totalAngle -= Math.abs(a2 - a1);\n      a1 = a2;\n    }\n\n    return curves;\n  };\n  /**\n  * Cubic bezier approximation of a circular arc centered at the origin, from (radians) a1 to a2, where a2-a1 < pi/2. The arc's radius is r.\n  *\n  * Returns an object with four points, where x1,y1 and x4,y4 are the arc's end points and x2,y2 and x3,y3 are the cubic bezier's control points.\n  *\n  * This algorithm is based on the approach described in: A. Riškus, \"Approximation of a Cubic Bezier Curve by Circular Arcs and Vice Versa,\" Information Technology and Control, 35(4), 2006 pp. 371-378.\n  */\n\n\n  var createSmallArc = function createSmallArc(r, a1, a2) {\n    var a = (a2 - a1) / 2.0;\n    var x4 = r * Math.cos(a);\n    var y4 = r * Math.sin(a);\n    var x1 = x4;\n    var y1 = -y4;\n    var q1 = x1 * x1 + y1 * y1;\n    var q2 = q1 + x1 * x4 + y1 * y4;\n    var k2 = 4 / 3 * (Math.sqrt(2 * q1 * q2) - q2) / (x1 * y4 - y1 * x4);\n    var x2 = x1 - k2 * y1;\n    var y2 = y1 + k2 * x1;\n    var x3 = x2;\n    var y3 = -y2;\n    var ar = a + a1;\n    var cos_ar = Math.cos(ar);\n    var sin_ar = Math.sin(ar);\n    return {\n      x1: r * Math.cos(a1),\n      y1: r * Math.sin(a1),\n      x2: x2 * cos_ar - y2 * sin_ar,\n      y2: x2 * sin_ar + y2 * cos_ar,\n      x3: x3 * cos_ar - y3 * sin_ar,\n      y3: x3 * sin_ar + y3 * cos_ar,\n      x4: r * Math.cos(a2),\n      y4: r * Math.sin(a2)\n    };\n  };\n\n  var rad2deg = function rad2deg(value) {\n    return value * 180 / Math.PI;\n  };\n\n  var deg2rad = function deg2rad(deg) {\n    return deg * Math.PI / 180;\n  };\n\n  var getQuadraticCurveBoundary = function getQuadraticCurveBoundary(sx, sy, cpx, cpy, ex, ey) {\n    var midX1 = sx + (cpx - sx) * 0.50;\n    var midY1 = sy + (cpy - sy) * 0.50;\n    var midX2 = ex + (cpx - ex) * 0.50;\n    var midY2 = ey + (cpy - ey) * 0.50;\n    var resultX1 = Math.min(sx, ex, midX1, midX2);\n    var resultX2 = Math.max(sx, ex, midX1, midX2);\n    var resultY1 = Math.min(sy, ey, midY1, midY2);\n    var resultY2 = Math.max(sy, ey, midY1, midY2);\n    return new Rectangle(resultX1, resultY1, resultX2 - resultX1, resultY2 - resultY1);\n  }; //De Casteljau algorithm\n\n\n  var getBezierCurveBoundary = function getBezierCurveBoundary(ax, ay, bx, by, cx, cy, dx, dy) {\n    var tobx = bx - ax;\n    var toby = by - ay;\n    var tocx = cx - bx;\n    var tocy = cy - by;\n    var todx = dx - cx;\n    var tody = dy - cy;\n    var precision = 40;\n    var d, px, py, qx, qy, rx, ry, tx, ty, sx, sy, x, y, i, minx, miny, maxx, maxy, toqx, toqy, torx, tory, totx, toty;\n\n    for (var i = 0; i < precision + 1; i++) {\n      d = i / precision;\n      px = ax + d * tobx;\n      py = ay + d * toby;\n      qx = bx + d * tocx;\n      qy = by + d * tocy;\n      rx = cx + d * todx;\n      ry = cy + d * tody;\n      toqx = qx - px;\n      toqy = qy - py;\n      torx = rx - qx;\n      tory = ry - qy;\n      sx = px + d * toqx;\n      sy = py + d * toqy;\n      tx = qx + d * torx;\n      ty = qy + d * tory;\n      totx = tx - sx;\n      toty = ty - sy;\n      x = sx + d * totx;\n      y = sy + d * toty;\n\n      if (i == 0) {\n        minx = x;\n        miny = y;\n        maxx = x;\n        maxy = y;\n      } else {\n        minx = Math.min(minx, x);\n        miny = Math.min(miny, y);\n        maxx = Math.max(maxx, x);\n        maxy = Math.max(maxy, y);\n      }\n    }\n\n    return new Rectangle(Math.round(minx), Math.round(miny), Math.round(maxx - minx), Math.round(maxy - miny));\n  };\n\n  var Point = function Point(x, y) {\n    var _x = x || 0;\n\n    Object.defineProperty(this, 'x', {\n      enumerable: true,\n      get: function get() {\n        return _x;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          _x = parseFloat(value);\n        }\n      }\n    });\n\n    var _y = y || 0;\n\n    Object.defineProperty(this, 'y', {\n      enumerable: true,\n      get: function get() {\n        return _y;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          _y = parseFloat(value);\n        }\n      }\n    });\n    var _type = 'pt';\n    Object.defineProperty(this, 'type', {\n      enumerable: true,\n      get: function get() {\n        return _type;\n      },\n      set: function set(value) {\n        _type = value.toString();\n      }\n    });\n    return this;\n  };\n\n  var Rectangle = function Rectangle(x, y, w, h) {\n    Point.call(this, x, y);\n    this.type = 'rect';\n\n    var _w = w || 0;\n\n    Object.defineProperty(this, 'w', {\n      enumerable: true,\n      get: function get() {\n        return _w;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          _w = parseFloat(value);\n        }\n      }\n    });\n\n    var _h = h || 0;\n\n    Object.defineProperty(this, 'h', {\n      enumerable: true,\n      get: function get() {\n        return _h;\n      },\n      set: function set(value) {\n        if (!isNaN(value)) {\n          _h = parseFloat(value);\n        }\n      }\n    });\n    return this;\n  };\n\n  var Matrix = function Matrix(sx, shy, shx, sy, tx, ty) {\n    var _matrix = [];\n    Object.defineProperty(this, 'sx', {\n      get: function get() {\n        return _matrix[0];\n      },\n      set: function set(value) {\n        _matrix[0] = Math.round(value * 100000) / 100000;\n      }\n    });\n    Object.defineProperty(this, 'shy', {\n      get: function get() {\n        return _matrix[1];\n      },\n      set: function set(value) {\n        _matrix[1] = Math.round(value * 100000) / 100000;\n      }\n    });\n    Object.defineProperty(this, 'shx', {\n      get: function get() {\n        return _matrix[2];\n      },\n      set: function set(value) {\n        _matrix[2] = Math.round(value * 100000) / 100000;\n      }\n    });\n    Object.defineProperty(this, 'sy', {\n      get: function get() {\n        return _matrix[3];\n      },\n      set: function set(value) {\n        _matrix[3] = Math.round(value * 100000) / 100000;\n      }\n    });\n    Object.defineProperty(this, 'tx', {\n      get: function get() {\n        return _matrix[4];\n      },\n      set: function set(value) {\n        _matrix[4] = Math.round(value * 100000) / 100000;\n      }\n    });\n    Object.defineProperty(this, 'ty', {\n      get: function get() {\n        return _matrix[5];\n      },\n      set: function set(value) {\n        _matrix[5] = Math.round(value * 100000) / 100000;\n      }\n    });\n    Object.defineProperty(this, 'rotation', {\n      get: function get() {\n        return Math.atan2(this.shx, this.sx);\n      }\n    });\n    Object.defineProperty(this, 'scaleX', {\n      get: function get() {\n        return this.decompose().scale.sx;\n      }\n    });\n    Object.defineProperty(this, 'scaleY', {\n      get: function get() {\n        return this.decompose().scale.sy;\n      }\n    });\n    Object.defineProperty(this, 'isIdentity', {\n      get: function get() {\n        if (this.sx !== 1) {\n          return false;\n        }\n\n        if (this.shy !== 0) {\n          return false;\n        }\n\n        if (this.shx !== 0) {\n          return false;\n        }\n\n        if (this.sy !== 1) {\n          return false;\n        }\n\n        if (this.tx !== 0) {\n          return false;\n        }\n\n        if (this.ty !== 0) {\n          return false;\n        }\n\n        return true;\n      }\n    });\n    this.sx = !isNaN(sx) ? sx : 1;\n    this.shy = !isNaN(shy) ? shy : 0;\n    this.shx = !isNaN(shx) ? shx : 0;\n    this.sy = !isNaN(sy) ? sy : 1;\n    this.tx = !isNaN(tx) ? tx : 0;\n    this.ty = !isNaN(ty) ? ty : 0;\n    return this;\n  };\n  /**\n  * Multiply the matrix with given Matrix\n  * \n  * @function multiply\n  * @param matrix\n  * @returns {Matrix}\n  * @private\n  * @ignore\n  */\n\n\n  Matrix.prototype.multiply = function (matrix) {\n    var sx = matrix.sx * this.sx + matrix.shy * this.shx;\n    var shy = matrix.sx * this.shy + matrix.shy * this.sy;\n    var shx = matrix.shx * this.sx + matrix.sy * this.shx;\n    var sy = matrix.shx * this.shy + matrix.sy * this.sy;\n    var tx = matrix.tx * this.sx + matrix.ty * this.shx + this.tx;\n    var ty = matrix.tx * this.shy + matrix.ty * this.sy + this.ty;\n    return new Matrix(sx, shy, shx, sy, tx, ty);\n  };\n  /**\n  * @function decompose\n  * @private\n  * @ignore\n  */\n\n\n  Matrix.prototype.decompose = function () {\n    var a = this.sx;\n    var b = this.shy;\n    var c = this.shx;\n    var d = this.sy;\n    var e = this.tx;\n    var f = this.ty;\n    var scaleX = Math.sqrt(a * a + b * b);\n    a /= scaleX;\n    b /= scaleX;\n    var shear = a * c + b * d;\n    c -= a * shear;\n    d -= b * shear;\n    var scaleY = Math.sqrt(c * c + d * d);\n    c /= scaleY;\n    d /= scaleY;\n    shear /= scaleY;\n\n    if (a * d < b * c) {\n      a = -a;\n      b = -b;\n      shear = -shear;\n      scaleX = -scaleX;\n    }\n\n    return {\n      scale: new Matrix(scaleX, 0, 0, scaleY, 0, 0),\n      translate: new Matrix(1, 0, 0, 1, e, f),\n      rotate: new Matrix(a, b, -b, a, 0, 0),\n      skew: new Matrix(1, 0, shear, 1, 0, 0)\n    };\n  };\n  /**\n  * @function applyToPoint\n  * @private\n  * @ignore\n  */\n\n\n  Matrix.prototype.applyToPoint = function (pt) {\n    var x = pt.x * this.sx + pt.y * this.shx + this.tx;\n    var y = pt.x * this.shy + pt.y * this.sy + this.ty;\n    return new Point(x, y);\n  };\n  /**\n  * @function applyToRectangle\n  * @private\n  * @ignore\n  */\n\n\n  Matrix.prototype.applyToRectangle = function (rect) {\n    var pt1 = this.applyToPoint(rect);\n    var pt2 = this.applyToPoint(new Point(rect.x + rect.w, rect.y + rect.h));\n    return new Rectangle(pt1.x, pt1.y, pt2.x - pt1.x, pt2.y - pt1.y);\n  };\n  /**\n  * @function clone\n  * @private\n  * @ignore\n  */\n\n\n  Matrix.prototype.clone = function () {\n    var sx = this.sx;\n    var shy = this.shy;\n    var shx = this.shx;\n    var sy = this.sy;\n    var tx = this.tx;\n    var ty = this.ty;\n    return new Matrix(sx, shy, shx, sy, tx, ty);\n  };\n})(jsPDF.API, typeof self !== 'undefined' && self || typeof window !== 'undefined' && window || typeof global !== 'undefined' && global || Function('return typeof this === \"object\" && this.content')() || Function('return this')());\n\n/**\n * jsPDF filters PlugIn\n * Copyright (c) 2014 Aras Abbasi \n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n(function (jsPDFAPI) {\n\n  var ASCII85Encode = function ASCII85Encode(a) {\n    var b, c, d, e, f, g, h, i, j, k;\n\n    for (!/[^\\x00-\\xFF]/.test(a), b = \"\\x00\\x00\\x00\\x00\".slice(a.length % 4 || 4), a += b, c = [], d = 0, e = a.length; e > d; d += 4) {\n      f = (a.charCodeAt(d) << 24) + (a.charCodeAt(d + 1) << 16) + (a.charCodeAt(d + 2) << 8) + a.charCodeAt(d + 3), 0 !== f ? (k = f % 85, f = (f - k) / 85, j = f % 85, f = (f - j) / 85, i = f % 85, f = (f - i) / 85, h = f % 85, f = (f - h) / 85, g = f % 85, c.push(g + 33, h + 33, i + 33, j + 33, k + 33)) : c.push(122);\n    }\n\n    return function (a, b) {\n      for (var c = b; c > 0; c--) {\n        a.pop();\n      }\n    }(c, b.length), String.fromCharCode.apply(String, c) + \"~>\";\n  };\n\n  var ASCII85Decode = function ASCII85Decode(a) {\n    var c,\n        d,\n        e,\n        f,\n        g,\n        h = String,\n        l = \"length\",\n        w = 255,\n        x = \"charCodeAt\",\n        y = \"slice\",\n        z = \"replace\";\n\n    for (\"~>\" === a[y](-2), a = a[y](0, -2)[z](/\\s/g, \"\")[z](\"z\", \"!!!!!\"), c = \"uuuuu\"[y](a[l] % 5 || 5), a += c, e = [], f = 0, g = a[l]; g > f; f += 5) {\n      d = 52200625 * (a[x](f) - 33) + 614125 * (a[x](f + 1) - 33) + 7225 * (a[x](f + 2) - 33) + 85 * (a[x](f + 3) - 33) + (a[x](f + 4) - 33), e.push(w & d >> 24, w & d >> 16, w & d >> 8, w & d);\n    }\n\n    return function (a, b) {\n      for (var c = b; c > 0; c--) {\n        a.pop();\n      }\n    }(e, c[l]), h.fromCharCode.apply(h, e);\n  };\n  /**\n  * TODO: Not Tested:\n  //https://gist.github.com/revolunet/843889\n  // LZW-compress a string\n  var LZWEncode = function(s, options) {\n    options = Object.assign({\n      predictor: 1,\n      colors: 1,\n      bitsPerComponent: 8,\n      columns: 1,\n      earlyChange: 1\n    }, options);\n     var dict = {};\n    var data = (s + \"\").split(\"\");\n    var out = [];\n    var currChar;\n    var phrase = data[0];\n    var code = 256; //0xe000\n    for (var i=1; i<data.length; i++) {\n      currChar=data[i];\n      if (dict['_' + phrase + currChar] != null) {\n        phrase += currChar;\n      }\n      else {\n        out.push(phrase.length > 1 ? dict['_'+phrase] : phrase.charCodeAt(0));\n        dict['_' + phrase + currChar] = code;\n        code++;\n        phrase=currChar;\n      }\n    }\n    out.push(phrase.length > 1 ? dict['_'+phrase] : phrase.charCodeAt(0));\n    for (var i=0; i<out.length; i++) {\n      out[i] = String.fromCharCode(out[i]);\n    }\n    return out.join(\"\");\n  }\n   // Decompress an LZW-encoded string\n  var LZWDecode = function(s, options) {\n    options = Object.assign({\n      predictor: 1,\n      colors: 1,\n      bitsPerComponent: 8,\n      columns: 1,\n      earlyChange: 1\n    }, options);\n     var dict = {};\n    var data = (s + \"\").split(\"\");\n    var currChar = data[0];\n    var oldPhrase = currChar;\n    var out = [currChar];\n    var code = 256;\n    var phrase;\n    for (var i=1; i<data.length; i++) {\n      var currCode = data[i].charCodeAt(0);\n      if (currCode < 256) {\n        phrase = data[i];\n      }\n      else {\n         phrase = dict['_'+currCode] ? dict['_'+currCode] : (oldPhrase + currChar);\n      }\n      out.push(phrase);\n      currChar = phrase.charAt(0);\n      dict['_'+code] = oldPhrase + currChar;\n      code++;\n      oldPhrase = phrase;\n    }\n    return out.join(\"\");\n  }\n  */\n\n\n  var ASCIIHexEncode = function ASCIIHexEncode(value) {\n    var result = '';\n    var i;\n\n    for (var i = 0; i < value.length; i += 1) {\n      result += (\"0\" + value.charCodeAt(i).toString(16)).slice(-2);\n    }\n\n    result += '>';\n    return result;\n  };\n\n  var ASCIIHexDecode = function ASCIIHexDecode(value) {\n    var regexCheckIfHex = new RegExp(/^([0-9A-Fa-f]{2})+$/);\n    value = value.replace(/\\s/g, '');\n\n    if (value.indexOf(\">\") !== -1) {\n      value = value.substr(0, value.indexOf(\">\"));\n    }\n\n    if (value.length % 2) {\n      value += \"0\";\n    }\n\n    if (regexCheckIfHex.test(value) === false) {\n      return \"\";\n    }\n\n    var result = '';\n    var i;\n\n    for (var i = 0; i < value.length; i += 2) {\n      result += String.fromCharCode(\"0x\" + (value[i] + value[i + 1]));\n    }\n\n    return result;\n  };\n\n  var FlateEncode = function FlateEncode(data, options) {\n    options = Object.assign({\n      predictor: 1,\n      colors: 1,\n      bitsPerComponent: 8,\n      columns: 1\n    }, options);\n    var arr = [];\n    var i = data.length;\n    var adler32;\n    var deflater;\n\n    while (i--) {\n      arr[i] = data.charCodeAt(i);\n    }\n\n    adler32 = jsPDFAPI.adler32cs.from(data);\n    deflater = new Deflater(6);\n    deflater.append(new Uint8Array(arr));\n    data = deflater.flush();\n    arr = new Uint8Array(data.length + 6);\n    arr.set(new Uint8Array([120, 156])), arr.set(data, 2);\n    arr.set(new Uint8Array([adler32 & 0xFF, adler32 >> 8 & 0xFF, adler32 >> 16 & 0xFF, adler32 >> 24 & 0xFF]), data.length + 2);\n    data = String.fromCharCode.apply(null, arr);\n    return data;\n  };\n\n  jsPDFAPI.processDataByFilters = function (origData, filterChain) {\n\n    var i = 0;\n    var data = origData || '';\n    var reverseChain = [];\n    filterChain = filterChain || [];\n\n    if (typeof filterChain === \"string\") {\n      filterChain = [filterChain];\n    }\n\n    for (i = 0; i < filterChain.length; i += 1) {\n      switch (filterChain[i]) {\n        case \"ASCII85Decode\":\n        case \"/ASCII85Decode\":\n          data = ASCII85Decode(data);\n          reverseChain.push(\"/ASCII85Encode\");\n          break;\n\n        case \"ASCII85Encode\":\n        case \"/ASCII85Encode\":\n          data = ASCII85Encode(data);\n          reverseChain.push(\"/ASCII85Decode\");\n          break;\n\n        case \"ASCIIHexDecode\":\n        case \"/ASCIIHexDecode\":\n          data = ASCIIHexDecode(data);\n          reverseChain.push(\"/ASCIIHexEncode\");\n          break;\n\n        case \"ASCIIHexEncode\":\n        case \"/ASCIIHexEncode\":\n          data = ASCIIHexEncode(data);\n          reverseChain.push(\"/ASCIIHexDecode\");\n          break;\n\n        case \"FlateEncode\":\n        case \"/FlateEncode\":\n          data = FlateEncode(data);\n          reverseChain.push(\"/FlateDecode\");\n          break;\n\n        /**\n        case \"LZWDecode\":\n        case \"/LZWDecode\":\n          data = LZWDecode(data);\n          reverseChain.push(\"/LZWEncode\");\n          break;\n        case \"LZWEncode\":\n        case \"/LZWEncode\":\n          data = LZWEncode(data);\n          reverseChain.push(\"/LZWDecode\");\n          break;\n        */\n\n        default:\n          throw \"The filter: \\\"\" + filterChain[i] + \"\\\" is not implemented\";\n      }\n    }\n\n    return {\n      data: data,\n      reverseChain: reverseChain.reverse().join(\" \")\n    };\n  };\n})(jsPDF.API);\n\n/**\n * jsPDF fileloading PlugIn\n * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)\n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n* @name fileloading\n* @module\n*/\n(function (jsPDFAPI) {\n  /**\n  * @name loadFile\n  * @function\n  * @param {string} url\n  * @param {boolean} sync\n  * @param {function} callback\n  * @returns {string|undefined} result\n  */\n\n  jsPDFAPI.loadFile = function (url, sync, callback) {\n    sync = sync || true;\n\n    callback = callback || function () {};\n\n    var result;\n\n    var xhr = function xhr(url, sync, callback) {\n      var req = new XMLHttpRequest();\n      var byteArray = [];\n      var i = 0;\n\n      var sanitizeUnicode = function sanitizeUnicode(data) {\n        var dataLength = data.length;\n        var StringFromCharCode = String.fromCharCode; //Transform Unicode to ASCII\n\n        for (i = 0; i < dataLength; i += 1) {\n          byteArray.push(StringFromCharCode(data.charCodeAt(i) & 0xff));\n        }\n\n        return byteArray.join(\"\");\n      };\n\n      req.open('GET', url, !sync); // XHR binary charset opt by Marcus Granado 2006 [http://mgran.blogspot.com]\n\n      req.overrideMimeType('text\\/plain; charset=x-user-defined');\n\n      if (sync === false) {\n        req.onload = function () {\n          return sanitizeUnicode(this.responseText);\n        };\n      }\n\n      req.send(null);\n\n      if (req.status !== 200) {\n        console.warn('Unable to load file \"' + url + '\"');\n        return;\n      }\n\n      if (sync) {\n        return sanitizeUnicode(req.responseText);\n      }\n    };\n\n    try {\n      result = xhr(url, sync, callback);\n    } catch (e) {\n      result = undefined;\n    }\n\n    return result;\n  };\n  /**\n  * @name loadImageFile\n  * @function\n  * @param {string} path\n  * @param {boolean} sync\n  * @param {function} callback\n  */\n\n\n  jsPDFAPI.loadImageFile = jsPDFAPI.loadFile;\n})(jsPDF.API);\n\n/**\n * Copyright (c) 2018 Erik Koopmans\n * Released under the MIT License.\n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * jsPDF html PlugIn\n *\n * @name html\n * @module\n */\n(function (jsPDFAPI, global) {\n  /**\n  * Determine the type of a variable/object.\n  * \n  * @private\n  * @ignore\n  */\n\n  var objType = function objType(obj) {\n    var type = _typeof(obj);\n\n    if (type === 'undefined') return 'undefined';else if (type === 'string' || obj instanceof String) return 'string';else if (type === 'number' || obj instanceof Number) return 'number';else if (type === 'function' || obj instanceof Function) return 'function';else if (!!obj && obj.constructor === Array) return 'array';else if (obj && obj.nodeType === 1) return 'element';else if (type === 'object') return 'object';else return 'unknown';\n  };\n  /**\n  * Create an HTML element with optional className, innerHTML, and style.\n  * \n  * @private\n  * @ignore\n  */\n\n\n  var createElement = function createElement(tagName, opt) {\n    var el = document.createElement(tagName);\n    if (opt.className) el.className = opt.className;\n\n    if (opt.innerHTML) {\n      el.innerHTML = opt.innerHTML;\n      var scripts = el.getElementsByTagName('script');\n\n      for (var i = scripts.length; i-- > 0; null) {\n        scripts[i].parentNode.removeChild(scripts[i]);\n      }\n    }\n\n    for (var key in opt.style) {\n      el.style[key] = opt.style[key];\n    }\n\n    return el;\n  };\n  /**\n  * Deep-clone a node and preserve contents/properties.\n  * \n  * @private\n  * @ignore\n  */\n\n\n  var cloneNode = function cloneNode(node, javascriptEnabled) {\n    // Recursively clone the node.\n    var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);\n\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {\n        clone.appendChild(cloneNode(child, javascriptEnabled));\n      }\n    }\n\n    if (node.nodeType === 1) {\n      // Preserve contents/properties of special nodes.\n      if (node.nodeName === 'CANVAS') {\n        clone.width = node.width;\n        clone.height = node.height;\n        clone.getContext('2d').drawImage(node, 0, 0);\n      } else if (node.nodeName === 'TEXTAREA' || node.nodeName === 'SELECT') {\n        clone.value = node.value;\n      } // Preserve the node's scroll position when it loads.\n\n\n      clone.addEventListener('load', function () {\n        clone.scrollTop = node.scrollTop;\n        clone.scrollLeft = node.scrollLeft;\n      }, true);\n    } // Return the cloned node.\n\n\n    return clone;\n  };\n  /* ----- CONSTRUCTOR ----- */\n\n\n  var Worker = function Worker(opt) {\n    // Create the root parent for the proto chain, and the starting Worker.\n    var root = Object.assign(Worker.convert(Promise.resolve()), JSON.parse(JSON.stringify(Worker.template)));\n    var self = Worker.convert(Promise.resolve(), root); // Set progress, optional settings, and return.\n\n    self = self.setProgress(1, Worker, 1, [Worker]);\n    self = self.set(opt);\n    return self;\n  }; // Boilerplate for subclassing Promise.\n\n\n  Worker.prototype = Object.create(Promise.prototype);\n  Worker.prototype.constructor = Worker; // Converts/casts promises into Workers.\n\n  Worker.convert = function convert(promise, inherit) {\n    // Uses prototypal inheritance to receive changes made to ancestors' properties.\n    promise.__proto__ = inherit || Worker.prototype;\n    return promise;\n  };\n\n  Worker.template = {\n    prop: {\n      src: null,\n      container: null,\n      overlay: null,\n      canvas: null,\n      img: null,\n      pdf: null,\n      pageSize: null,\n      callback: function callback() {}\n    },\n    progress: {\n      val: 0,\n      state: null,\n      n: 0,\n      stack: []\n    },\n    opt: {\n      filename: 'file.pdf',\n      margin: [0, 0, 0, 0],\n      enableLinks: true,\n      x: 0,\n      y: 0,\n      html2canvas: {},\n      jsPDF: {}\n    }\n  };\n  /* ----- FROM / TO ----- */\n\n  Worker.prototype.from = function from(src, type) {\n    function getType(src) {\n      switch (objType(src)) {\n        case 'string':\n          return 'string';\n\n        case 'element':\n          return src.nodeName.toLowerCase === 'canvas' ? 'canvas' : 'element';\n\n        default:\n          return 'unknown';\n      }\n    }\n\n    return this.then(function from_main() {\n      type = type || getType(src);\n\n      switch (type) {\n        case 'string':\n          return this.set({\n            src: createElement('div', {\n              innerHTML: src\n            })\n          });\n\n        case 'element':\n          return this.set({\n            src: src\n          });\n\n        case 'canvas':\n          return this.set({\n            canvas: src\n          });\n\n        case 'img':\n          return this.set({\n            img: src\n          });\n\n        default:\n          return this.error('Unknown source type.');\n      }\n    });\n  };\n\n  Worker.prototype.to = function to(target) {\n    // Route the 'to' request to the appropriate method.\n    switch (target) {\n      case 'container':\n        return this.toContainer();\n\n      case 'canvas':\n        return this.toCanvas();\n\n      case 'img':\n        return this.toImg();\n\n      case 'pdf':\n        return this.toPdf();\n\n      default:\n        return this.error('Invalid target.');\n    }\n  };\n\n  Worker.prototype.toContainer = function toContainer() {\n    // Set up function prerequisites.\n    var prereqs = [function checkSrc() {\n      return this.prop.src || this.error('Cannot duplicate - no source HTML.');\n    }, function checkPageSize() {\n      return this.prop.pageSize || this.setPageSize();\n    }];\n    return this.thenList(prereqs).then(function toContainer_main() {\n      // Define the CSS styles for the container and its overlay parent.\n      var overlayCSS = {\n        position: 'fixed',\n        overflow: 'hidden',\n        zIndex: 1000,\n        left: '-100000px',\n        right: 0,\n        bottom: 0,\n        top: 0\n      };\n      var containerCSS = {\n        position: 'relative',\n        display: 'inline-block',\n        width: Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) + 'px',\n        left: 0,\n        right: 0,\n        top: 0,\n        margin: 'auto',\n        backgroundColor: 'white'\n      }; // Set the overlay to hidden (could be changed in the future to provide a print preview).\n\n      var source = cloneNode(this.prop.src, this.opt.html2canvas.javascriptEnabled);\n\n      if (source.tagName === 'BODY') {\n        containerCSS.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + 'px';\n      }\n\n      this.prop.overlay = createElement('div', {\n        className: 'html2pdf__overlay',\n        style: overlayCSS\n      });\n      this.prop.container = createElement('div', {\n        className: 'html2pdf__container',\n        style: containerCSS\n      });\n      this.prop.container.appendChild(source);\n      this.prop.container.firstChild.appendChild(createElement('div', {\n        style: {\n          clear: 'both',\n          border: '0 none transparent',\n          margin: 0,\n          padding: 0,\n          height: 0\n        }\n      }));\n      this.prop.container.style.float = 'none';\n      this.prop.overlay.appendChild(this.prop.container);\n      document.body.appendChild(this.prop.overlay);\n      this.prop.container.firstChild.style.position = 'relative';\n      this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + 'px';\n    });\n  };\n\n  Worker.prototype.toCanvas = function toCanvas() {\n    // Set up function prerequisites.\n    var prereqs = [function checkContainer() {\n      return document.body.contains(this.prop.container) || this.toContainer();\n    }]; // Fulfill prereqs then create the canvas.\n\n    return this.thenList(prereqs).then(function toCanvas_main() {\n      // Handle old-fashioned 'onrendered' argument.\n      var options = Object.assign({}, this.opt.html2canvas);\n      delete options.onrendered;\n\n      if (!this.isHtml2CanvasLoaded()) {\n        return;\n      }\n\n      return html2canvas(this.prop.container, options);\n    }).then(function toCanvas_post(canvas) {\n      // Handle old-fashioned 'onrendered' argument.\n      var onRendered = this.opt.html2canvas.onrendered || function () {};\n\n      onRendered(canvas);\n      this.prop.canvas = canvas;\n      document.body.removeChild(this.prop.overlay);\n    });\n  };\n\n  Worker.prototype.toContext2d = function toContext2d() {\n    // Set up function prerequisites.\n    var prereqs = [function checkContainer() {\n      return document.body.contains(this.prop.container) || this.toContainer();\n    }]; // Fulfill prereqs then create the canvas.\n\n    return this.thenList(prereqs).then(function toContext2d_main() {\n      // Handle old-fashioned 'onrendered' argument.\n      var pdf = this.opt.jsPDF;\n      var options = Object.assign({\n        async: true,\n        allowTaint: true,\n        backgroundColor: '#ffffff',\n        imageTimeout: 15000,\n        logging: true,\n        proxy: null,\n        removeContainer: true,\n        foreignObjectRendering: false,\n        useCORS: false\n      }, this.opt.html2canvas);\n      delete options.onrendered;\n      pdf.context2d.autoPaging = true;\n      pdf.context2d.posX = this.opt.x;\n      pdf.context2d.posY = this.opt.y;\n      options.windowHeight = options.windowHeight || 0;\n      options.windowHeight = options.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : options.windowHeight;\n\n      if (!this.isHtml2CanvasLoaded()) {\n        return;\n      }\n\n      return html2canvas(this.prop.container, options);\n    }).then(function toContext2d_post(canvas) {\n      // Handle old-fashioned 'onrendered' argument.\n      var onRendered = this.opt.html2canvas.onrendered || function () {};\n\n      onRendered(canvas);\n      this.prop.canvas = canvas;\n      document.body.removeChild(this.prop.overlay);\n    });\n  };\n\n  Worker.prototype.toImg = function toImg() {\n    // Set up function prerequisites.\n    var prereqs = [function checkCanvas() {\n      return this.prop.canvas || this.toCanvas();\n    }]; // Fulfill prereqs then create the image.\n\n    return this.thenList(prereqs).then(function toImg_main() {\n      var imgData = this.prop.canvas.toDataURL('image/' + this.opt.image.type, this.opt.image.quality);\n      this.prop.img = document.createElement('img');\n      this.prop.img.src = imgData;\n    });\n  };\n\n  Worker.prototype.toPdf = function toPdf() {\n    // Set up function prerequisites.\n    var prereqs = [function checkContext2d() {\n      return this.toContext2d();\n    } //function checkCanvas() { return this.prop.canvas || this.toCanvas(); }\n    ]; // Fulfill prereqs then create the image.\n\n    return this.thenList(prereqs).then(function toPdf_main() {\n      // Create local copies of frequently used properties.\n      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;\n    });\n  };\n  /* ----- OUTPUT / SAVE ----- */\n\n\n  Worker.prototype.output = function output(type, options, src) {\n    // Redirect requests to the correct function (outputPdf / outputImg).\n    src = src || 'pdf';\n\n    if (src.toLowerCase() === 'img' || src.toLowerCase() === 'image') {\n      return this.outputImg(type, options);\n    } else {\n      return this.outputPdf(type, options);\n    }\n  };\n\n  Worker.prototype.outputPdf = function outputPdf(type, options) {\n    // Set up function prerequisites.\n    var prereqs = [function checkPdf() {\n      return this.prop.pdf || this.toPdf();\n    }]; // Fulfill prereqs then perform the appropriate output.\n\n    return this.thenList(prereqs).then(function outputPdf_main() {\n      /* Currently implemented output types:\n       *    https://rawgit.com/MrRio/jsPDF/master/docs/jspdf.js.html#line992\n       *  save(options), arraybuffer, blob, bloburi/bloburl,\n       *  datauristring/dataurlstring, dataurlnewwindow, datauri/dataurl\n       */\n      return this.prop.pdf.output(type, options);\n    });\n  };\n\n  Worker.prototype.outputImg = function outputImg(type, options) {\n    // Set up function prerequisites.\n    var prereqs = [function checkImg() {\n      return this.prop.img || this.toImg();\n    }]; // Fulfill prereqs then perform the appropriate output.\n\n    return this.thenList(prereqs).then(function outputImg_main() {\n      switch (type) {\n        case undefined:\n        case 'img':\n          return this.prop.img;\n\n        case 'datauristring':\n        case 'dataurlstring':\n          return this.prop.img.src;\n\n        case 'datauri':\n        case 'dataurl':\n          return document.location.href = this.prop.img.src;\n\n        default:\n          throw 'Image output type \"' + type + '\" is not supported.';\n      }\n    });\n  };\n\n  Worker.prototype.isHtml2CanvasLoaded = function () {\n    var result = typeof global.html2canvas !== \"undefined\";\n\n    if (!result) {\n      console.error(\"html2canvas not loaded.\");\n    }\n\n    return result;\n  };\n\n  Worker.prototype.save = function save(filename) {\n    // Set up function prerequisites.\n    var prereqs = [function checkPdf() {\n      return this.prop.pdf || this.toPdf();\n    }];\n\n    if (!this.isHtml2CanvasLoaded()) {\n      return;\n    } // Fulfill prereqs, update the filename (if provided), and save the PDF.\n\n\n    return this.thenList(prereqs).set(filename ? {\n      filename: filename\n    } : null).then(function save_main() {\n      this.prop.pdf.save(this.opt.filename);\n    });\n  };\n\n  Worker.prototype.doCallback = function doCallback(filename) {\n    // Set up function prerequisites.\n    var prereqs = [function checkPdf() {\n      return this.prop.pdf || this.toPdf();\n    }];\n\n    if (!this.isHtml2CanvasLoaded()) {\n      return;\n    } // Fulfill prereqs, update the filename (if provided), and save the PDF.\n\n\n    return this.thenList(prereqs).then(function doCallback_main() {\n      this.prop.callback(this.prop.pdf);\n    });\n  };\n  /* ----- SET / GET ----- */\n\n\n  Worker.prototype.set = function set(opt) {\n    // TODO: Implement ordered pairs?\n    // Silently ignore invalid or empty input.\n    if (objType(opt) !== 'object') {\n      return this;\n    } // Build an array of setter functions to queue.\n\n\n    var fns = Object.keys(opt || {}).map(function (key) {\n      if (key in Worker.template.prop) {\n        // Set pre-defined properties.\n        return function set_prop() {\n          this.prop[key] = opt[key];\n        };\n      } else {\n        switch (key) {\n          case 'margin':\n            return this.setMargin.bind(this, opt.margin);\n\n          case 'jsPDF':\n            return function set_jsPDF() {\n              this.opt.jsPDF = opt.jsPDF;\n              return this.setPageSize();\n            };\n\n          case 'pageSize':\n            return this.setPageSize.bind(this, opt.pageSize);\n\n          default:\n            // Set any other properties in opt.\n            return function set_opt() {\n              this.opt[key] = opt[key];\n            };\n        }\n      }\n    }, this); // Set properties within the promise chain.\n\n    return this.then(function set_main() {\n      return this.thenList(fns);\n    });\n  };\n\n  Worker.prototype.get = function get(key, cbk) {\n    return this.then(function get_main() {\n      // Fetch the requested property, either as a predefined prop or in opt.\n      var val = key in Worker.template.prop ? this.prop[key] : this.opt[key];\n      return cbk ? cbk(val) : val;\n    });\n  };\n\n  Worker.prototype.setMargin = function setMargin(margin) {\n    return this.then(function setMargin_main() {\n      // Parse the margin property.\n      switch (objType(margin)) {\n        case 'number':\n          margin = [margin, margin, margin, margin];\n\n        case 'array':\n          if (margin.length === 2) {\n            margin = [margin[0], margin[1], margin[0], margin[1]];\n          }\n\n          if (margin.length === 4) {\n            break;\n          }\n\n        default:\n          return this.error('Invalid margin array.');\n      } // Set the margin property, then update pageSize.\n\n\n      this.opt.margin = margin;\n    }).then(this.setPageSize);\n  };\n\n  Worker.prototype.setPageSize = function setPageSize(pageSize) {\n    function toPx(val, k) {\n      return Math.floor(val * k / 72 * 96);\n    }\n\n    return this.then(function setPageSize_main() {\n      // Retrieve page-size based on jsPDF settings, if not explicitly provided.\n      pageSize = pageSize || jsPDF.getPageSize(this.opt.jsPDF); // Add 'inner' field if not present.\n\n      if (!pageSize.hasOwnProperty('inner')) {\n        pageSize.inner = {\n          width: pageSize.width - this.opt.margin[1] - this.opt.margin[3],\n          height: pageSize.height - this.opt.margin[0] - this.opt.margin[2]\n        };\n        pageSize.inner.px = {\n          width: toPx(pageSize.inner.width, pageSize.k),\n          height: toPx(pageSize.inner.height, pageSize.k)\n        };\n        pageSize.inner.ratio = pageSize.inner.height / pageSize.inner.width;\n      } // Attach pageSize to this.\n\n\n      this.prop.pageSize = pageSize;\n    });\n  };\n\n  Worker.prototype.setProgress = function setProgress(val, state, n, stack) {\n    // Immediately update all progress values.\n    if (val != null) this.progress.val = val;\n    if (state != null) this.progress.state = state;\n    if (n != null) this.progress.n = n;\n    if (stack != null) this.progress.stack = stack;\n    this.progress.ratio = this.progress.val / this.progress.state; // Return this for command chaining.\n\n    return this;\n  };\n\n  Worker.prototype.updateProgress = function updateProgress(val, state, n, stack) {\n    // Immediately update all progress values, using setProgress.\n    return this.setProgress(val ? this.progress.val + val : null, state ? state : null, n ? this.progress.n + n : null, stack ? this.progress.stack.concat(stack) : null);\n  };\n  /* ----- PROMISE MAPPING ----- */\n\n\n  Worker.prototype.then = function then(onFulfilled, onRejected) {\n    // Wrap `this` for encapsulation.\n    var self = this;\n    return this.thenCore(onFulfilled, onRejected, function then_main(onFulfilled, onRejected) {\n      // Update progress while queuing, calling, and resolving `then`.\n      self.updateProgress(null, null, 1, [onFulfilled]);\n      return Promise.prototype.then.call(this, function then_pre(val) {\n        self.updateProgress(null, onFulfilled);\n        return val;\n      }).then(onFulfilled, onRejected).then(function then_post(val) {\n        self.updateProgress(1);\n        return val;\n      });\n    });\n  };\n\n  Worker.prototype.thenCore = function thenCore(onFulfilled, onRejected, thenBase) {\n    // Handle optional thenBase parameter.\n    thenBase = thenBase || Promise.prototype.then; // Wrap `this` for encapsulation and bind it to the promise handlers.\n\n    var self = this;\n\n    if (onFulfilled) {\n      onFulfilled = onFulfilled.bind(self);\n    }\n\n    if (onRejected) {\n      onRejected = onRejected.bind(self);\n    } // Cast self into a Promise to avoid polyfills recursively defining `then`.\n\n\n    var isNative = Promise.toString().indexOf('[native code]') !== -1 && Promise.name === 'Promise';\n    var selfPromise = isNative ? self : Worker.convert(Object.assign({}, self), Promise.prototype); // Return the promise, after casting it into a Worker and preserving props.\n\n    var returnVal = thenBase.call(selfPromise, onFulfilled, onRejected);\n    return Worker.convert(returnVal, self.__proto__);\n  };\n\n  Worker.prototype.thenExternal = function thenExternal(onFulfilled, onRejected) {\n    // Call `then` and return a standard promise (exits the Worker chain).\n    return Promise.prototype.then.call(this, onFulfilled, onRejected);\n  };\n\n  Worker.prototype.thenList = function thenList(fns) {\n    // Queue a series of promise 'factories' into the promise chain.\n    var self = this;\n    fns.forEach(function thenList_forEach(fn) {\n      self = self.thenCore(fn);\n    });\n    return self;\n  };\n\n  Worker.prototype['catch'] = function (onRejected) {\n    // Bind `this` to the promise handler, call `catch`, and return a Worker.\n    if (onRejected) {\n      onRejected = onRejected.bind(this);\n    }\n\n    var returnVal = Promise.prototype['catch'].call(this, onRejected);\n    return Worker.convert(returnVal, this);\n  };\n\n  Worker.prototype.catchExternal = function catchExternal(onRejected) {\n    // Call `catch` and return a standard promise (exits the Worker chain).\n    return Promise.prototype['catch'].call(this, onRejected);\n  };\n\n  Worker.prototype.error = function error(msg) {\n    // Throw the error in the Promise chain.\n    return this.then(function error_main() {\n      throw new Error(msg);\n    });\n  };\n  /* ----- ALIASES ----- */\n\n\n  Worker.prototype.using = Worker.prototype.set;\n  Worker.prototype.saveAs = Worker.prototype.save;\n  Worker.prototype.export = Worker.prototype.output;\n  Worker.prototype.run = Worker.prototype.then; // Get dimensions of a PDF page, as determined by jsPDF.\n\n  jsPDF.getPageSize = function (orientation, unit, format) {\n    // Decode options object\n    if (_typeof(orientation) === 'object') {\n      var options = orientation;\n      orientation = options.orientation;\n      unit = options.unit || unit;\n      format = options.format || format;\n    } // Default options\n\n\n    unit = unit || 'mm';\n    format = format || 'a4';\n    orientation = ('' + (orientation || 'P')).toLowerCase();\n    var format_as_string = ('' + format).toLowerCase(); // Size in pt of various paper formats\n\n    var pageFormats = {\n      'a0': [2383.94, 3370.39],\n      'a1': [1683.78, 2383.94],\n      'a2': [1190.55, 1683.78],\n      'a3': [841.89, 1190.55],\n      'a4': [595.28, 841.89],\n      'a5': [419.53, 595.28],\n      'a6': [297.64, 419.53],\n      'a7': [209.76, 297.64],\n      'a8': [147.40, 209.76],\n      'a9': [104.88, 147.40],\n      'a10': [73.70, 104.88],\n      'b0': [2834.65, 4008.19],\n      'b1': [2004.09, 2834.65],\n      'b2': [1417.32, 2004.09],\n      'b3': [1000.63, 1417.32],\n      'b4': [708.66, 1000.63],\n      'b5': [498.90, 708.66],\n      'b6': [354.33, 498.90],\n      'b7': [249.45, 354.33],\n      'b8': [175.75, 249.45],\n      'b9': [124.72, 175.75],\n      'b10': [87.87, 124.72],\n      'c0': [2599.37, 3676.54],\n      'c1': [1836.85, 2599.37],\n      'c2': [1298.27, 1836.85],\n      'c3': [918.43, 1298.27],\n      'c4': [649.13, 918.43],\n      'c5': [459.21, 649.13],\n      'c6': [323.15, 459.21],\n      'c7': [229.61, 323.15],\n      'c8': [161.57, 229.61],\n      'c9': [113.39, 161.57],\n      'c10': [79.37, 113.39],\n      'dl': [311.81, 623.62],\n      'letter': [612, 792],\n      'government-letter': [576, 756],\n      'legal': [612, 1008],\n      'junior-legal': [576, 360],\n      'ledger': [1224, 792],\n      'tabloid': [792, 1224],\n      'credit-card': [153, 243]\n    }; // Unit conversion\n\n    switch (unit) {\n      case 'pt':\n        var k = 1;\n        break;\n\n      case 'mm':\n        var k = 72 / 25.4;\n        break;\n\n      case 'cm':\n        var k = 72 / 2.54;\n        break;\n\n      case 'in':\n        var k = 72;\n        break;\n\n      case 'px':\n        var k = 72 / 96;\n        break;\n\n      case 'pc':\n        var k = 12;\n        break;\n\n      case 'em':\n        var k = 12;\n        break;\n\n      case 'ex':\n        var k = 6;\n        break;\n\n      default:\n        throw 'Invalid unit: ' + unit;\n    } // Dimensions are stored as user units and converted to points on output\n\n\n    if (pageFormats.hasOwnProperty(format_as_string)) {\n      var pageHeight = pageFormats[format_as_string][1] / k;\n      var pageWidth = pageFormats[format_as_string][0] / k;\n    } else {\n      try {\n        var pageHeight = format[1];\n        var pageWidth = format[0];\n      } catch (err) {\n        throw new Error('Invalid format: ' + format);\n      }\n    } // Handle page orientation\n\n\n    if (orientation === 'p' || orientation === 'portrait') {\n      orientation = 'p';\n\n      if (pageWidth > pageHeight) {\n        var tmp = pageWidth;\n        pageWidth = pageHeight;\n        pageHeight = tmp;\n      }\n    } else if (orientation === 'l' || orientation === 'landscape') {\n      orientation = 'l';\n\n      if (pageHeight > pageWidth) {\n        var tmp = pageWidth;\n        pageWidth = pageHeight;\n        pageHeight = tmp;\n      }\n    } else {\n      throw 'Invalid orientation: ' + orientation;\n    } // Return information (k is the unit conversion ratio from pts)\n\n\n    var info = {\n      'width': pageWidth,\n      'height': pageHeight,\n      'unit': unit,\n      'k': k\n    };\n    return info;\n  };\n  /**\n   * Generate a PDF from an HTML element or string using.\n   *\n   * @name html\n   * @function\n   * @param {Element|string} source The source element or HTML string.\n   * @param {Object=} options An object of optional settings.\n   * @description The Plugin needs html2canvas from niklasvh\n   */\n\n\n  jsPDFAPI.html = function (src, options) {\n\n    options = options || {};\n\n    options.callback = options.callback || function () {};\n\n    options.html2canvas = options.html2canvas || {};\n    options.html2canvas.canvas = options.html2canvas.canvas || this.canvas;\n    options.jsPDF = options.jsPDF || this; // Create a new worker with the given options.\n\n    var pdf = options.jsPDF;\n    var worker = new Worker(options);\n\n    if (!options.worker) {\n      // If worker is not set to true, perform the traditional 'simple' operation.\n      return worker.from(src).doCallback();\n    } else {\n      // Otherwise, return the worker for new Promise-based operation.\n      return worker;\n    }\n\n    return this;\n  };\n})(jsPDF.API, typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global);\n\n/**\n * @license\n * ==================================================================== \n * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com\n * \n * \n * ====================================================================\n */\n\n/*global jsPDF */\n\n/**\n * jsPDF JavaScript plugin\n *\n * @name javascript\n * @module\n*/\n(function (jsPDFAPI) {\n\n  var jsNamesObj, jsJsObj, text;\n  /**\n  * @name addJS\n  * @function\n  * @param {string} javascript The javascript to be embedded into the PDF-file.\n  * @returns {jsPDF}\n  */\n\n  jsPDFAPI.addJS = function (javascript) {\n    text = javascript;\n    this.internal.events.subscribe('postPutResources', function (javascript) {\n      jsNamesObj = this.internal.newObject();\n      this.internal.out('<<');\n      this.internal.out('/Names [(EmbeddedJS) ' + (jsNamesObj + 1) + ' 0 R]');\n      this.internal.out('>>');\n      this.internal.out('endobj');\n      jsJsObj = this.internal.newObject();\n      this.internal.out('<<');\n      this.internal.out('/S /JavaScript');\n      this.internal.out('/JS (' + text + ')');\n      this.internal.out('>>');\n      this.internal.out('endobj');\n    });\n    this.internal.events.subscribe('putCatalog', function () {\n      if (jsNamesObj !== undefined && jsJsObj !== undefined) {\n        this.internal.out('/Names <</JavaScript ' + jsNamesObj + ' 0 R>>');\n      }\n    });\n    return this;\n  };\n})(jsPDF.API);\n\n/**\n * @license\n * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv\n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n(function (jsPDFAPI) {\n\n  jsPDFAPI.events.push(['postPutResources', function () {\n    var pdf = this;\n    var rx = /^(\\d+) 0 obj$/; // Write action goto objects for each page\n    // this.outline.destsGoto = [];\n    // for (var i = 0; i < totalPages; i++) {\n    // var id = pdf.internal.newObject();\n    // this.outline.destsGoto.push(id);\n    // pdf.internal.write(\"<</D[\" + (i * 2 + 3) + \" 0 R /XYZ null\n    // null null]/S/GoTo>> endobj\");\n    // }\n    //\n    // for (var i = 0; i < dests.length; i++) {\n    // pdf.internal.write(\"(page_\" + (i + 1) + \")\" + dests[i] + \" 0\n    // R\");\n    // }\n    //\t\t\t\t\n\n    if (this.outline.root.children.length > 0) {\n      var lines = pdf.outline.render().split(/\\r\\n/);\n\n      for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        var m = rx.exec(line);\n\n        if (m != null) {\n          var oid = m[1];\n          pdf.internal.newObjectDeferredBegin(oid, false);\n        }\n\n        pdf.internal.write(line);\n      }\n    } // This code will write named destination for each page reference\n    // (page_1, etc)\n\n\n    if (this.outline.createNamedDestinations) {\n      var totalPages = this.internal.pages.length; // WARNING: this assumes jsPDF starts on page 3 and pageIDs\n      // follow 5, 7, 9, etc\n      // Write destination objects for each page\n\n      var dests = [];\n\n      for (var i = 0; i < totalPages; i++) {\n        var id = pdf.internal.newObject();\n        dests.push(id);\n        var info = pdf.internal.getPageInfo(i + 1);\n        pdf.internal.write(\"<< /D[\" + info.objId + \" 0 R /XYZ null null null]>> endobj\");\n      } // assign a name for each destination\n\n\n      var names2Oid = pdf.internal.newObject();\n      pdf.internal.write('<< /Names [ ');\n\n      for (var i = 0; i < dests.length; i++) {\n        pdf.internal.write(\"(page_\" + (i + 1) + \")\" + dests[i] + \" 0 R\");\n      }\n\n      pdf.internal.write(' ] >>', 'endobj'); // var kids = pdf.internal.newObject();\n      // pdf.internal.write('<< /Kids [ ' + names2Oid + ' 0 R');\n      // pdf.internal.write(' ] >>', 'endobj');\n\n      var namesOid = pdf.internal.newObject();\n      pdf.internal.write('<< /Dests ' + names2Oid + \" 0 R\");\n      pdf.internal.write('>>', 'endobj');\n    }\n  }]);\n  jsPDFAPI.events.push(['putCatalog', function () {\n    var pdf = this;\n\n    if (pdf.outline.root.children.length > 0) {\n      pdf.internal.write(\"/Outlines\", this.outline.makeRef(this.outline.root));\n\n      if (this.outline.createNamedDestinations) {\n        pdf.internal.write(\"/Names \" + namesOid + \" 0 R\");\n      } // Open with Bookmarks showing\n      // pdf.internal.write(\"/PageMode /UseOutlines\");\n\n    }\n  }]);\n  jsPDFAPI.events.push(['initialized', function () {\n    var pdf = this;\n    pdf.outline = {\n      createNamedDestinations: false,\n      root: {\n        children: []\n      }\n    };\n    /**\n     * Options: pageNumber\n     */\n\n    pdf.outline.add = function (parent, title, options) {\n      var item = {\n        title: title,\n        options: options,\n        children: []\n      };\n\n      if (parent == null) {\n        parent = this.root;\n      }\n\n      parent.children.push(item);\n      return item;\n    };\n\n    pdf.outline.render = function () {\n      this.ctx = {};\n      this.ctx.val = '';\n      this.ctx.pdf = pdf;\n      this.genIds_r(this.root);\n      this.renderRoot(this.root);\n      this.renderItems(this.root);\n      return this.ctx.val;\n    };\n\n    pdf.outline.genIds_r = function (node) {\n      node.id = pdf.internal.newObjectDeferred();\n\n      for (var i = 0; i < node.children.length; i++) {\n        this.genIds_r(node.children[i]);\n      }\n    };\n\n    pdf.outline.renderRoot = function (node) {\n      this.objStart(node);\n      this.line('/Type /Outlines');\n\n      if (node.children.length > 0) {\n        this.line('/First ' + this.makeRef(node.children[0]));\n        this.line('/Last ' + this.makeRef(node.children[node.children.length - 1]));\n      }\n\n      this.line('/Count ' + this.count_r({\n        count: 0\n      }, node));\n      this.objEnd();\n    };\n\n    pdf.outline.renderItems = function (node) {\n      var getHorizontalCoordinateString = this.ctx.pdf.internal.getCoordinateString;\n      var getVerticalCoordinateString = this.ctx.pdf.internal.getVerticalCoordinateString;\n\n      for (var i = 0; i < node.children.length; i++) {\n        var item = node.children[i];\n        this.objStart(item);\n        this.line('/Title ' + this.makeString(item.title));\n        this.line('/Parent ' + this.makeRef(node));\n\n        if (i > 0) {\n          this.line('/Prev ' + this.makeRef(node.children[i - 1]));\n        }\n\n        if (i < node.children.length - 1) {\n          this.line('/Next ' + this.makeRef(node.children[i + 1]));\n        }\n\n        if (item.children.length > 0) {\n          this.line('/First ' + this.makeRef(item.children[0]));\n          this.line('/Last ' + this.makeRef(item.children[item.children.length - 1]));\n        }\n\n        var count = this.count = this.count_r({\n          count: 0\n        }, item);\n\n        if (count > 0) {\n          this.line('/Count ' + count);\n        }\n\n        if (item.options) {\n          if (item.options.pageNumber) {\n            // Explicit Destination\n            //WARNING this assumes page ids are 3,5,7, etc.\n            var info = pdf.internal.getPageInfo(item.options.pageNumber);\n            this.line('/Dest ' + '[' + info.objId + ' 0 R /XYZ 0 ' + getVerticalCoordinateString(0) + ' 0]'); // this line does not work on all clients (pageNumber instead of page ref)\n            //this.line('/Dest ' + '[' + (item.options.pageNumber - 1) + ' /XYZ 0 ' + this.ctx.pdf.internal.pageSize.getHeight() + ' 0]');\n            // Named Destination\n            // this.line('/Dest (page_' + (item.options.pageNumber) + ')');\n            // Action Destination\n            // var id = pdf.internal.newObject();\n            // pdf.internal.write('<</D[' + (item.options.pageNumber - 1) + ' /XYZ null null null]/S/GoTo>> endobj');\n            // this.line('/A ' + id + ' 0 R' );\n          }\n        }\n\n        this.objEnd();\n      }\n\n      for (var i = 0; i < node.children.length; i++) {\n        var item = node.children[i];\n        this.renderItems(item);\n      }\n    };\n\n    pdf.outline.line = function (text) {\n      this.ctx.val += text + '\\r\\n';\n    };\n\n    pdf.outline.makeRef = function (node) {\n      return node.id + ' 0 R';\n    };\n\n    pdf.outline.makeString = function (val) {\n      return '(' + pdf.internal.pdfEscape(val) + ')';\n    };\n\n    pdf.outline.objStart = function (node) {\n      this.ctx.val += '\\r\\n' + node.id + ' 0 obj' + '\\r\\n<<\\r\\n';\n    };\n\n    pdf.outline.objEnd = function (node) {\n      this.ctx.val += '>> \\r\\n' + 'endobj' + '\\r\\n';\n    };\n\n    pdf.outline.count_r = function (ctx, node) {\n      for (var i = 0; i < node.children.length; i++) {\n        ctx.count++;\n        this.count_r(ctx, node.children[i]);\n      }\n\n      return ctx.count;\n    };\n  }]);\n  return this;\n})(jsPDF.API);\n\n/**\n * @license\n * \n * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb\n *\n * \n * ====================================================================\n */\n\n/**\n* jsPDF PNG PlugIn\n* @name png_support\n* @module\n*/\n(function (jsPDFAPI) {\n  /*\n   * @see http://www.w3.org/TR/PNG-Chunks.html\n   *\n   Color    Allowed      Interpretation\n   Type     Bit Depths\n  \t   0       1,2,4,8,16  Each pixel is a grayscale sample.\n  \t   2       8,16        Each pixel is an R,G,B triple.\n  \t   3       1,2,4,8     Each pixel is a palette index;\n                         a PLTE chunk must appear.\n  \t   4       8,16        Each pixel is a grayscale sample,\n                         followed by an alpha sample.\n  \t   6       8,16        Each pixel is an R,G,B triple,\n                         followed by an alpha sample.\n  */\n\n  /*\n   * PNG filter method types\n   *\n   * @see http://www.w3.org/TR/PNG-Filters.html\n   * @see http://www.libpng.org/pub/png/book/chapter09.html\n   *\n   * This is what the value 'Predictor' in decode params relates to\n   *\n   * 15 is \"optimal prediction\", which means the prediction algorithm can change from line to line.\n   * In that case, you actually have to read the first byte off each line for the prediction algorthim (which should be 0-4, corresponding to PDF 10-14) and select the appropriate unprediction algorithm based on that byte.\n   *\n     0       None\n     1       Sub\n     2       Up\n     3       Average\n     4       Paeth\n   */\n\n  var doesNotHavePngJS = function doesNotHavePngJS() {\n    return typeof PNG !== 'function' || typeof FlateStream !== 'function';\n  },\n      canCompress = function canCompress(value) {\n    return value !== jsPDFAPI.image_compression.NONE && hasCompressionJS();\n  },\n      hasCompressionJS = function hasCompressionJS() {\n    var inst = typeof Deflater === 'function';\n    if (!inst) throw new Error(\"requires deflate.js for compression\");\n    return inst;\n  },\n      compressBytes = function compressBytes(bytes, lineLength, colorsPerPixel, compression) {\n    var level = 5,\n        filter_method = filterUp;\n\n    switch (compression) {\n      case jsPDFAPI.image_compression.FAST:\n        level = 3;\n        filter_method = filterSub;\n        break;\n\n      case jsPDFAPI.image_compression.MEDIUM:\n        level = 6;\n        filter_method = filterAverage;\n        break;\n\n      case jsPDFAPI.image_compression.SLOW:\n        level = 9;\n        filter_method = filterPaeth; //uses to sum to choose best filter for each line\n\n        break;\n    }\n\n    bytes = applyPngFilterMethod(bytes, lineLength, colorsPerPixel, filter_method);\n    var header = new Uint8Array(createZlibHeader(level));\n    var checksum = adler32(bytes);\n    var deflate = new Deflater(level);\n    var a = deflate.append(bytes);\n    var cBytes = deflate.flush();\n    var len = header.length + a.length + cBytes.length;\n    var cmpd = new Uint8Array(len + 4);\n    cmpd.set(header);\n    cmpd.set(a, header.length);\n    cmpd.set(cBytes, header.length + a.length);\n    cmpd[len++] = checksum >>> 24 & 0xff;\n    cmpd[len++] = checksum >>> 16 & 0xff;\n    cmpd[len++] = checksum >>> 8 & 0xff;\n    cmpd[len++] = checksum & 0xff;\n    return jsPDFAPI.arrayBufferToBinaryString(cmpd);\n  },\n      createZlibHeader = function createZlibHeader(bytes, level) {\n    /*\n     * @see http://www.ietf.org/rfc/rfc1950.txt for zlib header\n     */\n    var cm = 8;\n    var cinfo = Math.LOG2E * Math.log(0x8000) - 8;\n    var cmf = cinfo << 4 | cm;\n    var hdr = cmf << 8;\n    var flevel = Math.min(3, (level - 1 & 0xff) >> 1);\n    hdr |= flevel << 6;\n    hdr |= 0; //FDICT\n\n    hdr += 31 - hdr % 31;\n    return [cmf, hdr & 0xff & 0xff];\n  },\n      adler32 = function adler32(array, param) {\n    var adler = 1;\n    var s1 = adler & 0xffff,\n        s2 = adler >>> 16 & 0xffff;\n    var len = array.length;\n    var tlen;\n    var i = 0;\n\n    while (len > 0) {\n      tlen = len > param ? param : len;\n      len -= tlen;\n\n      do {\n        s1 += array[i++];\n        s2 += s1;\n      } while (--tlen);\n\n      s1 %= 65521;\n      s2 %= 65521;\n    }\n\n    return (s2 << 16 | s1) >>> 0;\n  },\n      applyPngFilterMethod = function applyPngFilterMethod(bytes, lineLength, colorsPerPixel, filter_method) {\n    var lines = bytes.length / lineLength,\n        result = new Uint8Array(bytes.length + lines),\n        filter_methods = getFilterMethods(),\n        i = 0,\n        line,\n        prevLine,\n        offset;\n\n    for (; i < lines; i++) {\n      offset = i * lineLength;\n      line = bytes.subarray(offset, offset + lineLength);\n\n      if (filter_method) {\n        result.set(filter_method(line, colorsPerPixel, prevLine), offset + i);\n      } else {\n        var j = 0,\n            len = filter_methods.length,\n            results = [];\n\n        for (; j < len; j++) {\n          results[j] = filter_methods[j](line, colorsPerPixel, prevLine);\n        }\n\n        var ind = getIndexOfSmallestSum(results.concat());\n        result.set(results[ind], offset + i);\n      }\n\n      prevLine = line;\n    }\n\n    return result;\n  },\n      filterNone = function filterNone(line, colorsPerPixel, prevLine) {\n    /*var result = new Uint8Array(line.length + 1);\n    result[0] = 0;\n    result.set(line, 1);*/\n    var result = Array.apply([], line);\n    result.unshift(0);\n    return result;\n  },\n      filterSub = function filterSub(line, colorsPerPixel, prevLine) {\n    var result = [],\n        i = 0,\n        len = line.length,\n        left;\n    result[0] = 1;\n\n    for (; i < len; i++) {\n      left = line[i - colorsPerPixel] || 0;\n      result[i + 1] = line[i] - left + 0x0100 & 0xff;\n    }\n\n    return result;\n  },\n      filterUp = function filterUp(line, colorsPerPixel, prevLine) {\n    var result = [],\n        i = 0,\n        len = line.length,\n        up;\n    result[0] = 2;\n\n    for (; i < len; i++) {\n      up = prevLine && prevLine[i] || 0;\n      result[i + 1] = line[i] - up + 0x0100 & 0xff;\n    }\n\n    return result;\n  },\n      filterAverage = function filterAverage(line, colorsPerPixel, prevLine) {\n    var result = [],\n        i = 0,\n        len = line.length,\n        left,\n        up;\n    result[0] = 3;\n\n    for (; i < len; i++) {\n      left = line[i - colorsPerPixel] || 0;\n      up = prevLine && prevLine[i] || 0;\n      result[i + 1] = line[i] + 0x0100 - (left + up >>> 1) & 0xff;\n    }\n\n    return result;\n  },\n      filterPaeth = function filterPaeth(line, colorsPerPixel, prevLine) {\n    var result = [],\n        i = 0,\n        len = line.length,\n        left,\n        up,\n        upLeft,\n        paeth;\n    result[0] = 4;\n\n    for (; i < len; i++) {\n      left = line[i - colorsPerPixel] || 0;\n      up = prevLine && prevLine[i] || 0;\n      upLeft = prevLine && prevLine[i - colorsPerPixel] || 0;\n      paeth = paethPredictor(left, up, upLeft);\n      result[i + 1] = line[i] - paeth + 0x0100 & 0xff;\n    }\n\n    return result;\n  },\n      paethPredictor = function paethPredictor(left, up, upLeft) {\n    var p = left + up - upLeft,\n        pLeft = Math.abs(p - left),\n        pUp = Math.abs(p - up),\n        pUpLeft = Math.abs(p - upLeft);\n    return pLeft <= pUp && pLeft <= pUpLeft ? left : pUp <= pUpLeft ? up : upLeft;\n  },\n      getFilterMethods = function getFilterMethods() {\n    return [filterNone, filterSub, filterUp, filterAverage, filterPaeth];\n  },\n      getIndexOfSmallestSum = function getIndexOfSmallestSum(arrays) {\n    var i = 0,\n        len = arrays.length,\n        sum,\n        min,\n        ind;\n\n    while (i < len) {\n      sum = absSum(arrays[i].slice(1));\n\n      if (sum < min || !min) {\n        min = sum;\n        ind = i;\n      }\n\n      i++;\n    }\n\n    return ind;\n  },\n      absSum = function absSum(array) {\n    var i = 0,\n        len = array.length,\n        sum = 0;\n\n    while (i < len) {\n      sum += Math.abs(array[i++]);\n    }\n\n    return sum;\n  },\n      getPredictorFromCompression = function getPredictorFromCompression(compression) {\n    var predictor;\n\n    switch (compression) {\n      case jsPDFAPI.image_compression.FAST:\n        predictor = 11;\n        break;\n\n      case jsPDFAPI.image_compression.MEDIUM:\n        predictor = 13;\n        break;\n\n      case jsPDFAPI.image_compression.SLOW:\n        predictor = 14;\n        break;\n\n      default:\n        predictor = 12;\n        break;\n    }\n\n    return predictor;\n  };\n  /**\n  *\n  * @name processPNG\n  * @function\n  * @ignore\n  */\n\n\n  jsPDFAPI.processPNG = function (imageData, imageIndex, alias, compression, dataAsBinaryString) {\n\n    var colorSpace = this.color_spaces.DEVICE_RGB,\n        decode = this.decode.FLATE_DECODE,\n        bpc = 8,\n        img,\n        dp,\n        trns,\n        colors,\n        pal,\n        smask;\n    /*\tif(this.isString(imageData)) {\n    \t\t}*/\n\n    if (this.isArrayBuffer(imageData)) imageData = new Uint8Array(imageData);\n\n    if (this.isArrayBufferView(imageData)) {\n      if (doesNotHavePngJS()) throw new Error(\"PNG support requires png.js and zlib.js\");\n      img = new PNG(imageData);\n      imageData = img.imgData;\n      bpc = img.bits;\n      colorSpace = img.colorSpace;\n      colors = img.colors; //logImg(img);\n\n      /*\n       * colorType 6 - Each pixel is an R,G,B triple, followed by an alpha sample.\n       *\n       * colorType 4 - Each pixel is a grayscale sample, followed by an alpha sample.\n       *\n       * Extract alpha to create two separate images, using the alpha as a sMask\n       */\n\n      if ([4, 6].indexOf(img.colorType) !== -1) {\n        /*\n         * processes 8 bit RGBA and grayscale + alpha images\n         */\n        if (img.bits === 8) {\n          var pixels = img.pixelBitlength == 32 ? new Uint32Array(img.decodePixels().buffer) : img.pixelBitlength == 16 ? new Uint16Array(img.decodePixels().buffer) : new Uint8Array(img.decodePixels().buffer),\n              len = pixels.length,\n              imgData = new Uint8Array(len * img.colors),\n              alphaData = new Uint8Array(len),\n              pDiff = img.pixelBitlength - img.bits,\n              i = 0,\n              n = 0,\n              pixel,\n              pbl;\n\n          for (; i < len; i++) {\n            pixel = pixels[i];\n            pbl = 0;\n\n            while (pbl < pDiff) {\n              imgData[n++] = pixel >>> pbl & 0xff;\n              pbl = pbl + img.bits;\n            }\n\n            alphaData[i] = pixel >>> pbl & 0xff;\n          }\n        }\n        /*\n         * processes 16 bit RGBA and grayscale + alpha images\n         */\n\n\n        if (img.bits === 16) {\n          var pixels = new Uint32Array(img.decodePixels().buffer),\n              len = pixels.length,\n              imgData = new Uint8Array(len * (32 / img.pixelBitlength) * img.colors),\n              alphaData = new Uint8Array(len * (32 / img.pixelBitlength)),\n              hasColors = img.colors > 1,\n              i = 0,\n              n = 0,\n              a = 0,\n              pixel;\n\n          while (i < len) {\n            pixel = pixels[i++];\n            imgData[n++] = pixel >>> 0 & 0xFF;\n\n            if (hasColors) {\n              imgData[n++] = pixel >>> 16 & 0xFF;\n              pixel = pixels[i++];\n              imgData[n++] = pixel >>> 0 & 0xFF;\n            }\n\n            alphaData[a++] = pixel >>> 16 & 0xFF;\n          }\n\n          bpc = 8;\n        }\n\n        if (canCompress(compression)) {\n          imageData = compressBytes(imgData, img.width * img.colors, img.colors, compression);\n          smask = compressBytes(alphaData, img.width, 1, compression);\n        } else {\n          imageData = imgData;\n          smask = alphaData;\n          decode = null;\n        }\n      }\n      /*\n       * Indexed png. Each pixel is a palette index.\n       */\n\n\n      if (img.colorType === 3) {\n        colorSpace = this.color_spaces.INDEXED;\n        pal = img.palette;\n\n        if (img.transparency.indexed) {\n          var trans = img.transparency.indexed;\n          var total = 0,\n              i = 0,\n              len = trans.length;\n\n          for (; i < len; ++i) {\n            total += trans[i];\n          }\n\n          total = total / 255;\n          /*\n           * a single color is specified as 100% transparent (0),\n           * so we set trns to use a /Mask with that index\n           */\n\n          if (total === len - 1 && trans.indexOf(0) !== -1) {\n            trns = [trans.indexOf(0)];\n            /*\n             * there's more than one colour within the palette that specifies\n             * a transparency value less than 255, so we unroll the pixels to create an image sMask\n             */\n          } else if (total !== len) {\n            var pixels = img.decodePixels(),\n                alphaData = new Uint8Array(pixels.length),\n                i = 0,\n                len = pixels.length;\n\n            for (; i < len; i++) {\n              alphaData[i] = trans[pixels[i]];\n            }\n\n            smask = compressBytes(alphaData, img.width, 1);\n          }\n        }\n      }\n\n      var predictor = getPredictorFromCompression(compression);\n      if (decode === this.decode.FLATE_DECODE) dp = '/Predictor ' + predictor + ' /Colors ' + colors + ' /BitsPerComponent ' + bpc + ' /Columns ' + img.width;else //remove 'Predictor' as it applies to the type of png filter applied to its IDAT - we only apply with compression\n        dp = '/Colors ' + colors + ' /BitsPerComponent ' + bpc + ' /Columns ' + img.width;\n      if (this.isArrayBuffer(imageData) || this.isArrayBufferView(imageData)) imageData = this.arrayBufferToBinaryString(imageData);\n      if (smask && this.isArrayBuffer(smask) || this.isArrayBufferView(smask)) smask = this.arrayBufferToBinaryString(smask);\n      return this.createImageInfo(imageData, img.width, img.height, colorSpace, bpc, decode, imageIndex, alias, dp, trns, pal, smask, predictor);\n    }\n\n    throw new Error(\"Unsupported PNG image data, try using JPEG instead.\");\n  };\n})(jsPDF.API);\n\n/**\n * @license\n * Copyright (c) 2017 Aras Abbasi \n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n* jsPDF gif Support PlugIn\n*\n* @name gif_support\n* @module\n*/\n(function (jsPDFAPI) {\n\n  jsPDFAPI.processGIF89A = function (imageData, imageIndex, alias, compression, dataAsBinaryString) {\n    var reader = new GifReader(imageData);\n    var width = reader.width,\n        height = reader.height;\n    var qu = 100;\n    var pixels = [];\n    reader.decodeAndBlitFrameRGBA(0, pixels);\n    var rawImageData = {\n      data: pixels,\n      width: width,\n      height: height\n    };\n    var encoder = new JPEGEncoder(qu);\n    var data = encoder.encode(rawImageData, qu);\n    return jsPDFAPI.processJPEG.call(this, data, imageIndex, alias, compression);\n  };\n\n  jsPDFAPI.processGIF87A = jsPDFAPI.processGIF89A;\n})(jsPDF.API);\n\n/**\n * Copyright (c) 2018 Aras Abbasi \n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n* jsPDF bmp Support PlugIn\n* @name bmp_support\n* @module\n*/\n(function (jsPDFAPI) {\n\n  jsPDFAPI.processBMP = function (imageData, imageIndex, alias, compression, dataAsBinaryString) {\n    var reader = new BmpDecoder(imageData, false);\n    var width = reader.width,\n        height = reader.height;\n    var qu = 100;\n    var pixels = reader.getData();\n    var rawImageData = {\n      data: pixels,\n      width: width,\n      height: height\n    };\n    var encoder = new JPEGEncoder(qu);\n    var data = encoder.encode(rawImageData, qu);\n    return jsPDFAPI.processJPEG.call(this, data, imageIndex, alias, compression);\n  };\n})(jsPDF.API);\n\n/**\n * @license\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * jsPDF setLanguage Plugin\n *\n * @name setLanguage\n * @module\n */\n(function (jsPDFAPI) {\n  /**\n  * Add Language Tag to the generated PDF\n  *\n  * @name setLanguage\n  * @function \n  * @param {string} langCode The Language code as ISO-639-1 (e.g. 'en') or as country language code (e.g. 'en-GB'). \n  * @returns {jsPDF}\n  * @example\n  * var doc = new jsPDF()\n  * doc.text(10, 10, 'This is a test')\n  * doc.setLanguage(\"en-US\")\n  * doc.save('english.pdf')\n  */\n\n  jsPDFAPI.setLanguage = function (langCode) {\n\n    var langCodes = {\n      \"af\": \"Afrikaans\",\n      \"sq\": \"Albanian\",\n      \"ar\": \"Arabic (Standard)\",\n      \"ar-DZ\": \"Arabic (Algeria)\",\n      \"ar-BH\": \"Arabic (Bahrain)\",\n      \"ar-EG\": \"Arabic (Egypt)\",\n      \"ar-IQ\": \"Arabic (Iraq)\",\n      \"ar-JO\": \"Arabic (Jordan)\",\n      \"ar-KW\": \"Arabic (Kuwait)\",\n      \"ar-LB\": \"Arabic (Lebanon)\",\n      \"ar-LY\": \"Arabic (Libya)\",\n      \"ar-MA\": \"Arabic (Morocco)\",\n      \"ar-OM\": \"Arabic (Oman)\",\n      \"ar-QA\": \"Arabic (Qatar)\",\n      \"ar-SA\": \"Arabic (Saudi Arabia)\",\n      \"ar-SY\": \"Arabic (Syria)\",\n      \"ar-TN\": \"Arabic (Tunisia)\",\n      \"ar-AE\": \"Arabic (U.A.E.)\",\n      \"ar-YE\": \"Arabic (Yemen)\",\n      \"an\": \"Aragonese\",\n      \"hy\": \"Armenian\",\n      \"as\": \"Assamese\",\n      \"ast\": \"Asturian\",\n      \"az\": \"Azerbaijani\",\n      \"eu\": \"Basque\",\n      \"be\": \"Belarusian\",\n      \"bn\": \"Bengali\",\n      \"bs\": \"Bosnian\",\n      \"br\": \"Breton\",\n      \"bg\": \"Bulgarian\",\n      \"my\": \"Burmese\",\n      \"ca\": \"Catalan\",\n      \"ch\": \"Chamorro\",\n      \"ce\": \"Chechen\",\n      \"zh\": \"Chinese\",\n      \"zh-HK\": \"Chinese (Hong Kong)\",\n      \"zh-CN\": \"Chinese (PRC)\",\n      \"zh-SG\": \"Chinese (Singapore)\",\n      \"zh-TW\": \"Chinese (Taiwan)\",\n      \"cv\": \"Chuvash\",\n      \"co\": \"Corsican\",\n      \"cr\": \"Cree\",\n      \"hr\": \"Croatian\",\n      \"cs\": \"Czech\",\n      \"da\": \"Danish\",\n      \"nl\": \"Dutch (Standard)\",\n      \"nl-BE\": \"Dutch (Belgian)\",\n      \"en\": \"English\",\n      \"en-AU\": \"English (Australia)\",\n      \"en-BZ\": \"English (Belize)\",\n      \"en-CA\": \"English (Canada)\",\n      \"en-IE\": \"English (Ireland)\",\n      \"en-JM\": \"English (Jamaica)\",\n      \"en-NZ\": \"English (New Zealand)\",\n      \"en-PH\": \"English (Philippines)\",\n      \"en-ZA\": \"English (South Africa)\",\n      \"en-TT\": \"English (Trinidad & Tobago)\",\n      \"en-GB\": \"English (United Kingdom)\",\n      \"en-US\": \"English (United States)\",\n      \"en-ZW\": \"English (Zimbabwe)\",\n      \"eo\": \"Esperanto\",\n      \"et\": \"Estonian\",\n      \"fo\": \"Faeroese\",\n      \"fj\": \"Fijian\",\n      \"fi\": \"Finnish\",\n      \"fr\": \"French (Standard)\",\n      \"fr-BE\": \"French (Belgium)\",\n      \"fr-CA\": \"French (Canada)\",\n      \"fr-FR\": \"French (France)\",\n      \"fr-LU\": \"French (Luxembourg)\",\n      \"fr-MC\": \"French (Monaco)\",\n      \"fr-CH\": \"French (Switzerland)\",\n      \"fy\": \"Frisian\",\n      \"fur\": \"Friulian\",\n      \"gd\": \"Gaelic (Scots)\",\n      \"gd-IE\": \"Gaelic (Irish)\",\n      \"gl\": \"Galacian\",\n      \"ka\": \"Georgian\",\n      \"de\": \"German (Standard)\",\n      \"de-AT\": \"German (Austria)\",\n      \"de-DE\": \"German (Germany)\",\n      \"de-LI\": \"German (Liechtenstein)\",\n      \"de-LU\": \"German (Luxembourg)\",\n      \"de-CH\": \"German (Switzerland)\",\n      \"el\": \"Greek\",\n      \"gu\": \"Gujurati\",\n      \"ht\": \"Haitian\",\n      \"he\": \"Hebrew\",\n      \"hi\": \"Hindi\",\n      \"hu\": \"Hungarian\",\n      \"is\": \"Icelandic\",\n      \"id\": \"Indonesian\",\n      \"iu\": \"Inuktitut\",\n      \"ga\": \"Irish\",\n      \"it\": \"Italian (Standard)\",\n      \"it-CH\": \"Italian (Switzerland)\",\n      \"ja\": \"Japanese\",\n      \"kn\": \"Kannada\",\n      \"ks\": \"Kashmiri\",\n      \"kk\": \"Kazakh\",\n      \"km\": \"Khmer\",\n      \"ky\": \"Kirghiz\",\n      \"tlh\": \"Klingon\",\n      \"ko\": \"Korean\",\n      \"ko-KP\": \"Korean (North Korea)\",\n      \"ko-KR\": \"Korean (South Korea)\",\n      \"la\": \"Latin\",\n      \"lv\": \"Latvian\",\n      \"lt\": \"Lithuanian\",\n      \"lb\": \"Luxembourgish\",\n      \"mk\": \"FYRO Macedonian\",\n      \"ms\": \"Malay\",\n      \"ml\": \"Malayalam\",\n      \"mt\": \"Maltese\",\n      \"mi\": \"Maori\",\n      \"mr\": \"Marathi\",\n      \"mo\": \"Moldavian\",\n      \"nv\": \"Navajo\",\n      \"ng\": \"Ndonga\",\n      \"ne\": \"Nepali\",\n      \"no\": \"Norwegian\",\n      \"nb\": \"Norwegian (Bokmal)\",\n      \"nn\": \"Norwegian (Nynorsk)\",\n      \"oc\": \"Occitan\",\n      \"or\": \"Oriya\",\n      \"om\": \"Oromo\",\n      \"fa\": \"Persian\",\n      \"fa-IR\": \"Persian/Iran\",\n      \"pl\": \"Polish\",\n      \"pt\": \"Portuguese\",\n      \"pt-BR\": \"Portuguese (Brazil)\",\n      \"pa\": \"Punjabi\",\n      \"pa-IN\": \"Punjabi (India)\",\n      \"pa-PK\": \"Punjabi (Pakistan)\",\n      \"qu\": \"Quechua\",\n      \"rm\": \"Rhaeto-Romanic\",\n      \"ro\": \"Romanian\",\n      \"ro-MO\": \"Romanian (Moldavia)\",\n      \"ru\": \"Russian\",\n      \"ru-MO\": \"Russian (Moldavia)\",\n      \"sz\": \"Sami (Lappish)\",\n      \"sg\": \"Sango\",\n      \"sa\": \"Sanskrit\",\n      \"sc\": \"Sardinian\",\n      \"sd\": \"Sindhi\",\n      \"si\": \"Singhalese\",\n      \"sr\": \"Serbian\",\n      \"sk\": \"Slovak\",\n      \"sl\": \"Slovenian\",\n      \"so\": \"Somani\",\n      \"sb\": \"Sorbian\",\n      \"es\": \"Spanish\",\n      \"es-AR\": \"Spanish (Argentina)\",\n      \"es-BO\": \"Spanish (Bolivia)\",\n      \"es-CL\": \"Spanish (Chile)\",\n      \"es-CO\": \"Spanish (Colombia)\",\n      \"es-CR\": \"Spanish (Costa Rica)\",\n      \"es-DO\": \"Spanish (Dominican Republic)\",\n      \"es-EC\": \"Spanish (Ecuador)\",\n      \"es-SV\": \"Spanish (El Salvador)\",\n      \"es-GT\": \"Spanish (Guatemala)\",\n      \"es-HN\": \"Spanish (Honduras)\",\n      \"es-MX\": \"Spanish (Mexico)\",\n      \"es-NI\": \"Spanish (Nicaragua)\",\n      \"es-PA\": \"Spanish (Panama)\",\n      \"es-PY\": \"Spanish (Paraguay)\",\n      \"es-PE\": \"Spanish (Peru)\",\n      \"es-PR\": \"Spanish (Puerto Rico)\",\n      \"es-ES\": \"Spanish (Spain)\",\n      \"es-UY\": \"Spanish (Uruguay)\",\n      \"es-VE\": \"Spanish (Venezuela)\",\n      \"sx\": \"Sutu\",\n      \"sw\": \"Swahili\",\n      \"sv\": \"Swedish\",\n      \"sv-FI\": \"Swedish (Finland)\",\n      \"sv-SV\": \"Swedish (Sweden)\",\n      \"ta\": \"Tamil\",\n      \"tt\": \"Tatar\",\n      \"te\": \"Teluga\",\n      \"th\": \"Thai\",\n      \"tig\": \"Tigre\",\n      \"ts\": \"Tsonga\",\n      \"tn\": \"Tswana\",\n      \"tr\": \"Turkish\",\n      \"tk\": \"Turkmen\",\n      \"uk\": \"Ukrainian\",\n      \"hsb\": \"Upper Sorbian\",\n      \"ur\": \"Urdu\",\n      \"ve\": \"Venda\",\n      \"vi\": \"Vietnamese\",\n      \"vo\": \"Volapuk\",\n      \"wa\": \"Walloon\",\n      \"cy\": \"Welsh\",\n      \"xh\": \"Xhosa\",\n      \"ji\": \"Yiddish\",\n      \"zu\": \"Zulu\"\n    };\n\n    if (this.internal.languageSettings === undefined) {\n      this.internal.languageSettings = {};\n      this.internal.languageSettings.isSubscribed = false;\n    }\n\n    if (langCodes[langCode] !== undefined) {\n      this.internal.languageSettings.languageCode = langCode;\n\n      if (this.internal.languageSettings.isSubscribed === false) {\n        this.internal.events.subscribe(\"putCatalog\", function () {\n          this.internal.write(\"/Lang (\" + this.internal.languageSettings.languageCode + \")\");\n        });\n        this.internal.languageSettings.isSubscribed = true;\n      }\n    }\n\n    return this;\n  };\n})(jsPDF.API);\n\n/** @license\n * MIT license.\n * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com\n *               2014 Diego Casorran, https://github.com/diegocr\n *\n * \n * ====================================================================\n */\n\n/**\n* jsPDF split_text_to_size plugin \n* \n* @name split_text_to_size\n* @module\n*/\n(function (API) {\n  /**\n   * Returns an array of length matching length of the 'word' string, with each\n   * cell occupied by the width of the char in that position.\n   * \n   * @name getCharWidthsArray\n   * @function\n   * @param {string} text\n   * @param {Object} options\n   * @returns {Array}\n   */\n\n  var getCharWidthsArray = API.getCharWidthsArray = function (text, options) {\n    options = options || {};\n    var activeFont = options.font || this.internal.getFont();\n    var fontSize = options.fontSize || this.internal.getFontSize();\n    var charSpace = options.charSpace || this.internal.getCharSpace();\n    var widths = options.widths ? options.widths : activeFont.metadata.Unicode.widths;\n    var widthsFractionOf = widths.fof ? widths.fof : 1;\n    var kerning = options.kerning ? options.kerning : activeFont.metadata.Unicode.kerning;\n    var kerningFractionOf = kerning.fof ? kerning.fof : 1;\n    var i;\n    var l;\n    var char_code;\n    var prior_char_code = 0; //for kerning\n\n    var default_char_width = widths[0] || widthsFractionOf;\n    var output = [];\n\n    for (i = 0, l = text.length; i < l; i++) {\n      char_code = text.charCodeAt(i);\n\n      if (typeof activeFont.metadata.widthOfString === \"function\") {\n        output.push((activeFont.metadata.widthOfGlyph(activeFont.metadata.characterToGlyph(char_code)) + charSpace * (1000 / fontSize) || 0) / 1000);\n      } else {\n        output.push((widths[char_code] || default_char_width) / widthsFractionOf + (kerning[char_code] && kerning[char_code][prior_char_code] || 0) / kerningFractionOf);\n      }\n\n      prior_char_code = char_code;\n    }\n\n    return output;\n  };\n  /**\n   * Calculate the sum of a number-array\n   * \n   * @name getArraySum\n   * @public\n   * @function\n   * @param {Array} array Array of numbers\n   * @returns {number}\n   */\n\n\n  var getArraySum = API.getArraySum = function (array) {\n    var i = array.length,\n        output = 0;\n\n    while (i) {\n      i--;\n      output += array[i];\n    }\n\n    return output;\n  };\n  /**\n  * Returns a widths of string in a given font, if the font size is set as 1 point.\n  *\n  * In other words, this is \"proportional\" value. For 1 unit of font size, the length\n  * of the string will be that much.\n  * \n  * Multiply by font size to get actual width in *points*\n  * Then divide by 72 to get inches or divide by (72/25.6) to get 'mm' etc.\n  * \n  * @name getStringUnitWidth\n  * @public\n  * @function\n  * @param {string} text\n  * @param {string} options\n  * @returns {number} result\n  */\n\n\n  var getStringUnitWidth = API.getStringUnitWidth = function (text, options) {\n    options = options || {};\n    var fontSize = options.fontSize || this.internal.getFontSize();\n    var font = options.font || this.internal.getFont();\n    var charSpace = options.charSpace || this.internal.getCharSpace();\n    var result = 0;\n\n    if (typeof font.metadata.widthOfString === \"function\") {\n      result = font.metadata.widthOfString(text, fontSize, charSpace) / fontSize;\n    } else {\n      result = getArraySum(getCharWidthsArray.apply(this, arguments));\n    }\n\n    return result;\n  };\n  /**\n  returns array of lines\n  */\n\n\n  var splitLongWord = function splitLongWord(word, widths_array, firstLineMaxLen, maxLen) {\n    var answer = []; // 1st, chop off the piece that can fit on the hanging line.\n\n    var i = 0,\n        l = word.length,\n        workingLen = 0;\n\n    while (i !== l && workingLen + widths_array[i] < firstLineMaxLen) {\n      workingLen += widths_array[i];\n      i++;\n    } // this is first line.\n\n\n    answer.push(word.slice(0, i)); // 2nd. Split the rest into maxLen pieces.\n\n    var startOfLine = i;\n    workingLen = 0;\n\n    while (i !== l) {\n      if (workingLen + widths_array[i] > maxLen) {\n        answer.push(word.slice(startOfLine, i));\n        workingLen = 0;\n        startOfLine = i;\n      }\n\n      workingLen += widths_array[i];\n      i++;\n    }\n\n    if (startOfLine !== i) {\n      answer.push(word.slice(startOfLine, i));\n    }\n\n    return answer;\n  }; // Note, all sizing inputs for this function must be in \"font measurement units\"\n  // By default, for PDF, it's \"point\".\n\n\n  var splitParagraphIntoLines = function splitParagraphIntoLines(text, maxlen, options) {\n    // at this time works only on Western scripts, ones with space char\n    // separating the words. Feel free to expand.\n    if (!options) {\n      options = {};\n    }\n\n    var line = [],\n        lines = [line],\n        line_length = options.textIndent || 0,\n        separator_length = 0,\n        current_word_length = 0,\n        word,\n        widths_array,\n        words = text.split(' '),\n        spaceCharWidth = getCharWidthsArray.apply(this, [' ', options])[0],\n        i,\n        l,\n        tmp,\n        lineIndent;\n\n    if (options.lineIndent === -1) {\n      lineIndent = words[0].length + 2;\n    } else {\n      lineIndent = options.lineIndent || 0;\n    }\n\n    if (lineIndent) {\n      var pad = Array(lineIndent).join(\" \"),\n          wrds = [];\n      words.map(function (wrd) {\n        wrd = wrd.split(/\\s*\\n/);\n\n        if (wrd.length > 1) {\n          wrds = wrds.concat(wrd.map(function (wrd, idx) {\n            return (idx && wrd.length ? \"\\n\" : \"\") + wrd;\n          }));\n        } else {\n          wrds.push(wrd[0]);\n        }\n      });\n      words = wrds;\n      lineIndent = getStringUnitWidth.apply(this, [pad, options]);\n    }\n\n    for (i = 0, l = words.length; i < l; i++) {\n      var force = 0;\n      word = words[i];\n\n      if (lineIndent && word[0] == \"\\n\") {\n        word = word.substr(1);\n        force = 1;\n      }\n\n      widths_array = getCharWidthsArray.apply(this, [word, options]);\n      current_word_length = getArraySum(widths_array);\n\n      if (line_length + separator_length + current_word_length > maxlen || force) {\n        if (current_word_length > maxlen) {\n          // this happens when you have space-less long URLs for example.\n          // we just chop these to size. We do NOT insert hiphens\n          tmp = splitLongWord.apply(this, [word, widths_array, maxlen - (line_length + separator_length), maxlen]); // first line we add to existing line object\n\n          line.push(tmp.shift()); // it's ok to have extra space indicator there\n          // last line we make into new line object\n\n          line = [tmp.pop()]; // lines in the middle we apped to lines object as whole lines\n\n          while (tmp.length) {\n            lines.push([tmp.shift()]); // single fragment occupies whole line\n          }\n\n          current_word_length = getArraySum(widths_array.slice(word.length - (line[0] ? line[0].length : 0)));\n        } else {\n          // just put it on a new line\n          line = [word];\n        } // now we attach new line to lines\n\n\n        lines.push(line);\n        line_length = current_word_length + lineIndent;\n        separator_length = spaceCharWidth;\n      } else {\n        line.push(word);\n        line_length += separator_length + current_word_length;\n        separator_length = spaceCharWidth;\n      }\n    }\n\n    if (lineIndent) {\n      var postProcess = function postProcess(ln, idx) {\n        return (idx ? pad : '') + ln.join(\" \");\n      };\n    } else {\n      var postProcess = function postProcess(ln) {\n        return ln.join(\" \");\n      };\n    }\n\n    return lines.map(postProcess);\n  };\n  /**\n  * Splits a given string into an array of strings. Uses 'size' value\n  * (in measurement units declared as default for the jsPDF instance)\n  * and the font's \"widths\" and \"Kerning\" tables, where available, to\n  * determine display length of a given string for a given font.\n  * \n  * We use character's 100% of unit size (height) as width when Width\n  * table or other default width is not available.\n  * \n  * @name splitTextToSize\n  * @public\n  * @function\n  * @param {string} text Unencoded, regular JavaScript (Unicode, UTF-16 / UCS-2) string.\n  * @param {number} size Nominal number, measured in units default to this instance of jsPDF.\n  * @param {Object} options Optional flags needed for chopper to do the right thing.\n  * @returns {Array} array Array with strings chopped to size.\n  */\n\n\n  API.splitTextToSize = function (text, maxlen, options) {\n\n    options = options || {};\n\n    var fsize = options.fontSize || this.internal.getFontSize(),\n        newOptions = function (options) {\n      var widths = {\n        0: 1\n      },\n          kerning = {};\n\n      if (!options.widths || !options.kerning) {\n        var f = this.internal.getFont(options.fontName, options.fontStyle),\n            encoding = 'Unicode'; // NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE\n        // Actual JavaScript-native String's 16bit char codes used.\n        // no multi-byte logic here\n\n        if (f.metadata[encoding]) {\n          return {\n            widths: f.metadata[encoding].widths || widths,\n            kerning: f.metadata[encoding].kerning || kerning\n          };\n        } else {\n          return {\n            font: f.metadata,\n            fontSize: this.internal.getFontSize(),\n            charSpace: this.internal.getCharSpace()\n          };\n        }\n      } else {\n        return {\n          widths: options.widths,\n          kerning: options.kerning\n        };\n      } // then use default values\n\n\n      return {\n        widths: widths,\n        kerning: kerning\n      };\n    }.call(this, options); // first we split on end-of-line chars\n\n\n    var paragraphs;\n\n    if (Array.isArray(text)) {\n      paragraphs = text;\n    } else {\n      paragraphs = text.split(/\\r?\\n/);\n    } // now we convert size (max length of line) into \"font size units\"\n    // at present time, the \"font size unit\" is always 'point'\n    // 'proportional' means, \"in proportion to font size\"\n\n\n    var fontUnit_maxLen = 1.0 * this.internal.scaleFactor * maxlen / fsize; // at this time, fsize is always in \"points\" regardless of the default measurement unit of the doc.\n    // this may change in the future?\n    // until then, proportional_maxlen is likely to be in 'points'\n    // If first line is to be indented (shorter or longer) than maxLen\n    // we indicate that by using CSS-style \"text-indent\" option.\n    // here it's in font units too (which is likely 'points')\n    // it can be negative (which makes the first line longer than maxLen)\n\n    newOptions.textIndent = options.textIndent ? options.textIndent * 1.0 * this.internal.scaleFactor / fsize : 0;\n    newOptions.lineIndent = options.lineIndent;\n    var i,\n        l,\n        output = [];\n\n    for (i = 0, l = paragraphs.length; i < l; i++) {\n      output = output.concat(splitParagraphIntoLines.apply(this, [paragraphs[i], fontUnit_maxLen, newOptions]));\n    }\n\n    return output;\n  };\n})(jsPDF.API);\n\n/** @license\n jsPDF standard_fonts_metrics plugin\n * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com\n * MIT license.\n * \n * ====================================================================\n */\n\n(function (API) {\n  /*\n  # reference (Python) versions of 'compress' and 'uncompress'\n  # only 'uncompress' function is featured lower as JavaScript\n  # if you want to unit test \"roundtrip\", just transcribe the reference\n  # 'compress' function from Python into JavaScript\n  \n  def compress(data):\n  \n  \tkeys =   '0123456789abcdef'\n  \tvalues = 'klmnopqrstuvwxyz'\n  \tmapping = dict(zip(keys, values))\n  \tvals = []\n  \tfor key in data.keys():\n  \t\tvalue = data[key]\n  \t\ttry:\n  \t\t\tkeystring = hex(key)[2:]\n  \t\t\tkeystring = keystring[:-1] + mapping[keystring[-1:]]\n  \t\texcept:\n  \t\t\tkeystring = key.join([\"'\",\"'\"])\n  \t\t\t#print('Keystring is %s' % keystring)\n  \n  \t\ttry:\n  \t\t\tif value < 0:\n  \t\t\t\tvaluestring = hex(value)[3:]\n  \t\t\t\tnumberprefix = '-'\n  \t\t\telse:\n  \t\t\t\tvaluestring = hex(value)[2:]\n  \t\t\t\tnumberprefix = ''\n  \t\t\tvaluestring = numberprefix + valuestring[:-1] + mapping[valuestring[-1:]]\n  \t\texcept:\n  \t\t\tif type(value) == dict:\n  \t\t\t\tvaluestring = compress(value)\n  \t\t\telse:\n  \t\t\t\traise Exception(\"Don't know what to do with value type %s\" % type(value))\n  \n  \t\tvals.append(keystring+valuestring)\n  \t\n  \treturn '{' + ''.join(vals) + '}'\n  \n  def uncompress(data):\n  \n  \tdecoded = '0123456789abcdef'\n  \tencoded = 'klmnopqrstuvwxyz'\n  \tmapping = dict(zip(encoded, decoded))\n  \n  \tsign = +1\n  \tstringmode = False\n  \tstringparts = []\n  \n  \toutput = {}\n  \n  \tactiveobject = output\n  \tparentchain = []\n  \n  \tkeyparts = ''\n  \tvalueparts = ''\n  \n  \tkey = None\n  \n  \tending = set(encoded)\n  \n  \ti = 1\n  \tl = len(data) - 1 # stripping starting, ending {}\n  \twhile i != l: # stripping {}\n  \t\t# -, {, }, ' are special.\n  \n  \t\tch = data[i]\n  \t\ti += 1\n  \n  \t\tif ch == \"'\":\n  \t\t\tif stringmode:\n  \t\t\t\t# end of string mode\n  \t\t\t\tstringmode = False\n  \t\t\t\tkey = ''.join(stringparts)\n  \t\t\telse:\n  \t\t\t\t# start of string mode\n  \t\t\t\tstringmode = True\n  \t\t\t\tstringparts = []\n  \t\telif stringmode == True:\n  \t\t\t#print(\"Adding %s to stringpart\" % ch)\n  \t\t\tstringparts.append(ch)\n  \n  \t\telif ch == '{':\n  \t\t\t# start of object\n  \t\t\tparentchain.append( [activeobject, key] )\n  \t\t\tactiveobject = {}\n  \t\t\tkey = None\n  \t\t\t#DEBUG = True\n  \t\telif ch == '}':\n  \t\t\t# end of object\n  \t\t\tparent, key = parentchain.pop()\n  \t\t\tparent[key] = activeobject\n  \t\t\tkey = None\n  \t\t\tactiveobject = parent\n  \t\t\t#DEBUG = False\n  \n  \t\telif ch == '-':\n  \t\t\tsign = -1\n  \t\telse:\n  \t\t\t# must be number\n  \t\t\tif key == None:\n  \t\t\t\t#debug(\"In Key. It is '%s', ch is '%s'\" % (keyparts, ch))\n  \t\t\t\tif ch in ending:\n  \t\t\t\t\t#debug(\"End of key\")\n  \t\t\t\t\tkeyparts += mapping[ch]\n  \t\t\t\t\tkey = int(keyparts, 16) * sign\n  \t\t\t\t\tsign = +1\n  \t\t\t\t\tkeyparts = ''\n  \t\t\t\telse:\n  \t\t\t\t\tkeyparts += ch\n  \t\t\telse:\n  \t\t\t\t#debug(\"In value. It is '%s', ch is '%s'\" % (valueparts, ch))\n  \t\t\t\tif ch in ending:\n  \t\t\t\t\t#debug(\"End of value\")\n  \t\t\t\t\tvalueparts += mapping[ch]\n  \t\t\t\t\tactiveobject[key] = int(valueparts, 16) * sign\n  \t\t\t\t\tsign = +1\n  \t\t\t\t\tkey = None\n  \t\t\t\t\tvalueparts = ''\n  \t\t\t\telse:\n  \t\t\t\t\tvalueparts += ch\n  \n  \t\t\t#debug(activeobject)\n  \n  \treturn output\n  \n  */\n\n  /**\n  Uncompresses data compressed into custom, base16-like format. \n  @public\n  @function\n  @param\n  @returns {Type}\n  */\n\n  var uncompress = function uncompress(data) {\n    var decoded = '0123456789abcdef',\n        encoded = 'klmnopqrstuvwxyz',\n        mapping = {};\n\n    for (var i = 0; i < encoded.length; i++) {\n      mapping[encoded[i]] = decoded[i];\n    }\n\n    var undef,\n        output = {},\n        sign = 1,\n        stringparts // undef. will be [] in string mode\n    ,\n        activeobject = output,\n        parentchain = [],\n        parent_key_pair,\n        keyparts = '',\n        valueparts = '',\n        key // undef. will be Truthy when Key is resolved.\n    ,\n        datalen = data.length - 1 // stripping ending }\n    ,\n        ch;\n    i = 1; // stripping starting {\n\n    while (i != datalen) {\n      // - { } ' are special.\n      ch = data[i];\n      i += 1;\n\n      if (ch == \"'\") {\n        if (stringparts) {\n          // end of string mode\n          key = stringparts.join('');\n          stringparts = undef;\n        } else {\n          // start of string mode\n          stringparts = [];\n        }\n      } else if (stringparts) {\n        stringparts.push(ch);\n      } else if (ch == '{') {\n        // start of object\n        parentchain.push([activeobject, key]);\n        activeobject = {};\n        key = undef;\n      } else if (ch == '}') {\n        // end of object\n        parent_key_pair = parentchain.pop();\n        parent_key_pair[0][parent_key_pair[1]] = activeobject;\n        key = undef;\n        activeobject = parent_key_pair[0];\n      } else if (ch == '-') {\n        sign = -1;\n      } else {\n        // must be number\n        if (key === undef) {\n          if (mapping.hasOwnProperty(ch)) {\n            keyparts += mapping[ch];\n            key = parseInt(keyparts, 16) * sign;\n            sign = +1;\n            keyparts = '';\n          } else {\n            keyparts += ch;\n          }\n        } else {\n          if (mapping.hasOwnProperty(ch)) {\n            valueparts += mapping[ch];\n            activeobject[key] = parseInt(valueparts, 16) * sign;\n            sign = +1;\n            key = undef;\n            valueparts = '';\n          } else {\n            valueparts += ch;\n          }\n        }\n      }\n    } // end while\n\n\n    return output;\n  }; // encoding = 'Unicode' \n  // NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE. NO clever BOM behavior\n  // Actual 16bit char codes used.\n  // no multi-byte logic here\n  // Unicode characters to WinAnsiEncoding:\n  // {402: 131, 8211: 150, 8212: 151, 8216: 145, 8217: 146, 8218: 130, 8220: 147, 8221: 148, 8222: 132, 8224: 134, 8225: 135, 8226: 149, 8230: 133, 8364: 128, 8240:137, 8249: 139, 8250: 155, 710: 136, 8482: 153, 338: 140, 339: 156, 732: 152, 352: 138, 353: 154, 376: 159, 381: 142, 382: 158}\n  // as you can see, all Unicode chars are outside of 0-255 range. No char code conflicts.\n  // this means that you can give Win cp1252 encoded strings to jsPDF for rendering directly\n  // as well as give strings with some (supported by these fonts) Unicode characters and \n  // these will be mapped to win cp1252 \n  // for example, you can send char code (cp1252) 0x80 or (unicode) 0x20AC, getting \"Euro\" glyph displayed in both cases.\n\n\n  var encodingBlock = {\n    'codePages': ['WinAnsiEncoding'],\n    'WinAnsiEncoding': uncompress(\"{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}\")\n  },\n      encodings = {\n    'Unicode': {\n      'Courier': encodingBlock,\n      'Courier-Bold': encodingBlock,\n      'Courier-BoldOblique': encodingBlock,\n      'Courier-Oblique': encodingBlock,\n      'Helvetica': encodingBlock,\n      'Helvetica-Bold': encodingBlock,\n      'Helvetica-BoldOblique': encodingBlock,\n      'Helvetica-Oblique': encodingBlock,\n      'Times-Roman': encodingBlock,\n      'Times-Bold': encodingBlock,\n      'Times-BoldItalic': encodingBlock,\n      'Times-Italic': encodingBlock //\t, 'Symbol'\n      //\t, 'ZapfDingbats'\n\n    }\n  },\n      fontMetrics = {\n    'Unicode': {\n      // all sizing numbers are n/fontMetricsFractionOf = one font size unit\n      // this means that if fontMetricsFractionOf = 1000, and letter A's width is 476, it's\n      // width is 476/1000 or 47.6% of its height (regardless of font size)\n      // At this time this value applies to \"widths\" and \"kerning\" numbers.\n      // char code 0 represents \"default\" (average) width - use it for chars missing in this table.\n      // key 'fof' represents the \"fontMetricsFractionOf\" value\n      'Courier-Oblique': uncompress(\"{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}\"),\n      'Times-BoldItalic': uncompress(\"{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}\"),\n      'Helvetica-Bold': uncompress(\"{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}\"),\n      'Courier': uncompress(\"{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}\"),\n      'Courier-BoldOblique': uncompress(\"{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}\"),\n      'Times-Bold': uncompress(\"{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}\"),\n      'Symbol': uncompress(\"{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}\"),\n      'Helvetica': uncompress(\"{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}\"),\n      'Helvetica-BoldOblique': uncompress(\"{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}\"),\n      'ZapfDingbats': uncompress(\"{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}\"),\n      'Courier-Bold': uncompress(\"{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}\"),\n      'Times-Italic': uncompress(\"{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}\"),\n      'Times-Roman': uncompress(\"{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}\"),\n      'Helvetica-Oblique': uncompress(\"{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}\")\n    }\n  };\n  /*\n  This event handler is fired when a new jsPDF object is initialized\n  This event handler appends metrics data to standard fonts within\n  that jsPDF instance. The metrics are mapped over Unicode character\n  codes, NOT CIDs or other codes matching the StandardEncoding table of the\n  standard PDF fonts.\n  Future:\n  Also included is the encoding maping table, converting Unicode (UCS-2, UTF-16)\n  char codes to StandardEncoding character codes. The encoding table is to be used\n  somewhere around \"pdfEscape\" call.\n  */\n\n  API.events.push(['addFont', function (data) {\n    var font = data.font;\n    var metrics,\n        unicode_section,\n        encoding = 'Unicode',\n        encodingBlock;\n    metrics = fontMetrics[encoding][font.postScriptName];\n\n    if (metrics) {\n      if (font.metadata[encoding]) {\n        unicode_section = font.metadata[encoding];\n      } else {\n        unicode_section = font.metadata[encoding] = {};\n      }\n\n      unicode_section.widths = metrics.widths;\n      unicode_section.kerning = metrics.kerning;\n    }\n\n    encodingBlock = encodings[encoding][font.postScriptName];\n\n    if (encodingBlock) {\n      if (font.metadata[encoding]) {\n        unicode_section = font.metadata[encoding];\n      } else {\n        unicode_section = font.metadata[encoding] = {};\n      }\n\n      unicode_section.encoding = encodingBlock;\n\n      if (encodingBlock.codePages && encodingBlock.codePages.length) {\n        font.encoding = encodingBlock.codePages[0];\n      }\n    }\n  }]); // end of adding event handler\n})(jsPDF.API);\n\n/**\n * @license\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n* @name ttfsupport\n* @module\n*/\n(function (jsPDF, global) {\n\n  jsPDF.API.events.push(['addFont', function (data) {\n    var font = data.font;\n    var instance = data.instance;\n\n    if (typeof instance !== \"undefined\" && instance.existsFileInVFS(font.postScriptName)) {\n      var file = instance.getFileFromVFS(font.postScriptName);\n\n      if (typeof file !== \"string\") {\n        throw new Error(\"Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('\" + font.postScriptName + \"').\");\n      }\n\n      font.metadata = jsPDF.API.TTFFont.open(font.postScriptName, font.fontName, file, font.encoding);\n      font.metadata.Unicode = font.metadata.Unicode || {\n        encoding: {},\n        kerning: {},\n        widths: []\n      };\n      font.metadata.glyIdsUsed = [0];\n    } else if (font.isStandardFont === false) {\n      throw new Error(\"Font does not exist in vFS, import fonts or remove declaration doc.addFont('\" + font.postScriptName + \"').\");\n    }\n  }]); // end of adding event handler\n})(jsPDF, typeof self !== \"undefined\" && self || typeof global !== \"undefined\" && global || typeof window !== \"undefined\" && window || Function(\"return this\")());\n\n/** @license\n * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com\n * \n * \n * ====================================================================\n */\n\n(function (jsPDFAPI) {\n  /**\n  * Parses SVG XML and converts only some of the SVG elements into\n  * PDF elements.\n  *\n  * Supports:\n  * paths\n  * \n  * @name addSvg\n  * @public\n  * @function \n  * @param {string} SVG-Data as Text\n  * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page\n  * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n  * @param {number} width of SVG (in units declared at inception of PDF document)\n  * @param {number} height of SVG (in units declared at inception of PDF document)\n  * @returns {Object} jsPDF-instance\n  */\n\n  jsPDFAPI.addSvg = function (svgtext, x, y, w, h) {\n    // 'this' is _jsPDF object returned when jsPDF is inited (new jsPDF())\n    var undef;\n\n    if (x === undef || y === undef) {\n      throw new Error(\"addSVG needs values for 'x' and 'y'\");\n    }\n\n    function InjectCSS(cssbody, document) {\n      var styletag = document.createElement('style');\n      styletag.type = 'text/css';\n\n      if (styletag.styleSheet) {\n        // ie\n        styletag.styleSheet.cssText = cssbody;\n      } else {\n        // others\n        styletag.appendChild(document.createTextNode(cssbody));\n      }\n\n      document.getElementsByTagName(\"head\")[0].appendChild(styletag);\n    }\n\n    function createWorkerNode(document) {\n      var frameID = 'childframe' // Date.now().toString() + '_' + (Math.random() * 100).toString()\n      ,\n          frame = document.createElement('iframe');\n      InjectCSS('.jsPDF_sillysvg_iframe {display:none;position:absolute;}', document);\n      frame.name = frameID;\n      frame.setAttribute(\"width\", 0);\n      frame.setAttribute(\"height\", 0);\n      frame.setAttribute(\"frameborder\", \"0\");\n      frame.setAttribute(\"scrolling\", \"no\");\n      frame.setAttribute(\"seamless\", \"seamless\");\n      frame.setAttribute(\"class\", \"jsPDF_sillysvg_iframe\");\n      document.body.appendChild(frame);\n      return frame;\n    }\n\n    function attachSVGToWorkerNode(svgtext, frame) {\n      var framedoc = (frame.contentWindow || frame.contentDocument).document;\n      framedoc.write(svgtext);\n      framedoc.close();\n      return framedoc.getElementsByTagName('svg')[0];\n    }\n\n    function convertPathToPDFLinesArgs(path) {\n      // - starting coordinate pair\n      // - array of arrays of vector shifts (2-len for line, 6 len for bezier)\n      // - scale array [horizontal, vertical] ratios\n      // - style (stroke, fill, both)\n\n      var x = parseFloat(path[1]),\n          y = parseFloat(path[2]),\n          vectors = [],\n          position = 3,\n          len = path.length;\n\n      while (position < len) {\n        if (path[position] === 'c') {\n          vectors.push([parseFloat(path[position + 1]), parseFloat(path[position + 2]), parseFloat(path[position + 3]), parseFloat(path[position + 4]), parseFloat(path[position + 5]), parseFloat(path[position + 6])]);\n          position += 7;\n        } else if (path[position] === 'l') {\n          vectors.push([parseFloat(path[position + 1]), parseFloat(path[position + 2])]);\n          position += 3;\n        } else {\n          position += 1;\n        }\n      }\n\n      return [x, y, vectors];\n    }\n\n    var workernode = createWorkerNode(document),\n        svgnode = attachSVGToWorkerNode(svgtext, workernode),\n        scale = [1, 1],\n        svgw = parseFloat(svgnode.getAttribute('width')),\n        svgh = parseFloat(svgnode.getAttribute('height'));\n\n    if (svgw && svgh) {\n      // setting both w and h makes image stretch to size.\n      // this may distort the image, but fits your demanded size\n      if (w && h) {\n        scale = [w / svgw, h / svgh];\n      } // if only one is set, that value is set as max and SVG\n      // is scaled proportionately.\n      else if (w) {\n          scale = [w / svgw, w / svgw];\n        } else if (h) {\n          scale = [h / svgh, h / svgh];\n        }\n    }\n\n    var i,\n        l,\n        tmp,\n        linesargs,\n        items = svgnode.childNodes;\n\n    for (i = 0, l = items.length; i < l; i++) {\n      tmp = items[i];\n\n      if (tmp.tagName && tmp.tagName.toUpperCase() === 'PATH') {\n        linesargs = convertPathToPDFLinesArgs(tmp.getAttribute(\"d\").split(' ')); // path start x coordinate\n\n        linesargs[0] = linesargs[0] * scale[0] + x; // where x is upper left X of image\n        // path start y coordinate\n\n        linesargs[1] = linesargs[1] * scale[1] + y; // where y is upper left Y of image\n        // the rest of lines are vectors. these will adjust with scale value auto.\n\n        this.lines.call(this, linesargs[2] // lines\n        , linesargs[0] // starting x\n        , linesargs[1] // starting y\n        , scale);\n      }\n    } // clean up\n    // workernode.parentNode.removeChild(workernode)\n\n\n    return this;\n  }; //fallback\n\n\n  jsPDFAPI.addSVG = jsPDFAPI.addSvg;\n  /**\n  * Parses SVG XML and saves it as image into the PDF.\n  *\n  * Depends on canvas-element and canvg\n  *\n  * @name addSvgAsImage\n  * @public\n  * @function\n  * @param {string} SVG-Data as Text\n  * @param {number} x Coordinate (in units declared at inception of PDF document) against left edge of the page\n  * @param {number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n  * @param {number} width of SVG-Image (in units declared at inception of PDF document)\n  * @param {number} height of SVG-Image (in units declared at inception of PDF document)\n  * @param {string} alias of SVG-Image (if used multiple times)\n  * @param {string} compression of the generated JPEG, can have the values 'NONE', 'FAST', 'MEDIUM' and 'SLOW'\n  * @param {number} rotation of the image in degrees (0-359)\n  * \n  * @returns jsPDF jsPDF-instance\n  */\n\n  jsPDFAPI.addSvgAsImage = function (svg, x, y, w, h, alias, compression, rotation) {\n    if (isNaN(x) || isNaN(y)) {\n      console.error('jsPDF.addSvgAsImage: Invalid coordinates', arguments);\n      throw new Error('Invalid coordinates passed to jsPDF.addSvgAsImage');\n    }\n\n    if (isNaN(w) || isNaN(h)) {\n      console.error('jsPDF.addSvgAsImage: Invalid measurements', arguments);\n      throw new Error('Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage');\n    }\n\n    var canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h;\n    var ctx = canvas.getContext('2d');\n    ctx.fillStyle = '#fff'; /// set white fill style\n\n    ctx.fillRect(0, 0, canvas.width, canvas.height); //load a svg snippet in the canvas with id = 'drawingArea'\n\n    canvg(canvas, svg, {\n      ignoreMouse: true,\n      ignoreAnimation: true,\n      ignoreDimensions: true,\n      ignoreClear: true\n    });\n    this.addImage(canvas.toDataURL(\"image/jpeg\", 1.0), x, y, w, h, compression, rotation);\n    return this;\n  };\n})(jsPDF.API);\n\n/** \n * @license\n * ==================================================================== \n * Copyright (c) 2013 Eduardo Menezes de Morais, eduardo.morais@usp.br\n * \n * \n * ====================================================================\n */\n\n/**\n * jsPDF total_pages plugin\n * @name total_pages\n * @module\n */\n(function (jsPDFAPI) {\n  /**\n  * @name putTotalPages\n  * @function\n  * @param {string} pageExpression Regular Expression\n  * @returns {jsPDF} jsPDF-instance\n  */\n\n  jsPDFAPI.putTotalPages = function (pageExpression) {\n\n    var replaceExpression;\n    var totalNumberOfPages = 0;\n\n    if (parseInt(this.internal.getFont().id.substr(1), 10) < 15) {\n      replaceExpression = new RegExp(pageExpression, 'g');\n      totalNumberOfPages = this.internal.getNumberOfPages();\n    } else {\n      replaceExpression = new RegExp(this.pdfEscape16(pageExpression, this.internal.getFont()), 'g');\n      totalNumberOfPages = this.pdfEscape16(this.internal.getNumberOfPages() + '', this.internal.getFont());\n    }\n\n    for (var n = 1; n <= this.internal.getNumberOfPages(); n++) {\n      for (var i = 0; i < this.internal.pages[n].length; i++) {\n        this.internal.pages[n][i] = this.internal.pages[n][i].replace(replaceExpression, totalNumberOfPages);\n      }\n    }\n\n    return this;\n  };\n})(jsPDF.API);\n\n/**\n * jsPDF viewerPreferences Plugin\n * @author Aras Abbasi (github.com/arasabbasi)\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n* Adds the ability to set ViewerPreferences and by thus\n* controlling the way the document is to be presented on the\n* screen or in print.\n* @name viewerpreferences\n* @module\n*/\n(function (jsPDFAPI) {\n  /**\n   * Set the ViewerPreferences of the generated PDF\n   *\n   * @name viewerPreferences\n  * @function\n  * @public\n   * @param {Object} options Array with the ViewerPreferences<br />\n   * Example: doc.viewerPreferences({\"FitWindow\":true});<br />\n   * <br />\n   * You can set following preferences:<br />\n   * <br/>\n   * <b>HideToolbar</b> <i>(boolean)</i><br />\n   * Default value: false<br />\n   * <br />\n   * <b>HideMenubar</b> <i>(boolean)</i><br />\n   * Default value: false.<br />\n   * <br />\n   * <b>HideWindowUI</b> <i>(boolean)</i><br />\n   * Default value: false.<br />\n   * <br />\n   * <b>FitWindow</b> <i>(boolean)</i><br />\n   * Default value: false.<br />\n   * <br />\n   * <b>CenterWindow</b> <i>(boolean)</i><br />\n   * Default value: false<br />\n   * <br />\n   * <b>DisplayDocTitle</b> <i>(boolean)</i><br />\n   * Default value: false.<br />\n   * <br />\n   * <b>NonFullScreenPageMode</b> <i>(string)</i><br />\n   * Possible values: UseNone, UseOutlines, UseThumbs, UseOC<br />\n   * Default value: UseNone<br/>\n   * <br />\n   * <b>Direction</b> <i>(string)</i><br />\n   * Possible values: L2R, R2L<br />\n   * Default value: L2R.<br />\n   * <br />\n   * <b>ViewArea</b> <i>(string)</i><br />\n   * Possible values: MediaBox, CropBox, TrimBox, BleedBox, ArtBox<br />\n   * Default value: CropBox.<br />\n   * <br />\n   * <b>ViewClip</b> <i>(string)</i><br />\n   * Possible values: MediaBox, CropBox, TrimBox, BleedBox, ArtBox<br />\n   * Default value: CropBox<br />\n   * <br />\n   * <b>PrintArea</b> <i>(string)</i><br />\n   * Possible values: MediaBox, CropBox, TrimBox, BleedBox, ArtBox<br />\n   * Default value: CropBox<br />\n   * <br />\n   * <b>PrintClip</b> <i>(string)</i><br />\n   * Possible values: MediaBox, CropBox, TrimBox, BleedBox, ArtBox<br />\n   * Default value: CropBox.<br />\n   * <br />\n   * <b>PrintScaling</b> <i>(string)</i><br />\n   * Possible values: AppDefault, None<br />\n   * Default value: AppDefault.<br />\n   * <br />\n   * <b>Duplex</b> <i>(string)</i><br />\n   * Possible values: Simplex, DuplexFlipLongEdge, DuplexFlipShortEdge\n   * Default value: none<br />\n   * <br />\n   * <b>PickTrayByPDFSize</b> <i>(boolean)</i><br />\n   * Default value: false<br />\n   * <br />\n   * <b>PrintPageRange</b> <i>(Array)</i><br />\n   * Example: [[1,5], [7,9]]<br />\n   * Default value: as defined by PDF viewer application<br />\n   * <br />\n   * <b>NumCopies</b> <i>(Number)</i><br />\n   * Possible values: 1, 2, 3, 4, 5<br />\n   * Default value: 1<br />\n   * <br />\n   * For more information see the PDF Reference, sixth edition on Page 577\n   * @param {boolean} doReset True to reset the settings\n   * @function\n   * @returns jsPDF jsPDF-instance\n   * @example\n   * var doc = new jsPDF()\n   * doc.text('This is a test', 10, 10)\n   * doc.viewerPreferences({'FitWindow': true}, true)\n   * doc.save(\"viewerPreferences.pdf\")\n   *\n   * // Example printing 10 copies, using cropbox, and hiding UI.\n   * doc.viewerPreferences({\n   *   'HideWindowUI': true,\n   *   'PrintArea': 'CropBox',\n   *   'NumCopies': 10\n   * })\n   */\n\n  jsPDFAPI.viewerPreferences = function (options, doReset) {\n    options = options || {};\n    doReset = doReset || false;\n    var configuration;\n    var configurationTemplate = {\n      \"HideToolbar\": {\n        defaultValue: false,\n        value: false,\n        type: \"boolean\",\n        explicitSet: false,\n        valueSet: [true, false],\n        pdfVersion: 1.3\n      },\n      \"HideMenubar\": {\n        defaultValue: false,\n        value: false,\n        type: \"boolean\",\n        explicitSet: false,\n        valueSet: [true, false],\n        pdfVersion: 1.3\n      },\n      \"HideWindowUI\": {\n        defaultValue: false,\n        value: false,\n        type: \"boolean\",\n        explicitSet: false,\n        valueSet: [true, false],\n        pdfVersion: 1.3\n      },\n      \"FitWindow\": {\n        defaultValue: false,\n        value: false,\n        type: \"boolean\",\n        explicitSet: false,\n        valueSet: [true, false],\n        pdfVersion: 1.3\n      },\n      \"CenterWindow\": {\n        defaultValue: false,\n        value: false,\n        type: \"boolean\",\n        explicitSet: false,\n        valueSet: [true, false],\n        pdfVersion: 1.3\n      },\n      \"DisplayDocTitle\": {\n        defaultValue: false,\n        value: false,\n        type: \"boolean\",\n        explicitSet: false,\n        valueSet: [true, false],\n        pdfVersion: 1.4\n      },\n      \"NonFullScreenPageMode\": {\n        defaultValue: \"UseNone\",\n        value: \"UseNone\",\n        type: \"name\",\n        explicitSet: false,\n        valueSet: [\"UseNone\", \"UseOutlines\", \"UseThumbs\", \"UseOC\"],\n        pdfVersion: 1.3\n      },\n      \"Direction\": {\n        defaultValue: \"L2R\",\n        value: \"L2R\",\n        type: \"name\",\n        explicitSet: false,\n        valueSet: [\"L2R\", \"R2L\"],\n        pdfVersion: 1.3\n      },\n      \"ViewArea\": {\n        defaultValue: \"CropBox\",\n        value: \"CropBox\",\n        type: \"name\",\n        explicitSet: false,\n        valueSet: [\"MediaBox\", \"CropBox\", \"TrimBox\", \"BleedBox\", \"ArtBox\"],\n        pdfVersion: 1.4\n      },\n      \"ViewClip\": {\n        defaultValue: \"CropBox\",\n        value: \"CropBox\",\n        type: \"name\",\n        explicitSet: false,\n        valueSet: [\"MediaBox\", \"CropBox\", \"TrimBox\", \"BleedBox\", \"ArtBox\"],\n        pdfVersion: 1.4\n      },\n      \"PrintArea\": {\n        defaultValue: \"CropBox\",\n        value: \"CropBox\",\n        type: \"name\",\n        explicitSet: false,\n        valueSet: [\"MediaBox\", \"CropBox\", \"TrimBox\", \"BleedBox\", \"ArtBox\"],\n        pdfVersion: 1.4\n      },\n      \"PrintClip\": {\n        defaultValue: \"CropBox\",\n        value: \"CropBox\",\n        type: \"name\",\n        explicitSet: false,\n        valueSet: [\"MediaBox\", \"CropBox\", \"TrimBox\", \"BleedBox\", \"ArtBox\"],\n        pdfVersion: 1.4\n      },\n      \"PrintScaling\": {\n        defaultValue: \"AppDefault\",\n        value: \"AppDefault\",\n        type: \"name\",\n        explicitSet: false,\n        valueSet: [\"AppDefault\", \"None\"],\n        pdfVersion: 1.6\n      },\n      \"Duplex\": {\n        defaultValue: \"\",\n        value: \"none\",\n        type: \"name\",\n        explicitSet: false,\n        valueSet: [\"Simplex\", \"DuplexFlipShortEdge\", \"DuplexFlipLongEdge\", \"none\"],\n        pdfVersion: 1.7\n      },\n      \"PickTrayByPDFSize\": {\n        defaultValue: false,\n        value: false,\n        type: \"boolean\",\n        explicitSet: false,\n        valueSet: [true, false],\n        pdfVersion: 1.7\n      },\n      \"PrintPageRange\": {\n        defaultValue: \"\",\n        value: \"\",\n        type: \"array\",\n        explicitSet: false,\n        valueSet: null,\n        pdfVersion: 1.7\n      },\n      \"NumCopies\": {\n        defaultValue: 1,\n        value: 1,\n        type: \"integer\",\n        explicitSet: false,\n        valueSet: null,\n        pdfVersion: 1.7\n      }\n    };\n    var configurationKeys = Object.keys(configurationTemplate);\n    var rangeArray = [];\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var isValid = true;\n    var method;\n    var value;\n\n    function arrayContainsElement(array, element) {\n      var iterator;\n      var result = false;\n\n      for (iterator = 0; iterator < array.length; iterator += 1) {\n        if (array[iterator] === element) {\n          result = true;\n        }\n      }\n\n      return result;\n    }\n\n    if (this.internal.viewerpreferences === undefined) {\n      this.internal.viewerpreferences = {};\n      this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(configurationTemplate));\n      this.internal.viewerpreferences.isSubscribed = false;\n    }\n\n    configuration = this.internal.viewerpreferences.configuration;\n\n    if (options === \"reset\" || doReset === true) {\n      var len = configurationKeys.length;\n\n      for (k = 0; k < len; k += 1) {\n        configuration[configurationKeys[k]].value = configuration[configurationKeys[k]].defaultValue;\n        configuration[configurationKeys[k]].explicitSet = false;\n      }\n    }\n\n    if (_typeof(options) === \"object\") {\n      for (method in options) {\n        value = options[method];\n\n        if (arrayContainsElement(configurationKeys, method) && value !== undefined) {\n          if (configuration[method].type === \"boolean\" && typeof value === \"boolean\") {\n            configuration[method].value = value;\n          } else if (configuration[method].type === \"name\" && arrayContainsElement(configuration[method].valueSet, value)) {\n            configuration[method].value = value;\n          } else if (configuration[method].type === \"integer\" && Number.isInteger(value)) {\n            configuration[method].value = value;\n          } else if (configuration[method].type === \"array\") {\n            for (i = 0; i < value.length; i += 1) {\n              isValid = true;\n\n              if (value[i].length === 1 && typeof value[i][0] === \"number\") {\n                rangeArray.push(String(value[i] - 1));\n              } else if (value[i].length > 1) {\n                for (j = 0; j < value[i].length; j += 1) {\n                  if (typeof value[i][j] !== \"number\") {\n                    isValid = false;\n                  }\n                }\n\n                if (isValid === true) {\n                  rangeArray.push([value[i][0] - 1, value[i][1] - 1].join(\" \"));\n                }\n              }\n            }\n\n            configuration[method].value = \"[\" + rangeArray.join(\" \") + \"]\";\n          } else {\n            configuration[method].value = configuration[method].defaultValue;\n          }\n\n          configuration[method].explicitSet = true;\n        }\n      }\n    }\n\n    if (this.internal.viewerpreferences.isSubscribed === false) {\n      this.internal.events.subscribe(\"putCatalog\", function () {\n        var pdfDict = [];\n        var vPref;\n\n        for (vPref in configuration) {\n          if (configuration[vPref].explicitSet === true) {\n            if (configuration[vPref].type === \"name\") {\n              pdfDict.push(\"/\" + vPref + \" /\" + configuration[vPref].value);\n            } else {\n              pdfDict.push(\"/\" + vPref + \" \" + configuration[vPref].value);\n            }\n          }\n        }\n\n        if (pdfDict.length !== 0) {\n          this.internal.write(\"/ViewerPreferences\\n<<\\n\" + pdfDict.join(\"\\n\") + \"\\n>>\");\n        }\n      });\n      this.internal.viewerpreferences.isSubscribed = true;\n    }\n\n    this.internal.viewerpreferences.configuration = configuration;\n    return this;\n  };\n})(jsPDF.API);\n\n/** ==================================================================== \n * jsPDF XMP metadata plugin\n * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi\n * \n * \n * ====================================================================\n */\n\n/*global jsPDF */\n\n/**\n* @name xmp_metadata\n* @module\n*/\n(function (jsPDFAPI) {\n\n  var xmpmetadata = \"\";\n  var xmpnamespaceuri = \"\";\n  var metadata_object_number = \"\";\n  /**\n  * Adds XMP formatted metadata to PDF\n  *\n  * @name addMetadata\n  * @function\n  * @param {String} metadata The actual metadata to be added. The metadata shall be stored as XMP simple value. Note that if the metadata string contains XML markup characters \"<\", \">\" or \"&\", those characters should be written using XML entities.\n  * @param {String} namespaceuri Sets the namespace URI for the metadata. Last character should be slash or hash.\n  * @returns {jsPDF} jsPDF-instance\n  */\n\n  jsPDFAPI.addMetadata = function (metadata, namespaceuri) {\n    xmpnamespaceuri = namespaceuri || \"http://jspdf.default.namespaceuri/\"; //The namespace URI for an XMP name shall not be empty\n\n    xmpmetadata = metadata;\n    this.internal.events.subscribe('postPutResources', function () {\n      if (!xmpmetadata) {\n        metadata_object_number = \"\";\n      } else {\n        var xmpmeta_beginning = '<x:xmpmeta xmlns:x=\"adobe:ns:meta/\">';\n        var rdf_beginning = '<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"><rdf:Description rdf:about=\"\" xmlns:jspdf=\"' + xmpnamespaceuri + '\"><jspdf:metadata>';\n        var rdf_ending = '</jspdf:metadata></rdf:Description></rdf:RDF>';\n        var xmpmeta_ending = '</x:xmpmeta>';\n        var utf8_xmpmeta_beginning = unescape(encodeURIComponent(xmpmeta_beginning));\n        var utf8_rdf_beginning = unescape(encodeURIComponent(rdf_beginning));\n        var utf8_metadata = unescape(encodeURIComponent(xmpmetadata));\n        var utf8_rdf_ending = unescape(encodeURIComponent(rdf_ending));\n        var utf8_xmpmeta_ending = unescape(encodeURIComponent(xmpmeta_ending));\n        var total_len = utf8_rdf_beginning.length + utf8_metadata.length + utf8_rdf_ending.length + utf8_xmpmeta_beginning.length + utf8_xmpmeta_ending.length;\n        metadata_object_number = this.internal.newObject();\n        this.internal.write('<< /Type /Metadata /Subtype /XML /Length ' + total_len + ' >>');\n        this.internal.write('stream');\n        this.internal.write(utf8_xmpmeta_beginning + utf8_rdf_beginning + utf8_metadata + utf8_rdf_ending + utf8_xmpmeta_ending);\n        this.internal.write('endstream');\n        this.internal.write('endobj');\n      }\n    });\n    this.internal.events.subscribe('putCatalog', function () {\n      if (metadata_object_number) {\n        this.internal.write('/Metadata ' + metadata_object_number + ' 0 R');\n      }\n    });\n    return this;\n  };\n})(jsPDF.API);\n\n/**\n* @name utf8\n* @module\n*/\n(function (jsPDF, global) {\n\n  var jsPDFAPI = jsPDF.API;\n  /**************************************************/\n\n  /* function : toHex                               */\n\n  /* comment : Replace str with a hex string.       */\n\n  /**************************************************/\n\n  function toHex(str) {\n    var hex = '';\n\n    for (var i = 0; i < str.length; i++) {\n      hex += '' + str.charCodeAt(i).toString(16);\n    }\n\n    return hex;\n  }\n  /***************************************************************************************************/\n\n  /* function : pdfEscape16                                                                          */\n\n  /* comment : The character id of a 2-byte string is converted to a hexadecimal number by obtaining */\n\n  /*   the corresponding glyph id and width, and then adding padding to the string.                  */\n\n  /***************************************************************************************************/\n\n\n  var pdfEscape16 = jsPDFAPI.pdfEscape16 = function (text, font) {\n    var widths = font.metadata.Unicode.widths;\n    var padz = [\"\", \"0\", \"00\", \"000\", \"0000\"];\n    var ar = [\"\"];\n\n    for (var i = 0, l = text.length, t; i < l; ++i) {\n      t = font.metadata.characterToGlyph(text.charCodeAt(i));\n      font.metadata.glyIdsUsed.push(t);\n      font.metadata.toUnicode[t] = text.charCodeAt(i);\n\n      if (widths.indexOf(t) == -1) {\n        widths.push(t);\n        widths.push([parseInt(font.metadata.widthOfGlyph(t), 10)]);\n      }\n\n      if (t == '0') {\n        //Spaces are not allowed in cmap.\n        return ar.join(\"\");\n      } else {\n        t = t.toString(16);\n        ar.push(padz[4 - t.length], t);\n      }\n    }\n\n    return ar.join(\"\");\n  };\n\n  var toUnicodeCmap = function toUnicodeCmap(map) {\n    var code, codes, range, unicode, unicodeMap, _i, _len;\n\n    unicodeMap = '/CIDInit /ProcSet findresource begin\\n12 dict begin\\nbegincmap\\n/CIDSystemInfo <<\\n  /Registry (Adobe)\\n  /Ordering (UCS)\\n  /Supplement 0\\n>> def\\n/CMapName /Adobe-Identity-UCS def\\n/CMapType 2 def\\n1 begincodespacerange\\n<0000><ffff>\\nendcodespacerange';\n    codes = Object.keys(map).sort(function (a, b) {\n      return a - b;\n    });\n    range = [];\n\n    for (_i = 0, _len = codes.length; _i < _len; _i++) {\n      code = codes[_i];\n\n      if (range.length >= 100) {\n        unicodeMap += \"\\n\" + range.length + \" beginbfchar\\n\" + range.join('\\n') + \"\\nendbfchar\";\n        range = [];\n      }\n\n      unicode = ('0000' + map[code].toString(16)).slice(-4);\n      code = ('0000' + (+code).toString(16)).slice(-4);\n      range.push(\"<\" + code + \"><\" + unicode + \">\");\n    }\n\n    if (range.length) {\n      unicodeMap += \"\\n\" + range.length + \" beginbfchar\\n\" + range.join('\\n') + \"\\nendbfchar\\n\";\n    }\n\n    unicodeMap += 'endcmap\\nCMapName currentdict /CMap defineresource pop\\nend\\nend';\n    return unicodeMap;\n  };\n\n  var identityHFunction = function identityHFunction(font, out, newObject, putStream) {\n    if (font.metadata instanceof jsPDF.API.TTFFont && font.encoding === 'Identity-H') {\n      //Tag with Identity-H\n      var widths = font.metadata.Unicode.widths;\n      var data = font.metadata.subset.encode(font.metadata.glyIdsUsed, 1);\n      var pdfOutput = data;\n      var pdfOutput2 = \"\";\n\n      for (var i = 0; i < pdfOutput.length; i++) {\n        pdfOutput2 += String.fromCharCode(pdfOutput[i]);\n      }\n\n      var fontTable = newObject();\n      putStream({\n        data: pdfOutput2,\n        addLength1: true\n      });\n      out('endobj');\n      var cmap = newObject();\n      var cmapData = toUnicodeCmap(font.metadata.toUnicode);\n      putStream({\n        data: cmapData,\n        addLength1: true\n      });\n      out('endobj');\n      var fontDescriptor = newObject();\n      out('<<');\n      out('/Type /FontDescriptor');\n      out('/FontName /' + font.fontName);\n      out('/FontFile2 ' + fontTable + ' 0 R');\n      out('/FontBBox ' + jsPDF.API.PDFObject.convert(font.metadata.bbox));\n      out('/Flags ' + font.metadata.flags);\n      out('/StemV ' + font.metadata.stemV);\n      out('/ItalicAngle ' + font.metadata.italicAngle);\n      out('/Ascent ' + font.metadata.ascender);\n      out('/Descent ' + font.metadata.decender);\n      out('/CapHeight ' + font.metadata.capHeight);\n      out('>>');\n      out('endobj');\n      var DescendantFont = newObject();\n      out('<<');\n      out('/Type /Font');\n      out('/BaseFont /' + font.fontName);\n      out('/FontDescriptor ' + fontDescriptor + ' 0 R');\n      out('/W ' + jsPDF.API.PDFObject.convert(widths));\n      out('/CIDToGIDMap /Identity');\n      out('/DW 1000');\n      out('/Subtype /CIDFontType2');\n      out('/CIDSystemInfo');\n      out('<<');\n      out('/Supplement 0');\n      out('/Registry (Adobe)');\n      out('/Ordering (' + font.encoding + ')');\n      out('>>');\n      out('>>');\n      out('endobj');\n      font.objectNumber = newObject();\n      out('<<');\n      out('/Type /Font');\n      out('/Subtype /Type0');\n      out('/ToUnicode ' + cmap + ' 0 R');\n      out('/BaseFont /' + font.fontName);\n      out('/Encoding /' + font.encoding);\n      out('/DescendantFonts [' + DescendantFont + ' 0 R]');\n      out('>>');\n      out('endobj');\n      font.isAlreadyPutted = true;\n    }\n  };\n\n  jsPDFAPI.events.push(['putFont', function (args) {\n    identityHFunction(args.font, args.out, args.newObject, args.putStream);\n  }]);\n\n  var winAnsiEncodingFunction = function winAnsiEncodingFunction(font, out, newObject, putStream) {\n    if (font.metadata instanceof jsPDF.API.TTFFont && font.encoding === 'WinAnsiEncoding') {\n      //Tag with WinAnsi encoding\n      var widths = font.metadata.Unicode.widths;\n      var data = font.metadata.rawData;\n      var pdfOutput = data;\n      var pdfOutput2 = \"\";\n\n      for (var i = 0; i < pdfOutput.length; i++) {\n        pdfOutput2 += String.fromCharCode(pdfOutput[i]);\n      }\n\n      var fontTable = newObject();\n      putStream({\n        data: pdfOutput2,\n        addLength1: true\n      });\n      out('endobj');\n      var cmap = newObject();\n      var cmapData = toUnicodeCmap(font.metadata.toUnicode);\n      putStream({\n        data: cmapData,\n        addLength1: true\n      });\n      out('endobj');\n      var fontDescriptor = newObject();\n      out('<<');\n      out('/Descent ' + font.metadata.decender);\n      out('/CapHeight ' + font.metadata.capHeight);\n      out('/StemV ' + font.metadata.stemV);\n      out('/Type /FontDescriptor');\n      out('/FontFile2 ' + fontTable + ' 0 R');\n      out('/Flags 96');\n      out('/FontBBox ' + jsPDF.API.PDFObject.convert(font.metadata.bbox));\n      out('/FontName /' + font.fontName);\n      out('/ItalicAngle ' + font.metadata.italicAngle);\n      out('/Ascent ' + font.metadata.ascender);\n      out('>>');\n      out('endobj');\n      font.objectNumber = newObject();\n\n      for (var i = 0; i < font.metadata.hmtx.widths.length; i++) {\n        font.metadata.hmtx.widths[i] = parseInt(font.metadata.hmtx.widths[i] * (1000 / font.metadata.head.unitsPerEm)); //Change the width of Em units to Point units.\n      }\n\n      out('<</Subtype/TrueType/Type/Font/ToUnicode ' + cmap + ' 0 R/BaseFont/' + font.fontName + '/FontDescriptor ' + fontDescriptor + ' 0 R' + '/Encoding/' + font.encoding + ' /FirstChar 29 /LastChar 255 /Widths ' + jsPDF.API.PDFObject.convert(font.metadata.hmtx.widths) + '>>');\n      out('endobj');\n      font.isAlreadyPutted = true;\n    }\n  };\n\n  jsPDFAPI.events.push(['putFont', function (args) {\n    winAnsiEncodingFunction(args.font, args.out, args.newObject, args.putStream);\n  }]);\n\n  var utf8TextFunction = function utf8TextFunction(args) {\n    var text = args.text || '';\n    var x = args.x;\n    var y = args.y;\n    var options = args.options || {};\n    var mutex = args.mutex || {};\n    var pdfEscape = mutex.pdfEscape;\n    var activeFontKey = mutex.activeFontKey;\n    var fonts = mutex.fonts;\n    var key,\n        fontSize = mutex.activeFontSize;\n    var str = '',\n        s = 0,\n        cmapConfirm;\n    var strText = '';\n    var key = activeFontKey;\n    var encoding = fonts[key].encoding;\n\n    if (fonts[key].encoding !== 'Identity-H') {\n      return {\n        text: text,\n        x: x,\n        y: y,\n        options: options,\n        mutex: mutex\n      };\n    }\n    strText = text;\n    key = activeFontKey;\n\n    if (Object.prototype.toString.call(text) === '[object Array]') {\n      strText = text[0];\n    }\n\n    for (s = 0; s < strText.length; s += 1) {\n      if (fonts[key].metadata.hasOwnProperty('cmap')) {\n        cmapConfirm = fonts[key].metadata.cmap.unicode.codeMap[strText[s].charCodeAt(0)];\n        /*\n        if (Object.prototype.toString.call(text) === '[object Array]') {\n          var i = 0;\n         // for (i = 0; i < text.length; i += 1) {\n              if (Object.prototype.toString.call(text[s]) === '[object Array]') {\n                  cmapConfirm = fonts[key].metadata.cmap.unicode.codeMap[strText[s][0].charCodeAt(0)]; //Make sure the cmap has the corresponding glyph id\n              } else {\n                  \n              }\n          //}\n          \n        } else {\n          cmapConfirm = fonts[key].metadata.cmap.unicode.codeMap[strText[s].charCodeAt(0)]; //Make sure the cmap has the corresponding glyph id\n        }*/\n      }\n\n      if (!cmapConfirm) {\n        if (strText[s].charCodeAt(0) < 256 && fonts[key].metadata.hasOwnProperty('Unicode')) {\n          str += strText[s];\n        } else {\n          str += '';\n        }\n      } else {\n        str += strText[s];\n      }\n    }\n\n    var result = '';\n\n    if (parseInt(key.slice(1)) < 14 || encoding === 'WinAnsiEncoding') {\n      //For the default 13 font\n      result = toHex(pdfEscape(str, key));\n    } else if (encoding === 'Identity-H') {\n      result = pdfEscape16(str, fonts[key]);\n    }\n\n    mutex.isHex = true;\n    return {\n      text: result,\n      x: x,\n      y: y,\n      options: options,\n      mutex: mutex\n    };\n  };\n\n  var utf8EscapeFunction = function utf8EscapeFunction(parms) {\n    var text = parms.text || '',\n        x = parms.x,\n        y = parms.y,\n        options = parms.options,\n        mutex = parms.mutex;\n    var lang = options.lang;\n    var tmpText = [];\n    var args = {\n      text: text,\n      x: x,\n      y: y,\n      options: options,\n      mutex: mutex\n    };\n\n    if (Object.prototype.toString.call(text) === '[object Array]') {\n      var i = 0;\n\n      for (i = 0; i < text.length; i += 1) {\n        if (Object.prototype.toString.call(text[i]) === '[object Array]') {\n          if (text[i].length === 3) {\n            tmpText.push([utf8TextFunction(Object.assign({}, args, {\n              text: text[i][0]\n            })).text, text[i][1], text[i][2]]);\n          } else {\n            tmpText.push(utf8TextFunction(Object.assign({}, args, {\n              text: text[i]\n            })).text);\n          }\n        } else {\n          tmpText.push(utf8TextFunction(Object.assign({}, args, {\n            text: text[i]\n          })).text);\n        }\n      }\n\n      parms.text = tmpText;\n    } else {\n      parms.text = utf8TextFunction(Object.assign({}, args, {\n        text: text\n      })).text;\n    }\n  };\n\n  jsPDFAPI.events.push(['postProcessText', utf8EscapeFunction]);\n})(jsPDF, typeof self !== \"undefined\" && self || typeof global !== \"undefined\" && global || typeof window !== \"undefined\" && window || Function(\"return this\")());\n\n/**\n * jsPDF virtual FileSystem functionality\n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n* Use the vFS to handle files\n* \n* @name vFS\n* @module\n*/\n(function (jsPDFAPI) {\n\n  var _initializeVFS = function _initializeVFS(instance) {\n    if (typeof instance === \"undefined\") {\n      return false;\n    }\n\n    if (typeof instance.vFS === \"undefined\") {\n      instance.vFS = {};\n    }\n\n    return true;\n  };\n  /** \n  * Check if the file exists in the vFS\n  * \n  * @name existsFileInVFS\n  * @function \n  * @param {string} Possible filename in the vFS.\n  * @returns {boolean}\n  * @example\n  * doc.existsFileInVFS(\"someFile.txt\");\n  */\n\n\n  jsPDFAPI.existsFileInVFS = function (filename) {\n    if (_initializeVFS(this.internal)) {\n      return typeof this.internal.vFS[filename] !== \"undefined\";\n    }\n\n    return false;\n  };\n  /**\n  * Add a file to the vFS\n  *\n  * @name addFileToVFS\n  * @function \n  * @param {string} filename The name of the file which should be added.\n  * @param {string} filecontent The content of the file.\n  * @returns {jsPDF}\n  * @example\n  * doc.addFileToVFS(\"someFile.txt\", \"BADFACE1\");\n  */\n\n\n  jsPDFAPI.addFileToVFS = function (filename, filecontent) {\n    _initializeVFS(this.internal);\n\n    this.internal.vFS[filename] = filecontent;\n    return this;\n  };\n  /** \n  * Get the file from the vFS\n  * \n  * @name getFileFromVFS\n  * @function \n  * @param {string} The name of the file which gets requested.\n  * @returns {string} \n  * @example\n  * doc.getFileFromVFS(\"someFile.txt\");\n  */\n\n\n  jsPDFAPI.getFileFromVFS = function (filename) {\n    _initializeVFS(this.internal);\n\n    if (typeof this.internal.vFS[filename] !== \"undefined\") {\n      return this.internal.vFS[filename];\n    }\n\n    return null;\n  };\n})(jsPDF.API);\n\n/*\n * Copyright (c) 2012 chick307 <chick307@gmail.com>\n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\n(function (jsPDF, callback) {\n  jsPDF.API.adler32cs = callback();\n})(jsPDF, function () {\n  var _hasArrayBuffer = typeof ArrayBuffer === 'function' && typeof Uint8Array === 'function';\n\n  var _Buffer = null,\n      _isBuffer = function () {\n    if (!_hasArrayBuffer) return function _isBuffer() {\n      return false;\n    };\n\n    try {\n      var buffer = {};\n      if (typeof buffer.Buffer === 'function') _Buffer = buffer.Buffer;\n    } catch (error) {}\n\n    return function _isBuffer(value) {\n      return value instanceof ArrayBuffer || _Buffer !== null && value instanceof _Buffer;\n    };\n  }();\n\n  var _utf8ToBinary = function () {\n    if (_Buffer !== null) {\n      return function _utf8ToBinary(utf8String) {\n        return new _Buffer(utf8String, 'utf8').toString('binary');\n      };\n    } else {\n      return function _utf8ToBinary(utf8String) {\n        return unescape(encodeURIComponent(utf8String));\n      };\n    }\n  }();\n\n  var MOD = 65521;\n\n  var _update = function _update(checksum, binaryString) {\n    var a = checksum & 0xFFFF,\n        b = checksum >>> 16;\n\n    for (var i = 0, length = binaryString.length; i < length; i++) {\n      a = (a + (binaryString.charCodeAt(i) & 0xFF)) % MOD;\n      b = (b + a) % MOD;\n    }\n\n    return (b << 16 | a) >>> 0;\n  };\n\n  var _updateUint8Array = function _updateUint8Array(checksum, uint8Array) {\n    var a = checksum & 0xFFFF,\n        b = checksum >>> 16;\n\n    for (var i = 0, length = uint8Array.length; i < length; i++) {\n      a = (a + uint8Array[i]) % MOD;\n      b = (b + a) % MOD;\n    }\n\n    return (b << 16 | a) >>> 0;\n  };\n\n  var exports = {};\n\n  var Adler32 = exports.Adler32 = function () {\n    var ctor = function Adler32(checksum) {\n      if (!(this instanceof ctor)) {\n        throw new TypeError('Constructor cannot called be as a function.');\n      }\n\n      if (!isFinite(checksum = checksum == null ? 1 : +checksum)) {\n        throw new Error('First arguments needs to be a finite number.');\n      }\n\n      this.checksum = checksum >>> 0;\n    };\n\n    var proto = ctor.prototype = {};\n    proto.constructor = ctor;\n\n    ctor.from = function (from) {\n      from.prototype = proto;\n      return from;\n    }(function from(binaryString) {\n      if (!(this instanceof ctor)) {\n        throw new TypeError('Constructor cannot called be as a function.');\n      }\n\n      if (binaryString == null) throw new Error('First argument needs to be a string.');\n      this.checksum = _update(1, binaryString.toString());\n    });\n\n    ctor.fromUtf8 = function (fromUtf8) {\n      fromUtf8.prototype = proto;\n      return fromUtf8;\n    }(function fromUtf8(utf8String) {\n      if (!(this instanceof ctor)) {\n        throw new TypeError('Constructor cannot called be as a function.');\n      }\n\n      if (utf8String == null) throw new Error('First argument needs to be a string.');\n\n      var binaryString = _utf8ToBinary(utf8String.toString());\n\n      this.checksum = _update(1, binaryString);\n    });\n\n    if (_hasArrayBuffer) {\n      ctor.fromBuffer = function (fromBuffer) {\n        fromBuffer.prototype = proto;\n        return fromBuffer;\n      }(function fromBuffer(buffer) {\n        if (!(this instanceof ctor)) {\n          throw new TypeError('Constructor cannot called be as a function.');\n        }\n\n        if (!_isBuffer(buffer)) throw new Error('First argument needs to be ArrayBuffer.');\n        var array = new Uint8Array(buffer);\n        return this.checksum = _updateUint8Array(1, array);\n      });\n    }\n\n    proto.update = function update(binaryString) {\n      if (binaryString == null) throw new Error('First argument needs to be a string.');\n      binaryString = binaryString.toString();\n      return this.checksum = _update(this.checksum, binaryString);\n    };\n\n    proto.updateUtf8 = function updateUtf8(utf8String) {\n      if (utf8String == null) throw new Error('First argument needs to be a string.');\n\n      var binaryString = _utf8ToBinary(utf8String.toString());\n\n      return this.checksum = _update(this.checksum, binaryString);\n    };\n\n    if (_hasArrayBuffer) {\n      proto.updateBuffer = function updateBuffer(buffer) {\n        if (!_isBuffer(buffer)) throw new Error('First argument needs to be ArrayBuffer.');\n        var array = new Uint8Array(buffer);\n        return this.checksum = _updateUint8Array(this.checksum, array);\n      };\n    }\n\n    proto.clone = function clone() {\n      return new Adler32(this.checksum);\n    };\n\n    return ctor;\n  }();\n\n  exports.from = function from(binaryString) {\n    if (binaryString == null) throw new Error('First argument needs to be a string.');\n    return _update(1, binaryString.toString());\n  };\n\n  exports.fromUtf8 = function fromUtf8(utf8String) {\n    if (utf8String == null) throw new Error('First argument needs to be a string.');\n\n    var binaryString = _utf8ToBinary(utf8String.toString());\n\n    return _update(1, binaryString);\n  };\n\n  if (_hasArrayBuffer) {\n    exports.fromBuffer = function fromBuffer(buffer) {\n      if (!_isBuffer(buffer)) throw new Error('First argument need to be ArrayBuffer.');\n      var array = new Uint8Array(buffer);\n      return _updateUint8Array(1, array);\n    };\n  }\n\n  return exports;\n});\n\n/**\n* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)\n* MIT License\n*/\n(function (jsPDF) {\n  /**\n   * Table of Unicode types.\n   *\n   * Generated by:\n   *\n   * var bidi = require(\"./bidi/index\");\n   * var bidi_accumulate = bidi.slice(0, 256).concat(bidi.slice(0x0500, 0x0500 + 256 * 3)).\n   * concat(bidi.slice(0x2000, 0x2000 + 256)).concat(bidi.slice(0xFB00, 0xFB00 + 256)).\n   * concat(bidi.slice(0xFE00, 0xFE00 + 2 * 256));\n   *\n   * for( var i = 0; i < bidi_accumulate.length; i++) {\n   * \tif(bidi_accumulate[i] === undefined || bidi_accumulate[i] === 'ON')\n   * \t\tbidi_accumulate[i] = 'N'; //mark as neutral to conserve space and substitute undefined\n   * }\n   * var bidiAccumulateStr = 'return [ \"' + bidi_accumulate.toString().replace(/,/g, '\", \"') + '\" ];';\n   * require(\"fs\").writeFile('unicode-types.js', bidiAccumulateStr);\n   *\n   * Based on:\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   */\n\n  var bidiUnicodeTypes = [\"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"S\", \"B\", \"S\", \"WS\", \"B\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"B\", \"B\", \"B\", \"S\", \"WS\", \"N\", \"N\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ES\", \"CS\", \"ES\", \"CS\", \"CS\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"CS\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"B\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"CS\", \"N\", \"ET\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"L\", \"N\", \"N\", \"BN\", \"N\", \"N\", \"ET\", \"ET\", \"EN\", \"EN\", \"N\", \"L\", \"N\", \"N\", \"N\", \"EN\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ET\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"R\", \"NSM\", \"R\", \"NSM\", \"NSM\", \"R\", \"NSM\", \"NSM\", \"R\", \"NSM\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"N\", \"N\", \"N\", \"N\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"N\", \"N\", \"AL\", \"ET\", \"ET\", \"AL\", \"CS\", \"AL\", \"N\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"ET\", \"AN\", \"AN\", \"AL\", \"AL\", \"AL\", \"NSM\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AN\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"N\", \"AL\", \"AL\", \"NSM\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"N\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"R\", \"R\", \"N\", \"N\", \"N\", \"N\", \"R\", \"N\", \"N\", \"N\", \"N\", \"N\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"BN\", \"BN\", \"BN\", \"L\", \"R\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"WS\", \"B\", \"LRE\", \"RLE\", \"PDF\", \"LRO\", \"RLO\", \"CS\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"CS\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"WS\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"N\", \"LRI\", \"RLI\", \"FSI\", \"PDI\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"EN\", \"L\", \"N\", \"N\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"ES\", \"ES\", \"N\", \"N\", \"N\", \"L\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"ES\", \"ES\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"R\", \"NSM\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"ES\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"N\", \"R\", \"N\", \"R\", \"R\", \"N\", \"R\", \"R\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"CS\", \"N\", \"CS\", \"N\", \"N\", \"CS\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ET\", \"N\", \"N\", \"ES\", \"ES\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"N\", \"N\", \"BN\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ES\", \"CS\", \"ES\", \"CS\", \"CS\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"CS\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\"];\n  /**\n   * Unicode Bidi algorithm compliant Bidi engine.\n   * For reference see http://unicode.org/reports/tr9/\n  */\n\n  /**\n   * constructor ( options )\n   *\n   * Initializes Bidi engine\n   *\n   * @param {Object} See 'setOptions' below for detailed description.\n   * options are cashed between invocation of 'doBidiReorder' method\n   *\n   * sample usage pattern of BidiEngine:\n   * var opt = {\n   * \tisInputVisual: true,\n   * \tisInputRtl: false,\n   * \tisOutputVisual: false,\n   * \tisOutputRtl: false,\n   * \tisSymmetricSwapping: true\n   * }\n   * var sourceToTarget = [], levels = [];\n   * var bidiEng = Globalize.bidiEngine(opt);\n   * var src = \"text string to be reordered\";\n   * var ret = bidiEng.doBidiReorder(src, sourceToTarget, levels);\n   */\n\n  jsPDF.__bidiEngine__ = jsPDF.prototype.__bidiEngine__ = function (options) {\n    var _UNICODE_TYPES = _bidiUnicodeTypes;\n    var _STATE_TABLE_LTR = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 0x11, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 0x15, 0x15, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]];\n    var _STATE_TABLE_RTL = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 0x21, 3, 1, 1]];\n    var _TYPE_NAMES_MAP = {\n      \"L\": 0,\n      \"R\": 1,\n      \"EN\": 2,\n      \"AN\": 3,\n      \"N\": 4,\n      \"B\": 5,\n      \"S\": 6\n    };\n    var _UNICODE_RANGES_MAP = {\n      0: 0,\n      5: 1,\n      6: 2,\n      7: 3,\n      0x20: 4,\n      0xFB: 5,\n      0xFE: 6,\n      0xFF: 7\n    };\n    var _SWAP_TABLE = [\"(\", \")\", \"(\", \"<\", \">\", \"<\", \"[\", \"]\", \"[\", \"{\", \"}\", \"{\", \"\\xAB\", \"\\xBB\", \"\\xAB\", \"\\u2039\", \"\\u203A\", \"\\u2039\", \"\\u2045\", \"\\u2046\", \"\\u2045\", \"\\u207D\", \"\\u207E\", \"\\u207D\", \"\\u208D\", \"\\u208E\", \"\\u208D\", \"\\u2264\", \"\\u2265\", \"\\u2264\", \"\\u2329\", \"\\u232A\", \"\\u2329\", \"\\uFE59\", \"\\uFE5A\", \"\\uFE59\", \"\\uFE5B\", \"\\uFE5C\", \"\\uFE5B\", \"\\uFE5D\", \"\\uFE5E\", \"\\uFE5D\", \"\\uFE64\", \"\\uFE65\", \"\\uFE64\"];\n\n    var _LTR_RANGES_REG_EXPR = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/);\n\n    var _lastArabic = false,\n        _hasUbatB,\n        _hasUbatS,\n        DIR_LTR = 0,\n        DIR_RTL = 1,\n        _isInVisual,\n        _isInRtl,\n        _isOutVisual,\n        _isOutRtl,\n        _isSymmetricSwapping,\n        _dir = DIR_LTR;\n\n    this.__bidiEngine__ = {};\n\n    var _init = function _init(text, sourceToTargetMap) {\n      if (sourceToTargetMap) {\n        for (var i = 0; i < text.length; i++) {\n          sourceToTargetMap[i] = i;\n        }\n      }\n\n      if (_isInRtl === undefined) {\n        _isInRtl = _isContextualDirRtl(text);\n      }\n\n      if (_isOutRtl === undefined) {\n        _isOutRtl = _isContextualDirRtl(text);\n      }\n    }; // for reference see 3.2 in http://unicode.org/reports/tr9/\n    //\n\n\n    var _getCharType = function _getCharType(ch) {\n      var charCode = ch.charCodeAt(),\n          range = charCode >> 8,\n          rangeIdx = _UNICODE_RANGES_MAP[range];\n\n      if (rangeIdx !== undefined) {\n        return _UNICODE_TYPES[rangeIdx * 256 + (charCode & 0xFF)];\n      } else if (range === 0xFC || range === 0xFD) {\n        return \"AL\";\n      } else if (_LTR_RANGES_REG_EXPR.test(range)) {\n        //unlikely case\n        return \"L\";\n      } else if (range === 8) {\n        // even less likely\n        return \"R\";\n      }\n\n      return \"N\"; //undefined type, mark as neutral\n    };\n\n    var _isContextualDirRtl = function _isContextualDirRtl(text) {\n      for (var i = 0, charType; i < text.length; i++) {\n        charType = _getCharType(text.charAt(i));\n\n        if (charType === \"L\") {\n          return false;\n        } else if (charType === \"R\") {\n          return true;\n        }\n      }\n\n      return false;\n    }; // for reference see 3.3.4 & 3.3.5 in http://unicode.org/reports/tr9/\n    //\n\n\n    var _resolveCharType = function _resolveCharType(chars, types, resolvedTypes, index) {\n      var cType = types[index],\n          wType,\n          nType,\n          i,\n          len;\n\n      switch (cType) {\n        case \"L\":\n        case \"R\":\n          _lastArabic = false;\n          break;\n\n        case \"N\":\n        case \"AN\":\n          break;\n\n        case \"EN\":\n          if (_lastArabic) {\n            cType = \"AN\";\n          }\n\n          break;\n\n        case \"AL\":\n          _lastArabic = true;\n          cType = \"R\";\n          break;\n\n        case \"WS\":\n          cType = \"N\";\n          break;\n\n        case \"CS\":\n          if (index < 1 || index + 1 >= types.length || (wType = resolvedTypes[index - 1]) !== \"EN\" && wType !== \"AN\" || (nType = types[index + 1]) !== \"EN\" && nType !== \"AN\") {\n            cType = \"N\";\n          } else if (_lastArabic) {\n            nType = \"AN\";\n          }\n\n          cType = nType === wType ? nType : \"N\";\n          break;\n\n        case \"ES\":\n          wType = index > 0 ? resolvedTypes[index - 1] : \"B\";\n          cType = wType === \"EN\" && index + 1 < types.length && types[index + 1] === \"EN\" ? \"EN\" : \"N\";\n          break;\n\n        case \"ET\":\n          if (index > 0 && resolvedTypes[index - 1] === \"EN\") {\n            cType = \"EN\";\n            break;\n          } else if (_lastArabic) {\n            cType = \"N\";\n            break;\n          }\n\n          i = index + 1;\n          len = types.length;\n\n          while (i < len && types[i] === \"ET\") {\n            i++;\n          }\n\n          if (i < len && types[i] === \"EN\") {\n            cType = \"EN\";\n          } else {\n            cType = \"N\";\n          }\n\n          break;\n\n        case \"NSM\":\n          if (_isInVisual && !_isInRtl) {\n            //V->L\n            len = types.length;\n            i = index + 1;\n\n            while (i < len && types[i] === \"NSM\") {\n              i++;\n            }\n\n            if (i < len) {\n              var c = chars[index];\n              var rtlCandidate = c >= 0x0591 && c <= 0x08FF || c === 0xFB1E;\n              wType = types[i];\n\n              if (rtlCandidate && (wType === \"R\" || wType === \"AL\")) {\n                cType = \"R\";\n                break;\n              }\n            }\n          }\n\n          if (index < 1 || (wType = types[index - 1]) === \"B\") {\n            cType = \"N\";\n          } else {\n            cType = resolvedTypes[index - 1];\n          }\n\n          break;\n\n        case \"B\":\n          _lastArabic = false;\n          _hasUbatB = true;\n          cType = _dir;\n          break;\n\n        case \"S\":\n          _hasUbatS = true;\n          cType = \"N\";\n          break;\n\n        case \"LRE\":\n        case \"RLE\":\n        case \"LRO\":\n        case \"RLO\":\n        case \"PDF\":\n          _lastArabic = false;\n          break;\n\n        case \"BN\":\n          cType = \"N\";\n          break;\n      }\n\n      return cType;\n    };\n\n    var _handleUbatS = function _handleUbatS(types, levels, length) {\n      for (var i = 0; i < length; i++) {\n        if (types[i] === \"S\") {\n          levels[i] = _dir;\n\n          for (var j = i - 1; j >= 0; j--) {\n            if (types[j] === \"WS\") {\n              levels[j] = _dir;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    };\n\n    var _invertString = function _invertString(text, sourceToTargetMap, levels) {\n      var charArray = text.split(\"\");\n\n      if (levels) {\n        _computeLevels(charArray, levels, {\n          hiLevel: _dir\n        });\n      }\n\n      charArray.reverse();\n      sourceToTargetMap && sourceToTargetMap.reverse();\n      return charArray.join(\"\");\n    }; // For reference see 3.3 in http://unicode.org/reports/tr9/\n    //\n\n\n    var _computeLevels = function _computeLevels(chars, levels, params) {\n      var action,\n          condition,\n          i,\n          index,\n          newLevel,\n          prevState,\n          condPos = -1,\n          len = chars.length,\n          newState = 0,\n          resolvedTypes = [],\n          stateTable = _dir ? _STATE_TABLE_RTL : _STATE_TABLE_LTR,\n          types = [];\n      _lastArabic = false;\n      _hasUbatB = false;\n      _hasUbatS = false;\n\n      for (i = 0; i < len; i++) {\n        types[i] = _getCharType(chars[i]);\n      }\n\n      for (index = 0; index < len; index++) {\n        prevState = newState;\n        resolvedTypes[index] = _resolveCharType(chars, types, resolvedTypes, index);\n        newState = stateTable[prevState][_TYPE_NAMES_MAP[resolvedTypes[index]]];\n        action = newState & 0xF0;\n        newState &= 0x0F;\n        levels[index] = newLevel = stateTable[newState][5];\n\n        if (action > 0) {\n          if (action === 0x10) {\n            for (i = condPos; i < index; i++) {\n              levels[i] = 1;\n            }\n\n            condPos = -1;\n          } else {\n            condPos = -1;\n          }\n        }\n\n        condition = stateTable[newState][6];\n\n        if (condition) {\n          if (condPos === -1) {\n            condPos = index;\n          }\n        } else {\n          if (condPos > -1) {\n            for (i = condPos; i < index; i++) {\n              levels[i] = newLevel;\n            }\n\n            condPos = -1;\n          }\n        }\n\n        if (types[index] === \"B\") {\n          levels[index] = 0;\n        }\n\n        params.hiLevel |= newLevel;\n      }\n\n      if (_hasUbatS) {\n        _handleUbatS(types, levels, len);\n      }\n    }; // for reference see 3.4 in http://unicode.org/reports/tr9/\n    //\n\n\n    var _invertByLevel = function _invertByLevel(level, charArray, sourceToTargetMap, levels, params) {\n      if (params.hiLevel < level) {\n        return;\n      }\n\n      if (level === 1 && _dir === DIR_RTL && !_hasUbatB) {\n        charArray.reverse();\n        sourceToTargetMap && sourceToTargetMap.reverse();\n        return;\n      }\n\n      var ch,\n          high,\n          end,\n          low,\n          len = charArray.length,\n          start = 0;\n\n      while (start < len) {\n        if (levels[start] >= level) {\n          end = start + 1;\n\n          while (end < len && levels[end] >= level) {\n            end++;\n          }\n\n          for (low = start, high = end - 1; low < high; low++, high--) {\n            ch = charArray[low];\n            charArray[low] = charArray[high];\n            charArray[high] = ch;\n\n            if (sourceToTargetMap) {\n              ch = sourceToTargetMap[low];\n              sourceToTargetMap[low] = sourceToTargetMap[high];\n              sourceToTargetMap[high] = ch;\n            }\n          }\n\n          start = end;\n        }\n\n        start++;\n      }\n    }; // for reference see 7 & BD16 in http://unicode.org/reports/tr9/\n    //\n\n\n    var _symmetricSwap = function _symmetricSwap(charArray, levels, params) {\n      if (params.hiLevel !== 0 && _isSymmetricSwapping) {\n        for (var i = 0, index; i < charArray.length; i++) {\n          if (levels[i] === 1) {\n            index = _SWAP_TABLE.indexOf(charArray[i]);\n\n            if (index >= 0) {\n              charArray[i] = _SWAP_TABLE[index + 1];\n            }\n          }\n        }\n      }\n    };\n\n    var _reorder = function _reorder(text, sourceToTargetMap, levels) {\n      var charArray = text.split(\"\"),\n          params = {\n        hiLevel: _dir\n      };\n\n      if (!levels) {\n        levels = [];\n      }\n\n      _computeLevels(charArray, levels, params);\n\n      _symmetricSwap(charArray, levels, params);\n\n      _invertByLevel(DIR_RTL + 1, charArray, sourceToTargetMap, levels, params);\n\n      _invertByLevel(DIR_RTL, charArray, sourceToTargetMap, levels, params);\n\n      return charArray.join(\"\");\n    }; // doBidiReorder( text, sourceToTargetMap, levels )\n    // Performs Bidi reordering by implementing Unicode Bidi algorithm.\n    // Returns reordered string\n    // @text [String]:\n    // - input string to be reordered, this is input parameter\n    // $sourceToTargetMap [Array] (optional)\n    // - resultant mapping between input and output strings, this is output parameter\n    // $levels [Array] (optional)\n    // - array of calculated Bidi levels, , this is output parameter\n\n\n    this.__bidiEngine__.doBidiReorder = function (text, sourceToTargetMap, levels) {\n      _init(text, sourceToTargetMap);\n\n      if (!_isInVisual && _isOutVisual && !_isOutRtl) {\n        // LLTR->VLTR, LRTL->VLTR\n        _dir = _isInRtl ? DIR_RTL : DIR_LTR;\n        text = _reorder(text, sourceToTargetMap, levels);\n      } else if (_isInVisual && _isOutVisual && _isInRtl ^ _isOutRtl) {\n        // VRTL->VLTR, VLTR->VRTL\n        _dir = _isInRtl ? DIR_RTL : DIR_LTR;\n        text = _invertString(text, sourceToTargetMap, levels);\n      } else if (!_isInVisual && _isOutVisual && _isOutRtl) {\n        // LLTR->VRTL, LRTL->VRTL\n        _dir = _isInRtl ? DIR_RTL : DIR_LTR;\n        text = _reorder(text, sourceToTargetMap, levels);\n        text = _invertString(text, sourceToTargetMap);\n      } else if (_isInVisual && !_isInRtl && !_isOutVisual && !_isOutRtl) {\n        // VLTR->LLTR\n        _dir = DIR_LTR;\n        text = _reorder(text, sourceToTargetMap, levels);\n      } else if (_isInVisual && !_isOutVisual && _isInRtl ^ _isOutRtl) {\n        // VLTR->LRTL, VRTL->LLTR\n        text = _invertString(text, sourceToTargetMap);\n\n        if (_isInRtl) {\n          //LLTR -> VLTR\n          _dir = DIR_LTR;\n          text = _reorder(text, sourceToTargetMap, levels);\n        } else {\n          //LRTL -> VRTL\n          _dir = DIR_RTL;\n          text = _reorder(text, sourceToTargetMap, levels);\n          text = _invertString(text, sourceToTargetMap);\n        }\n      } else if (_isInVisual && _isInRtl && !_isOutVisual && _isOutRtl) {\n        //  VRTL->LRTL\n        _dir = DIR_RTL;\n        text = _reorder(text, sourceToTargetMap, levels);\n        text = _invertString(text, sourceToTargetMap);\n      } else if (!_isInVisual && !_isOutVisual && _isInRtl ^ _isOutRtl) {\n        // LRTL->LLTR, LLTR->LRTL\n        var isSymmetricSwappingOrig = _isSymmetricSwapping;\n\n        if (_isInRtl) {\n          //LRTL->LLTR\n          _dir = DIR_RTL;\n          text = _reorder(text, sourceToTargetMap, levels);\n          _dir = DIR_LTR;\n          _isSymmetricSwapping = false;\n          text = _reorder(text, sourceToTargetMap, levels);\n          _isSymmetricSwapping = isSymmetricSwappingOrig;\n        } else {\n          //LLTR->LRTL\n          _dir = DIR_LTR;\n          text = _reorder(text, sourceToTargetMap, levels);\n          text = _invertString(text, sourceToTargetMap);\n          _dir = DIR_RTL;\n          _isSymmetricSwapping = false;\n          text = _reorder(text, sourceToTargetMap, levels);\n          _isSymmetricSwapping = isSymmetricSwappingOrig;\n          text = _invertString(text, sourceToTargetMap);\n        }\n      }\n\n      return text;\n    };\n    /**\n    * @name setOptions( options )\n    * @function \n    * Sets options for Bidi conversion\n    * @param {Object}:\n    * - isInputVisual {boolean} (defaults to false): allowed values: true(Visual mode), false(Logical mode)\n    * - isInputRtl {boolean}: allowed values true(Right-to-left direction), false (Left-to-right directiion), undefined(Contectual direction, i.e.direction defined by first strong character of input string)\n    * - isOutputVisual {boolean} (defaults to false): allowed values: true(Visual mode), false(Logical mode)\n    * - isOutputRtl {boolean}: allowed values true(Right-to-left direction), false (Left-to-right directiion), undefined(Contectual direction, i.e.direction defined by first strong characterof input string)\n    * - isSymmetricSwapping {boolean} (defaults to false): allowed values true(needs symmetric swapping), false (no need in symmetric swapping),\n    */\n\n\n    this.__bidiEngine__.setOptions = function (options) {\n      if (options) {\n        _isInVisual = options.isInputVisual;\n        _isOutVisual = options.isOutputVisual;\n        _isInRtl = options.isInputRtl;\n        _isOutRtl = options.isOutputRtl;\n        _isSymmetricSwapping = options.isSymmetricSwapping;\n      }\n    };\n\n    this.__bidiEngine__.setOptions(options);\n\n    return this.__bidiEngine__;\n  };\n\n  var _bidiUnicodeTypes = bidiUnicodeTypes;\n  var bidiEngine = new jsPDF.__bidiEngine__({\n    isInputVisual: true\n  });\n\n  var bidiEngineFunction = function bidiEngineFunction(args) {\n    var text = args.text;\n    var x = args.x;\n    var y = args.y;\n    var options = args.options || {};\n    var mutex = args.mutex || {};\n    var lang = options.lang;\n    var tmpText = [];\n\n    if (Object.prototype.toString.call(text) === '[object Array]') {\n      var i = 0;\n      tmpText = [];\n\n      for (i = 0; i < text.length; i += 1) {\n        if (Object.prototype.toString.call(text[i]) === '[object Array]') {\n          tmpText.push([bidiEngine.doBidiReorder(text[i][0]), text[i][1], text[i][2]]);\n        } else {\n          tmpText.push([bidiEngine.doBidiReorder(text[i])]);\n        }\n      }\n\n      args.text = tmpText;\n    } else {\n      args.text = bidiEngine.doBidiReorder(text);\n    }\n  };\n\n  jsPDF.API.events.push(['postProcessText', bidiEngineFunction]);\n})(jsPDF);\n\n/*\n  Copyright (c) 2008, Adobe Systems Incorporated\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without \n  modification, are permitted provided that the following conditions are\n  met:\n\n  * Redistributions of source code must retain the above copyright notice, \n    this list of conditions and the following disclaimer.\n  \n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the \n    documentation and/or other materials provided with the distribution.\n  \n  * Neither the name of Adobe Systems Incorporated nor the names of its \n    contributors may be used to endorse or promote products derived from \n    this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR \n  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nJPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009\n\nBasic GUI blocking jpeg encoder\n*/\nfunction JPEGEncoder(quality) {\n  var ffloor = Math.floor;\n  var YTable = new Array(64);\n  var UVTable = new Array(64);\n  var fdtbl_Y = new Array(64);\n  var fdtbl_UV = new Array(64);\n  var YDC_HT;\n  var UVDC_HT;\n  var YAC_HT;\n  var UVAC_HT;\n  var bitcode = new Array(65535);\n  var category = new Array(65535);\n  var outputfDCTQuant = new Array(64);\n  var DU = new Array(64);\n  var byteout = [];\n  var bytenew = 0;\n  var bytepos = 7;\n  var YDU = new Array(64);\n  var UDU = new Array(64);\n  var VDU = new Array(64);\n  var clt = new Array(256);\n  var RGB_YUV_TABLE = new Array(2048);\n  var currentQuality;\n  var ZigZag = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];\n  var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];\n  var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n  var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d];\n  var std_ac_luminance_values = [0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa];\n  var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];\n  var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n  var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77];\n  var std_ac_chrominance_values = [0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa];\n\n  function initQuantTables(sf) {\n    var YQT = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99];\n\n    for (var i = 0; i < 64; i++) {\n      var t = ffloor((YQT[i] * sf + 50) / 100);\n\n      if (t < 1) {\n        t = 1;\n      } else if (t > 255) {\n        t = 255;\n      }\n\n      YTable[ZigZag[i]] = t;\n    }\n\n    var UVQT = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99];\n\n    for (var j = 0; j < 64; j++) {\n      var u = ffloor((UVQT[j] * sf + 50) / 100);\n\n      if (u < 1) {\n        u = 1;\n      } else if (u > 255) {\n        u = 255;\n      }\n\n      UVTable[ZigZag[j]] = u;\n    }\n\n    var aasf = [1.0, 1.387039845, 1.306562965, 1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379];\n    var k = 0;\n\n    for (var row = 0; row < 8; row++) {\n      for (var col = 0; col < 8; col++) {\n        fdtbl_Y[k] = 1.0 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0);\n        fdtbl_UV[k] = 1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0);\n        k++;\n      }\n    }\n  }\n\n  function computeHuffmanTbl(nrcodes, std_table) {\n    var codevalue = 0;\n    var pos_in_table = 0;\n    var HT = new Array();\n\n    for (var k = 1; k <= 16; k++) {\n      for (var j = 1; j <= nrcodes[k]; j++) {\n        HT[std_table[pos_in_table]] = [];\n        HT[std_table[pos_in_table]][0] = codevalue;\n        HT[std_table[pos_in_table]][1] = k;\n        pos_in_table++;\n        codevalue++;\n      }\n\n      codevalue *= 2;\n    }\n\n    return HT;\n  }\n\n  function initHuffmanTbl() {\n    YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);\n    UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);\n    YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);\n    UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);\n  }\n\n  function initCategoryNumber() {\n    var nrlower = 1;\n    var nrupper = 2;\n\n    for (var cat = 1; cat <= 15; cat++) {\n      //Positive numbers\n      for (var nr = nrlower; nr < nrupper; nr++) {\n        category[32767 + nr] = cat;\n        bitcode[32767 + nr] = [];\n        bitcode[32767 + nr][1] = cat;\n        bitcode[32767 + nr][0] = nr;\n      } //Negative numbers\n\n\n      for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {\n        category[32767 + nrneg] = cat;\n        bitcode[32767 + nrneg] = [];\n        bitcode[32767 + nrneg][1] = cat;\n        bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;\n      }\n\n      nrlower <<= 1;\n      nrupper <<= 1;\n    }\n  }\n\n  function initRGBYUVTable() {\n    for (var i = 0; i < 256; i++) {\n      RGB_YUV_TABLE[i] = 19595 * i;\n      RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;\n      RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 0x8000;\n      RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;\n      RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;\n      RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 0x807FFF;\n      RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;\n      RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;\n    }\n  } // IO functions\n\n\n  function writeBits(bs) {\n    var value = bs[0];\n    var posval = bs[1] - 1;\n\n    while (posval >= 0) {\n      if (value & 1 << posval) {\n        bytenew |= 1 << bytepos;\n      }\n\n      posval--;\n      bytepos--;\n\n      if (bytepos < 0) {\n        if (bytenew == 0xFF) {\n          writeByte(0xFF);\n          writeByte(0);\n        } else {\n          writeByte(bytenew);\n        }\n\n        bytepos = 7;\n        bytenew = 0;\n      }\n    }\n  }\n\n  function writeByte(value) {\n    //byteout.push(clt[value]); // write char directly instead of converting later\n    byteout.push(value);\n  }\n\n  function writeWord(value) {\n    writeByte(value >> 8 & 0xFF);\n    writeByte(value & 0xFF);\n  } // DCT & quantization core\n\n\n  function fDCTQuant(data, fdtbl) {\n    var d0, d1, d2, d3, d4, d5, d6, d7;\n    /* Pass 1: process rows. */\n\n    var dataOff = 0;\n    var i;\n    var I8 = 8;\n    var I64 = 64;\n\n    for (i = 0; i < I8; ++i) {\n      d0 = data[dataOff];\n      d1 = data[dataOff + 1];\n      d2 = data[dataOff + 2];\n      d3 = data[dataOff + 3];\n      d4 = data[dataOff + 4];\n      d5 = data[dataOff + 5];\n      d6 = data[dataOff + 6];\n      d7 = data[dataOff + 7];\n      var tmp0 = d0 + d7;\n      var tmp7 = d0 - d7;\n      var tmp1 = d1 + d6;\n      var tmp6 = d1 - d6;\n      var tmp2 = d2 + d5;\n      var tmp5 = d2 - d5;\n      var tmp3 = d3 + d4;\n      var tmp4 = d3 - d4;\n      /* Even part */\n\n      var tmp10 = tmp0 + tmp3;\n      /* phase 2 */\n\n      var tmp13 = tmp0 - tmp3;\n      var tmp11 = tmp1 + tmp2;\n      var tmp12 = tmp1 - tmp2;\n      data[dataOff] = tmp10 + tmp11;\n      /* phase 3 */\n\n      data[dataOff + 4] = tmp10 - tmp11;\n      var z1 = (tmp12 + tmp13) * 0.707106781;\n      /* c4 */\n\n      data[dataOff + 2] = tmp13 + z1;\n      /* phase 5 */\n\n      data[dataOff + 6] = tmp13 - z1;\n      /* Odd part */\n\n      tmp10 = tmp4 + tmp5;\n      /* phase 2 */\n\n      tmp11 = tmp5 + tmp6;\n      tmp12 = tmp6 + tmp7;\n      /* The rotator is modified from fig 4-8 to avoid extra negations. */\n\n      var z5 = (tmp10 - tmp12) * 0.382683433;\n      /* c6 */\n\n      var z2 = 0.541196100 * tmp10 + z5;\n      /* c2-c6 */\n\n      var z4 = 1.306562965 * tmp12 + z5;\n      /* c2+c6 */\n\n      var z3 = tmp11 * 0.707106781;\n      /* c4 */\n\n      var z11 = tmp7 + z3;\n      /* phase 5 */\n\n      var z13 = tmp7 - z3;\n      data[dataOff + 5] = z13 + z2;\n      /* phase 6 */\n\n      data[dataOff + 3] = z13 - z2;\n      data[dataOff + 1] = z11 + z4;\n      data[dataOff + 7] = z11 - z4;\n      dataOff += 8;\n      /* advance pointer to next row */\n    }\n    /* Pass 2: process columns. */\n\n\n    dataOff = 0;\n\n    for (i = 0; i < I8; ++i) {\n      d0 = data[dataOff];\n      d1 = data[dataOff + 8];\n      d2 = data[dataOff + 16];\n      d3 = data[dataOff + 24];\n      d4 = data[dataOff + 32];\n      d5 = data[dataOff + 40];\n      d6 = data[dataOff + 48];\n      d7 = data[dataOff + 56];\n      var tmp0p2 = d0 + d7;\n      var tmp7p2 = d0 - d7;\n      var tmp1p2 = d1 + d6;\n      var tmp6p2 = d1 - d6;\n      var tmp2p2 = d2 + d5;\n      var tmp5p2 = d2 - d5;\n      var tmp3p2 = d3 + d4;\n      var tmp4p2 = d3 - d4;\n      /* Even part */\n\n      var tmp10p2 = tmp0p2 + tmp3p2;\n      /* phase 2 */\n\n      var tmp13p2 = tmp0p2 - tmp3p2;\n      var tmp11p2 = tmp1p2 + tmp2p2;\n      var tmp12p2 = tmp1p2 - tmp2p2;\n      data[dataOff] = tmp10p2 + tmp11p2;\n      /* phase 3 */\n\n      data[dataOff + 32] = tmp10p2 - tmp11p2;\n      var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;\n      /* c4 */\n\n      data[dataOff + 16] = tmp13p2 + z1p2;\n      /* phase 5 */\n\n      data[dataOff + 48] = tmp13p2 - z1p2;\n      /* Odd part */\n\n      tmp10p2 = tmp4p2 + tmp5p2;\n      /* phase 2 */\n\n      tmp11p2 = tmp5p2 + tmp6p2;\n      tmp12p2 = tmp6p2 + tmp7p2;\n      /* The rotator is modified from fig 4-8 to avoid extra negations. */\n\n      var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;\n      /* c6 */\n\n      var z2p2 = 0.541196100 * tmp10p2 + z5p2;\n      /* c2-c6 */\n\n      var z4p2 = 1.306562965 * tmp12p2 + z5p2;\n      /* c2+c6 */\n\n      var z3p2 = tmp11p2 * 0.707106781;\n      /* c4 */\n\n      var z11p2 = tmp7p2 + z3p2;\n      /* phase 5 */\n\n      var z13p2 = tmp7p2 - z3p2;\n      data[dataOff + 40] = z13p2 + z2p2;\n      /* phase 6 */\n\n      data[dataOff + 24] = z13p2 - z2p2;\n      data[dataOff + 8] = z11p2 + z4p2;\n      data[dataOff + 56] = z11p2 - z4p2;\n      dataOff++;\n      /* advance pointer to next column */\n    } // Quantize/descale the coefficients\n\n\n    var fDCTQuant;\n\n    for (i = 0; i < I64; ++i) {\n      // Apply the quantization and scaling factor & Round to nearest integer\n      fDCTQuant = data[i] * fdtbl[i];\n      outputfDCTQuant[i] = fDCTQuant > 0.0 ? fDCTQuant + 0.5 | 0 : fDCTQuant - 0.5 | 0; //outputfDCTQuant[i] = fround(fDCTQuant);\n    }\n\n    return outputfDCTQuant;\n  }\n\n  function writeAPP0() {\n    writeWord(0xFFE0); // marker\n\n    writeWord(16); // length\n\n    writeByte(0x4A); // J\n\n    writeByte(0x46); // F\n\n    writeByte(0x49); // I\n\n    writeByte(0x46); // F\n\n    writeByte(0); // = \"JFIF\",'\\0'\n\n    writeByte(1); // versionhi\n\n    writeByte(1); // versionlo\n\n    writeByte(0); // xyunits\n\n    writeWord(1); // xdensity\n\n    writeWord(1); // ydensity\n\n    writeByte(0); // thumbnwidth\n\n    writeByte(0); // thumbnheight\n  }\n\n  function writeSOF0(width, height) {\n    writeWord(0xFFC0); // marker\n\n    writeWord(17); // length, truecolor YUV JPG\n\n    writeByte(8); // precision\n\n    writeWord(height);\n    writeWord(width);\n    writeByte(3); // nrofcomponents\n\n    writeByte(1); // IdY\n\n    writeByte(0x11); // HVY\n\n    writeByte(0); // QTY\n\n    writeByte(2); // IdU\n\n    writeByte(0x11); // HVU\n\n    writeByte(1); // QTU\n\n    writeByte(3); // IdV\n\n    writeByte(0x11); // HVV\n\n    writeByte(1); // QTV\n  }\n\n  function writeDQT() {\n    writeWord(0xFFDB); // marker\n\n    writeWord(132); // length\n\n    writeByte(0);\n\n    for (var i = 0; i < 64; i++) {\n      writeByte(YTable[i]);\n    }\n\n    writeByte(1);\n\n    for (var j = 0; j < 64; j++) {\n      writeByte(UVTable[j]);\n    }\n  }\n\n  function writeDHT() {\n    writeWord(0xFFC4); // marker\n\n    writeWord(0x01A2); // length\n\n    writeByte(0); // HTYDCinfo\n\n    for (var i = 0; i < 16; i++) {\n      writeByte(std_dc_luminance_nrcodes[i + 1]);\n    }\n\n    for (var j = 0; j <= 11; j++) {\n      writeByte(std_dc_luminance_values[j]);\n    }\n\n    writeByte(0x10); // HTYACinfo\n\n    for (var k = 0; k < 16; k++) {\n      writeByte(std_ac_luminance_nrcodes[k + 1]);\n    }\n\n    for (var l = 0; l <= 161; l++) {\n      writeByte(std_ac_luminance_values[l]);\n    }\n\n    writeByte(1); // HTUDCinfo\n\n    for (var m = 0; m < 16; m++) {\n      writeByte(std_dc_chrominance_nrcodes[m + 1]);\n    }\n\n    for (var n = 0; n <= 11; n++) {\n      writeByte(std_dc_chrominance_values[n]);\n    }\n\n    writeByte(0x11); // HTUACinfo\n\n    for (var o = 0; o < 16; o++) {\n      writeByte(std_ac_chrominance_nrcodes[o + 1]);\n    }\n\n    for (var p = 0; p <= 161; p++) {\n      writeByte(std_ac_chrominance_values[p]);\n    }\n  }\n\n  function writeSOS() {\n    writeWord(0xFFDA); // marker\n\n    writeWord(12); // length\n\n    writeByte(3); // nrofcomponents\n\n    writeByte(1); // IdY\n\n    writeByte(0); // HTY\n\n    writeByte(2); // IdU\n\n    writeByte(0x11); // HTU\n\n    writeByte(3); // IdV\n\n    writeByte(0x11); // HTV\n\n    writeByte(0); // Ss\n\n    writeByte(0x3f); // Se\n\n    writeByte(0); // Bf\n  }\n\n  function processDU(CDU, fdtbl, DC, HTDC, HTAC) {\n    var EOB = HTAC[0x00];\n    var M16zeroes = HTAC[0xF0];\n    var pos;\n    var I16 = 16;\n    var I63 = 63;\n    var I64 = 64;\n    var DU_DCT = fDCTQuant(CDU, fdtbl); //ZigZag reorder\n\n    for (var j = 0; j < I64; ++j) {\n      DU[ZigZag[j]] = DU_DCT[j];\n    }\n\n    var Diff = DU[0] - DC;\n    DC = DU[0]; //Encode DC\n\n    if (Diff == 0) {\n      writeBits(HTDC[0]); // Diff might be 0\n    } else {\n      pos = 32767 + Diff;\n      writeBits(HTDC[category[pos]]);\n      writeBits(bitcode[pos]);\n    } //Encode ACs\n\n\n    var end0pos = 63; // was const... which is crazy\n\n    for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {}\n\n    if (end0pos == 0) {\n      writeBits(EOB);\n      return DC;\n    }\n\n    var i = 1;\n    var lng;\n\n    while (i <= end0pos) {\n      var startpos = i;\n\n      for (; DU[i] == 0 && i <= end0pos; ++i) {}\n\n      var nrzeroes = i - startpos;\n\n      if (nrzeroes >= I16) {\n        lng = nrzeroes >> 4;\n\n        for (var nrmarker = 1; nrmarker <= lng; ++nrmarker) {\n          writeBits(M16zeroes);\n        }\n\n        nrzeroes = nrzeroes & 0xF;\n      }\n\n      pos = 32767 + DU[i];\n      writeBits(HTAC[(nrzeroes << 4) + category[pos]]);\n      writeBits(bitcode[pos]);\n      i++;\n    }\n\n    if (end0pos != I63) {\n      writeBits(EOB);\n    }\n\n    return DC;\n  }\n\n  function initCharLookupTable() {\n    var sfcc = String.fromCharCode;\n\n    for (var i = 0; i < 256; i++) {\n      ///// ACHTUNG // 255\n      clt[i] = sfcc(i);\n    }\n  }\n\n  this.encode = function (image, quality) // image data object\n  {\n    var time_start = new Date().getTime();\n    if (quality) setQuality(quality); // Initialize bit writer\n\n    byteout = new Array();\n    bytenew = 0;\n    bytepos = 7; // Add JPEG headers\n\n    writeWord(0xFFD8); // SOI\n\n    writeAPP0();\n    writeDQT();\n    writeSOF0(image.width, image.height);\n    writeDHT();\n    writeSOS(); // Encode 8x8 macroblocks\n\n    var DCY = 0;\n    var DCU = 0;\n    var DCV = 0;\n    bytenew = 0;\n    bytepos = 7;\n    this.encode.displayName = \"_encode_\";\n    var imageData = image.data;\n    var width = image.width;\n    var height = image.height;\n    var quadWidth = width * 4;\n    var x,\n        y = 0;\n    var r, g, b;\n    var start, p, col, row, pos;\n\n    while (y < height) {\n      x = 0;\n\n      while (x < quadWidth) {\n        start = quadWidth * y + x;\n        p = start;\n        col = -1;\n        row = 0;\n\n        for (pos = 0; pos < 64; pos++) {\n          row = pos >> 3; // /8\n\n          col = (pos & 7) * 4; // %8\n\n          p = start + row * quadWidth + col;\n\n          if (y + row >= height) {\n            // padding bottom\n            p -= quadWidth * (y + 1 + row - height);\n          }\n\n          if (x + col >= quadWidth) {\n            // padding right\t\n            p -= x + col - quadWidth + 4;\n          }\n\n          r = imageData[p++];\n          g = imageData[p++];\n          b = imageData[p++];\n          /* // calculate YUV values dynamically\n          YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80\n          UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));\n          VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));\n          */\n          // use lookup table (slightly faster)\n\n          YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;\n          UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;\n          VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;\n        }\n\n        DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n        DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\n        DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\n        x += 32;\n      }\n\n      y += 8;\n    } ////////////////////////////////////////////////////////////////\n    // Do the bit alignment of the EOI marker\n\n\n    if (bytepos >= 0) {\n      var fillbits = [];\n      fillbits[1] = bytepos + 1;\n      fillbits[0] = (1 << bytepos + 1) - 1;\n      writeBits(fillbits);\n    }\n\n    writeWord(0xFFD9); //EOI\n\n    return new Uint8Array(byteout);\n  };\n\n  function setQuality(quality) {\n    if (quality <= 0) {\n      quality = 1;\n    }\n\n    if (quality > 100) {\n      quality = 100;\n    }\n\n    if (currentQuality == quality) return; // don't recalc if unchanged\n\n    var sf = 0;\n\n    if (quality < 50) {\n      sf = Math.floor(5000 / quality);\n    } else {\n      sf = Math.floor(200 - quality * 2);\n    }\n\n    initQuantTables(sf);\n    currentQuality = quality; //console.log('Quality set to: '+quality +'%');\n  }\n\n  function init() {\n    var time_start = new Date().getTime();\n    if (!quality) quality = 50; // Create tables\n\n    initCharLookupTable();\n    initHuffmanTbl();\n    initCategoryNumber();\n    initRGBYUVTable();\n    setQuality(quality);\n    var duration = new Date().getTime() - time_start; //console.log('Initialization '+ duration + 'ms');\n  }\n\n  init();\n}\n/*rollup-keeper-start*/\n\nwindow.tmp = JPEGEncoder;\n/*rollup-keeper-end*/\n\n/**\n * @author shaozilee\n *\n * Bmp format decoder,support 1bit 4bit 8bit 24bit bmp\n *\n */\nfunction BmpDecoder(buffer, is_with_alpha) {\n  this.pos = 0;\n  this.buffer = buffer;\n  this.datav = new DataView(buffer.buffer);\n  this.is_with_alpha = !!is_with_alpha;\n  this.bottom_up = true;\n  this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]);\n  this.pos += 2;\n  if ([\"BM\", \"BA\", \"CI\", \"CP\", \"IC\", \"PT\"].indexOf(this.flag) === -1) throw new Error(\"Invalid BMP File\");\n  this.parseHeader();\n  this.parseBGR();\n}\n\nBmpDecoder.prototype.parseHeader = function () {\n  this.fileSize = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.reserved = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.offset = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.headerSize = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.width = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.height = this.datav.getInt32(this.pos, true);\n  this.pos += 4;\n  this.planes = this.datav.getUint16(this.pos, true);\n  this.pos += 2;\n  this.bitPP = this.datav.getUint16(this.pos, true);\n  this.pos += 2;\n  this.compress = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.rawSize = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.hr = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.vr = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.colors = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n  this.importantColors = this.datav.getUint32(this.pos, true);\n  this.pos += 4;\n\n  if (this.bitPP === 16 && this.is_with_alpha) {\n    this.bitPP = 15;\n  }\n\n  if (this.bitPP < 15) {\n    var len = this.colors === 0 ? 1 << this.bitPP : this.colors;\n    this.palette = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      var blue = this.datav.getUint8(this.pos++, true);\n      var green = this.datav.getUint8(this.pos++, true);\n      var red = this.datav.getUint8(this.pos++, true);\n      var quad = this.datav.getUint8(this.pos++, true);\n      this.palette[i] = {\n        red: red,\n        green: green,\n        blue: blue,\n        quad: quad\n      };\n    }\n  }\n\n  if (this.height < 0) {\n    this.height *= -1;\n    this.bottom_up = false;\n  }\n};\n\nBmpDecoder.prototype.parseBGR = function () {\n  this.pos = this.offset;\n\n  try {\n    var bitn = \"bit\" + this.bitPP;\n    var len = this.width * this.height * 4;\n    this.data = new Uint8Array(len);\n    this[bitn]();\n  } catch (e) {\n    console.log(\"bit decode error:\" + e);\n  }\n};\n\nBmpDecoder.prototype.bit1 = function () {\n  var xlen = Math.ceil(this.width / 8);\n  var mode = xlen % 4;\n  var y = this.height >= 0 ? this.height - 1 : -this.height;\n\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y;\n\n    for (var x = 0; x < xlen; x++) {\n      var b = this.datav.getUint8(this.pos++, true);\n      var location = line * this.width * 4 + x * 8 * 4;\n\n      for (var i = 0; i < 8; i++) {\n        if (x * 8 + i < this.width) {\n          var rgb = this.palette[b >> 7 - i & 0x1];\n          this.data[location + i * 4] = rgb.blue;\n          this.data[location + i * 4 + 1] = rgb.green;\n          this.data[location + i * 4 + 2] = rgb.red;\n          this.data[location + i * 4 + 3] = 0xFF;\n        } else {\n          break;\n        }\n      }\n    }\n\n    if (mode != 0) {\n      this.pos += 4 - mode;\n    }\n  }\n};\n\nBmpDecoder.prototype.bit4 = function () {\n  var xlen = Math.ceil(this.width / 2);\n  var mode = xlen % 4;\n\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y;\n\n    for (var x = 0; x < xlen; x++) {\n      var b = this.datav.getUint8(this.pos++, true);\n      var location = line * this.width * 4 + x * 2 * 4;\n      var before = b >> 4;\n      var after = b & 0x0F;\n      var rgb = this.palette[before];\n      this.data[location] = rgb.blue;\n      this.data[location + 1] = rgb.green;\n      this.data[location + 2] = rgb.red;\n      this.data[location + 3] = 0xFF;\n      if (x * 2 + 1 >= this.width) break;\n      rgb = this.palette[after];\n      this.data[location + 4] = rgb.blue;\n      this.data[location + 4 + 1] = rgb.green;\n      this.data[location + 4 + 2] = rgb.red;\n      this.data[location + 4 + 3] = 0xFF;\n    }\n\n    if (mode != 0) {\n      this.pos += 4 - mode;\n    }\n  }\n};\n\nBmpDecoder.prototype.bit8 = function () {\n  var mode = this.width % 4;\n\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y;\n\n    for (var x = 0; x < this.width; x++) {\n      var b = this.datav.getUint8(this.pos++, true);\n      var location = line * this.width * 4 + x * 4;\n\n      if (b < this.palette.length) {\n        var rgb = this.palette[b];\n        this.data[location] = rgb.red;\n        this.data[location + 1] = rgb.green;\n        this.data[location + 2] = rgb.blue;\n        this.data[location + 3] = 0xFF;\n      } else {\n        this.data[location] = 0xFF;\n        this.data[location + 1] = 0xFF;\n        this.data[location + 2] = 0xFF;\n        this.data[location + 3] = 0xFF;\n      }\n    }\n\n    if (mode != 0) {\n      this.pos += 4 - mode;\n    }\n  }\n};\n\nBmpDecoder.prototype.bit15 = function () {\n  var dif_w = this.width % 3;\n\n  var _11111 = parseInt(\"11111\", 2),\n      _1_5 = _11111;\n\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y;\n\n    for (var x = 0; x < this.width; x++) {\n      var B = this.datav.getUint16(this.pos, true);\n      this.pos += 2;\n      var blue = (B & _1_5) / _1_5 * 255 | 0;\n      var green = (B >> 5 & _1_5) / _1_5 * 255 | 0;\n      var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;\n      var alpha = B >> 15 ? 0xFF : 0x00;\n      var location = line * this.width * 4 + x * 4;\n      this.data[location] = red;\n      this.data[location + 1] = green;\n      this.data[location + 2] = blue;\n      this.data[location + 3] = alpha;\n    } //skip extra bytes\n\n\n    this.pos += dif_w;\n  }\n};\n\nBmpDecoder.prototype.bit16 = function () {\n  var dif_w = this.width % 3;\n\n  var _11111 = parseInt(\"11111\", 2),\n      _1_5 = _11111;\n\n  var _111111 = parseInt(\"111111\", 2),\n      _1_6 = _111111;\n\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y;\n\n    for (var x = 0; x < this.width; x++) {\n      var B = this.datav.getUint16(this.pos, true);\n      this.pos += 2;\n      var alpha = 0xFF;\n      var blue = (B & _1_5) / _1_5 * 255 | 0;\n      var green = (B >> 5 & _1_6) / _1_6 * 255 | 0;\n      var red = (B >> 11) / _1_5 * 255 | 0;\n      var location = line * this.width * 4 + x * 4;\n      this.data[location] = red;\n      this.data[location + 1] = green;\n      this.data[location + 2] = blue;\n      this.data[location + 3] = alpha;\n    } //skip extra bytes\n\n\n    this.pos += dif_w;\n  }\n};\n\nBmpDecoder.prototype.bit24 = function () {\n  //when height > 0\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y;\n\n    for (var x = 0; x < this.width; x++) {\n      var blue = this.datav.getUint8(this.pos++, true);\n      var green = this.datav.getUint8(this.pos++, true);\n      var red = this.datav.getUint8(this.pos++, true);\n      var location = line * this.width * 4 + x * 4;\n      this.data[location] = red;\n      this.data[location + 1] = green;\n      this.data[location + 2] = blue;\n      this.data[location + 3] = 0xFF;\n    } //skip extra bytes\n\n\n    this.pos += this.width % 4;\n  }\n};\n/**\n * add 32bit decode func\n * @author soubok\n */\n\n\nBmpDecoder.prototype.bit32 = function () {\n  //when height > 0\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y;\n\n    for (var x = 0; x < this.width; x++) {\n      var blue = this.datav.getUint8(this.pos++, true);\n      var green = this.datav.getUint8(this.pos++, true);\n      var red = this.datav.getUint8(this.pos++, true);\n      var alpha = this.datav.getUint8(this.pos++, true);\n      var location = line * this.width * 4 + x * 4;\n      this.data[location] = red;\n      this.data[location + 1] = green;\n      this.data[location + 2] = blue;\n      this.data[location + 3] = alpha;\n    } //skip extra bytes\n    //this.pos += (this.width % 4);\n\n  }\n};\n\nBmpDecoder.prototype.getData = function () {\n  return this.data;\n};\n/*rollup-keeper-start*/\n\n\nwindow.tmp = BmpDecoder;\n/*rollup-keeper-end*/\n\n/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\n * JZlib is based on zlib-1.1.3, so all credit should go authors\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\n * and contributors of zlib.\n */\n(function (global) {\n\n  var MAX_BITS = 15;\n  var D_CODES = 30;\n  var BL_CODES = 19;\n  var LENGTH_CODES = 29;\n  var LITERALS = 256;\n  var L_CODES = LITERALS + 1 + LENGTH_CODES;\n  var HEAP_SIZE = 2 * L_CODES + 1;\n  var END_BLOCK = 256; // Bit length codes must not exceed MAX_BL_BITS bits\n\n  var MAX_BL_BITS = 7; // repeat previous bit length 3-6 times (2 bits of repeat count)\n\n  var REP_3_6 = 16; // repeat a zero length 3-10 times (3 bits of repeat count)\n\n  var REPZ_3_10 = 17; // repeat a zero length 11-138 times (7 bits of repeat count)\n\n  var REPZ_11_138 = 18; // The lengths of the bit length codes are sent in order of decreasing\n  // probability, to avoid transmitting the lengths for unused bit\n  // length codes.\n\n  var Buf_size = 8 * 2; // JZlib version : \"1.0.2\"\n\n  var Z_DEFAULT_COMPRESSION = -1; // compression strategy\n\n  var Z_FILTERED = 1;\n  var Z_HUFFMAN_ONLY = 2;\n  var Z_DEFAULT_STRATEGY = 0;\n  var Z_NO_FLUSH = 0;\n  var Z_PARTIAL_FLUSH = 1;\n  var Z_FULL_FLUSH = 3;\n  var Z_FINISH = 4;\n  var Z_OK = 0;\n  var Z_STREAM_END = 1;\n  var Z_NEED_DICT = 2;\n  var Z_STREAM_ERROR = -2;\n  var Z_DATA_ERROR = -3;\n  var Z_BUF_ERROR = -5; // Tree\n  // see definition of array dist_code below\n\n  var _dist_code = [0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29];\n\n  function Tree() {\n    var that = this; // dyn_tree; // the dynamic tree\n    // max_code; // largest code with non zero frequency\n    // stat_desc; // the corresponding static tree\n    // Compute the optimal bit lengths for a tree and update the total bit\n    // length\n    // for the current block.\n    // IN assertion: the fields freq and dad are set, heap[heap_max] and\n    // above are the tree nodes sorted by increasing frequency.\n    // OUT assertions: the field len is set to the optimal bit length, the\n    // array bl_count contains the frequencies for each bit length.\n    // The length opt_len is updated; static_len is also updated if stree is\n    // not null.\n\n    function gen_bitlen(s) {\n      var tree = that.dyn_tree;\n      var stree = that.stat_desc.static_tree;\n      var extra = that.stat_desc.extra_bits;\n      var base = that.stat_desc.extra_base;\n      var max_length = that.stat_desc.max_length;\n      var h; // heap index\n\n      var n, m; // iterate over the tree elements\n\n      var bits; // bit length\n\n      var xbits; // extra bits\n\n      var f; // frequency\n\n      var overflow = 0; // number of elements with bit length too large\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0;\n      } // In a first pass, compute the optimal bit lengths (which may\n      // overflow in the case of the bit length tree).\n\n\n      tree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap\n\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n\n        if (bits > max_length) {\n          bits = max_length;\n          overflow++;\n        }\n\n        tree[n * 2 + 1] = bits; // We overwrite tree[n*2+1] which is no longer needed\n\n        if (n > that.max_code) continue; // not a leaf node\n\n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) xbits = extra[n - base];\n        f = tree[n * 2];\n        s.opt_len += f * (bits + xbits);\n        if (stree) s.static_len += f * (stree[n * 2 + 1] + xbits);\n      }\n\n      if (overflow === 0) return; // This happens for example on obj2 and pic of the Calgary corpus\n      // Find the first bit length which could increase:\n\n      do {\n        bits = max_length - 1;\n\n        while (s.bl_count[bits] === 0) {\n          bits--;\n        }\n\n        s.bl_count[bits]--; // move one leaf down the tree\n\n        s.bl_count[bits + 1] += 2; // move one overflow item as its brother\n\n        s.bl_count[max_length]--; // The brother of the overflow item also moves one step up,\n        // but this does not affect bl_count[max_length]\n\n        overflow -= 2;\n      } while (overflow > 0);\n\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits];\n\n        while (n !== 0) {\n          m = s.heap[--h];\n          if (m > that.max_code) continue;\n\n          if (tree[m * 2 + 1] != bits) {\n            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n            tree[m * 2 + 1] = bits;\n          }\n\n          n--;\n        }\n      }\n    } // Reverse the first len bits of a code, using straightforward code (a\n    // faster\n    // method would use a table)\n    // IN assertion: 1 <= len <= 15\n\n\n    function bi_reverse(code, // the value to invert\n    len // its bit length\n    ) {\n      var res = 0;\n\n      do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n      } while (--len > 0);\n\n      return res >>> 1;\n    } // Generate the codes for a given tree and bit counts (which need not be\n    // optimal).\n    // IN assertion: the array bl_count contains the bit length statistics for\n    // the given tree and the field len is set for all tree elements.\n    // OUT assertion: the field code is set for all tree elements of non\n    // zero code length.\n\n\n    function gen_codes(tree, // the tree to decorate\n    max_code, // largest code with non zero frequency\n    bl_count // number of codes at each bit length\n    ) {\n      var next_code = []; // next code value for each\n      // bit length\n\n      var code = 0; // running code value\n\n      var bits; // bit index\n\n      var n; // code index\n\n      var len; // The distribution counts are first used to generate the code values\n      // without bit reversal.\n\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n      } // Check that the bit counts in bl_count are consistent. The last code\n      // must be all ones.\n      // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n      // \"inconsistent bit counts\");\n      // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\n      for (n = 0; n <= max_code; n++) {\n        len = tree[n * 2 + 1];\n        if (len === 0) continue; // Now reverse the bits\n\n        tree[n * 2] = bi_reverse(next_code[len]++, len);\n      }\n    } // Construct one Huffman tree and assigns the code bit strings and lengths.\n    // Update the total bit length for the current block.\n    // IN assertion: the field freq is set for all tree elements.\n    // OUT assertions: the fields len and code are set to the optimal bit length\n    // and corresponding code. The length opt_len is updated; static_len is\n    // also updated if stree is not null. The field max_code is set.\n\n\n    that.build_tree = function (s) {\n      var tree = that.dyn_tree;\n      var stree = that.stat_desc.static_tree;\n      var elems = that.stat_desc.elems;\n      var n, m; // iterate over heap elements\n\n      var max_code = -1; // largest code with non zero frequency\n\n      var node; // new node being created\n      // Construct the initial heap, with least frequent element in\n      // heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n      // heap[0] is not used.\n\n      s.heap_len = 0;\n      s.heap_max = HEAP_SIZE;\n\n      for (n = 0; n < elems; n++) {\n        if (tree[n * 2] !== 0) {\n          s.heap[++s.heap_len] = max_code = n;\n          s.depth[n] = 0;\n        } else {\n          tree[n * 2 + 1] = 0;\n        }\n      } // The pkzip format requires that at least one distance code exists,\n      // and that at least one bit should be sent even if there is only one\n      // possible code. So to avoid special checks later on we force at least\n      // two codes of non zero frequency.\n\n\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] = 1;\n        s.depth[node] = 0;\n        s.opt_len--;\n        if (stree) s.static_len -= stree[node * 2 + 1]; // node is 0 or 1 so it does not have extra bits\n      }\n\n      that.max_code = max_code; // The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n      // establish sub-heaps of increasing lengths:\n\n      for (n = Math.floor(s.heap_len / 2); n >= 1; n--) {\n        s.pqdownheap(tree, n);\n      } // Construct the Huffman tree by repeatedly combining the least two\n      // frequent nodes.\n\n\n      node = elems; // next internal node of the tree\n\n      do {\n        // n = node of least frequency\n        n = s.heap[1];\n        s.heap[1] = s.heap[s.heap_len--];\n        s.pqdownheap(tree, 1);\n        m = s.heap[1]; // m = node of next least frequency\n\n        s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency\n\n        s.heap[--s.heap_max] = m; // Create a new node father of n and m\n\n        tree[node * 2] = tree[n * 2] + tree[m * 2];\n        s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;\n        tree[n * 2 + 1] = tree[m * 2 + 1] = node; // and insert the new node in the heap\n\n        s.heap[1] = node++;\n        s.pqdownheap(tree, 1);\n      } while (s.heap_len >= 2);\n\n      s.heap[--s.heap_max] = s.heap[1]; // At this point, the fields freq and dad are set. We can now\n      // generate the bit lengths.\n\n      gen_bitlen(s); // The field len is now set, we can generate the bit codes\n\n      gen_codes(tree, that.max_code, s.bl_count);\n    };\n  }\n\n  Tree._length_code = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28];\n  Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];\n  Tree.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576]; // Mapping from a distance to a distance code. dist is the distance - 1 and\n  // must not have side effects. _dist_code[256] and _dist_code[257] are never\n  // used.\n\n  Tree.d_code = function (dist) {\n    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n  }; // extra bits for each length code\n\n\n  Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]; // extra bits for each distance code\n\n  Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]; // extra bits for each bit length code\n\n  Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n  Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; // StaticTree\n\n  function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {\n    var that = this;\n    that.static_tree = static_tree;\n    that.extra_bits = extra_bits;\n    that.extra_base = extra_base;\n    that.elems = elems;\n    that.max_length = max_length;\n  }\n\n  StaticTree.static_ltree = [12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8, 130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42, 8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8, 22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8, 222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113, 8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8, 69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8, 173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9, 51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9, 427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379, 9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23, 9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9, 399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9, 223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7, 40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8, 99, 8, 227, 8];\n  StaticTree.static_dtree = [0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5, 25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5];\n  StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);\n  StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS); // Deflate\n\n  var MAX_MEM_LEVEL = 9;\n  var DEF_MEM_LEVEL = 8;\n\n  function Config(good_length, max_lazy, nice_length, max_chain, func) {\n    var that = this;\n    that.good_length = good_length;\n    that.max_lazy = max_lazy;\n    that.nice_length = nice_length;\n    that.max_chain = max_chain;\n    that.func = func;\n  }\n\n  var STORED = 0;\n  var FAST = 1;\n  var SLOW = 2;\n  var config_table = [new Config(0, 0, 0, 0, STORED), new Config(4, 4, 8, 4, FAST), new Config(4, 5, 16, 8, FAST), new Config(4, 6, 32, 32, FAST), new Config(4, 4, 16, 16, SLOW), new Config(8, 16, 32, 32, SLOW), new Config(8, 16, 128, 128, SLOW), new Config(8, 32, 128, 256, SLOW), new Config(32, 128, 258, 1024, SLOW), new Config(32, 258, 258, 4096, SLOW)];\n  var z_errmsg = [\"need dictionary\", // Z_NEED_DICT\n  // 2\n  \"stream end\", // Z_STREAM_END 1\n  \"\", // Z_OK 0\n  \"\", // Z_ERRNO (-1)\n  \"stream error\", // Z_STREAM_ERROR (-2)\n  \"data error\", // Z_DATA_ERROR (-3)\n  \"\", // Z_MEM_ERROR (-4)\n  \"buffer error\", // Z_BUF_ERROR (-5)\n  \"\", // Z_VERSION_ERROR (-6)\n  \"\"]; // block not completed, need more input or more output\n\n  var NeedMore = 0; // block flush performed\n\n  var BlockDone = 1; // finish started, need only more output at next deflate\n\n  var FinishStarted = 2; // finish done, accept no more input or output\n\n  var FinishDone = 3; // preset dictionary flag in zlib header\n\n  var PRESET_DICT = 0x20;\n  var INIT_STATE = 42;\n  var BUSY_STATE = 113;\n  var FINISH_STATE = 666; // The deflate compression method\n\n  var Z_DEFLATED = 8;\n  var STORED_BLOCK = 0;\n  var STATIC_TREES = 1;\n  var DYN_TREES = 2;\n  var MIN_MATCH = 3;\n  var MAX_MATCH = 258;\n  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\n\n  function smaller(tree, n, m, depth) {\n    var tn2 = tree[n * 2];\n    var tm2 = tree[m * 2];\n    return tn2 < tm2 || tn2 == tm2 && depth[n] <= depth[m];\n  }\n\n  function Deflate() {\n    var that = this;\n    var strm; // pointer back to this zlib stream\n\n    var status; // as the name implies\n    // pending_buf; // output still pending\n\n    var pending_buf_size; // size of pending_buf\n\n    var last_flush; // value of flush param for previous deflate call\n\n    var w_size; // LZ77 window size (32K by default)\n\n    var w_bits; // log2(w_size) (8..16)\n\n    var w_mask; // w_size - 1\n\n    var window; // Sliding window. Input bytes are read into the second half of the window,\n    // and move to the first half later to keep a dictionary of at least wSize\n    // bytes. With this organization, matches are limited to a distance of\n    // wSize-MAX_MATCH bytes, but this ensures that IO is always\n    // performed with a length multiple of the block size. Also, it limits\n    // the window size to 64K, which is quite useful on MSDOS.\n    // To do: use the user input buffer as sliding window.\n\n    var window_size; // Actual size of window: 2*wSize, except when the user input buffer\n    // is directly used as sliding window.\n\n    var prev; // Link to older string with same hash index. To limit the size of this\n    // array to 64K, this link is maintained only for the last 32K strings.\n    // An index in this array is thus a window index modulo 32K.\n\n    var head; // Heads of the hash chains or NIL.\n\n    var ins_h; // hash index of string to be inserted\n\n    var hash_size; // number of elements in hash table\n\n    var hash_bits; // log2(hash_size)\n\n    var hash_mask; // hash_size-1\n    // Number of bits by which ins_h must be shifted at each input\n    // step. It must be such that after MIN_MATCH steps, the oldest\n    // byte no longer takes part in the hash key, that is:\n    // hash_shift * MIN_MATCH >= hash_bits\n\n    var hash_shift; // Window position at the beginning of the current output block. Gets\n    // negative when the window is moved backwards.\n\n    var block_start;\n    var match_length; // length of best match\n\n    var prev_match; // previous match\n\n    var match_available; // set if previous match exists\n\n    var strstart; // start of string to insert\n\n    var match_start; // start of matching string\n\n    var lookahead; // number of valid bytes ahead in window\n    // Length of the best match at previous step. Matches not greater than this\n    // are discarded. This is used in the lazy match evaluation.\n\n    var prev_length; // To speed up deflation, hash chains are never searched beyond this\n    // length. A higher limit improves compression ratio but degrades the speed.\n\n    var max_chain_length; // Attempt to find a better match only when the current match is strictly\n    // smaller than this value. This mechanism is used only for compression\n    // levels >= 4.\n\n    var max_lazy_match; // Insert new strings in the hash table only if the match length is not\n    // greater than this length. This saves time but degrades compression.\n    // max_insert_length is used only for compression levels <= 3.\n\n    var level; // compression level (1..9)\n\n    var strategy; // favor or force Huffman coding\n    // Use a faster search when the previous match is longer than this\n\n    var good_match; // Stop searching when current match exceeds this\n\n    var nice_match;\n    var dyn_ltree; // literal and length tree\n\n    var dyn_dtree; // distance tree\n\n    var bl_tree; // Huffman tree for bit lengths\n\n    var l_desc = new Tree(); // desc for literal tree\n\n    var d_desc = new Tree(); // desc for distance tree\n\n    var bl_desc = new Tree(); // desc for bit length tree\n    // that.heap_len; // number of elements in the heap\n    // that.heap_max; // element of largest frequency\n    // The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n    // The same heap array is used to build all trees.\n    // Depth of each subtree used as tie breaker for trees of equal frequency\n\n    that.depth = [];\n    var l_buf; // index for literals or lengths */\n    // Size of match buffer for literals/lengths. There are 4 reasons for\n    // limiting lit_bufsize to 64K:\n    // - frequencies can be kept in 16 bit counters\n    // - if compression is not successful for the first block, all input\n    // data is still in the window so we can still emit a stored block even\n    // when input comes from standard input. (This can also be done for\n    // all blocks if lit_bufsize is not greater than 32K.)\n    // - if compression is not successful for a file smaller than 64K, we can\n    // even emit a stored file instead of a stored block (saving 5 bytes).\n    // This is applicable only for zip (not gzip or zlib).\n    // - creating new Huffman trees less frequently may not provide fast\n    // adaptation to changes in the input data statistics. (Take for\n    // example a binary file with poorly compressible code followed by\n    // a highly compressible string table.) Smaller buffer sizes give\n    // fast adaptation but have of course the overhead of transmitting\n    // trees more frequently.\n    // - I can't count above 4\n\n    var lit_bufsize;\n    var last_lit; // running index in l_buf\n    // Buffer for distances. To simplify the code, d_buf and l_buf have\n    // the same number of elements. To use different lengths, an extra flag\n    // array would be necessary.\n\n    var d_buf; // index of pendig_buf\n    // that.opt_len; // bit length of current block with optimal trees\n    // that.static_len; // bit length of current block with static trees\n\n    var matches; // number of string matches in current block\n\n    var last_eob_len; // bit length of EOB code for last block\n    // Output buffer. bits are inserted starting at the bottom (least\n    // significant bits).\n\n    var bi_buf; // Number of valid bits in bi_buf. All bits above the last valid bit\n    // are always zero.\n\n    var bi_valid; // number of codes at each bit length for an optimal tree\n\n    that.bl_count = []; // heap used to build the Huffman trees\n\n    that.heap = [];\n    dyn_ltree = [];\n    dyn_dtree = [];\n    bl_tree = [];\n\n    function lm_init() {\n      var i;\n      window_size = 2 * w_size;\n      head[hash_size - 1] = 0;\n\n      for (i = 0; i < hash_size - 1; i++) {\n        head[i] = 0;\n      } // Set the default configuration parameters:\n\n\n      max_lazy_match = config_table[level].max_lazy;\n      good_match = config_table[level].good_length;\n      nice_match = config_table[level].nice_length;\n      max_chain_length = config_table[level].max_chain;\n      strstart = 0;\n      block_start = 0;\n      lookahead = 0;\n      match_length = prev_length = MIN_MATCH - 1;\n      match_available = 0;\n      ins_h = 0;\n    }\n\n    function init_block() {\n      var i; // Initialize the trees.\n\n      for (i = 0; i < L_CODES; i++) {\n        dyn_ltree[i * 2] = 0;\n      }\n\n      for (i = 0; i < D_CODES; i++) {\n        dyn_dtree[i * 2] = 0;\n      }\n\n      for (i = 0; i < BL_CODES; i++) {\n        bl_tree[i * 2] = 0;\n      }\n\n      dyn_ltree[END_BLOCK * 2] = 1;\n      that.opt_len = that.static_len = 0;\n      last_lit = matches = 0;\n    } // Initialize the tree data structures for a new zlib stream.\n\n\n    function tr_init() {\n      l_desc.dyn_tree = dyn_ltree;\n      l_desc.stat_desc = StaticTree.static_l_desc;\n      d_desc.dyn_tree = dyn_dtree;\n      d_desc.stat_desc = StaticTree.static_d_desc;\n      bl_desc.dyn_tree = bl_tree;\n      bl_desc.stat_desc = StaticTree.static_bl_desc;\n      bi_buf = 0;\n      bi_valid = 0;\n      last_eob_len = 8; // enough lookahead for inflate\n      // Initialize the first block of the first file:\n\n      init_block();\n    } // Restore the heap property by moving down the tree starting at node k,\n    // exchanging a node with the smallest of its two sons if necessary,\n    // stopping\n    // when the heap property is re-established (each father smaller than its\n    // two sons).\n\n\n    that.pqdownheap = function (tree, // the tree to restore\n    k // node to move down\n    ) {\n      var heap = that.heap;\n      var v = heap[k];\n      var j = k << 1; // left son of k\n\n      while (j <= that.heap_len) {\n        // Set j to the smallest of the two sons:\n        if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {\n          j++;\n        } // Exit if v is smaller than both sons\n\n\n        if (smaller(tree, v, heap[j], that.depth)) break; // Exchange v with the smallest son\n\n        heap[k] = heap[j];\n        k = j; // And continue down the tree, setting j to the left son of k\n\n        j <<= 1;\n      }\n\n      heap[k] = v;\n    }; // Scan a literal or distance tree to determine the frequencies of the codes\n    // in the bit length tree.\n\n\n    function scan_tree(tree, // the tree to be scanned\n    max_code // and its largest code of non zero frequency\n    ) {\n      var n; // iterates over all tree elements\n\n      var prevlen = -1; // last emitted length\n\n      var curlen; // length of current code\n\n      var nextlen = tree[0 * 2 + 1]; // length of next code\n\n      var count = 0; // repeat count of the current code\n\n      var max_count = 7; // max repeat count\n\n      var min_count = 4; // min repeat count\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n\n      tree[(max_code + 1) * 2 + 1] = 0xffff; // guard\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n\n        if (++count < max_count && curlen == nextlen) {\n          continue;\n        } else if (count < min_count) {\n          bl_tree[curlen * 2] += count;\n        } else if (curlen !== 0) {\n          if (curlen != prevlen) bl_tree[curlen * 2]++;\n          bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10) {\n          bl_tree[REPZ_3_10 * 2]++;\n        } else {\n          bl_tree[REPZ_11_138 * 2]++;\n        }\n\n        count = 0;\n        prevlen = curlen;\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen == nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    } // Construct the Huffman tree for the bit lengths and return the index in\n    // bl_order of the last bit length code to send.\n\n\n    function build_bl_tree() {\n      var max_blindex; // index of last bit length code of non zero freq\n      // Determine the bit length frequencies for literal and distance trees\n\n      scan_tree(dyn_ltree, l_desc.max_code);\n      scan_tree(dyn_dtree, d_desc.max_code); // Build the bit length tree:\n\n      bl_desc.build_tree(that); // opt_len now includes the length of the tree representations, except\n      // the lengths of the bit lengths codes and the 5+5+4 bits for the\n      // counts.\n      // Determine the number of bit length codes to send. The pkzip format\n      // requires that at least 4 bit length codes be sent. (appnote.txt says\n      // 3 but the actual value used is 4.)\n\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0) break;\n      } // Update opt_len to include the bit length tree and counts\n\n\n      that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n      return max_blindex;\n    } // Output a byte on the stream.\n    // IN assertion: there is enough room in pending_buf.\n\n\n    function put_byte(p) {\n      that.pending_buf[that.pending++] = p;\n    }\n\n    function put_short(w) {\n      put_byte(w & 0xff);\n      put_byte(w >>> 8 & 0xff);\n    }\n\n    function putShortMSB(b) {\n      put_byte(b >> 8 & 0xff);\n      put_byte(b & 0xff & 0xff);\n    }\n\n    function send_bits(value, length) {\n      var val,\n          len = length;\n\n      if (bi_valid > Buf_size - len) {\n        val = value; // bi_buf |= (val << bi_valid);\n\n        bi_buf |= val << bi_valid & 0xffff;\n        put_short(bi_buf);\n        bi_buf = val >>> Buf_size - bi_valid;\n        bi_valid += len - Buf_size;\n      } else {\n        // bi_buf |= (value) << bi_valid;\n        bi_buf |= value << bi_valid & 0xffff;\n        bi_valid += len;\n      }\n    }\n\n    function send_code(c, tree) {\n      var c2 = c * 2;\n      send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);\n    } // Send a literal or distance tree in compressed form, using the codes in\n    // bl_tree.\n\n\n    function send_tree(tree, // the tree to be sent\n    max_code // and its largest code of non zero frequency\n    ) {\n      var n; // iterates over all tree elements\n\n      var prevlen = -1; // last emitted length\n\n      var curlen; // length of current code\n\n      var nextlen = tree[0 * 2 + 1]; // length of next code\n\n      var count = 0; // repeat count of the current code\n\n      var max_count = 7; // max repeat count\n\n      var min_count = 4; // min repeat count\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n\n        if (++count < max_count && curlen == nextlen) {\n          continue;\n        } else if (count < min_count) {\n          do {\n            send_code(curlen, bl_tree);\n          } while (--count !== 0);\n        } else if (curlen !== 0) {\n          if (curlen != prevlen) {\n            send_code(curlen, bl_tree);\n            count--;\n          }\n\n          send_code(REP_3_6, bl_tree);\n          send_bits(count - 3, 2);\n        } else if (count <= 10) {\n          send_code(REPZ_3_10, bl_tree);\n          send_bits(count - 3, 3);\n        } else {\n          send_code(REPZ_11_138, bl_tree);\n          send_bits(count - 11, 7);\n        }\n\n        count = 0;\n        prevlen = curlen;\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen == nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    } // Send the header for a block using dynamic Huffman trees: the counts, the\n    // lengths of the bit length codes, the literal tree and the distance tree.\n    // IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n\n\n    function send_all_trees(lcodes, dcodes, blcodes) {\n      var rank; // index in bl_order\n\n      send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n\n      send_bits(dcodes - 1, 5);\n      send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\n\n      for (rank = 0; rank < blcodes; rank++) {\n        send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);\n      }\n\n      send_tree(dyn_ltree, lcodes - 1); // literal tree\n\n      send_tree(dyn_dtree, dcodes - 1); // distance tree\n    } // Flush the bit buffer, keeping at most 7 bits in it.\n\n\n    function bi_flush() {\n      if (bi_valid == 16) {\n        put_short(bi_buf);\n        bi_buf = 0;\n        bi_valid = 0;\n      } else if (bi_valid >= 8) {\n        put_byte(bi_buf & 0xff);\n        bi_buf >>>= 8;\n        bi_valid -= 8;\n      }\n    } // Send one empty static block to give enough lookahead for inflate.\n    // This takes 10 bits, of which 7 may remain in the bit buffer.\n    // The current inflate code requires 9 bits of lookahead. If the\n    // last two codes for the previous block (real code plus EOB) were coded\n    // on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode\n    // the last real code. In this case we send two empty static blocks instead\n    // of one. (There are no problems if the previous block is stored or fixed.)\n    // To simplify the code, we assume the worst case of last real code encoded\n    // on one bit only.\n\n\n    function _tr_align() {\n      send_bits(STATIC_TREES << 1, 3);\n      send_code(END_BLOCK, StaticTree.static_ltree);\n      bi_flush(); // Of the 10 bits for the empty block, we have already sent\n      // (10 - bi_valid) bits. The lookahead for the last real code (before\n      // the EOB of the previous block) was thus at least one plus the length\n      // of the EOB plus what we have just sent of the empty static block.\n\n      if (1 + last_eob_len + 10 - bi_valid < 9) {\n        send_bits(STATIC_TREES << 1, 3);\n        send_code(END_BLOCK, StaticTree.static_ltree);\n        bi_flush();\n      }\n\n      last_eob_len = 7;\n    } // Save the match info and tally the frequency counts. Return true if\n    // the current block must be flushed.\n\n\n    function _tr_tally(dist, // distance of matched string\n    lc // match length-MIN_MATCH or unmatched char (if dist==0)\n    ) {\n      var out_length, in_length, dcode;\n      that.pending_buf[d_buf + last_lit * 2] = dist >>> 8 & 0xff;\n      that.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;\n      that.pending_buf[l_buf + last_lit] = lc & 0xff;\n      last_lit++;\n\n      if (dist === 0) {\n        // lc is the unmatched char\n        dyn_ltree[lc * 2]++;\n      } else {\n        matches++; // Here, lc is the match length - MIN_MATCH\n\n        dist--; // dist = match distance - 1\n\n        dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;\n        dyn_dtree[Tree.d_code(dist) * 2]++;\n      }\n\n      if ((last_lit & 0x1fff) === 0 && level > 2) {\n        // Compute an upper bound for the compressed length\n        out_length = last_lit * 8;\n        in_length = strstart - block_start;\n\n        for (dcode = 0; dcode < D_CODES; dcode++) {\n          out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);\n        }\n\n        out_length >>>= 3;\n        if (matches < Math.floor(last_lit / 2) && out_length < Math.floor(in_length / 2)) return true;\n      }\n\n      return last_lit == lit_bufsize - 1; // We avoid equality with lit_bufsize because of wraparound at 64K\n      // on 16 bit machines and because stored blocks are restricted to\n      // 64K-1 bytes.\n    } // Send the block data compressed using the given Huffman trees\n\n\n    function compress_block(ltree, dtree) {\n      var dist; // distance of matched string\n\n      var lc; // match length or unmatched char (if dist === 0)\n\n      var lx = 0; // running index in l_buf\n\n      var code; // the code to send\n\n      var extra; // number of extra bits to send\n\n      if (last_lit !== 0) {\n        do {\n          dist = that.pending_buf[d_buf + lx * 2] << 8 & 0xff00 | that.pending_buf[d_buf + lx * 2 + 1] & 0xff;\n          lc = that.pending_buf[l_buf + lx] & 0xff;\n          lx++;\n\n          if (dist === 0) {\n            send_code(lc, ltree); // send a literal byte\n          } else {\n            // Here, lc is the match length - MIN_MATCH\n            code = Tree._length_code[lc];\n            send_code(code + LITERALS + 1, ltree); // send the length\n            // code\n\n            extra = Tree.extra_lbits[code];\n\n            if (extra !== 0) {\n              lc -= Tree.base_length[code];\n              send_bits(lc, extra); // send the extra length bits\n            }\n\n            dist--; // dist is now the match distance - 1\n\n            code = Tree.d_code(dist);\n            send_code(code, dtree); // send the distance code\n\n            extra = Tree.extra_dbits[code];\n\n            if (extra !== 0) {\n              dist -= Tree.base_dist[code];\n              send_bits(dist, extra); // send the extra distance bits\n            }\n          } // literal or match pair ?\n          // Check that the overlay between pending_buf and d_buf+l_buf is\n          // ok:\n\n        } while (lx < last_lit);\n      }\n\n      send_code(END_BLOCK, ltree);\n      last_eob_len = ltree[END_BLOCK * 2 + 1];\n    } // Flush the bit buffer and align the output on a byte boundary\n\n\n    function bi_windup() {\n      if (bi_valid > 8) {\n        put_short(bi_buf);\n      } else if (bi_valid > 0) {\n        put_byte(bi_buf & 0xff);\n      }\n\n      bi_buf = 0;\n      bi_valid = 0;\n    } // Copy a stored block, storing first the length and its\n    // one's complement if requested.\n\n\n    function copy_block(buf, // the input data\n    len, // its length\n    header // true if block header must be written\n    ) {\n      bi_windup(); // align on byte boundary\n\n      last_eob_len = 8; // enough lookahead for inflate\n\n      if (header) {\n        put_short(len);\n        put_short(~len);\n      }\n\n      that.pending_buf.set(window.subarray(buf, buf + len), that.pending);\n      that.pending += len;\n    } // Send a stored block\n\n\n    function _tr_stored_block(buf, // input block\n    stored_len, // length of input block\n    eof // true if this is the last block for a file\n    ) {\n      send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type\n\n      copy_block(buf, stored_len, true); // with header\n    } // Determine the best encoding for the current block: dynamic trees, static\n    // trees or store, and output the encoded block to the zip file.\n\n\n    function _tr_flush_block(buf, // input block, or NULL if too old\n    stored_len, // length of input block\n    eof // true if this is the last block for a file\n    ) {\n      var opt_lenb, static_lenb; // opt_len and static_len in bytes\n\n      var max_blindex = 0; // index of last bit length code of non zero freq\n      // Build the Huffman trees unless a stored block is forced\n\n      if (level > 0) {\n        // Construct the literal and distance trees\n        l_desc.build_tree(that);\n        d_desc.build_tree(that); // At this point, opt_len and static_len are the total bit lengths\n        // of\n        // the compressed block data, excluding the tree representations.\n        // Build the bit length tree for the above two trees, and get the\n        // index\n        // in bl_order of the last bit length code to send.\n\n        max_blindex = build_bl_tree(); // Determine the best encoding. Compute first the block length in\n        // bytes\n\n        opt_lenb = that.opt_len + 3 + 7 >>> 3;\n        static_lenb = that.static_len + 3 + 7 >>> 3;\n        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;\n      } else {\n        opt_lenb = static_lenb = stored_len + 5; // force a stored block\n      }\n\n      if (stored_len + 4 <= opt_lenb && buf != -1) {\n        // 4: two words for the lengths\n        // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n        // Otherwise we can't have processed more than WSIZE input bytes\n        // since\n        // the last block flush, because compression would have been\n        // successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n        // transform a block into a stored block.\n        _tr_stored_block(buf, stored_len, eof);\n      } else if (static_lenb == opt_lenb) {\n        send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);\n        compress_block(StaticTree.static_ltree, StaticTree.static_dtree);\n      } else {\n        send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);\n        send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);\n        compress_block(dyn_ltree, dyn_dtree);\n      } // The above check is made mod 2^32, for files larger than 512 MB\n      // and uLong implemented on 32 bits.\n\n\n      init_block();\n\n      if (eof) {\n        bi_windup();\n      }\n    }\n\n    function flush_block_only(eof) {\n      _tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);\n\n      block_start = strstart;\n      strm.flush_pending();\n    } // Fill the window when the lookahead becomes insufficient.\n    // Updates strstart and lookahead.\n    //\n    // IN assertion: lookahead < MIN_LOOKAHEAD\n    // OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n    // At least one byte has been read, or avail_in === 0; reads are\n    // performed for at least two bytes (required for the zip translate_eol\n    // option -- not supported here).\n\n\n    function fill_window() {\n      var n, m;\n      var p;\n      var more; // Amount of free space at the end of the window.\n\n      do {\n        more = window_size - lookahead - strstart; // Deal with !@#$% 64K limit:\n\n        if (more === 0 && strstart === 0 && lookahead === 0) {\n          more = w_size;\n        } else if (more == -1) {\n          // Very unlikely, but possible on 16 bit machine if strstart ==\n          // 0\n          // and lookahead == 1 (input done one byte at time)\n          more--; // If the window is almost full and there is insufficient\n          // lookahead,\n          // move the upper half to the lower one to make room in the\n          // upper half.\n        } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {\n          window.set(window.subarray(w_size, w_size + w_size), 0);\n          match_start -= w_size;\n          strstart -= w_size; // we now have strstart >= MAX_DIST\n\n          block_start -= w_size; // Slide the hash table (could be avoided with 32 bit values\n          // at the expense of memory usage). We slide even when level ==\n          // 0\n          // to keep the hash table consistent if we switch back to level\n          // > 0\n          // later. (Using level 0 permanently is not an optimal usage of\n          // zlib, so we don't care about this pathological case.)\n\n          n = hash_size;\n          p = n;\n\n          do {\n            m = head[--p] & 0xffff;\n            head[p] = m >= w_size ? m - w_size : 0;\n          } while (--n !== 0);\n\n          n = w_size;\n          p = n;\n\n          do {\n            m = prev[--p] & 0xffff;\n            prev[p] = m >= w_size ? m - w_size : 0; // If n is not on any hash chain, prev[n] is garbage but\n            // its value will never be used.\n          } while (--n !== 0);\n\n          more += w_size;\n        }\n\n        if (strm.avail_in === 0) return; // If there was no sliding:\n        // strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n        // more == window_size - lookahead - strstart\n        // => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n        // => more >= window_size - 2*WSIZE + 2\n        // In the BIG_MEM or MMAP case (not yet supported),\n        // window_size == input_size + MIN_LOOKAHEAD &&\n        // strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n        // Otherwise, window_size == 2*WSIZE so more >= 2.\n        // If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n\n        n = strm.read_buf(window, strstart + lookahead, more);\n        lookahead += n; // Initialize the hash value now that we have some input:\n\n        if (lookahead >= MIN_MATCH) {\n          ins_h = window[strstart] & 0xff;\n          ins_h = (ins_h << hash_shift ^ window[strstart + 1] & 0xff) & hash_mask;\n        } // If the whole input has less than MIN_MATCH bytes, ins_h is\n        // garbage,\n        // but this is not important since only literal bytes will be\n        // emitted.\n\n      } while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);\n    } // Copy without compression as much as possible from the input stream,\n    // return\n    // the current block state.\n    // This function does not insert new strings in the dictionary since\n    // uncompressible data is probably not useful. This function is used\n    // only for the level=0 compression option.\n    // NOTE: this function should be optimized to avoid extra copying from\n    // window to pending_buf.\n\n\n    function deflate_stored(flush) {\n      // Stored blocks are limited to 0xffff bytes, pending_buf is limited\n      // to pending_buf_size, and each stored block has a 5 byte header:\n      var max_block_size = 0xffff;\n      var max_start;\n\n      if (max_block_size > pending_buf_size - 5) {\n        max_block_size = pending_buf_size - 5;\n      } // Copy as much as possible from input to output:\n\n\n      while (true) {\n        // Fill the window as much as possible:\n        if (lookahead <= 1) {\n          fill_window();\n          if (lookahead === 0 && flush == Z_NO_FLUSH) return NeedMore;\n          if (lookahead === 0) break; // flush the current block\n        }\n\n        strstart += lookahead;\n        lookahead = 0; // Emit a stored block if pending_buf will be full:\n\n        max_start = block_start + max_block_size;\n\n        if (strstart === 0 || strstart >= max_start) {\n          // strstart === 0 is possible when wraparound on 16-bit machine\n          lookahead = strstart - max_start;\n          strstart = max_start;\n          flush_block_only(false);\n          if (strm.avail_out === 0) return NeedMore;\n        } // Flush if we may have to slide, otherwise block_start may become\n        // negative and the data will be gone:\n\n\n        if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {\n          flush_block_only(false);\n          if (strm.avail_out === 0) return NeedMore;\n        }\n      }\n\n      flush_block_only(flush == Z_FINISH);\n      if (strm.avail_out === 0) return flush == Z_FINISH ? FinishStarted : NeedMore;\n      return flush == Z_FINISH ? FinishDone : BlockDone;\n    }\n\n    function longest_match(cur_match) {\n      var chain_length = max_chain_length; // max hash chain length\n\n      var scan = strstart; // current string\n\n      var match; // matched string\n\n      var len; // length of current match\n\n      var best_len = prev_length; // best match length so far\n\n      var limit = strstart > w_size - MIN_LOOKAHEAD ? strstart - (w_size - MIN_LOOKAHEAD) : 0;\n      var _nice_match = nice_match; // Stop when cur_match becomes <= limit. To simplify the code,\n      // we prevent matches with the string of window index 0.\n\n      var wmask = w_mask;\n      var strend = strstart + MAX_MATCH;\n      var scan_end1 = window[scan + best_len - 1];\n      var scan_end = window[scan + best_len]; // The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of\n      // 16.\n      // It is easy to get rid of this optimization if necessary.\n      // Do not waste too much time if we already have a good match:\n\n      if (prev_length >= good_match) {\n        chain_length >>= 2;\n      } // Do not look for matches beyond the end of the input. This is\n      // necessary\n      // to make deflate deterministic.\n\n\n      if (_nice_match > lookahead) _nice_match = lookahead;\n\n      do {\n        match = cur_match; // Skip to next match if the match length cannot increase\n        // or if the match length is less than 2:\n\n        if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]) continue; // The check at best_len-1 can be removed because it will be made\n        // again later. (This heuristic is not always a win.)\n        // It is not necessary to compare scan[2] and match[2] since they\n        // are always equal when the other bytes match, given that\n        // the hash keys are equal and that HASH_BITS >= 8.\n\n        scan += 2;\n        match++; // We check for insufficient lookahead only every 8th comparison;\n        // the 256th check will be made at strstart+258.\n\n        do {} while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);\n\n        len = MAX_MATCH - (strend - scan);\n        scan = strend - MAX_MATCH;\n\n        if (len > best_len) {\n          match_start = cur_match;\n          best_len = len;\n          if (len >= _nice_match) break;\n          scan_end1 = window[scan + best_len - 1];\n          scan_end = window[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask] & 0xffff) > limit && --chain_length !== 0);\n\n      if (best_len <= lookahead) return best_len;\n      return lookahead;\n    } // Compress as much as possible from the input stream, return the current\n    // block state.\n    // This function does not perform lazy evaluation of matches and inserts\n    // new strings in the dictionary only for unmatched strings or for short\n    // matches. It is used only for the fast compression options.\n\n\n    function deflate_fast(flush) {\n      // short hash_head = 0; // head of the hash chain\n      var hash_head = 0; // head of the hash chain\n\n      var bflush; // set if current block must be flushed\n\n      while (true) {\n        // Make sure that we always have enough lookahead, except\n        // at the end of the input file. We need MAX_MATCH bytes\n        // for the next match, plus MIN_MATCH bytes to insert the\n        // string following the next match.\n        if (lookahead < MIN_LOOKAHEAD) {\n          fill_window();\n\n          if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n            return NeedMore;\n          }\n\n          if (lookahead === 0) break; // flush the current block\n        } // Insert the string window[strstart .. strstart+2] in the\n        // dictionary, and set hash_head to the head of the hash chain:\n\n\n        if (lookahead >= MIN_MATCH) {\n          ins_h = (ins_h << hash_shift ^ window[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask; // prev[strstart&w_mask]=hash_head=head[ins_h];\n\n          hash_head = head[ins_h] & 0xffff;\n          prev[strstart & w_mask] = head[ins_h];\n          head[ins_h] = strstart;\n        } // Find the longest match, discarding those <= prev_length.\n        // At this point we have always match_length < MIN_MATCH\n\n\n        if (hash_head !== 0 && (strstart - hash_head & 0xffff) <= w_size - MIN_LOOKAHEAD) {\n          // To simplify the code, we prevent matches with the string\n          // of window index 0 (in particular we have to avoid a match\n          // of the string with itself at the start of the input file).\n          if (strategy != Z_HUFFMAN_ONLY) {\n            match_length = longest_match(hash_head);\n          } // longest_match() sets match_start\n\n        }\n\n        if (match_length >= MIN_MATCH) {\n          // check_match(strstart, match_start, match_length);\n          bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);\n          lookahead -= match_length; // Insert new strings in the hash table only if the match length\n          // is not too large. This saves time but degrades compression.\n\n          if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {\n            match_length--; // string at strstart already in hash table\n\n            do {\n              strstart++;\n              ins_h = (ins_h << hash_shift ^ window[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask; // prev[strstart&w_mask]=hash_head=head[ins_h];\n\n              hash_head = head[ins_h] & 0xffff;\n              prev[strstart & w_mask] = head[ins_h];\n              head[ins_h] = strstart; // strstart never exceeds WSIZE-MAX_MATCH, so there are\n              // always MIN_MATCH bytes ahead.\n            } while (--match_length !== 0);\n\n            strstart++;\n          } else {\n            strstart += match_length;\n            match_length = 0;\n            ins_h = window[strstart] & 0xff;\n            ins_h = (ins_h << hash_shift ^ window[strstart + 1] & 0xff) & hash_mask; // If lookahead < MIN_MATCH, ins_h is garbage, but it does\n            // not\n            // matter since it will be recomputed at next deflate call.\n          }\n        } else {\n          // No match, output a literal byte\n          bflush = _tr_tally(0, window[strstart] & 0xff);\n          lookahead--;\n          strstart++;\n        }\n\n        if (bflush) {\n          flush_block_only(false);\n          if (strm.avail_out === 0) return NeedMore;\n        }\n      }\n\n      flush_block_only(flush == Z_FINISH);\n\n      if (strm.avail_out === 0) {\n        if (flush == Z_FINISH) return FinishStarted;else return NeedMore;\n      }\n\n      return flush == Z_FINISH ? FinishDone : BlockDone;\n    } // Same as above, but achieves better compression. We use a lazy\n    // evaluation for matches: a match is finally adopted only if there is\n    // no better match at the next window position.\n\n\n    function deflate_slow(flush) {\n      // short hash_head = 0; // head of hash chain\n      var hash_head = 0; // head of hash chain\n\n      var bflush; // set if current block must be flushed\n\n      var max_insert; // Process the input block.\n\n      while (true) {\n        // Make sure that we always have enough lookahead, except\n        // at the end of the input file. We need MAX_MATCH bytes\n        // for the next match, plus MIN_MATCH bytes to insert the\n        // string following the next match.\n        if (lookahead < MIN_LOOKAHEAD) {\n          fill_window();\n\n          if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n            return NeedMore;\n          }\n\n          if (lookahead === 0) break; // flush the current block\n        } // Insert the string window[strstart .. strstart+2] in the\n        // dictionary, and set hash_head to the head of the hash chain:\n\n\n        if (lookahead >= MIN_MATCH) {\n          ins_h = (ins_h << hash_shift ^ window[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask; // prev[strstart&w_mask]=hash_head=head[ins_h];\n\n          hash_head = head[ins_h] & 0xffff;\n          prev[strstart & w_mask] = head[ins_h];\n          head[ins_h] = strstart;\n        } // Find the longest match, discarding those <= prev_length.\n\n\n        prev_length = match_length;\n        prev_match = match_start;\n        match_length = MIN_MATCH - 1;\n\n        if (hash_head !== 0 && prev_length < max_lazy_match && (strstart - hash_head & 0xffff) <= w_size - MIN_LOOKAHEAD) {\n          // To simplify the code, we prevent matches with the string\n          // of window index 0 (in particular we have to avoid a match\n          // of the string with itself at the start of the input file).\n          if (strategy != Z_HUFFMAN_ONLY) {\n            match_length = longest_match(hash_head);\n          } // longest_match() sets match_start\n\n\n          if (match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096)) {\n            // If prev_match is also MIN_MATCH, match_start is garbage\n            // but we will ignore the current match anyway.\n            match_length = MIN_MATCH - 1;\n          }\n        } // If there was a match at the previous step and the current\n        // match is not better, output the previous match:\n\n\n        if (prev_length >= MIN_MATCH && match_length <= prev_length) {\n          max_insert = strstart + lookahead - MIN_MATCH; // Do not insert strings in hash table beyond this.\n          // check_match(strstart-1, prev_match, prev_length);\n\n          bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH); // Insert in hash table all strings up to the end of the match.\n          // strstart-1 and strstart are already inserted. If there is not\n          // enough lookahead, the last two strings are not inserted in\n          // the hash table.\n\n          lookahead -= prev_length - 1;\n          prev_length -= 2;\n\n          do {\n            if (++strstart <= max_insert) {\n              ins_h = (ins_h << hash_shift ^ window[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask; // prev[strstart&w_mask]=hash_head=head[ins_h];\n\n              hash_head = head[ins_h] & 0xffff;\n              prev[strstart & w_mask] = head[ins_h];\n              head[ins_h] = strstart;\n            }\n          } while (--prev_length !== 0);\n\n          match_available = 0;\n          match_length = MIN_MATCH - 1;\n          strstart++;\n\n          if (bflush) {\n            flush_block_only(false);\n            if (strm.avail_out === 0) return NeedMore;\n          }\n        } else if (match_available !== 0) {\n          // If there was no match at the previous position, output a\n          // single literal. If there was a match but the current match\n          // is longer, truncate the previous match to a single literal.\n          bflush = _tr_tally(0, window[strstart - 1] & 0xff);\n\n          if (bflush) {\n            flush_block_only(false);\n          }\n\n          strstart++;\n          lookahead--;\n          if (strm.avail_out === 0) return NeedMore;\n        } else {\n          // There is no previous match to compare with, wait for\n          // the next step to decide.\n          match_available = 1;\n          strstart++;\n          lookahead--;\n        }\n      }\n\n      if (match_available !== 0) {\n        bflush = _tr_tally(0, window[strstart - 1] & 0xff);\n        match_available = 0;\n      }\n\n      flush_block_only(flush == Z_FINISH);\n\n      if (strm.avail_out === 0) {\n        if (flush == Z_FINISH) return FinishStarted;else return NeedMore;\n      }\n\n      return flush == Z_FINISH ? FinishDone : BlockDone;\n    }\n\n    function deflateReset(strm) {\n      strm.total_in = strm.total_out = 0;\n      strm.msg = null; //\n\n      that.pending = 0;\n      that.pending_out = 0;\n      status = BUSY_STATE;\n      last_flush = Z_NO_FLUSH;\n      tr_init();\n      lm_init();\n      return Z_OK;\n    }\n\n    that.deflateInit = function (strm, _level, bits, _method, memLevel, _strategy) {\n      if (!_method) _method = Z_DEFLATED;\n      if (!memLevel) memLevel = DEF_MEM_LEVEL;\n      if (!_strategy) _strategy = Z_DEFAULT_STRATEGY; // byte[] my_version=ZLIB_VERSION;\n      //\n      // if (!version || version[0] != my_version[0]\n      // || stream_size != sizeof(z_stream)) {\n      // return Z_VERSION_ERROR;\n      // }\n\n      strm.msg = null;\n      if (_level == Z_DEFAULT_COMPRESSION) _level = 6;\n\n      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {\n        return Z_STREAM_ERROR;\n      }\n\n      strm.dstate = that;\n      w_bits = bits;\n      w_size = 1 << w_bits;\n      w_mask = w_size - 1;\n      hash_bits = memLevel + 7;\n      hash_size = 1 << hash_bits;\n      hash_mask = hash_size - 1;\n      hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n      window = new Uint8Array(w_size * 2);\n      prev = [];\n      head = [];\n      lit_bufsize = 1 << memLevel + 6; // 16K elements by default\n      // We overlay pending_buf and d_buf+l_buf. This works since the average\n      // output size for (length,distance) codes is <= 24 bits.\n\n      that.pending_buf = new Uint8Array(lit_bufsize * 4);\n      pending_buf_size = lit_bufsize * 4;\n      d_buf = Math.floor(lit_bufsize / 2);\n      l_buf = (1 + 2) * lit_bufsize;\n      level = _level;\n      strategy = _strategy;\n      return deflateReset(strm);\n    };\n\n    that.deflateEnd = function () {\n      if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {\n        return Z_STREAM_ERROR;\n      } // Deallocate in reverse order of allocations:\n\n\n      that.pending_buf = null;\n      head = null;\n      prev = null;\n      window = null; // free\n\n      that.dstate = null;\n      return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n    };\n\n    that.deflateParams = function (strm, _level, _strategy) {\n      var err = Z_OK;\n\n      if (_level == Z_DEFAULT_COMPRESSION) {\n        _level = 6;\n      }\n\n      if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {\n        return Z_STREAM_ERROR;\n      }\n\n      if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {\n        // Flush the last buffer:\n        err = strm.deflate(Z_PARTIAL_FLUSH);\n      }\n\n      if (level != _level) {\n        level = _level;\n        max_lazy_match = config_table[level].max_lazy;\n        good_match = config_table[level].good_length;\n        nice_match = config_table[level].nice_length;\n        max_chain_length = config_table[level].max_chain;\n      }\n\n      strategy = _strategy;\n      return err;\n    };\n\n    that.deflateSetDictionary = function (strm, dictionary, dictLength) {\n      var length = dictLength;\n      var n,\n          index = 0;\n      if (!dictionary || status != INIT_STATE) return Z_STREAM_ERROR;\n      if (length < MIN_MATCH) return Z_OK;\n\n      if (length > w_size - MIN_LOOKAHEAD) {\n        length = w_size - MIN_LOOKAHEAD;\n        index = dictLength - length; // use the tail of the dictionary\n      }\n\n      window.set(dictionary.subarray(index, index + length), 0);\n      strstart = length;\n      block_start = length; // Insert all strings in the hash table (except for the last two bytes).\n      // s->lookahead stays null, so s->ins_h will be recomputed at the next\n      // call of fill_window.\n\n      ins_h = window[0] & 0xff;\n      ins_h = (ins_h << hash_shift ^ window[1] & 0xff) & hash_mask;\n\n      for (n = 0; n <= length - MIN_MATCH; n++) {\n        ins_h = (ins_h << hash_shift ^ window[n + (MIN_MATCH - 1)] & 0xff) & hash_mask;\n        prev[n & w_mask] = head[ins_h];\n        head[ins_h] = n;\n      }\n\n      return Z_OK;\n    };\n\n    that.deflate = function (_strm, flush) {\n      var i, header, level_flags, old_flush, bstate;\n\n      if (flush > Z_FINISH || flush < 0) {\n        return Z_STREAM_ERROR;\n      }\n\n      if (!_strm.next_out || !_strm.next_in && _strm.avail_in !== 0 || status == FINISH_STATE && flush != Z_FINISH) {\n        _strm.msg = z_errmsg[Z_NEED_DICT - Z_STREAM_ERROR];\n        return Z_STREAM_ERROR;\n      }\n\n      if (_strm.avail_out === 0) {\n        _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];\n        return Z_BUF_ERROR;\n      }\n\n      strm = _strm; // just in case\n\n      old_flush = last_flush;\n      last_flush = flush; // Write the zlib header\n\n      if (status == INIT_STATE) {\n        header = Z_DEFLATED + (w_bits - 8 << 4) << 8;\n        level_flags = (level - 1 & 0xff) >> 1;\n        if (level_flags > 3) level_flags = 3;\n        header |= level_flags << 6;\n        if (strstart !== 0) header |= PRESET_DICT;\n        header += 31 - header % 31;\n        status = BUSY_STATE;\n        putShortMSB(header);\n      } // Flush as much pending output as possible\n\n\n      if (that.pending !== 0) {\n        strm.flush_pending();\n\n        if (strm.avail_out === 0) {\n          // console.log(\" avail_out==0\");\n          // Since avail_out is 0, deflate will be called again with\n          // more output space, but possibly with both pending and\n          // avail_in equal to zero. There won't be anything to do,\n          // but this is not an error situation so make sure we\n          // return OK instead of BUF_ERROR at next call of deflate:\n          last_flush = -1;\n          return Z_OK;\n        } // Make sure there is something to do and avoid duplicate\n        // consecutive\n        // flushes. For repeated and useless calls with Z_FINISH, we keep\n        // returning Z_STREAM_END instead of Z_BUFF_ERROR.\n\n      } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {\n        strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];\n        return Z_BUF_ERROR;\n      } // User must not provide more input after the first FINISH:\n\n\n      if (status == FINISH_STATE && strm.avail_in !== 0) {\n        _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];\n        return Z_BUF_ERROR;\n      } // Start a new block or continue the current one.\n\n\n      if (strm.avail_in !== 0 || lookahead !== 0 || flush != Z_NO_FLUSH && status != FINISH_STATE) {\n        bstate = -1;\n\n        switch (config_table[level].func) {\n          case STORED:\n            bstate = deflate_stored(flush);\n            break;\n\n          case FAST:\n            bstate = deflate_fast(flush);\n            break;\n\n          case SLOW:\n            bstate = deflate_slow(flush);\n            break;\n\n          default:\n        }\n\n        if (bstate == FinishStarted || bstate == FinishDone) {\n          status = FINISH_STATE;\n        }\n\n        if (bstate == NeedMore || bstate == FinishStarted) {\n          if (strm.avail_out === 0) {\n            last_flush = -1; // avoid BUF_ERROR next call, see above\n          }\n\n          return Z_OK; // If flush != Z_NO_FLUSH && avail_out === 0, the next call\n          // of deflate should use the same flush parameter to make sure\n          // that the flush is complete. So we don't have to output an\n          // empty block here, this will be done at next call. This also\n          // ensures that for a very small output buffer, we emit at most\n          // one empty block.\n        }\n\n        if (bstate == BlockDone) {\n          if (flush == Z_PARTIAL_FLUSH) {\n            _tr_align();\n          } else {\n            // FULL_FLUSH or SYNC_FLUSH\n            _tr_stored_block(0, 0, false); // For a full flush, this empty block will be recognized\n            // as a special marker by inflate_sync().\n\n\n            if (flush == Z_FULL_FLUSH) {\n              // state.head[s.hash_size-1]=0;\n              for (i = 0; i < hash_size\n              /*-1*/\n              ; i++) {\n                // forget history\n                head[i] = 0;\n              }\n            }\n          }\n\n          strm.flush_pending();\n\n          if (strm.avail_out === 0) {\n            last_flush = -1; // avoid BUF_ERROR at next call, see above\n\n            return Z_OK;\n          }\n        }\n      }\n\n      if (flush != Z_FINISH) return Z_OK;\n      return Z_STREAM_END;\n    };\n  } // ZStream\n\n\n  function ZStream() {\n    var that = this;\n    that.next_in_index = 0;\n    that.next_out_index = 0; // that.next_in; // next input byte\n\n    that.avail_in = 0; // number of bytes available at next_in\n\n    that.total_in = 0; // total nb of input bytes read so far\n    // that.next_out; // next output byte should be put there\n\n    that.avail_out = 0; // remaining free space at next_out\n\n    that.total_out = 0; // total nb of bytes output so far\n    // that.msg;\n    // that.dstate;\n  }\n\n  ZStream.prototype = {\n    deflateInit: function deflateInit(level, bits) {\n      var that = this;\n      that.dstate = new Deflate();\n      if (!bits) bits = MAX_BITS;\n      return that.dstate.deflateInit(that, level, bits);\n    },\n    deflate: function deflate(flush) {\n      var that = this;\n\n      if (!that.dstate) {\n        return Z_STREAM_ERROR;\n      }\n\n      return that.dstate.deflate(that, flush);\n    },\n    deflateEnd: function deflateEnd() {\n      var that = this;\n      if (!that.dstate) return Z_STREAM_ERROR;\n      var ret = that.dstate.deflateEnd();\n      that.dstate = null;\n      return ret;\n    },\n    deflateParams: function deflateParams(level, strategy) {\n      var that = this;\n      if (!that.dstate) return Z_STREAM_ERROR;\n      return that.dstate.deflateParams(that, level, strategy);\n    },\n    deflateSetDictionary: function deflateSetDictionary(dictionary, dictLength) {\n      var that = this;\n      if (!that.dstate) return Z_STREAM_ERROR;\n      return that.dstate.deflateSetDictionary(that, dictionary, dictLength);\n    },\n    // Read a new buffer from the current input stream, update the\n    // total number of bytes read. All deflate() input goes through\n    // this function so some applications may wish to modify it to avoid\n    // allocating a large strm->next_in buffer and copying from it.\n    // (See also flush_pending()).\n    read_buf: function read_buf(buf, start, size) {\n      var that = this;\n      var len = that.avail_in;\n      if (len > size) len = size;\n      if (len === 0) return 0;\n      that.avail_in -= len;\n      buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);\n      that.next_in_index += len;\n      that.total_in += len;\n      return len;\n    },\n    // Flush as much pending output as possible. All deflate() output goes\n    // through this function so some applications may wish to modify it\n    // to avoid allocating a large strm->next_out buffer and copying into it.\n    // (See also read_buf()).\n    flush_pending: function flush_pending() {\n      var that = this;\n      var len = that.dstate.pending;\n      if (len > that.avail_out) len = that.avail_out;\n      if (len === 0) return; // if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index\n      // || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +\n      // len)) {\n      // console.log(that.dstate.pending_buf.length + \", \" + that.dstate.pending_out + \", \" + that.next_out.length + \", \" +\n      // that.next_out_index + \", \" + len);\n      // console.log(\"avail_out=\" + that.avail_out);\n      // }\n\n      that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);\n      that.next_out_index += len;\n      that.dstate.pending_out += len;\n      that.total_out += len;\n      that.avail_out -= len;\n      that.dstate.pending -= len;\n\n      if (that.dstate.pending === 0) {\n        that.dstate.pending_out = 0;\n      }\n    }\n  }; // Deflater\n\n  function Deflater(options) {\n    var that = this;\n    var z = new ZStream();\n    var bufsize = 512;\n    var flush = Z_NO_FLUSH;\n    var buf = new Uint8Array(bufsize);\n    var level = options ? options.level : Z_DEFAULT_COMPRESSION;\n    if (typeof level == \"undefined\") level = Z_DEFAULT_COMPRESSION;\n    z.deflateInit(level);\n    z.next_out = buf;\n\n    that.append = function (data, onprogress) {\n      var err,\n          buffers = [],\n          lastIndex = 0,\n          bufferIndex = 0,\n          bufferSize = 0,\n          array;\n      if (!data.length) return;\n      z.next_in_index = 0;\n      z.next_in = data;\n      z.avail_in = data.length;\n\n      do {\n        z.next_out_index = 0;\n        z.avail_out = bufsize;\n        err = z.deflate(flush);\n        if (err != Z_OK) throw new Error(\"deflating: \" + z.msg);\n        if (z.next_out_index) if (z.next_out_index == bufsize) buffers.push(new Uint8Array(buf));else buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n        bufferSize += z.next_out_index;\n\n        if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\n          onprogress(z.next_in_index);\n          lastIndex = z.next_in_index;\n        }\n      } while (z.avail_in > 0 || z.avail_out === 0);\n\n      array = new Uint8Array(bufferSize);\n      buffers.forEach(function (chunk) {\n        array.set(chunk, bufferIndex);\n        bufferIndex += chunk.length;\n      });\n      return array;\n    };\n\n    that.flush = function () {\n      var err,\n          buffers = [],\n          bufferIndex = 0,\n          bufferSize = 0,\n          array;\n\n      do {\n        z.next_out_index = 0;\n        z.avail_out = bufsize;\n        err = z.deflate(Z_FINISH);\n        if (err != Z_STREAM_END && err != Z_OK) throw new Error(\"deflating: \" + z.msg);\n        if (bufsize - z.avail_out > 0) buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n        bufferSize += z.next_out_index;\n      } while (z.avail_in > 0 || z.avail_out === 0);\n\n      z.deflateEnd();\n      array = new Uint8Array(bufferSize);\n      buffers.forEach(function (chunk) {\n        array.set(chunk, bufferIndex);\n        bufferIndex += chunk.length;\n      });\n      return array;\n    };\n  } // 'zip' may not be defined in z-worker and some tests\n\n\n  var env = global.zip || global;\n  env.Deflater = env._jzlib_Deflater = Deflater;\n})(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || Function('return typeof this === \"object\" && this.content')() || Function('return this')()); // `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\n/**\n * A class to parse color values\n * @author Stoyan Stefanov <sstoo@gmail.com>\n * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}\n * @license Use it if you like it\n */\n(function (global) {\n\n  function RGBColor(color_string) {\n    color_string = color_string || '';\n    this.ok = false; // strip any leading #\n\n    if (color_string.charAt(0) == '#') {\n      // remove # if any\n      color_string = color_string.substr(1, 6);\n    }\n\n    color_string = color_string.replace(/ /g, '');\n    color_string = color_string.toLowerCase();\n    var channels; // before getting into regexps, try simple matches\n    // and overwrite the input\n\n    var simple_colors = {\n      aliceblue: 'f0f8ff',\n      antiquewhite: 'faebd7',\n      aqua: '00ffff',\n      aquamarine: '7fffd4',\n      azure: 'f0ffff',\n      beige: 'f5f5dc',\n      bisque: 'ffe4c4',\n      black: '000000',\n      blanchedalmond: 'ffebcd',\n      blue: '0000ff',\n      blueviolet: '8a2be2',\n      brown: 'a52a2a',\n      burlywood: 'deb887',\n      cadetblue: '5f9ea0',\n      chartreuse: '7fff00',\n      chocolate: 'd2691e',\n      coral: 'ff7f50',\n      cornflowerblue: '6495ed',\n      cornsilk: 'fff8dc',\n      crimson: 'dc143c',\n      cyan: '00ffff',\n      darkblue: '00008b',\n      darkcyan: '008b8b',\n      darkgoldenrod: 'b8860b',\n      darkgray: 'a9a9a9',\n      darkgreen: '006400',\n      darkkhaki: 'bdb76b',\n      darkmagenta: '8b008b',\n      darkolivegreen: '556b2f',\n      darkorange: 'ff8c00',\n      darkorchid: '9932cc',\n      darkred: '8b0000',\n      darksalmon: 'e9967a',\n      darkseagreen: '8fbc8f',\n      darkslateblue: '483d8b',\n      darkslategray: '2f4f4f',\n      darkturquoise: '00ced1',\n      darkviolet: '9400d3',\n      deeppink: 'ff1493',\n      deepskyblue: '00bfff',\n      dimgray: '696969',\n      dodgerblue: '1e90ff',\n      feldspar: 'd19275',\n      firebrick: 'b22222',\n      floralwhite: 'fffaf0',\n      forestgreen: '228b22',\n      fuchsia: 'ff00ff',\n      gainsboro: 'dcdcdc',\n      ghostwhite: 'f8f8ff',\n      gold: 'ffd700',\n      goldenrod: 'daa520',\n      gray: '808080',\n      green: '008000',\n      greenyellow: 'adff2f',\n      honeydew: 'f0fff0',\n      hotpink: 'ff69b4',\n      indianred: 'cd5c5c',\n      indigo: '4b0082',\n      ivory: 'fffff0',\n      khaki: 'f0e68c',\n      lavender: 'e6e6fa',\n      lavenderblush: 'fff0f5',\n      lawngreen: '7cfc00',\n      lemonchiffon: 'fffacd',\n      lightblue: 'add8e6',\n      lightcoral: 'f08080',\n      lightcyan: 'e0ffff',\n      lightgoldenrodyellow: 'fafad2',\n      lightgrey: 'd3d3d3',\n      lightgreen: '90ee90',\n      lightpink: 'ffb6c1',\n      lightsalmon: 'ffa07a',\n      lightseagreen: '20b2aa',\n      lightskyblue: '87cefa',\n      lightslateblue: '8470ff',\n      lightslategray: '778899',\n      lightsteelblue: 'b0c4de',\n      lightyellow: 'ffffe0',\n      lime: '00ff00',\n      limegreen: '32cd32',\n      linen: 'faf0e6',\n      magenta: 'ff00ff',\n      maroon: '800000',\n      mediumaquamarine: '66cdaa',\n      mediumblue: '0000cd',\n      mediumorchid: 'ba55d3',\n      mediumpurple: '9370d8',\n      mediumseagreen: '3cb371',\n      mediumslateblue: '7b68ee',\n      mediumspringgreen: '00fa9a',\n      mediumturquoise: '48d1cc',\n      mediumvioletred: 'c71585',\n      midnightblue: '191970',\n      mintcream: 'f5fffa',\n      mistyrose: 'ffe4e1',\n      moccasin: 'ffe4b5',\n      navajowhite: 'ffdead',\n      navy: '000080',\n      oldlace: 'fdf5e6',\n      olive: '808000',\n      olivedrab: '6b8e23',\n      orange: 'ffa500',\n      orangered: 'ff4500',\n      orchid: 'da70d6',\n      palegoldenrod: 'eee8aa',\n      palegreen: '98fb98',\n      paleturquoise: 'afeeee',\n      palevioletred: 'd87093',\n      papayawhip: 'ffefd5',\n      peachpuff: 'ffdab9',\n      peru: 'cd853f',\n      pink: 'ffc0cb',\n      plum: 'dda0dd',\n      powderblue: 'b0e0e6',\n      purple: '800080',\n      red: 'ff0000',\n      rosybrown: 'bc8f8f',\n      royalblue: '4169e1',\n      saddlebrown: '8b4513',\n      salmon: 'fa8072',\n      sandybrown: 'f4a460',\n      seagreen: '2e8b57',\n      seashell: 'fff5ee',\n      sienna: 'a0522d',\n      silver: 'c0c0c0',\n      skyblue: '87ceeb',\n      slateblue: '6a5acd',\n      slategray: '708090',\n      snow: 'fffafa',\n      springgreen: '00ff7f',\n      steelblue: '4682b4',\n      tan: 'd2b48c',\n      teal: '008080',\n      thistle: 'd8bfd8',\n      tomato: 'ff6347',\n      turquoise: '40e0d0',\n      violet: 'ee82ee',\n      violetred: 'd02090',\n      wheat: 'f5deb3',\n      white: 'ffffff',\n      whitesmoke: 'f5f5f5',\n      yellow: 'ffff00',\n      yellowgreen: '9acd32'\n    };\n\n    for (var key in simple_colors) {\n      if (color_string == key) {\n        color_string = simple_colors[key];\n      }\n    } // emd of simple type-in colors\n    // array of color definition objects\n\n\n    var color_defs = [{\n      re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n      example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],\n      process: function process(bits) {\n        return [parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3])];\n      }\n    }, {\n      re: /^(\\w{2})(\\w{2})(\\w{2})$/,\n      example: ['#00ff00', '336699'],\n      process: function process(bits) {\n        return [parseInt(bits[1], 16), parseInt(bits[2], 16), parseInt(bits[3], 16)];\n      }\n    }, {\n      re: /^(\\w{1})(\\w{1})(\\w{1})$/,\n      example: ['#fb0', 'f0f'],\n      process: function process(bits) {\n        return [parseInt(bits[1] + bits[1], 16), parseInt(bits[2] + bits[2], 16), parseInt(bits[3] + bits[3], 16)];\n      }\n    }]; // search through the definitions to find a match\n\n    for (var i = 0; i < color_defs.length; i++) {\n      var re = color_defs[i].re;\n      var processor = color_defs[i].process;\n      var bits = re.exec(color_string);\n\n      if (bits) {\n        channels = processor(bits);\n        this.r = channels[0];\n        this.g = channels[1];\n        this.b = channels[2];\n        this.ok = true;\n      }\n    } // validate/cleanup values\n\n\n    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;\n    this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;\n    this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b; // some getters\n\n    this.toRGB = function () {\n      return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';\n    };\n\n    this.toHex = function () {\n      var r = this.r.toString(16);\n      var g = this.g.toString(16);\n      var b = this.b.toString(16);\n      if (r.length == 1) r = '0' + r;\n      if (g.length == 1) g = '0' + g;\n      if (b.length == 1) b = '0' + b;\n      return '#' + r + g + b;\n    };\n  }\n\n  global.RGBColor = RGBColor;\n})(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || Function('return typeof this === \"object\" && this.content')() || Function('return this')()); // `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\n/************************************************\n * Title : custom font                          *\n * Start Data : 2017. 01. 22.                   *\n * Comment : TEXT API                           *\n ************************************************/\n\n/******************************\n * jsPDF extension API Design *\n * ****************************/\n(function (jsPDF) {\n\n  var PLUS = '+'.charCodeAt(0);\n  var SLASH = '/'.charCodeAt(0);\n  var NUMBER = '0'.charCodeAt(0);\n  var LOWER = 'a'.charCodeAt(0);\n  var UPPER = 'A'.charCodeAt(0);\n  var PLUS_URL_SAFE = '-'.charCodeAt(0);\n  var SLASH_URL_SAFE = '_'.charCodeAt(0);\n  /*****************************************************************/\n\n  /* function : b64ToByteArray                                     */\n\n  /* comment : Base64 encoded TTF file contents (b64) are decoded  */\n\n  /*     by Byte array and stored.                                 */\n\n  /*****************************************************************/\n\n  var b64ToByteArray = function b64ToByteArray(b64) {\n    var i, j, l, tmp, placeHolders, arr;\n\n    if (b64.length % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4');\n    } // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n\n\n    var len = b64.length;\n    placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0; // base64 is 4/3 + up to two characters of the original data\n\n    arr = new Uint8Array(b64.length * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars\n\n    l = placeHolders > 0 ? b64.length - 4 : b64.length;\n    var L = 0;\n\n    function push(v) {\n      arr[L++] = v;\n    }\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n      push((tmp & 0xFF0000) >> 16);\n      push((tmp & 0xFF00) >> 8);\n      push(tmp & 0xFF);\n    }\n\n    if (placeHolders === 2) {\n      tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n      push(tmp & 0xFF);\n    } else if (placeHolders === 1) {\n      tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n      push(tmp >> 8 & 0xFF);\n      push(tmp & 0xFF);\n    }\n\n    return arr;\n  };\n  /***************************************************************/\n\n  /* function : decode                                           */\n\n  /* comment : Change the base64 encoded font's content to match */\n\n  /*   the base64 index value.                                   */\n\n  /***************************************************************/\n\n\n  var decode = function decode(elt) {\n    var code = elt.charCodeAt(0);\n    if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'\n\n    if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'\n\n    if (code < NUMBER) return -1; //no match\n\n    if (code < NUMBER + 10) return code - NUMBER + 26 + 26;\n    if (code < UPPER + 26) return code - UPPER;\n    if (code < LOWER + 26) return code - LOWER + 26;\n  };\n\n  jsPDF.API.TTFFont = function () {\n    /************************************************************************/\n\n    /* function : open                                                       */\n\n    /* comment : Decode the encoded ttf content and create a TTFFont object. */\n\n    /************************************************************************/\n    TTFFont.open = function (filename, name, vfs, encoding) {\n      var contents;\n\n      if (typeof vfs !== \"string\") {\n        throw new Error('Invalid argument supplied in TTFFont.open');\n      }\n\n      contents = b64ToByteArray(vfs);\n      return new TTFFont(contents, name, encoding);\n    };\n    /***************************************************************/\n\n    /* function : TTFFont gernerator                               */\n\n    /* comment : Decode TTF contents are parsed, Data,             */\n\n    /* Subset object is created, and registerTTF function is called.*/\n\n    /***************************************************************/\n\n\n    function TTFFont(rawData, name, encoding) {\n      var data;\n\n      this.rawData = rawData;\n      data = this.contents = new Data(rawData);\n      this.contents.pos = 4;\n\n      if (data.readString(4) === 'ttcf') {\n        if (!name) {\n          throw new Error(\"Must specify a font name for TTC files.\");\n        }\n        throw new Error(\"Font \" + name + \" not found in TTC file.\");\n      } else {\n        data.pos = 0;\n        this.parse();\n        this.subset = new Subset(this);\n        this.registerTTF();\n      }\n    }\n    /********************************************************/\n\n    /* function : parse                                     */\n\n    /* comment : TTF Parses the file contents by each table.*/\n\n    /********************************************************/\n\n\n    TTFFont.prototype.parse = function () {\n      this.directory = new Directory(this.contents);\n      this.head = new HeadTable(this);\n      this.name = new NameTable(this);\n      this.cmap = new CmapTable(this);\n      this.toUnicode = new Map();\n      this.hhea = new HheaTable(this);\n      this.maxp = new MaxpTable(this);\n      this.hmtx = new HmtxTable(this);\n      this.post = new PostTable(this);\n      this.os2 = new OS2Table(this);\n      this.loca = new LocaTable(this);\n      this.glyf = new GlyfTable(this);\n      this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender;\n      this.decender = this.os2.exists && this.os2.decender || this.hhea.decender;\n      this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap;\n      return this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];\n    };\n    /***************************************************************/\n\n    /* function : registerTTF                                      */\n\n    /* comment : Get the value to assign pdf font descriptors.     */\n\n    /***************************************************************/\n\n\n    TTFFont.prototype.registerTTF = function () {\n      var e, hi, low, raw, _ref;\n\n      this.scaleFactor = 1000.0 / this.head.unitsPerEm;\n\n      this.bbox = function () {\n        var _i, _len, _ref, _results;\n\n        _ref = this.bbox;\n        _results = [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          e = _ref[_i];\n\n          _results.push(Math.round(e * this.scaleFactor));\n        }\n\n        return _results;\n      }.call(this);\n\n      this.stemV = 0;\n\n      if (this.post.exists) {\n        raw = this.post.italic_angle;\n        hi = raw >> 16;\n        low = raw & 0xFF;\n\n        if (hi & 0x8000 !== 0) {\n          hi = -((hi ^ 0xFFFF) + 1);\n        }\n\n        this.italicAngle = +(\"\" + hi + \".\" + low);\n      } else {\n        this.italicAngle = 0;\n      }\n\n      this.ascender = Math.round(this.ascender * this.scaleFactor);\n      this.decender = Math.round(this.decender * this.scaleFactor);\n      this.lineGap = Math.round(this.lineGap * this.scaleFactor);\n      this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender;\n      this.xHeight = this.os2.exists && this.os2.xHeight || 0;\n      this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8;\n      this.isSerif = (_ref = this.familyClass) === 1 || _ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 7;\n      this.isScript = this.familyClass === 10;\n      this.flags = 0;\n\n      if (this.post.isFixedPitch) {\n        this.flags |= 1 << 0;\n      }\n\n      if (this.isSerif) {\n        this.flags |= 1 << 1;\n      }\n\n      if (this.isScript) {\n        this.flags |= 1 << 3;\n      }\n\n      if (this.italicAngle !== 0) {\n        this.flags |= 1 << 6;\n      }\n\n      this.flags |= 1 << 5;\n\n      if (!this.cmap.unicode) {\n        throw new Error('No unicode cmap for font');\n      }\n    };\n\n    TTFFont.prototype.characterToGlyph = function (character) {\n      var _ref;\n\n      return ((_ref = this.cmap.unicode) != null ? _ref.codeMap[character] : void 0) || 0;\n    };\n\n    TTFFont.prototype.widthOfGlyph = function (glyph) {\n      var scale;\n      scale = 1000.0 / this.head.unitsPerEm;\n      return this.hmtx.forGlyph(glyph).advance * scale;\n    };\n\n    TTFFont.prototype.widthOfString = function (string, size, charSpace) {\n      var charCode, i, scale, width, _i, _ref, charSpace;\n\n      string = '' + string;\n      width = 0;\n\n      for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        charCode = string.charCodeAt(i);\n        width += this.widthOfGlyph(this.characterToGlyph(charCode)) + charSpace * (1000 / size) || 0;\n      }\n\n      scale = size / 1000;\n      return width * scale;\n    };\n\n    TTFFont.prototype.lineHeight = function (size, includeGap) {\n      var gap;\n\n      if (includeGap == null) {\n        includeGap = false;\n      }\n\n      gap = includeGap ? this.lineGap : 0;\n      return (this.ascender + gap - this.decender) / 1000 * size;\n    };\n\n    return TTFFont;\n  }();\n  /************************************************************************************************/\n\n  /* function : Data                                                                              */\n\n  /* comment : The ttf data decoded and stored in an array is read and written to the Data object.*/\n\n  /************************************************************************************************/\n\n\n  var Data = function () {\n    function Data(data) {\n      this.data = data != null ? data : [];\n      this.pos = 0;\n      this.length = this.data.length;\n    }\n\n    Data.prototype.readByte = function () {\n      return this.data[this.pos++];\n    };\n\n    Data.prototype.writeByte = function (byte) {\n      return this.data[this.pos++] = byte;\n    };\n\n    Data.prototype.readUInt32 = function () {\n      var b1, b2, b3, b4;\n      b1 = this.readByte() * 0x1000000;\n      b2 = this.readByte() << 16;\n      b3 = this.readByte() << 8;\n      b4 = this.readByte();\n      return b1 + b2 + b3 + b4;\n    };\n\n    Data.prototype.writeUInt32 = function (val) {\n      this.writeByte(val >>> 24 & 0xff);\n      this.writeByte(val >> 16 & 0xff);\n      this.writeByte(val >> 8 & 0xff);\n      return this.writeByte(val & 0xff);\n    };\n\n    Data.prototype.readInt32 = function () {\n      var int;\n      int = this.readUInt32();\n\n      if (int >= 0x80000000) {\n        return int - 0x100000000;\n      } else {\n        return int;\n      }\n    };\n\n    Data.prototype.writeInt32 = function (val) {\n      if (val < 0) {\n        val += 0x100000000;\n      }\n\n      return this.writeUInt32(val);\n    };\n\n    Data.prototype.readUInt16 = function () {\n      var b1, b2;\n      b1 = this.readByte() << 8;\n      b2 = this.readByte();\n      return b1 | b2;\n    };\n\n    Data.prototype.writeUInt16 = function (val) {\n      this.writeByte(val >> 8 & 0xff);\n      return this.writeByte(val & 0xff);\n    };\n\n    Data.prototype.readInt16 = function () {\n      var int;\n      int = this.readUInt16();\n\n      if (int >= 0x8000) {\n        return int - 0x10000;\n      } else {\n        return int;\n      }\n    };\n\n    Data.prototype.writeInt16 = function (val) {\n      if (val < 0) {\n        val += 0x10000;\n      }\n\n      return this.writeUInt16(val);\n    };\n\n    Data.prototype.readString = function (length) {\n      var i, ret, _i;\n\n      ret = [];\n\n      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {\n        ret[i] = String.fromCharCode(this.readByte());\n      }\n\n      return ret.join('');\n    };\n\n    Data.prototype.writeString = function (val) {\n      var i, _i, _ref, _results;\n\n      _results = [];\n\n      for (i = _i = 0, _ref = val.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        _results.push(this.writeByte(val.charCodeAt(i)));\n      }\n\n      return _results;\n    };\n    /*Data.prototype.stringAt = function (pos, length) {\n        this.pos = pos;\n        return this.readString(length);\n    };*/\n\n\n    Data.prototype.readShort = function () {\n      return this.readInt16();\n    };\n\n    Data.prototype.writeShort = function (val) {\n      return this.writeInt16(val);\n    };\n\n    Data.prototype.readLongLong = function () {\n      var b1, b2, b3, b4, b5, b6, b7, b8;\n      b1 = this.readByte();\n      b2 = this.readByte();\n      b3 = this.readByte();\n      b4 = this.readByte();\n      b5 = this.readByte();\n      b6 = this.readByte();\n      b7 = this.readByte();\n      b8 = this.readByte();\n\n      if (b1 & 0x80) {\n        return ((b1 ^ 0xff) * 0x100000000000000 + (b2 ^ 0xff) * 0x1000000000000 + (b3 ^ 0xff) * 0x10000000000 + (b4 ^ 0xff) * 0x100000000 + (b5 ^ 0xff) * 0x1000000 + (b6 ^ 0xff) * 0x10000 + (b7 ^ 0xff) * 0x100 + (b8 ^ 0xff) + 1) * -1;\n      }\n\n      return b1 * 0x100000000000000 + b2 * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8;\n    };\n\n    Data.prototype.writeLongLong = function (val) {\n      var high, low;\n      high = Math.floor(val / 0x100000000);\n      low = val & 0xffffffff;\n      this.writeByte(high >> 24 & 0xff);\n      this.writeByte(high >> 16 & 0xff);\n      this.writeByte(high >> 8 & 0xff);\n      this.writeByte(high & 0xff);\n      this.writeByte(low >> 24 & 0xff);\n      this.writeByte(low >> 16 & 0xff);\n      this.writeByte(low >> 8 & 0xff);\n      return this.writeByte(low & 0xff);\n    };\n\n    Data.prototype.readInt = function () {\n      return this.readInt32();\n    };\n\n    Data.prototype.writeInt = function (val) {\n      return this.writeInt32(val);\n    };\n    /*Data.prototype.slice = function (start, end) {\n        return this.data.slice(start, end);\n    };*/\n\n\n    Data.prototype.read = function (bytes) {\n      var buf, i, _i;\n\n      buf = [];\n\n      for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {\n        buf.push(this.readByte());\n      }\n\n      return buf;\n    };\n\n    Data.prototype.write = function (bytes) {\n      var byte, _i, _len, _results;\n\n      _results = [];\n\n      for (_i = 0, _len = bytes.length; _i < _len; _i++) {\n        byte = bytes[_i];\n\n        _results.push(this.writeByte(byte));\n      }\n\n      return _results;\n    };\n\n    return Data;\n  }();\n\n  var Directory = function () {\n    var checksum;\n    /*****************************************************************************************************/\n\n    /* function : Directory generator                                                                    */\n\n    /* comment : Initialize the offset, tag, length, and checksum for each table for the font to be used.*/\n\n    /*****************************************************************************************************/\n\n    function Directory(data) {\n      var entry, i, _i, _ref;\n\n      this.scalarType = data.readInt();\n      this.tableCount = data.readShort();\n      this.searchRange = data.readShort();\n      this.entrySelector = data.readShort();\n      this.rangeShift = data.readShort();\n      this.tables = {};\n\n      for (i = _i = 0, _ref = this.tableCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        entry = {\n          tag: data.readString(4),\n          checksum: data.readInt(),\n          offset: data.readInt(),\n          length: data.readInt()\n        };\n        this.tables[entry.tag] = entry;\n      }\n    }\n    /********************************************************************************************************/\n\n    /* function : encode                                                                                    */\n\n    /* comment : It encodes and stores the font table object and information used for the directory object. */\n\n    /********************************************************************************************************/\n\n\n    Directory.prototype.encode = function (tables) {\n      var adjustment, directory, directoryLength, entrySelector, headOffset, log2, offset, rangeShift, searchRange, sum, table, tableCount, tableData, tag;\n      tableCount = Object.keys(tables).length;\n      log2 = Math.log(2);\n      searchRange = Math.floor(Math.log(tableCount) / log2) * 16;\n      entrySelector = Math.floor(searchRange / log2);\n      rangeShift = tableCount * 16 - searchRange;\n      directory = new Data();\n      directory.writeInt(this.scalarType);\n      directory.writeShort(tableCount);\n      directory.writeShort(searchRange);\n      directory.writeShort(entrySelector);\n      directory.writeShort(rangeShift);\n      directoryLength = tableCount * 16;\n      offset = directory.pos + directoryLength;\n      headOffset = null;\n      tableData = [];\n\n      for (tag in tables) {\n        table = tables[tag];\n        directory.writeString(tag);\n        directory.writeInt(checksum(table));\n        directory.writeInt(offset);\n        directory.writeInt(table.length);\n        tableData = tableData.concat(table);\n\n        if (tag === 'head') {\n          headOffset = offset;\n        }\n\n        offset += table.length;\n\n        while (offset % 4) {\n          tableData.push(0);\n          offset++;\n        }\n      }\n\n      directory.write(tableData);\n      sum = checksum(directory.data);\n      adjustment = 0xB1B0AFBA - sum;\n      directory.pos = headOffset + 8;\n      directory.writeUInt32(adjustment);\n      return directory.data;\n    };\n    /***************************************************************/\n\n    /* function : checksum                                         */\n\n    /* comment : Duplicate the table for the tag.                  */\n\n    /***************************************************************/\n\n\n    checksum = function checksum(data) {\n      var i, sum, tmp, _i, _ref;\n\n      data = __slice.call(data);\n\n      while (data.length % 4) {\n        data.push(0);\n      }\n\n      tmp = new Data(data);\n      sum = 0;\n\n      for (i = _i = 0, _ref = data.length; _i < _ref; i = _i += 4) {\n        sum += tmp.readUInt32();\n      }\n\n      return sum & 0xFFFFFFFF;\n    };\n\n    return Directory;\n  }();\n\n  var Table,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function __extends(child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n  /***************************************************************/\n\n  /* function : Table                                            */\n\n  /* comment : Save info for each table, and parse the table.    */\n\n  /***************************************************************/\n\n  Table = function () {\n    function Table(file) {\n      var info;\n      this.file = file;\n      info = this.file.directory.tables[this.tag];\n      this.exists = !!info;\n\n      if (info) {\n        this.offset = info.offset, this.length = info.length;\n        this.parse(this.file.contents);\n      }\n    }\n\n    Table.prototype.parse = function () {};\n\n    Table.prototype.encode = function () {};\n\n    Table.prototype.raw = function () {\n      if (!this.exists) {\n        return null;\n      }\n\n      this.file.contents.pos = this.offset;\n      return this.file.contents.read(this.length);\n    };\n\n    return Table;\n  }();\n\n  var HeadTable = function (_super) {\n    __extends(HeadTable, _super);\n\n    function HeadTable() {\n      return HeadTable.__super__.constructor.apply(this, arguments);\n    }\n\n    HeadTable.prototype.tag = 'head';\n\n    HeadTable.prototype.parse = function (data) {\n      data.pos = this.offset;\n      this.version = data.readInt();\n      this.revision = data.readInt();\n      this.checkSumAdjustment = data.readInt();\n      this.magicNumber = data.readInt();\n      this.flags = data.readShort();\n      this.unitsPerEm = data.readShort();\n      this.created = data.readLongLong();\n      this.modified = data.readLongLong();\n      this.xMin = data.readShort();\n      this.yMin = data.readShort();\n      this.xMax = data.readShort();\n      this.yMax = data.readShort();\n      this.macStyle = data.readShort();\n      this.lowestRecPPEM = data.readShort();\n      this.fontDirectionHint = data.readShort();\n      this.indexToLocFormat = data.readShort();\n      return this.glyphDataFormat = data.readShort();\n    };\n\n    HeadTable.prototype.encode = function (indexToLocFormat) {\n      var table;\n      table = new Data();\n      table.writeInt(this.version);\n      table.writeInt(this.revision);\n      table.writeInt(this.checkSumAdjustment);\n      table.writeInt(this.magicNumber);\n      table.writeShort(this.flags);\n      table.writeShort(this.unitsPerEm);\n      table.writeLongLong(this.created);\n      table.writeLongLong(this.modified);\n      table.writeShort(this.xMin);\n      table.writeShort(this.yMin);\n      table.writeShort(this.xMax);\n      table.writeShort(this.yMax);\n      table.writeShort(this.macStyle);\n      table.writeShort(this.lowestRecPPEM);\n      table.writeShort(this.fontDirectionHint);\n      table.writeShort(indexToLocFormat);\n      table.writeShort(this.glyphDataFormat);\n      return table.data;\n    };\n\n    return HeadTable;\n  }(Table);\n  /************************************************************************************/\n\n  /* function : CmapEntry                                                             */\n\n  /* comment : Cmap Initializes and encodes object information (required by pdf spec).*/\n\n  /************************************************************************************/\n\n\n  var CmapEntry = function () {\n    function CmapEntry(data, offset) {\n      var code, count, endCode, glyphId, glyphIds, i, idDelta, idRangeOffset, index, saveOffset, segCount, segCountX2, start, startCode, tail, _i, _j, _k, _len;\n\n      this.platformID = data.readUInt16();\n      this.encodingID = data.readShort();\n      this.offset = offset + data.readInt();\n      saveOffset = data.pos;\n      data.pos = this.offset;\n      this.format = data.readUInt16();\n      this.length = data.readUInt16();\n      this.language = data.readUInt16();\n      this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4;\n      this.codeMap = {};\n\n      switch (this.format) {\n        case 0:\n          for (i = _i = 0; _i < 256; i = ++_i) {\n            this.codeMap[i] = data.readByte();\n          }\n\n          break;\n\n        case 4:\n          segCountX2 = data.readUInt16();\n          segCount = segCountX2 / 2;\n          data.pos += 6;\n\n          endCode = function () {\n            var _j, _results;\n\n            _results = [];\n\n            for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {\n              _results.push(data.readUInt16());\n            }\n\n            return _results;\n          }();\n\n          data.pos += 2;\n\n          startCode = function () {\n            var _j, _results;\n\n            _results = [];\n\n            for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {\n              _results.push(data.readUInt16());\n            }\n\n            return _results;\n          }();\n\n          idDelta = function () {\n            var _j, _results;\n\n            _results = [];\n\n            for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {\n              _results.push(data.readUInt16());\n            }\n\n            return _results;\n          }();\n\n          idRangeOffset = function () {\n            var _j, _results;\n\n            _results = [];\n\n            for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {\n              _results.push(data.readUInt16());\n            }\n\n            return _results;\n          }();\n\n          count = (this.length - data.pos + this.offset) / 2;\n\n          glyphIds = function () {\n            var _j, _results;\n\n            _results = [];\n\n            for (i = _j = 0; 0 <= count ? _j < count : _j > count; i = 0 <= count ? ++_j : --_j) {\n              _results.push(data.readUInt16());\n            }\n\n            return _results;\n          }();\n\n          for (i = _j = 0, _len = endCode.length; _j < _len; i = ++_j) {\n            tail = endCode[i];\n            start = startCode[i];\n\n            for (code = _k = start; start <= tail ? _k <= tail : _k >= tail; code = start <= tail ? ++_k : --_k) {\n              if (idRangeOffset[i] === 0) {\n                glyphId = code + idDelta[i];\n              } else {\n                index = idRangeOffset[i] / 2 + (code - start) - (segCount - i);\n                glyphId = glyphIds[index] || 0;\n\n                if (glyphId !== 0) {\n                  glyphId += idDelta[i];\n                }\n              }\n\n              this.codeMap[code] = glyphId & 0xFFFF;\n            }\n          }\n\n      }\n\n      data.pos = saveOffset;\n    }\n\n    CmapEntry.encode = function (charmap, encoding) {\n      var charMap, code, codeMap, codes, delta, deltas, diff, endCode, endCodes, entrySelector, glyphIDs, i, id, indexes, last, map, nextID, offset, old, rangeOffsets, rangeShift, result, searchRange, segCount, segCountX2, startCode, startCodes, startGlyph, subtable, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _name, _o, _p, _q;\n\n      subtable = new Data();\n      codes = Object.keys(charmap).sort(function (a, b) {\n        return a - b;\n      });\n\n      switch (encoding) {\n        case 'macroman':\n          id = 0;\n\n          indexes = function () {\n            var _i, _results;\n\n            _results = [];\n\n            for (i = _i = 0; _i < 256; i = ++_i) {\n              _results.push(0);\n            }\n\n            return _results;\n          }();\n\n          map = {\n            0: 0\n          };\n          codeMap = {};\n\n          for (_i = 0, _len = codes.length; _i < _len; _i++) {\n            code = codes[_i];\n\n            if (map[_name = charmap[code]] == null) {\n              map[_name] = ++id;\n            }\n\n            codeMap[code] = {\n              old: charmap[code],\n              \"new\": map[charmap[code]]\n            };\n            indexes[code] = map[charmap[code]];\n          }\n\n          subtable.writeUInt16(1);\n          subtable.writeUInt16(0);\n          subtable.writeUInt32(12);\n          subtable.writeUInt16(0);\n          subtable.writeUInt16(262);\n          subtable.writeUInt16(0);\n          subtable.write(indexes);\n          return result = {\n            charMap: codeMap,\n            subtable: subtable.data,\n            maxGlyphID: id + 1\n          };\n\n        case 'unicode':\n          startCodes = [];\n          endCodes = [];\n          nextID = 0;\n          map = {};\n          charMap = {};\n          last = diff = null;\n\n          for (_j = 0, _len1 = codes.length; _j < _len1; _j++) {\n            code = codes[_j];\n            old = charmap[code];\n\n            if (map[old] == null) {\n              map[old] = ++nextID;\n            }\n\n            charMap[code] = {\n              old: old,\n              \"new\": map[old]\n            };\n            delta = map[old] - code;\n\n            if (last == null || delta !== diff) {\n              if (last) {\n                endCodes.push(last);\n              }\n\n              startCodes.push(code);\n              diff = delta;\n            }\n\n            last = code;\n          }\n\n          if (last) {\n            endCodes.push(last);\n          }\n\n          endCodes.push(0xFFFF);\n          startCodes.push(0xFFFF);\n          segCount = startCodes.length;\n          segCountX2 = segCount * 2;\n          searchRange = 2 * Math.pow(Math.log(segCount) / Math.LN2, 2);\n          entrySelector = Math.log(searchRange / 2) / Math.LN2;\n          rangeShift = 2 * segCount - searchRange;\n          deltas = [];\n          rangeOffsets = [];\n          glyphIDs = [];\n\n          for (i = _k = 0, _len2 = startCodes.length; _k < _len2; i = ++_k) {\n            startCode = startCodes[i];\n            endCode = endCodes[i];\n\n            if (startCode === 0xFFFF) {\n              deltas.push(0);\n              rangeOffsets.push(0);\n              break;\n            }\n\n            startGlyph = charMap[startCode][\"new\"];\n\n            if (startCode - startGlyph >= 0x8000) {\n              deltas.push(0);\n              rangeOffsets.push(2 * (glyphIDs.length + segCount - i));\n\n              for (code = _l = startCode; startCode <= endCode ? _l <= endCode : _l >= endCode; code = startCode <= endCode ? ++_l : --_l) {\n                glyphIDs.push(charMap[code][\"new\"]);\n              }\n            } else {\n              deltas.push(startGlyph - startCode);\n              rangeOffsets.push(0);\n            }\n          }\n\n          subtable.writeUInt16(3);\n          subtable.writeUInt16(1);\n          subtable.writeUInt32(12);\n          subtable.writeUInt16(4);\n          subtable.writeUInt16(16 + segCount * 8 + glyphIDs.length * 2);\n          subtable.writeUInt16(0);\n          subtable.writeUInt16(segCountX2);\n          subtable.writeUInt16(searchRange);\n          subtable.writeUInt16(entrySelector);\n          subtable.writeUInt16(rangeShift);\n\n          for (_m = 0, _len3 = endCodes.length; _m < _len3; _m++) {\n            code = endCodes[_m];\n            subtable.writeUInt16(code);\n          }\n\n          subtable.writeUInt16(0);\n\n          for (_n = 0, _len4 = startCodes.length; _n < _len4; _n++) {\n            code = startCodes[_n];\n            subtable.writeUInt16(code);\n          }\n\n          for (_o = 0, _len5 = deltas.length; _o < _len5; _o++) {\n            delta = deltas[_o];\n            subtable.writeUInt16(delta);\n          }\n\n          for (_p = 0, _len6 = rangeOffsets.length; _p < _len6; _p++) {\n            offset = rangeOffsets[_p];\n            subtable.writeUInt16(offset);\n          }\n\n          for (_q = 0, _len7 = glyphIDs.length; _q < _len7; _q++) {\n            id = glyphIDs[_q];\n            subtable.writeUInt16(id);\n          }\n\n          return result = {\n            charMap: charMap,\n            subtable: subtable.data,\n            maxGlyphID: nextID + 1\n          };\n      }\n    };\n\n    return CmapEntry;\n  }();\n\n  var CmapTable = function (_super) {\n    __extends(CmapTable, _super);\n\n    function CmapTable() {\n      return CmapTable.__super__.constructor.apply(this, arguments);\n    }\n\n    CmapTable.prototype.tag = 'cmap';\n\n    CmapTable.prototype.parse = function (data) {\n      var entry, i, tableCount, _i;\n\n      data.pos = this.offset;\n      this.version = data.readUInt16();\n      tableCount = data.readUInt16();\n      this.tables = [];\n      this.unicode = null;\n\n      for (i = _i = 0; 0 <= tableCount ? _i < tableCount : _i > tableCount; i = 0 <= tableCount ? ++_i : --_i) {\n        entry = new CmapEntry(data, this.offset);\n        this.tables.push(entry);\n\n        if (entry.isUnicode) {\n          if (this.unicode == null) {\n            this.unicode = entry;\n          }\n        }\n      }\n\n      return true;\n    };\n    /*************************************************************************/\n\n    /* function : encode                                                     */\n\n    /* comment : Encode the cmap table corresponding to the input character. */\n\n    /*************************************************************************/\n\n\n    CmapTable.encode = function (charmap, encoding) {\n      var result, table;\n\n      if (encoding == null) {\n        encoding = 'macroman';\n      }\n\n      result = CmapEntry.encode(charmap, encoding);\n      table = new Data();\n      table.writeUInt16(0);\n      table.writeUInt16(1);\n      result.table = table.data.concat(result.subtable);\n      return result;\n    };\n\n    return CmapTable;\n  }(Table);\n\n  var HheaTable = function (_super) {\n    __extends(HheaTable, _super);\n\n    function HheaTable() {\n      return HheaTable.__super__.constructor.apply(this, arguments);\n    }\n\n    HheaTable.prototype.tag = 'hhea';\n\n    HheaTable.prototype.parse = function (data) {\n      data.pos = this.offset;\n      this.version = data.readInt();\n      this.ascender = data.readShort();\n      this.decender = data.readShort();\n      this.lineGap = data.readShort();\n      this.advanceWidthMax = data.readShort();\n      this.minLeftSideBearing = data.readShort();\n      this.minRightSideBearing = data.readShort();\n      this.xMaxExtent = data.readShort();\n      this.caretSlopeRise = data.readShort();\n      this.caretSlopeRun = data.readShort();\n      this.caretOffset = data.readShort();\n      data.pos += 4 * 2;\n      this.metricDataFormat = data.readShort();\n      return this.numberOfMetrics = data.readUInt16();\n    };\n    /*HheaTable.prototype.encode = function (ids) {\n        var i, table, _i, _ref;\n        table = new Data;\n        table.writeInt(this.version);\n        table.writeShort(this.ascender);\n        table.writeShort(this.decender);\n        table.writeShort(this.lineGap);\n        table.writeShort(this.advanceWidthMax);\n        table.writeShort(this.minLeftSideBearing);\n        table.writeShort(this.minRightSideBearing);\n        table.writeShort(this.xMaxExtent);\n        table.writeShort(this.caretSlopeRise);\n        table.writeShort(this.caretSlopeRun);\n        table.writeShort(this.caretOffset);\n        for (i = _i = 0, _ref = 4 * 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            table.writeByte(0);\n        }\n        table.writeShort(this.metricDataFormat);\n        table.writeUInt16(ids.length);\n        return table.data;\n    };*/\n\n\n    return HheaTable;\n  }(Table);\n\n  var OS2Table = function (_super) {\n    __extends(OS2Table, _super);\n\n    function OS2Table() {\n      return OS2Table.__super__.constructor.apply(this, arguments);\n    }\n\n    OS2Table.prototype.tag = 'OS/2';\n\n    OS2Table.prototype.parse = function (data) {\n      var i;\n      data.pos = this.offset;\n      this.version = data.readUInt16();\n      this.averageCharWidth = data.readShort();\n      this.weightClass = data.readUInt16();\n      this.widthClass = data.readUInt16();\n      this.type = data.readShort();\n      this.ySubscriptXSize = data.readShort();\n      this.ySubscriptYSize = data.readShort();\n      this.ySubscriptXOffset = data.readShort();\n      this.ySubscriptYOffset = data.readShort();\n      this.ySuperscriptXSize = data.readShort();\n      this.ySuperscriptYSize = data.readShort();\n      this.ySuperscriptXOffset = data.readShort();\n      this.ySuperscriptYOffset = data.readShort();\n      this.yStrikeoutSize = data.readShort();\n      this.yStrikeoutPosition = data.readShort();\n      this.familyClass = data.readShort();\n\n      this.panose = function () {\n        var _i, _results;\n\n        _results = [];\n\n        for (i = _i = 0; _i < 10; i = ++_i) {\n          _results.push(data.readByte());\n        }\n\n        return _results;\n      }();\n\n      this.charRange = function () {\n        var _i, _results;\n\n        _results = [];\n\n        for (i = _i = 0; _i < 4; i = ++_i) {\n          _results.push(data.readInt());\n        }\n\n        return _results;\n      }();\n\n      this.vendorID = data.readString(4);\n      this.selection = data.readShort();\n      this.firstCharIndex = data.readShort();\n      this.lastCharIndex = data.readShort();\n\n      if (this.version > 0) {\n        this.ascent = data.readShort();\n        this.descent = data.readShort();\n        this.lineGap = data.readShort();\n        this.winAscent = data.readShort();\n        this.winDescent = data.readShort();\n\n        this.codePageRange = function () {\n          var _i, _results;\n\n          _results = [];\n\n          for (i = _i = 0; _i < 2; i = ++_i) {\n            _results.push(data.readInt());\n          }\n\n          return _results;\n        }();\n\n        if (this.version > 1) {\n          this.xHeight = data.readShort();\n          this.capHeight = data.readShort();\n          this.defaultChar = data.readShort();\n          this.breakChar = data.readShort();\n          return this.maxContext = data.readShort();\n        }\n      }\n    };\n    /*OS2Table.prototype.encode = function () {\n        return this.raw();\n    };*/\n\n\n    return OS2Table;\n  }(Table);\n\n  var PostTable = function (_super) {\n\n    __extends(PostTable, _super);\n\n    function PostTable() {\n      return PostTable.__super__.constructor.apply(this, arguments);\n    }\n\n    PostTable.prototype.tag = 'post';\n\n    PostTable.prototype.parse = function (data) {\n      var i, length, numberOfGlyphs, _i, _results;\n\n      data.pos = this.offset;\n      this.format = data.readInt();\n      this.italicAngle = data.readInt();\n      this.underlinePosition = data.readShort();\n      this.underlineThickness = data.readShort();\n      this.isFixedPitch = data.readInt();\n      this.minMemType42 = data.readInt();\n      this.maxMemType42 = data.readInt();\n      this.minMemType1 = data.readInt();\n      this.maxMemType1 = data.readInt();\n\n      switch (this.format) {\n        case 0x00010000:\n          break;\n\n        case 0x00020000:\n          numberOfGlyphs = data.readUInt16();\n          this.glyphNameIndex = [];\n\n          for (i = _i = 0; 0 <= numberOfGlyphs ? _i < numberOfGlyphs : _i > numberOfGlyphs; i = 0 <= numberOfGlyphs ? ++_i : --_i) {\n            this.glyphNameIndex.push(data.readUInt16());\n          }\n\n          this.names = [];\n          _results = [];\n\n          while (data.pos < this.offset + this.length) {\n            length = data.readByte();\n\n            _results.push(this.names.push(data.readString(length)));\n          }\n\n          return _results;\n          break;\n\n        case 0x00025000:\n          numberOfGlyphs = data.readUInt16();\n          return this.offsets = data.read(numberOfGlyphs);\n\n        case 0x00030000:\n          break;\n\n        case 0x00040000:\n          return this.map = function () {\n            var _j, _ref, _results1;\n\n            _results1 = [];\n\n            for (i = _j = 0, _ref = this.file.maxp.numGlyphs; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {\n              _results1.push(data.readUInt32());\n            }\n\n            return _results1;\n          }.call(this);\n      }\n    };\n    return PostTable;\n  }(Table);\n  /*********************************************************************************************************/\n\n  /* function : NameEntry                                                                                  */\n\n  /* comment : Store copyright information, platformID, encodingID, and languageID in the NameEntry object.*/\n\n  /*********************************************************************************************************/\n\n\n  var NameEntry = function () {\n    function NameEntry(raw, entry) {\n      this.raw = raw;\n      this.length = raw.length;\n      this.platformID = entry.platformID;\n      this.encodingID = entry.encodingID;\n      this.languageID = entry.languageID;\n    }\n\n    return NameEntry;\n  }();\n\n  var NameTable = function (_super) {\n\n    __extends(NameTable, _super);\n\n    function NameTable() {\n      return NameTable.__super__.constructor.apply(this, arguments);\n    }\n\n    NameTable.prototype.tag = 'name';\n\n    NameTable.prototype.parse = function (data) {\n      var count, entries, entry, format, i, name, stringOffset, strings, text, _i, _j, _len, _name;\n\n      data.pos = this.offset;\n      format = data.readShort();\n      count = data.readShort();\n      stringOffset = data.readShort();\n      entries = [];\n\n      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {\n        entries.push({\n          platformID: data.readShort(),\n          encodingID: data.readShort(),\n          languageID: data.readShort(),\n          nameID: data.readShort(),\n          length: data.readShort(),\n          offset: this.offset + stringOffset + data.readShort()\n        });\n      }\n\n      strings = {};\n\n      for (i = _j = 0, _len = entries.length; _j < _len; i = ++_j) {\n        entry = entries[i];\n        data.pos = entry.offset;\n        text = data.readString(entry.length);\n        name = new NameEntry(text, entry);\n\n        if (strings[_name = entry.nameID] == null) {\n          strings[_name] = [];\n        }\n\n        strings[entry.nameID].push(name);\n      }\n\n      this.strings = strings;\n      this.copyright = strings[0];\n      this.fontFamily = strings[1];\n      this.fontSubfamily = strings[2];\n      this.uniqueSubfamily = strings[3];\n      this.fontName = strings[4];\n      this.version = strings[5];\n\n      try {\n        this.postscriptName = strings[6][0].raw.replace(/[\\x00-\\x19\\x80-\\xff]/g, \"\");\n      } catch (e) {\n        this.postscriptName = strings[4][0].raw.replace(/[\\x00-\\x19\\x80-\\xff]/g, \"\");\n      }\n\n      this.trademark = strings[7];\n      this.manufacturer = strings[8];\n      this.designer = strings[9];\n      this.description = strings[10];\n      this.vendorUrl = strings[11];\n      this.designerUrl = strings[12];\n      this.license = strings[13];\n      this.licenseUrl = strings[14];\n      this.preferredFamily = strings[15];\n      this.preferredSubfamily = strings[17];\n      this.compatibleFull = strings[18];\n      return this.sampleText = strings[19];\n    };\n    /*NameTable.prototype.encode = function () {\n        var id, list, nameID, nameTable, postscriptName, strCount, strTable, string, strings, table, val, _i, _len, _ref;\n        strings = {};\n        _ref = this.strings;\n        for (id in _ref) {\n            val = _ref[id];\n            strings[id] = val;\n        }\n        postscriptName = new NameEntry(\"\" + subsetTag + \"+\" + this.postscriptName, {\n            platformID: 1\n            , encodingID: 0\n            , languageID: 0\n        });\n        strings[6] = [postscriptName];\n        subsetTag = successorOf(subsetTag);\n        strCount = 0;\n        for (id in strings) {\n            list = strings[id];\n            if (list != null) {\n                strCount += list.length;\n            }\n        }\n        table = new Data;\n        strTable = new Data;\n        table.writeShort(0);\n        table.writeShort(strCount);\n        table.writeShort(6 + 12 * strCount);\n        for (nameID in strings) {\n            list = strings[nameID];\n            if (list != null) {\n                for (_i = 0, _len = list.length; _i < _len; _i++) {\n                    string = list[_i];\n                    table.writeShort(string.platformID);\n                    table.writeShort(string.encodingID);\n                    table.writeShort(string.languageID);\n                    table.writeShort(nameID);\n                    table.writeShort(string.length);\n                    table.writeShort(strTable.pos);\n                    strTable.writeString(string.raw);\n                }\n            }\n        }\n        return nameTable = {\n            postscriptName: postscriptName.raw\n            , table: table.data.concat(strTable.data)\n        };\n    };*/\n\n    return NameTable;\n  }(Table);\n\n  var MaxpTable = function (_super) {\n    __extends(MaxpTable, _super);\n\n    function MaxpTable() {\n      return MaxpTable.__super__.constructor.apply(this, arguments);\n    }\n\n    MaxpTable.prototype.tag = 'maxp';\n\n    MaxpTable.prototype.parse = function (data) {\n      data.pos = this.offset;\n      this.version = data.readInt();\n      this.numGlyphs = data.readUInt16();\n      this.maxPoints = data.readUInt16();\n      this.maxContours = data.readUInt16();\n      this.maxCompositePoints = data.readUInt16();\n      this.maxComponentContours = data.readUInt16();\n      this.maxZones = data.readUInt16();\n      this.maxTwilightPoints = data.readUInt16();\n      this.maxStorage = data.readUInt16();\n      this.maxFunctionDefs = data.readUInt16();\n      this.maxInstructionDefs = data.readUInt16();\n      this.maxStackElements = data.readUInt16();\n      this.maxSizeOfInstructions = data.readUInt16();\n      this.maxComponentElements = data.readUInt16();\n      return this.maxComponentDepth = data.readUInt16();\n    };\n    /*MaxpTable.prototype.encode = function (ids) {\n        var table;\n        table = new Data;\n        table.writeInt(this.version);\n        table.writeUInt16(ids.length);\n        table.writeUInt16(this.maxPoints);\n        table.writeUInt16(this.maxContours);\n        table.writeUInt16(this.maxCompositePoints);\n        table.writeUInt16(this.maxComponentContours);\n        table.writeUInt16(this.maxZones);\n        table.writeUInt16(this.maxTwilightPoints);\n        table.writeUInt16(this.maxStorage);\n        table.writeUInt16(this.maxFunctionDefs);\n        table.writeUInt16(this.maxInstructionDefs);\n        table.writeUInt16(this.maxStackElements);\n        table.writeUInt16(this.maxSizeOfInstructions);\n        table.writeUInt16(this.maxComponentElements);\n        table.writeUInt16(this.maxComponentDepth);\n        return table.data;\n    };*/\n\n\n    return MaxpTable;\n  }(Table);\n\n  var HmtxTable = function (_super) {\n    __extends(HmtxTable, _super);\n\n    function HmtxTable() {\n      return HmtxTable.__super__.constructor.apply(this, arguments);\n    }\n\n    HmtxTable.prototype.tag = 'hmtx';\n\n    HmtxTable.prototype.parse = function (data) {\n      var i, last, lsbCount, m, _i, _j, _ref, _results;\n\n      data.pos = this.offset;\n      this.metrics = [];\n\n      for (i = _i = 0, _ref = this.file.hhea.numberOfMetrics; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        this.metrics.push({\n          advance: data.readUInt16(),\n          lsb: data.readInt16()\n        });\n      }\n\n      lsbCount = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics;\n\n      this.leftSideBearings = function () {\n        var _j, _results;\n\n        _results = [];\n\n        for (i = _j = 0; 0 <= lsbCount ? _j < lsbCount : _j > lsbCount; i = 0 <= lsbCount ? ++_j : --_j) {\n          _results.push(data.readInt16());\n        }\n\n        return _results;\n      }();\n\n      this.widths = function () {\n        var _j, _len, _ref1, _results;\n\n        _ref1 = this.metrics;\n        _results = [];\n\n        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {\n          m = _ref1[_j];\n\n          _results.push(m.advance);\n        }\n\n        return _results;\n      }.call(this);\n\n      last = this.widths[this.widths.length - 1];\n      _results = [];\n\n      for (i = _j = 0; 0 <= lsbCount ? _j < lsbCount : _j > lsbCount; i = 0 <= lsbCount ? ++_j : --_j) {\n        _results.push(this.widths.push(last));\n      }\n\n      return _results;\n    };\n    /***************************************************************/\n\n    /* function : forGlyph                                         */\n\n    /* comment : Returns the advance width and lsb for this glyph. */\n\n    /***************************************************************/\n\n\n    HmtxTable.prototype.forGlyph = function (id) {\n      var metrics;\n\n      if (id in this.metrics) {\n        return this.metrics[id];\n      }\n\n      return metrics = {\n        advance: this.metrics[this.metrics.length - 1].advance,\n        lsb: this.leftSideBearings[id - this.metrics.length]\n      };\n    };\n    /*HmtxTable.prototype.encode = function (mapping) {\n        var id, metric, table, _i, _len;\n        table = new Data;\n        for (_i = 0, _len = mapping.length; _i < _len; _i++) {\n            id = mapping[_i];\n            metric = this.forGlyph(id);\n            table.writeUInt16(metric.advance);\n            table.writeUInt16(metric.lsb);\n        }\n        return table.data;\n    };*/\n\n\n    return HmtxTable;\n  }(Table);\n\n  var __slice = [].slice;\n\n  var GlyfTable = function (_super) {\n    __extends(GlyfTable, _super);\n\n    function GlyfTable() {\n      return GlyfTable.__super__.constructor.apply(this, arguments);\n    }\n\n    GlyfTable.prototype.tag = 'glyf';\n\n    GlyfTable.prototype.parse = function (data) {\n      return this.cache = {};\n    };\n\n    GlyfTable.prototype.glyphFor = function (id) {\n      id = id;\n      var data, index, length, loca, numberOfContours, raw, xMax, xMin, yMax, yMin;\n\n      if (id in this.cache) {\n        return this.cache[id];\n      }\n\n      loca = this.file.loca;\n      data = this.file.contents;\n      index = loca.indexOf(id);\n      length = loca.lengthOf(id);\n\n      if (length === 0) {\n        return this.cache[id] = null;\n      }\n\n      data.pos = this.offset + index;\n      raw = new Data(data.read(length));\n      numberOfContours = raw.readShort();\n      xMin = raw.readShort();\n      yMin = raw.readShort();\n      xMax = raw.readShort();\n      yMax = raw.readShort();\n\n      if (numberOfContours === -1) {\n        this.cache[id] = new CompoundGlyph(raw, xMin, yMin, xMax, yMax);\n      } else {\n        this.cache[id] = new SimpleGlyph(raw, numberOfContours, xMin, yMin, xMax, yMax);\n      }\n\n      return this.cache[id];\n    };\n\n    GlyfTable.prototype.encode = function (glyphs, mapping, old2new) {\n      var glyph, id, offsets, table, _i, _len;\n\n      table = [];\n      offsets = [];\n\n      for (_i = 0, _len = mapping.length; _i < _len; _i++) {\n        id = mapping[_i];\n        glyph = glyphs[id];\n        offsets.push(table.length);\n\n        if (glyph) {\n          table = table.concat(glyph.encode(old2new));\n        }\n      }\n\n      offsets.push(table.length);\n      return {\n        table: table,\n        offsets: offsets\n      };\n    };\n\n    return GlyfTable;\n  }(Table);\n\n  var SimpleGlyph = function () {\n    /**************************************************************************/\n\n    /* function : SimpleGlyph                                                 */\n\n    /* comment : Stores raw, xMin, yMin, xMax, and yMax values for this glyph.*/\n\n    /**************************************************************************/\n    function SimpleGlyph(raw, numberOfContours, xMin, yMin, xMax, yMax) {\n      this.raw = raw;\n      this.numberOfContours = numberOfContours;\n      this.xMin = xMin;\n      this.yMin = yMin;\n      this.xMax = xMax;\n      this.yMax = yMax;\n      this.compound = false;\n    }\n\n    SimpleGlyph.prototype.encode = function () {\n      return this.raw.data;\n    };\n\n    return SimpleGlyph;\n  }();\n\n  var CompoundGlyph = function () {\n    var ARG_1_AND_2_ARE_WORDS, MORE_COMPONENTS, WE_HAVE_AN_X_AND_Y_SCALE, WE_HAVE_A_SCALE, WE_HAVE_A_TWO_BY_TWO;\n    ARG_1_AND_2_ARE_WORDS = 0x0001;\n    WE_HAVE_A_SCALE = 0x0008;\n    MORE_COMPONENTS = 0x0020;\n    WE_HAVE_AN_X_AND_Y_SCALE = 0x0040;\n    WE_HAVE_A_TWO_BY_TWO = 0x0080;\n    /********************************************************************************************************************/\n\n    /* function : CompoundGlypg generator                                                                               */\n\n    /* comment : It stores raw, xMin, yMin, xMax, yMax, glyph id, and glyph offset for the corresponding compound glyph.*/\n\n    /********************************************************************************************************************/\n\n    function CompoundGlyph(raw, xMin, yMin, xMax, yMax) {\n      var data, flags;\n      this.raw = raw;\n      this.xMin = xMin;\n      this.yMin = yMin;\n      this.xMax = xMax;\n      this.yMax = yMax;\n      this.compound = true;\n      this.glyphIDs = [];\n      this.glyphOffsets = [];\n      data = this.raw;\n\n      while (true) {\n        flags = data.readShort();\n        this.glyphOffsets.push(data.pos);\n        this.glyphIDs.push(data.readShort());\n\n        if (!(flags & MORE_COMPONENTS)) {\n          break;\n        }\n\n        if (flags & ARG_1_AND_2_ARE_WORDS) {\n          data.pos += 4;\n        } else {\n          data.pos += 2;\n        }\n\n        if (flags & WE_HAVE_A_TWO_BY_TWO) {\n          data.pos += 8;\n        } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {\n          data.pos += 4;\n        } else if (flags & WE_HAVE_A_SCALE) {\n          data.pos += 2;\n        }\n      }\n    }\n    /****************************************************************************************************************/\n\n    /* function : CompoundGlypg encode                                                                              */\n\n    /* comment : After creating a table for the characters you typed, you call directory.encode to encode the table.*/\n\n    /****************************************************************************************************************/\n\n\n    CompoundGlyph.prototype.encode = function (mapping) {\n      var i, id, result, _i, _len, _ref;\n\n      result = new Data(__slice.call(this.raw.data));\n      _ref = this.glyphIDs;\n\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        id = _ref[i];\n        result.pos = this.glyphOffsets[i];\n      }\n\n      return result.data;\n    };\n\n    return CompoundGlyph;\n  }();\n\n  var LocaTable = function (_super) {\n    __extends(LocaTable, _super);\n\n    function LocaTable() {\n      return LocaTable.__super__.constructor.apply(this, arguments);\n    }\n\n    LocaTable.prototype.tag = 'loca';\n\n    LocaTable.prototype.parse = function (data) {\n      var format, i;\n      data.pos = this.offset;\n      format = this.file.head.indexToLocFormat;\n\n      if (format === 0) {\n        return this.offsets = function () {\n          var _i, _ref, _results;\n\n          _results = [];\n\n          for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 2) {\n            _results.push(data.readUInt16() * 2);\n          }\n\n          return _results;\n        }.call(this);\n      } else {\n        return this.offsets = function () {\n          var _i, _ref, _results;\n\n          _results = [];\n\n          for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 4) {\n            _results.push(data.readUInt32());\n          }\n\n          return _results;\n        }.call(this);\n      }\n    };\n\n    LocaTable.prototype.indexOf = function (id) {\n      return this.offsets[id];\n    };\n\n    LocaTable.prototype.lengthOf = function (id) {\n      return this.offsets[id + 1] - this.offsets[id];\n    };\n\n    LocaTable.prototype.encode = function (offsets, activeGlyphs) {\n      var LocaTable = new Uint32Array(this.offsets.length);\n      var glyfPtr = 0;\n      var listGlyf = 0;\n\n      for (var k = 0; k < LocaTable.length; ++k) {\n        LocaTable[k] = glyfPtr;\n\n        if (listGlyf < activeGlyphs.length && activeGlyphs[listGlyf] == k) {\n          ++listGlyf;\n          LocaTable[k] = glyfPtr;\n          var start = this.offsets[k];\n          var len = this.offsets[k + 1] - start;\n\n          if (len > 0) {\n            glyfPtr += len;\n          }\n        }\n      }\n\n      var newLocaTable = new Array(LocaTable.length * 4);\n\n      for (var j = 0; j < LocaTable.length; ++j) {\n        newLocaTable[4 * j + 3] = LocaTable[j] & 0x000000ff;\n        newLocaTable[4 * j + 2] = (LocaTable[j] & 0x0000ff00) >> 8;\n        newLocaTable[4 * j + 1] = (LocaTable[j] & 0x00ff0000) >> 16;\n        newLocaTable[4 * j] = (LocaTable[j] & 0xff000000) >> 24;\n      }\n\n      return newLocaTable;\n    };\n\n    return LocaTable;\n  }(Table);\n  /************************************************************************************/\n\n  /* function : invert                                                                */\n\n  /* comment : Change the object's (key: value) to create an object with (value: key).*/\n\n  /************************************************************************************/\n\n\n  var invert = function invert(object) {\n    var key, ret, val;\n    ret = {};\n\n    for (key in object) {\n      val = object[key];\n      ret[val] = key;\n    }\n\n    return ret;\n  };\n  /*var successorOf = function (input) {\n      var added, alphabet, carry, i, index, isUpperCase, last, length, next, result;\n      alphabet = 'abcdefghijklmnopqrstuvwxyz';\n      length = alphabet.length;\n      result = input;\n      i = input.length;\n      while (i >= 0) {\n          last = input.charAt(--i);\n          if (isNaN(last)) {\n              index = alphabet.indexOf(last.toLowerCase());\n              if (index === -1) {\n                  next = last;\n                  carry = true;\n              }\n              else {\n                  next = alphabet.charAt((index + 1) % length);\n                  isUpperCase = last === last.toUpperCase();\n                  if (isUpperCase) {\n                      next = next.toUpperCase();\n                  }\n                  carry = index + 1 >= length;\n                  if (carry && i === 0) {\n                      added = isUpperCase ? 'A' : 'a';\n                      result = added + next + result.slice(1);\n                      break;\n                  }\n              }\n          }\n          else {\n              next = +last + 1;\n              carry = next > 9;\n              if (carry) {\n                  next = 0;\n              }\n              if (carry && i === 0) {\n                  result = '1' + next + result.slice(1);\n                  break;\n              }\n          }\n          result = result.slice(0, i) + next + result.slice(i + 1);\n          if (!carry) {\n              break;\n          }\n      }\n      return result;\n  };*/\n\n\n  var Subset = function () {\n    function Subset(font) {\n      this.font = font;\n      this.subset = {};\n      this.unicodes = {};\n      this.next = 33;\n    }\n    /*Subset.prototype.use = function (character) {\n        var i, _i, _ref;\n        if (typeof character === 'string') {\n            for (i = _i = 0, _ref = character.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n                this.use(character.charCodeAt(i));\n            }\n            return;\n        }\n        if (!this.unicodes[character]) {\n            this.subset[this.next] = character;\n            return this.unicodes[character] = this.next++;\n        }\n    };*/\n\n    /*Subset.prototype.encodeText = function (text) {\n        var char, i, string, _i, _ref;\n        string = '';\n        for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            char = this.unicodes[text.charCodeAt(i)];\n            string += String.fromCharCode(char);\n        }\n        return string;\n    };*/\n\n    /***************************************************************/\n\n    /* function : generateCmap                                     */\n\n    /* comment : Returns the unicode cmap for this font.         */\n\n    /***************************************************************/\n\n\n    Subset.prototype.generateCmap = function () {\n      var mapping, roman, unicode, unicodeCmap, _ref;\n\n      unicodeCmap = this.font.cmap.tables[0].codeMap;\n      mapping = {};\n      _ref = this.subset;\n\n      for (roman in _ref) {\n        unicode = _ref[roman];\n        mapping[roman] = unicodeCmap[unicode];\n      }\n\n      return mapping;\n    };\n    /*Subset.prototype.glyphIDs = function () {\n        var ret, roman, unicode, unicodeCmap, val, _ref;\n        unicodeCmap = this.font.cmap.tables[0].codeMap;\n        ret = [0];\n        _ref = this.subset;\n        for (roman in _ref) {\n            unicode = _ref[roman];\n            val = unicodeCmap[unicode];\n            if ((val != null) && __indexOf.call(ret, val) < 0) {\n                ret.push(val);\n            }\n        }\n        return ret.sort();\n    };*/\n\n    /******************************************************************/\n\n    /* function : glyphsFor                                           */\n\n    /* comment : Returns simple glyph objects for the input character.*/\n\n    /******************************************************************/\n\n\n    Subset.prototype.glyphsFor = function (glyphIDs) {\n      var additionalIDs, glyph, glyphs, id, _i, _len, _ref;\n\n      glyphs = {};\n\n      for (_i = 0, _len = glyphIDs.length; _i < _len; _i++) {\n        id = glyphIDs[_i];\n        glyphs[id] = this.font.glyf.glyphFor(id);\n      }\n\n      additionalIDs = [];\n\n      for (id in glyphs) {\n        glyph = glyphs[id];\n\n        if (glyph != null ? glyph.compound : void 0) {\n          additionalIDs.push.apply(additionalIDs, glyph.glyphIDs);\n        }\n      }\n\n      if (additionalIDs.length > 0) {\n        _ref = this.glyphsFor(additionalIDs);\n\n        for (id in _ref) {\n          glyph = _ref[id];\n          glyphs[id] = glyph;\n        }\n      }\n\n      return glyphs;\n    };\n    /***************************************************************/\n\n    /* function : encode                                           */\n\n    /* comment : Encode various tables for the characters you use. */\n\n    /***************************************************************/\n\n\n    Subset.prototype.encode = function (glyID, indexToLocFormat) {\n      var cmap, code, glyf, glyphs, id, ids, loca, new2old, newIDs, nextGlyphID, old2new, oldID, oldIDs, tables, _ref;\n\n      cmap = CmapTable.encode(this.generateCmap(), 'unicode');\n      glyphs = this.glyphsFor(glyID);\n      old2new = {\n        0: 0\n      };\n      _ref = cmap.charMap;\n\n      for (code in _ref) {\n        ids = _ref[code];\n        old2new[ids.old] = ids[\"new\"];\n      }\n\n      nextGlyphID = cmap.maxGlyphID;\n\n      for (oldID in glyphs) {\n        if (!(oldID in old2new)) {\n          old2new[oldID] = nextGlyphID++;\n        }\n      }\n\n      new2old = invert(old2new);\n      newIDs = Object.keys(new2old).sort(function (a, b) {\n        return a - b;\n      });\n\n      oldIDs = function () {\n        var _i, _len, _results;\n\n        _results = [];\n\n        for (_i = 0, _len = newIDs.length; _i < _len; _i++) {\n          id = newIDs[_i];\n\n          _results.push(new2old[id]);\n        }\n\n        return _results;\n      }();\n\n      glyf = this.font.glyf.encode(glyphs, oldIDs, old2new);\n      loca = this.font.loca.encode(glyf.offsets, oldIDs);\n      tables = {\n        cmap: this.font.cmap.raw(),\n        glyf: glyf.table,\n        loca: loca,\n        hmtx: this.font.hmtx.raw(),\n        hhea: this.font.hhea.raw(),\n        maxp: this.font.maxp.raw(),\n        post: this.font.post.raw(),\n        name: this.font.name.raw(),\n        head: this.font.head.encode(indexToLocFormat)\n      };\n\n      if (this.font.os2.exists) {\n        tables['OS/2'] = this.font.os2.raw();\n      }\n\n      return this.font.directory.encode(tables);\n    };\n\n    return Subset;\n  }();\n\n  jsPDF.API.PDFObject = function () {\n    var pad;\n\n    function PDFObject() {}\n\n    pad = function pad(str, length) {\n      return (Array(length + 1).join('0') + str).slice(-length);\n    };\n    /*****************************************************************************/\n\n    /* function : convert                                                        */\n\n    /* comment :Converts pdf tag's / FontBBox and array values in / W to strings */\n\n    /*****************************************************************************/\n\n\n    PDFObject.convert = function (object) {\n      var e, items, key, out, val;\n\n      if (Array.isArray(object)) {\n        items = function () {\n          var _i, _len, _results;\n\n          _results = [];\n\n          for (_i = 0, _len = object.length; _i < _len; _i++) {\n            e = object[_i];\n\n            _results.push(PDFObject.convert(e));\n          }\n\n          return _results;\n        }().join(' ');\n\n        return '[' + items + ']';\n      } else if (typeof object === 'string') {\n        return '/' + object;\n      } else if (object != null ? object.isString : void 0) {\n        return '(' + object + ')';\n      } else if (object instanceof Date) {\n        return '(D:' + pad(object.getUTCFullYear(), 4) + pad(object.getUTCMonth(), 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + 'Z)';\n      } else if ({}.toString.call(object) === '[object Object]') {\n        out = ['<<'];\n\n        for (key in object) {\n          val = object[key];\n          out.push('/' + key + ' ' + PDFObject.convert(val));\n        }\n\n        out.push('>>');\n        return out.join('\\n');\n      } else {\n        return '' + object;\n      }\n    };\n\n    return PDFObject;\n  }();\n})(jsPDF);\n\n// Generated by CoffeeScript 1.4.0\n\n/*\n# PNG.js\n# Copyright (c) 2011 Devon Govett\n# MIT LICENSE\n# \n# \n*/\n(function (global) {\n  var PNG;\n\n  PNG = function () {\n    var APNG_BLEND_OP_SOURCE, APNG_DISPOSE_OP_BACKGROUND, APNG_DISPOSE_OP_PREVIOUS, makeImage, scratchCanvas, scratchCtx;\n\n    PNG.load = function (url, canvas, callback) {\n      var xhr;\n\n      if (typeof canvas === 'function') {\n        callback = canvas;\n      }\n\n      xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", url, true);\n      xhr.responseType = \"arraybuffer\";\n\n      xhr.onload = function () {\n        var data, png;\n        data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        png = new PNG(data);\n\n        if (typeof (canvas != null ? canvas.getContext : void 0) === 'function') {\n          png.render(canvas);\n        }\n\n        return typeof callback === \"function\" ? callback(png) : void 0;\n      };\n\n      return xhr.send(null);\n    };\n    APNG_DISPOSE_OP_BACKGROUND = 1;\n    APNG_DISPOSE_OP_PREVIOUS = 2;\n    APNG_BLEND_OP_SOURCE = 0;\n\n    function PNG(data) {\n      var chunkSize, colors, palLen, delayDen, delayNum, frame, i, index, key, section, palShort, text, _i, _j, _ref;\n\n      this.data = data;\n      this.pos = 8;\n      this.palette = [];\n      this.imgData = [];\n      this.transparency = {};\n      this.animation = null;\n      this.text = {};\n      frame = null;\n\n      while (true) {\n        chunkSize = this.readUInt32();\n\n        section = function () {\n          var _i, _results;\n\n          _results = [];\n\n          for (i = _i = 0; _i < 4; i = ++_i) {\n            _results.push(String.fromCharCode(this.data[this.pos++]));\n          }\n\n          return _results;\n        }.call(this).join('');\n\n        switch (section) {\n          case 'IHDR':\n            this.width = this.readUInt32();\n            this.height = this.readUInt32();\n            this.bits = this.data[this.pos++];\n            this.colorType = this.data[this.pos++];\n            this.compressionMethod = this.data[this.pos++];\n            this.filterMethod = this.data[this.pos++];\n            this.interlaceMethod = this.data[this.pos++];\n            break;\n\n          case 'acTL':\n            this.animation = {\n              numFrames: this.readUInt32(),\n              numPlays: this.readUInt32() || Infinity,\n              frames: []\n            };\n            break;\n\n          case 'PLTE':\n            this.palette = this.read(chunkSize);\n            break;\n\n          case 'fcTL':\n            if (frame) {\n              this.animation.frames.push(frame);\n            }\n\n            this.pos += 4;\n            frame = {\n              width: this.readUInt32(),\n              height: this.readUInt32(),\n              xOffset: this.readUInt32(),\n              yOffset: this.readUInt32()\n            };\n            delayNum = this.readUInt16();\n            delayDen = this.readUInt16() || 100;\n            frame.delay = 1000 * delayNum / delayDen;\n            frame.disposeOp = this.data[this.pos++];\n            frame.blendOp = this.data[this.pos++];\n            frame.data = [];\n            break;\n\n          case 'IDAT':\n          case 'fdAT':\n            if (section === 'fdAT') {\n              this.pos += 4;\n              chunkSize -= 4;\n            }\n\n            data = (frame != null ? frame.data : void 0) || this.imgData;\n\n            for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {\n              data.push(this.data[this.pos++]);\n            }\n\n            break;\n\n          case 'tRNS':\n            this.transparency = {};\n\n            switch (this.colorType) {\n              case 3:\n                palLen = this.palette.length / 3;\n                this.transparency.indexed = this.read(chunkSize);\n                if (this.transparency.indexed.length > palLen) throw new Error('More transparent colors than palette size');\n                /*\n                 * According to the PNG spec trns should be increased to the same size as palette if shorter\n                 */\n                //palShort = 255 - this.transparency.indexed.length;\n\n                palShort = palLen - this.transparency.indexed.length;\n\n                if (palShort > 0) {\n                  for (i = _j = 0; 0 <= palShort ? _j < palShort : _j > palShort; i = 0 <= palShort ? ++_j : --_j) {\n                    this.transparency.indexed.push(255);\n                  }\n                }\n\n                break;\n\n              case 0:\n                this.transparency.grayscale = this.read(chunkSize)[0];\n                break;\n\n              case 2:\n                this.transparency.rgb = this.read(chunkSize);\n            }\n\n            break;\n\n          case 'tEXt':\n            text = this.read(chunkSize);\n            index = text.indexOf(0);\n            key = String.fromCharCode.apply(String, text.slice(0, index));\n            this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n            break;\n\n          case 'IEND':\n            if (frame) {\n              this.animation.frames.push(frame);\n            }\n\n            this.colors = function () {\n              switch (this.colorType) {\n                case 0:\n                case 3:\n                case 4:\n                  return 1;\n\n                case 2:\n                case 6:\n                  return 3;\n              }\n            }.call(this);\n\n            this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;\n            colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n            this.pixelBitlength = this.bits * colors;\n\n            this.colorSpace = function () {\n              switch (this.colors) {\n                case 1:\n                  return 'DeviceGray';\n\n                case 3:\n                  return 'DeviceRGB';\n              }\n            }.call(this);\n\n            this.imgData = new Uint8Array(this.imgData);\n            return;\n\n          default:\n            this.pos += chunkSize;\n        }\n\n        this.pos += 4;\n\n        if (this.pos > this.data.length) {\n          throw new Error(\"Incomplete or corrupt PNG file\");\n        }\n      }\n\n      return;\n    }\n\n    PNG.prototype.read = function (bytes) {\n      var i, _i, _results;\n\n      _results = [];\n\n      for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {\n        _results.push(this.data[this.pos++]);\n      }\n\n      return _results;\n    };\n\n    PNG.prototype.readUInt32 = function () {\n      var b1, b2, b3, b4;\n      b1 = this.data[this.pos++] << 24;\n      b2 = this.data[this.pos++] << 16;\n      b3 = this.data[this.pos++] << 8;\n      b4 = this.data[this.pos++];\n      return b1 | b2 | b3 | b4;\n    };\n\n    PNG.prototype.readUInt16 = function () {\n      var b1, b2;\n      b1 = this.data[this.pos++] << 8;\n      b2 = this.data[this.pos++];\n      return b1 | b2;\n    };\n\n    PNG.prototype.decodePixels = function (data) {\n      var pixelBytes = this.pixelBitlength / 8;\n      var fullPixels = new Uint8Array(this.width * this.height * pixelBytes);\n      var pos = 0;\n\n      var _this = this;\n\n      if (data == null) {\n        data = this.imgData;\n      }\n\n      if (data.length === 0) {\n        return new Uint8Array(0);\n      }\n\n      data = new FlateStream(data);\n      data = data.getBytes();\n\n      function pass(x0, y0, dx, dy) {\n        var abyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixels, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;\n\n        var w = Math.ceil((_this.width - x0) / dx),\n            h = Math.ceil((_this.height - y0) / dy);\n        var isFull = _this.width == w && _this.height == h;\n        scanlineLength = pixelBytes * w;\n        pixels = isFull ? fullPixels : new Uint8Array(scanlineLength * h);\n        length = data.length;\n        row = 0;\n        c = 0;\n\n        while (row < h && pos < length) {\n          switch (data[pos++]) {\n            case 0:\n              for (i = _i = 0; _i < scanlineLength; i = _i += 1) {\n                pixels[c++] = data[pos++];\n              }\n\n              break;\n\n            case 1:\n              for (i = _j = 0; _j < scanlineLength; i = _j += 1) {\n                abyte = data[pos++];\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                pixels[c++] = (abyte + left) % 256;\n              }\n\n              break;\n\n            case 2:\n              for (i = _k = 0; _k < scanlineLength; i = _k += 1) {\n                abyte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (upper + abyte) % 256;\n              }\n\n              break;\n\n            case 3:\n              for (i = _l = 0; _l < scanlineLength; i = _l += 1) {\n                abyte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (abyte + Math.floor((left + upper) / 2)) % 256;\n              }\n\n              break;\n\n            case 4:\n              for (i = _m = 0; _m < scanlineLength; i = _m += 1) {\n                abyte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                p = left + upper - upperLeft;\n                pa = Math.abs(p - left);\n                pb = Math.abs(p - upper);\n                pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                pixels[c++] = (abyte + paeth) % 256;\n              }\n\n              break;\n\n            default:\n              throw new Error(\"Invalid filter algorithm: \" + data[pos - 1]);\n          }\n\n          if (!isFull) {\n            var fullPos = ((y0 + row * dy) * _this.width + x0) * pixelBytes;\n            var partPos = row * scanlineLength;\n\n            for (i = 0; i < w; i += 1) {\n              for (var j = 0; j < pixelBytes; j += 1) {\n                fullPixels[fullPos++] = pixels[partPos++];\n              }\n\n              fullPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (_this.interlaceMethod == 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n\n        /* NOTE these seem to follow the pattern:\n         * pass(x, 0, 2*x, 2*x);\n         * pass(0, x,   x, 2*x);\n         * with x being 4, 2, 1.\n         */\n\n        pass(4, 0, 8, 8); // 2\n\n        pass(0, 4, 4, 8); // 3\n\n        pass(2, 0, 4, 4); // 4\n\n        pass(0, 2, 2, 4); // 5\n\n        pass(1, 0, 2, 2); // 6\n\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1);\n      }\n\n      return fullPixels;\n    };\n\n    PNG.prototype.decodePalette = function () {\n      var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;\n\n      palette = this.palette;\n      transparency = this.transparency.indexed || [];\n      ret = new Uint8Array((transparency.length || 0) + palette.length);\n      pos = 0;\n      length = palette.length;\n      c = 0;\n\n      for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {\n        ret[pos++] = palette[i];\n        ret[pos++] = palette[i + 1];\n        ret[pos++] = palette[i + 2];\n        ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;\n      }\n\n      return ret;\n    };\n\n    PNG.prototype.copyToImageData = function (imageData, pixels) {\n      var alpha, colors, data, i, input, j, k, length, palette, v, _ref;\n\n      colors = this.colors;\n      palette = null;\n      alpha = this.hasAlphaChannel;\n\n      if (this.palette.length) {\n        palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();\n        colors = 4;\n        alpha = true;\n      }\n\n      data = imageData.data || imageData;\n      length = data.length;\n      input = palette || pixels;\n      i = j = 0;\n\n      if (colors === 1) {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          v = input[k++];\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      } else {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      }\n    };\n\n    PNG.prototype.decode = function () {\n      var ret;\n      ret = new Uint8Array(this.width * this.height * 4);\n      this.copyToImageData(ret, this.decodePixels());\n      return ret;\n    };\n\n    try {\n      scratchCanvas = global.document.createElement('canvas');\n      scratchCtx = scratchCanvas.getContext('2d');\n    } catch (e) {\n      return -1;\n    }\n\n    makeImage = function makeImage(imageData) {\n      var img;\n      scratchCtx.width = imageData.width;\n      scratchCtx.height = imageData.height;\n      scratchCtx.clearRect(0, 0, imageData.width, imageData.height);\n      scratchCtx.putImageData(imageData, 0, 0);\n      img = new Image();\n      img.src = scratchCanvas.toDataURL();\n      return img;\n    };\n\n    PNG.prototype.decodeFrames = function (ctx) {\n      var frame, i, imageData, pixels, _i, _len, _ref, _results;\n\n      if (!this.animation) {\n        return;\n      }\n\n      _ref = this.animation.frames;\n      _results = [];\n\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        frame = _ref[i];\n        imageData = ctx.createImageData(frame.width, frame.height);\n        pixels = this.decodePixels(new Uint8Array(frame.data));\n        this.copyToImageData(imageData, pixels);\n        frame.imageData = imageData;\n\n        _results.push(frame.image = makeImage(imageData));\n      }\n\n      return _results;\n    };\n\n    PNG.prototype.renderFrame = function (ctx, number) {\n      var frame, frames, prev;\n      frames = this.animation.frames;\n      frame = frames[number];\n      prev = frames[number - 1];\n\n      if (number === 0) {\n        ctx.clearRect(0, 0, this.width, this.height);\n      }\n\n      if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_BACKGROUND) {\n        ctx.clearRect(prev.xOffset, prev.yOffset, prev.width, prev.height);\n      } else if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_PREVIOUS) {\n        ctx.putImageData(prev.imageData, prev.xOffset, prev.yOffset);\n      }\n\n      if (frame.blendOp === APNG_BLEND_OP_SOURCE) {\n        ctx.clearRect(frame.xOffset, frame.yOffset, frame.width, frame.height);\n      }\n\n      return ctx.drawImage(frame.image, frame.xOffset, frame.yOffset);\n    };\n\n    PNG.prototype.animate = function (ctx) {\n      var _doFrame,\n          frameNumber,\n          frames,\n          numFrames,\n          numPlays,\n          _ref,\n          _this = this;\n\n      frameNumber = 0;\n      _ref = this.animation, numFrames = _ref.numFrames, frames = _ref.frames, numPlays = _ref.numPlays;\n      return (_doFrame = function doFrame() {\n        var f, frame;\n        f = frameNumber++ % numFrames;\n        frame = frames[f];\n\n        _this.renderFrame(ctx, f);\n\n        if (numFrames > 1 && frameNumber / numFrames < numPlays) {\n          return _this.animation._timeout = setTimeout(_doFrame, frame.delay);\n        }\n      })();\n    };\n\n    PNG.prototype.stopAnimation = function () {\n      var _ref;\n\n      return clearTimeout((_ref = this.animation) != null ? _ref._timeout : void 0);\n    };\n\n    PNG.prototype.render = function (canvas) {\n      var ctx, data;\n\n      if (canvas._png) {\n        canvas._png.stopAnimation();\n      }\n\n      canvas._png = this;\n      canvas.width = this.width;\n      canvas.height = this.height;\n      ctx = canvas.getContext(\"2d\");\n\n      if (this.animation) {\n        this.decodeFrames(ctx);\n        return this.animate(ctx);\n      } else {\n        data = ctx.createImageData(this.width, this.height);\n        this.copyToImageData(data, this.decodePixels());\n        return ctx.putImageData(data, 0, 0);\n      }\n    };\n\n    return PNG;\n  }();\n\n  global.PNG = PNG;\n})(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || Function('return typeof this === \"object\" && this.content')() || Function('return this')()); // `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\n/*\n * Extracted from pdf.js\n * https://github.com/andreasgal/pdf.js\n *\n * Copyright (c) 2011 Mozilla Foundation\n *\n * Contributors: Andreas Gal <gal@mozilla.com>\n *               Chris G Jones <cjones@mozilla.com>\n *               Shaon Barman <shaon.barman@gmail.com>\n *               Vivien Nicolas <21@vingtetun.org>\n *               Justin D'Arcangelo <justindarc@gmail.com>\n *               Yury Delendik\n *\n * \n */\nvar DecodeStream = function () {\n  function constructor() {\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = false;\n    this.buffer = null;\n  }\n\n  constructor.prototype = {\n    ensureBuffer: function decodestream_ensureBuffer(requested) {\n      var buffer = this.buffer;\n      var current = buffer ? buffer.byteLength : 0;\n      if (requested < current) return buffer;\n      var size = 512;\n\n      while (size < requested) {\n        size <<= 1;\n      }\n\n      var buffer2 = new Uint8Array(size);\n\n      for (var i = 0; i < current; ++i) {\n        buffer2[i] = buffer[i];\n      }\n\n      return this.buffer = buffer2;\n    },\n    getByte: function decodestream_getByte() {\n      var pos = this.pos;\n\n      while (this.bufferLength <= pos) {\n        if (this.eof) return null;\n        this.readBlock();\n      }\n\n      return this.buffer[this.pos++];\n    },\n    getBytes: function decodestream_getBytes(length) {\n      var pos = this.pos;\n\n      if (length) {\n        this.ensureBuffer(pos + length);\n        var end = pos + length;\n\n        while (!this.eof && this.bufferLength < end) {\n          this.readBlock();\n        }\n\n        var bufEnd = this.bufferLength;\n        if (end > bufEnd) end = bufEnd;\n      } else {\n        while (!this.eof) {\n          this.readBlock();\n        }\n\n        var end = this.bufferLength;\n      }\n\n      this.pos = end;\n      return this.buffer.subarray(pos, end);\n    },\n    lookChar: function decodestream_lookChar() {\n      var pos = this.pos;\n\n      while (this.bufferLength <= pos) {\n        if (this.eof) return null;\n        this.readBlock();\n      }\n\n      return String.fromCharCode(this.buffer[this.pos]);\n    },\n    getChar: function decodestream_getChar() {\n      var pos = this.pos;\n\n      while (this.bufferLength <= pos) {\n        if (this.eof) return null;\n        this.readBlock();\n      }\n\n      return String.fromCharCode(this.buffer[this.pos++]);\n    },\n    makeSubStream: function decodestream_makeSubstream(start, length, dict) {\n      var end = start + length;\n\n      while (this.bufferLength <= end && !this.eof) {\n        this.readBlock();\n      }\n\n      return new Stream(this.buffer, start, length, dict);\n    },\n    skip: function decodestream_skip(n) {\n      if (!n) n = 1;\n      this.pos += n;\n    },\n    reset: function decodestream_reset() {\n      this.pos = 0;\n    }\n  };\n  return constructor;\n}();\n\nvar FlateStream = function () {\n  if (typeof Uint32Array === 'undefined') {\n    return undefined;\n  }\n\n  var codeLenCodeMap = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  var lengthDecode = new Uint32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);\n  var distDecode = new Uint32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);\n  var fixedLitCodeTab = [new Uint32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];\n  var fixedDistCodeTab = [new Uint32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];\n\n  function error(e) {\n    throw new Error(e);\n  }\n\n  function constructor(bytes) {\n    //var bytes = stream.getBytes();\n    var bytesPos = 0;\n    var cmf = bytes[bytesPos++];\n    var flg = bytes[bytesPos++];\n    if (cmf == -1 || flg == -1) error('Invalid header in flate stream');\n    if ((cmf & 0x0f) != 0x08) error('Unknown compression method in flate stream');\n    if (((cmf << 8) + flg) % 31 != 0) error('Bad FCHECK in flate stream');\n    if (flg & 0x20) error('FDICT bit set in flate stream');\n    this.bytes = bytes;\n    this.bytesPos = bytesPos;\n    this.codeSize = 0;\n    this.codeBuf = 0;\n    DecodeStream.call(this);\n  }\n\n  constructor.prototype = Object.create(DecodeStream.prototype);\n\n  constructor.prototype.getBits = function (bits) {\n    var codeSize = this.codeSize;\n    var codeBuf = this.codeBuf;\n    var bytes = this.bytes;\n    var bytesPos = this.bytesPos;\n    var b;\n\n    while (codeSize < bits) {\n      if (typeof (b = bytes[bytesPos++]) == 'undefined') error('Bad encoding in flate stream');\n      codeBuf |= b << codeSize;\n      codeSize += 8;\n    }\n\n    b = codeBuf & (1 << bits) - 1;\n    this.codeBuf = codeBuf >> bits;\n    this.codeSize = codeSize -= bits;\n    this.bytesPos = bytesPos;\n    return b;\n  };\n\n  constructor.prototype.getCode = function (table) {\n    var codes = table[0];\n    var maxLen = table[1];\n    var codeSize = this.codeSize;\n    var codeBuf = this.codeBuf;\n    var bytes = this.bytes;\n    var bytesPos = this.bytesPos;\n\n    while (codeSize < maxLen) {\n      var b;\n      if (typeof (b = bytes[bytesPos++]) == 'undefined') error('Bad encoding in flate stream');\n      codeBuf |= b << codeSize;\n      codeSize += 8;\n    }\n\n    var code = codes[codeBuf & (1 << maxLen) - 1];\n    var codeLen = code >> 16;\n    var codeVal = code & 0xffff;\n    if (codeSize == 0 || codeSize < codeLen || codeLen == 0) error('Bad encoding in flate stream');\n    this.codeBuf = codeBuf >> codeLen;\n    this.codeSize = codeSize - codeLen;\n    this.bytesPos = bytesPos;\n    return codeVal;\n  };\n\n  constructor.prototype.generateHuffmanTable = function (lengths) {\n    var n = lengths.length; // find max code length\n\n    var maxLen = 0;\n\n    for (var i = 0; i < n; ++i) {\n      if (lengths[i] > maxLen) maxLen = lengths[i];\n    } // build the table\n\n\n    var size = 1 << maxLen;\n    var codes = new Uint32Array(size);\n\n    for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {\n      for (var val = 0; val < n; ++val) {\n        if (lengths[val] == len) {\n          // bit-reverse the code\n          var code2 = 0;\n          var t = code;\n\n          for (var i = 0; i < len; ++i) {\n            code2 = code2 << 1 | t & 1;\n            t >>= 1;\n          } // fill the table entries\n\n\n          for (var i = code2; i < size; i += skip) {\n            codes[i] = len << 16 | val;\n          }\n\n          ++code;\n        }\n      }\n    }\n\n    return [codes, maxLen];\n  };\n\n  constructor.prototype.readBlock = function () {\n    function repeat(stream, array, len, offset, what) {\n      var repeat = stream.getBits(len) + offset;\n\n      while (repeat-- > 0) {\n        array[i++] = what;\n      }\n    } // read block header\n\n\n    var hdr = this.getBits(3);\n    if (hdr & 1) this.eof = true;\n    hdr >>= 1;\n\n    if (hdr == 0) {\n      // uncompressed block\n      var bytes = this.bytes;\n      var bytesPos = this.bytesPos;\n      var b;\n      if (typeof (b = bytes[bytesPos++]) == 'undefined') error('Bad block header in flate stream');\n      var blockLen = b;\n      if (typeof (b = bytes[bytesPos++]) == 'undefined') error('Bad block header in flate stream');\n      blockLen |= b << 8;\n      if (typeof (b = bytes[bytesPos++]) == 'undefined') error('Bad block header in flate stream');\n      var check = b;\n      if (typeof (b = bytes[bytesPos++]) == 'undefined') error('Bad block header in flate stream');\n      check |= b << 8;\n      if (check != (~blockLen & 0xffff)) error('Bad uncompressed block length in flate stream');\n      this.codeBuf = 0;\n      this.codeSize = 0;\n      var bufferLength = this.bufferLength;\n      var buffer = this.ensureBuffer(bufferLength + blockLen);\n      var end = bufferLength + blockLen;\n      this.bufferLength = end;\n\n      for (var n = bufferLength; n < end; ++n) {\n        if (typeof (b = bytes[bytesPos++]) == 'undefined') {\n          this.eof = true;\n          break;\n        }\n\n        buffer[n] = b;\n      }\n\n      this.bytesPos = bytesPos;\n      return;\n    }\n\n    var litCodeTable;\n    var distCodeTable;\n\n    if (hdr == 1) {\n      // compressed block, fixed codes\n      litCodeTable = fixedLitCodeTab;\n      distCodeTable = fixedDistCodeTab;\n    } else if (hdr == 2) {\n      // compressed block, dynamic codes\n      var numLitCodes = this.getBits(5) + 257;\n      var numDistCodes = this.getBits(5) + 1;\n      var numCodeLenCodes = this.getBits(4) + 4; // build the code lengths code table\n\n      var codeLenCodeLengths = Array(codeLenCodeMap.length);\n      var i = 0;\n\n      while (i < numCodeLenCodes) {\n        codeLenCodeLengths[codeLenCodeMap[i++]] = this.getBits(3);\n      }\n\n      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths); // build the literal and distance code tables\n\n      var len = 0;\n      var i = 0;\n      var codes = numLitCodes + numDistCodes;\n      var codeLengths = new Array(codes);\n\n      while (i < codes) {\n        var code = this.getCode(codeLenCodeTab);\n\n        if (code == 16) {\n          repeat(this, codeLengths, 2, 3, len);\n        } else if (code == 17) {\n          repeat(this, codeLengths, 3, 3, len = 0);\n        } else if (code == 18) {\n          repeat(this, codeLengths, 7, 11, len = 0);\n        } else {\n          codeLengths[i++] = len = code;\n        }\n      }\n\n      litCodeTable = this.generateHuffmanTable(codeLengths.slice(0, numLitCodes));\n      distCodeTable = this.generateHuffmanTable(codeLengths.slice(numLitCodes, codes));\n    } else {\n      error('Unknown block type in flate stream');\n    }\n\n    var buffer = this.buffer;\n    var limit = buffer ? buffer.length : 0;\n    var pos = this.bufferLength;\n\n    while (true) {\n      var code1 = this.getCode(litCodeTable);\n\n      if (code1 < 256) {\n        if (pos + 1 >= limit) {\n          buffer = this.ensureBuffer(pos + 1);\n          limit = buffer.length;\n        }\n\n        buffer[pos++] = code1;\n        continue;\n      }\n\n      if (code1 == 256) {\n        this.bufferLength = pos;\n        return;\n      }\n\n      code1 -= 257;\n      code1 = lengthDecode[code1];\n      var code2 = code1 >> 16;\n      if (code2 > 0) code2 = this.getBits(code2);\n      var len = (code1 & 0xffff) + code2;\n      code1 = this.getCode(distCodeTable);\n      code1 = distDecode[code1];\n      code2 = code1 >> 16;\n      if (code2 > 0) code2 = this.getBits(code2);\n      var dist = (code1 & 0xffff) + code2;\n\n      if (pos + len >= limit) {\n        buffer = this.ensureBuffer(pos + len);\n        limit = buffer.length;\n      }\n\n      for (var k = 0; k < len; ++k, ++pos) {\n        buffer[pos] = buffer[pos - dist];\n      }\n    }\n  };\n\n  return constructor;\n}();\n/*rollup-keeper-start*/\n\n\nwindow.tmp = FlateStream;\n/*rollup-keeper-end*/\n\ntry {\nmodule.exports = jsPDF;\n}\ncatch (e) {}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pzcGRmL2Rpc3QvanNwZGYubm9kZS5kZWJ1Zy5qcz80OWE5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdGQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUCxvREFBb0QsRUFBRTtBQUN0RDtBQUNBOztBQUVBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7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QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIs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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxSkFBcUo7QUFDcko7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsa0JBQWtCO0FBQ2pDOztBQUVBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEVBQUU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDBDQUEwQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMENBQTBDO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxj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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLGtDQUFrQywrQ0FBK0M7O0FBRWpGO0FBQ0E7O0FBRUEsNkVBQTZFLHNCQUFzQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkJBQTJCLDRDQUE0QztBQUM1RSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFFBQVE7O0FBRWI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFOztBQUVsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsdUVBQXVFLDRCQUE0Qjs7QUFFbkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFdBQVc7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4SkFBOEo7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSxxQkFBcUIsSUFBSSxTQUFTLElBQUksU0FBUyxJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQixFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsMk5BQTJOO0FBQzVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx5RkFBeUY7O0FBRXpGLDREQUE0RDs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRCw2REFBNkQ7O0FBRTdELGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFdBQVc7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLG1DQUFtQztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLHlDQUF5QztBQUMvRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsbUNBQW1DO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLFdBQVc7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLG1DQUFtQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QiwrQ0FBK0M7QUFDM0U7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2REFBNkQsbUNBQW1DO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QiwrQ0FBK0M7QUFDdkU7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxXQUFXO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsc0JBQXNCLCtDQUErQztBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLFdBQVc7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHNCQUFzQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUNBQW1DO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQ0FBbUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxXQUFXO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0Q0FBNEMsV0FBVztBQUN2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU8sWUFBWTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixrREFBa0Q7QUFDOUU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQywrQ0FBK0M7QUFDakY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5Qiw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekIseUJBQXlCOztBQUV6Qix5QkFBeUI7O0FBRXpCLHlCQUF5Qjs7QUFFekIseUJBQXlCOztBQUV6Qix5QkFBeUI7QUFDekIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDLDJOQUEyTjtBQUM1TjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQSx5Q0FBeUMsZUFBZTtBQUN4RCx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0EsV0FBVzs7O0FBR1gsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUVBQXlFOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qc3BkZi9kaXN0L2pzcGRmLm5vZGUuZGVidWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAbGljZW5zZVxyXG4gKiBqc1BERiAtIFBERiBEb2N1bWVudCBjcmVhdGlvbiBmcm9tIEphdmFTY3JpcHRcclxuICogVmVyc2lvbiAxLjUuMyBCdWlsdCBvbiAyMDE4LTEyLTI3VDE0OjExOjUwLjA2OFpcclxuICogICAgICAgICAgICAgICAgICAgICAgQ29tbWl0SUQgZDkzZDI4ZGIxNFxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNiBKYW1lcyBIYWxsIDxqYW1lc0BwYXJhbGwuYXg+LCBodHRwczovL2dpdGh1Yi5jb20vTXJSaW8vanNQREZcclxuICogICAgICAgICAgICAgICAyMDEwIEFhcm9uIFNwaWtlLCBodHRwczovL2dpdGh1Yi5jb20vYWNzcGlrZVxyXG4gKiAgICAgICAgICAgICAgIDIwMTIgV2lsbG93IFN5c3RlbXMgQ29ycG9yYXRpb24sIHdpbGxvdy1zeXN0ZW1zLmNvbVxyXG4gKiAgICAgICAgICAgICAgIDIwMTIgUGFibG8gSGVzcywgaHR0cHM6Ly9naXRodWIuY29tL3BhYmxvaGVzc1xyXG4gKiAgICAgICAgICAgICAgIDIwMTIgRmxvcmlhbiBKZW5ldHQsIGh0dHBzOi8vZ2l0aHViLmNvbS9mamVuZXR0XHJcbiAqICAgICAgICAgICAgICAgMjAxMyBXYXJyZW4gV2Vja2Vzc2VyLCBodHRwczovL2dpdGh1Yi5jb20vd2FycmVud2Vja2Vzc2VyXHJcbiAqICAgICAgICAgICAgICAgMjAxMyBZb3Vzc2VmIEJlZGRhZCwgaHR0cHM6Ly9naXRodWIuY29tL2xpZm9mXHJcbiAqICAgICAgICAgICAgICAgMjAxMyBMZWUgRHJpc2NvbGwsIGh0dHBzOi8vZ2l0aHViLmNvbS9sc2RyaXNjb2xsXHJcbiAqICAgICAgICAgICAgICAgMjAxMyBTdGVmYW4gU2xvbmV2c2tpeSwgaHR0cHM6Ly9naXRodWIuY29tL3N0ZWZzbG9uXHJcbiAqICAgICAgICAgICAgICAgMjAxMyBKZXJlbXkgTW9yZWwsIGh0dHBzOi8vZ2l0aHViLmNvbS9qbW9yZWxcclxuICogICAgICAgICAgICAgICAyMDEzIENocmlzdG9waCBIYXJ0bWFubiwgaHR0cHM6Ly9naXRodWIuY29tL2NocmlzLXJvY2tcclxuICogICAgICAgICAgICAgICAyMDE0IEp1YW4gUGFibG8gR2F2aXJpYSwgaHR0cHM6Ly9naXRodWIuY29tL2p1YW5wZ2F2aXJpYVxyXG4gKiAgICAgICAgICAgICAgIDIwMTQgSmFtZXMgTWFrZXMsIGh0dHBzOi8vZ2l0aHViLmNvbS9kb2xsYXJ1d1xyXG4gKiAgICAgICAgICAgICAgIDIwMTQgRGllZ28gQ2Fzb3JyYW4sIGh0dHBzOi8vZ2l0aHViLmNvbS9kaWVnb2NyXHJcbiAqICAgICAgICAgICAgICAgMjAxNCBTdGV2ZW4gU3B1bmdpbiwgaHR0cHM6Ly9naXRodWIuY29tL0ZsYW1lbmNvXHJcbiAqICAgICAgICAgICAgICAgMjAxNCBLZW5uZXRoIEdsYXNzZXksIGh0dHBzOi8vZ2l0aHViLmNvbS9HYXZ2ZXJzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxyXG4gKlxyXG4gKiBDb250cmlidXRvcihzKTpcclxuICogICAgc2llZmtlbmosIGFod29sZiwgcmlja3lndSwgTWlkbml0aCwgc2FpbnRjbGFpciwgZWFwYXJhbmdvLFxyXG4gKiAgICBraW0zZXIsIG1mbywgYWxub3J0aCwgRmxhbWVuY29cclxuICovXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBqc1BERiBkb2N1bWVudCBvYmplY3QgaW5zdGFuY2UuXG4gKiBAbmFtZSBqc1BERlxuICogQGNsYXNzXG4gKiBAcGFyYW0gb3JpZW50YXRpb24ge3N0cmluZy9PYmplY3R9IE9yaWVudGF0aW9uIG9mIHRoZSBmaXJzdCBwYWdlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwicG9ydHJhaXRcIiBvciBcImxhbmRzY2FwZVwiIChvciBzaG9ydGN1dHMgXCJwXCIgKERlZmF1bHQpLCBcImxcIikuPGJyIC8+XG4gKiBDYW4gYWxzbyBiZSBhbiBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB1bml0IHtzdHJpbmd9ICBNZWFzdXJlbWVudCB1bml0IHRvIGJlIHVzZWQgd2hlbiBjb29yZGluYXRlcyBhcmUgc3BlY2lmaWVkLjxiciAvPlxuICogUG9zc2libGUgdmFsdWVzIGFyZSBcInB0XCIgKHBvaW50cyksIFwibW1cIiAoRGVmYXVsdCksIFwiY21cIiwgXCJpblwiIG9yIFwicHhcIi5cbiAqIEBwYXJhbSBmb3JtYXQge3N0cmluZy9BcnJheX0gVGhlIGZvcm1hdCBvZiB0aGUgZmlyc3QgcGFnZS4gQ2FuIGJlOjx1bD48bGk+YTAgLSBhMTA8L2xpPjxsaT5iMCAtIGIxMDwvbGk+PGxpPmMwIC0gYzEwPC9saT48bGk+ZGw8L2xpPjxsaT5sZXR0ZXI8L2xpPjxsaT5nb3Zlcm5tZW50LWxldHRlcjwvbGk+PGxpPmxlZ2FsPC9saT48bGk+anVuaW9yLWxlZ2FsPC9saT48bGk+bGVkZ2VyPC9saT48bGk+dGFibG9pZDwvbGk+PGxpPmNyZWRpdC1jYXJkPC9saT48L3VsPjxiciAvPlxuICogRGVmYXVsdCBpcyBcImE0XCIuIElmIHlvdSB3YW50IHRvIHVzZSB5b3VyIG93biBmb3JtYXQganVzdCBwYXNzIGluc3RlYWQgb2Ygb25lIG9mIHRoZSBhYm92ZSBwcmVkZWZpbmVkIGZvcm1hdHMgdGhlIHNpemUgYXMgYW4gbnVtYmVyLWFycmF5LCBlLmcuIFs1OTUuMjgsIDg0MS44OV1cbiAqIEByZXR1cm5zIHtqc1BERn0ganNQREYtaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvblxuICogSWYgdGhlIGZpcnN0IHBhcmFtZXRlciAob3JpZW50YXRpb24pIGlzIGFuIG9iamVjdCwgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhbiBvYmplY3Qgb2YgbmFtZWQgcGFyYW1ldGVyc1xuICogYGBgXG4gKiB7XG4gKiAgb3JpZW50YXRpb246ICdwJyxcbiAqICB1bml0OiAnbW0nLFxuICogIGZvcm1hdDogJ2E0JyxcbiAqICBob3RmaXhlczogW10gLy8gYW4gYXJyYXkgb2YgaG90Zml4IHN0cmluZ3MgdG8gZW5hYmxlXG4gKiB9XG4gKiBgYGBcbiAqL1xudmFyIGpzUERGID0gZnVuY3Rpb24gKGdsb2JhbCkge1xuICAvKipcbiAgICoganNQREYncyBJbnRlcm5hbCBQdWJTdWIgSW1wbGVtZW50YXRpb24uXG4gICAqIEJhY2t3YXJkIGNvbXBhdGlibGUgcmV3cml0dGVuIG9uIDIwMTQgYnlcbiAgICogRGllZ28gQ2Fzb3JyYW4sIGh0dHBzOi8vZ2l0aHViLmNvbS9kaWVnb2NyXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAbmFtZSBQdWJTdWJcbiAgICogQGlnbm9yZVxuICAgKi9cblxuICBmdW5jdGlvbiBQdWJTdWIoY29udGV4dCkge1xuICAgIGlmIChfdHlwZW9mKGNvbnRleHQpICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENvbnRleHQgcGFzc2VkIHRvIGluaXRpYWxpemUgUHViU3ViIChqc1BERi1tb2R1bGUpJyk7XG4gICAgfVxuXG4gICAgdmFyIHRvcGljcyA9IHt9O1xuXG4gICAgdGhpcy5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodG9waWMsIGNhbGxiYWNrLCBvbmNlKSB7XG4gICAgICBvbmNlID0gb25jZSB8fCBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiB0b3BpYyAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvbmNlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8gUHViU3ViLnN1YnNjcmliZSAoanNQREYtbW9kdWxlKScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRvcGljcy5oYXNPd25Qcm9wZXJ0eSh0b3BpYykpIHtcbiAgICAgICAgdG9waWNzW3RvcGljXSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9rZW4gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM1KTtcbiAgICAgIHRvcGljc1t0b3BpY11bdG9rZW5dID0gW2NhbGxiYWNrLCAhIW9uY2VdO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH07XG5cbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICBmb3IgKHZhciB0b3BpYyBpbiB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHRvcGljc1t0b3BpY11bdG9rZW5dKSB7XG4gICAgICAgICAgZGVsZXRlIHRvcGljc1t0b3BpY11bdG9rZW5dO1xuXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRvcGljc1t0b3BpY10pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHRvcGljc1t0b3BpY107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnB1Ymxpc2ggPSBmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgIGlmICh0b3BpY3MuaGFzT3duUHJvcGVydHkodG9waWMpKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIHRva2VucyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIHRva2VuIGluIHRvcGljc1t0b3BpY10pIHtcbiAgICAgICAgICB2YXIgc3ViID0gdG9waWNzW3RvcGljXVt0b2tlbl07XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3ViWzBdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignanNQREYgUHViU3ViIEVycm9yJywgZXgubWVzc2FnZSwgZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdWJbMV0pIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKSB0b2tlbnMuZm9yRWFjaCh0aGlzLnVuc3Vic2NyaWJlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRUb3BpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdG9waWNzO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGpzUERGKG9yaWVudGF0aW9uLCB1bml0LCBmb3JtYXQsIGNvbXByZXNzUGRmKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgZmlsdGVycyA9IFtdO1xuICAgIHZhciB1c2VyVW5pdCA9IDEuMDtcblxuICAgIGlmIChfdHlwZW9mKG9yaWVudGF0aW9uKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBvcmllbnRhdGlvbjtcbiAgICAgIG9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbjtcbiAgICAgIHVuaXQgPSBvcHRpb25zLnVuaXQgfHwgdW5pdDtcbiAgICAgIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdDtcbiAgICAgIGNvbXByZXNzUGRmID0gb3B0aW9ucy5jb21wcmVzcyB8fCBvcHRpb25zLmNvbXByZXNzUGRmIHx8IGNvbXByZXNzUGRmO1xuICAgICAgZmlsdGVycyA9IG9wdGlvbnMuZmlsdGVycyB8fCAoY29tcHJlc3NQZGYgPT09IHRydWUgPyBbJ0ZsYXRlRW5jb2RlJ10gOiBmaWx0ZXJzKTtcbiAgICAgIHVzZXJVbml0ID0gdHlwZW9mIG9wdGlvbnMudXNlclVuaXQgPT09IFwibnVtYmVyXCIgPyBNYXRoLmFicyhvcHRpb25zLnVzZXJVbml0KSA6IDEuMDtcbiAgICB9XG5cbiAgICB1bml0ID0gdW5pdCB8fCAnbW0nO1xuICAgIG9yaWVudGF0aW9uID0gKCcnICsgKG9yaWVudGF0aW9uIHx8ICdQJykpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHB1dE9ubHlVc2VkRm9udHMgPSBvcHRpb25zLnB1dE9ubHlVc2VkRm9udHMgfHwgdHJ1ZTtcbiAgICB2YXIgdXNlZEZvbnRzID0ge307XG4gICAgdmFyIEFQSSA9IHtcbiAgICAgIGludGVybmFsOiB7fSxcbiAgICAgIF9fcHJpdmF0ZV9fOiB7fVxuICAgIH07XG4gICAgQVBJLl9fcHJpdmF0ZV9fLlB1YlN1YiA9IFB1YlN1YjtcbiAgICB2YXIgcGRmVmVyc2lvbiA9ICcxLjMnO1xuXG4gICAgdmFyIGdldFBkZlZlcnNpb24gPSBBUEkuX19wcml2YXRlX18uZ2V0UGRmVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwZGZWZXJzaW9uO1xuICAgIH07XG5cbiAgICB2YXIgc2V0UGRmVmVyc2lvbiA9IEFQSS5fX3ByaXZhdGVfXy5zZXRQZGZWZXJzaW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBwZGZWZXJzaW9uID0gdmFsdWU7XG4gICAgfTsgLy8gU2l6ZSBpbiBwdCBvZiB2YXJpb3VzIHBhcGVyIGZvcm1hdHNcblxuXG4gICAgdmFyIHBhZ2VGb3JtYXRzID0ge1xuICAgICAgJ2EwJzogWzIzODMuOTQsIDMzNzAuMzldLFxuICAgICAgJ2ExJzogWzE2ODMuNzgsIDIzODMuOTRdLFxuICAgICAgJ2EyJzogWzExOTAuNTUsIDE2ODMuNzhdLFxuICAgICAgJ2EzJzogWzg0MS44OSwgMTE5MC41NV0sXG4gICAgICAnYTQnOiBbNTk1LjI4LCA4NDEuODldLFxuICAgICAgJ2E1JzogWzQxOS41MywgNTk1LjI4XSxcbiAgICAgICdhNic6IFsyOTcuNjQsIDQxOS41M10sXG4gICAgICAnYTcnOiBbMjA5Ljc2LCAyOTcuNjRdLFxuICAgICAgJ2E4JzogWzE0Ny40MCwgMjA5Ljc2XSxcbiAgICAgICdhOSc6IFsxMDQuODgsIDE0Ny40MF0sXG4gICAgICAnYTEwJzogWzczLjcwLCAxMDQuODhdLFxuICAgICAgJ2IwJzogWzI4MzQuNjUsIDQwMDguMTldLFxuICAgICAgJ2IxJzogWzIwMDQuMDksIDI4MzQuNjVdLFxuICAgICAgJ2IyJzogWzE0MTcuMzIsIDIwMDQuMDldLFxuICAgICAgJ2IzJzogWzEwMDAuNjMsIDE0MTcuMzJdLFxuICAgICAgJ2I0JzogWzcwOC42NiwgMTAwMC42M10sXG4gICAgICAnYjUnOiBbNDk4LjkwLCA3MDguNjZdLFxuICAgICAgJ2I2JzogWzM1NC4zMywgNDk4LjkwXSxcbiAgICAgICdiNyc6IFsyNDkuNDUsIDM1NC4zM10sXG4gICAgICAnYjgnOiBbMTc1Ljc1LCAyNDkuNDVdLFxuICAgICAgJ2I5JzogWzEyNC43MiwgMTc1Ljc1XSxcbiAgICAgICdiMTAnOiBbODcuODcsIDEyNC43Ml0sXG4gICAgICAnYzAnOiBbMjU5OS4zNywgMzY3Ni41NF0sXG4gICAgICAnYzEnOiBbMTgzNi44NSwgMjU5OS4zN10sXG4gICAgICAnYzInOiBbMTI5OC4yNywgMTgzNi44NV0sXG4gICAgICAnYzMnOiBbOTE4LjQzLCAxMjk4LjI3XSxcbiAgICAgICdjNCc6IFs2NDkuMTMsIDkxOC40M10sXG4gICAgICAnYzUnOiBbNDU5LjIxLCA2NDkuMTNdLFxuICAgICAgJ2M2JzogWzMyMy4xNSwgNDU5LjIxXSxcbiAgICAgICdjNyc6IFsyMjkuNjEsIDMyMy4xNV0sXG4gICAgICAnYzgnOiBbMTYxLjU3LCAyMjkuNjFdLFxuICAgICAgJ2M5JzogWzExMy4zOSwgMTYxLjU3XSxcbiAgICAgICdjMTAnOiBbNzkuMzcsIDExMy4zOV0sXG4gICAgICAnZGwnOiBbMzExLjgxLCA2MjMuNjJdLFxuICAgICAgJ2xldHRlcic6IFs2MTIsIDc5Ml0sXG4gICAgICAnZ292ZXJubWVudC1sZXR0ZXInOiBbNTc2LCA3NTZdLFxuICAgICAgJ2xlZ2FsJzogWzYxMiwgMTAwOF0sXG4gICAgICAnanVuaW9yLWxlZ2FsJzogWzU3NiwgMzYwXSxcbiAgICAgICdsZWRnZXInOiBbMTIyNCwgNzkyXSxcbiAgICAgICd0YWJsb2lkJzogWzc5MiwgMTIyNF0sXG4gICAgICAnY3JlZGl0LWNhcmQnOiBbMTUzLCAyNDNdXG4gICAgfTtcblxuICAgIHZhciBnZXRQYWdlRm9ybWF0cyA9IEFQSS5fX3ByaXZhdGVfXy5nZXRQYWdlRm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwYWdlRm9ybWF0cztcbiAgICB9O1xuXG4gICAgdmFyIGdldFBhZ2VGb3JtYXQgPSBBUEkuX19wcml2YXRlX18uZ2V0UGFnZUZvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhZ2VGb3JtYXRzW3ZhbHVlXTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvcm1hdCA9IGdldFBhZ2VGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBmb3JtYXQgfHwgZ2V0UGFnZUZvcm1hdCgnYTQnKTtcblxuICAgIHZhciBmMiA9IEFQSS5mMiA9IEFQSS5fX3ByaXZhdGVfXy5mMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuZjInKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bWJlci50b0ZpeGVkKDIpOyAvLyBJZSwgJS4yZlxuICAgIH07XG5cbiAgICB2YXIgZjMgPSBBUEkuX19wcml2YXRlX18uZjMgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGpzUERGLmYzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudW1iZXIudG9GaXhlZCgzKTsgLy8gSWUsICUuM2ZcbiAgICB9O1xuXG4gICAgdmFyIGZpbGVJZCA9ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCc7XG5cbiAgICB2YXIgZ2V0RmlsZUlkID0gQVBJLl9fcHJpdmF0ZV9fLmdldEZpbGVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmaWxlSWQ7XG4gICAgfTtcblxuICAgIHZhciBzZXRGaWxlSWQgPSBBUEkuX19wcml2YXRlX18uc2V0RmlsZUlkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlIHx8IFwiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTJcIi5zcGxpdCgnJykubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiQUJDREVGMDEyMzQ1Njc4OVwiLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNikpO1xuICAgICAgfSkuam9pbignJyk7XG4gICAgICBmaWxlSWQgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBmaWxlSWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbmFtZSBzZXRGaWxlSWRcbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgR1VJRC5cbiAgICAgKiBAcmV0dXJucyB7anNQREZ9XG4gICAgICovXG5cblxuICAgIEFQSS5zZXRGaWxlSWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHNldEZpbGVJZCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBuYW1lIGdldEZpbGVJZFxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gR1VJRC5cbiAgICAgKi9cblxuXG4gICAgQVBJLmdldEZpbGVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRGaWxlSWQoKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0aW9uRGF0ZTtcblxuICAgIHZhciBjb252ZXJ0RGF0ZVRvUERGRGF0ZSA9IEFQSS5fX3ByaXZhdGVfXy5jb252ZXJ0RGF0ZVRvUERGRGF0ZSA9IGZ1bmN0aW9uIChwYXJtRGF0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgdmFyIHR6b2Zmc2V0ID0gcGFybURhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgICB0enNpZ24gPSB0em9mZnNldCA8IDAgPyAnKycgOiAnLScsXG4gICAgICAgICAgdHpob3VyID0gTWF0aC5mbG9vcihNYXRoLmFicyh0em9mZnNldCAvIDYwKSksXG4gICAgICAgICAgdHptaW4gPSBNYXRoLmFicyh0em9mZnNldCAlIDYwKSxcbiAgICAgICAgICB0aW1lWm9uZVN0cmluZyA9IFt0enNpZ24sIHBhZGQyKHR6aG91ciksIFwiJ1wiLCBwYWRkMih0em1pbiksIFwiJ1wiXS5qb2luKCcnKTtcbiAgICAgIHJlc3VsdCA9IFsnRDonLCBwYXJtRGF0ZS5nZXRGdWxsWWVhcigpLCBwYWRkMihwYXJtRGF0ZS5nZXRNb250aCgpICsgMSksIHBhZGQyKHBhcm1EYXRlLmdldERhdGUoKSksIHBhZGQyKHBhcm1EYXRlLmdldEhvdXJzKCkpLCBwYWRkMihwYXJtRGF0ZS5nZXRNaW51dGVzKCkpLCBwYWRkMihwYXJtRGF0ZS5nZXRTZWNvbmRzKCkpLCB0aW1lWm9uZVN0cmluZ10uam9pbignJyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB2YXIgY29udmVydFBERkRhdGVUb0RhdGUgPSBBUEkuX19wcml2YXRlX18uY29udmVydFBERkRhdGVUb0RhdGUgPSBmdW5jdGlvbiAocGFybVBERkRhdGUpIHtcbiAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQocGFybVBERkRhdGUuc3Vic3RyKDIsIDQpLCAxMCk7XG4gICAgICB2YXIgbW9udGggPSBwYXJzZUludChwYXJtUERGRGF0ZS5zdWJzdHIoNiwgMiksIDEwKSAtIDE7XG4gICAgICB2YXIgZGF0ZSA9IHBhcnNlSW50KHBhcm1QREZEYXRlLnN1YnN0cig4LCAyKSwgMTApO1xuICAgICAgdmFyIGhvdXIgPSBwYXJzZUludChwYXJtUERGRGF0ZS5zdWJzdHIoMTAsIDIpLCAxMCk7XG4gICAgICB2YXIgbWludXRlcyA9IHBhcnNlSW50KHBhcm1QREZEYXRlLnN1YnN0cigxMiwgMiksIDEwKTtcbiAgICAgIHZhciBzZWNvbmRzID0gcGFyc2VJbnQocGFybVBERkRhdGUuc3Vic3RyKDE0LCAyKSwgMTApO1xuICAgICAgdmFyIHRpbWVab25lSG91ciA9IHBhcnNlSW50KHBhcm1QREZEYXRlLnN1YnN0cigxNiwgMiksIDEwKTtcbiAgICAgIHZhciB0aW1lWm9uZU1pbnV0ZXMgPSBwYXJzZUludChwYXJtUERGRGF0ZS5zdWJzdHIoMjAsIDIpLCAxMCk7XG4gICAgICB2YXIgcmVzdWx0aW5nRGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXRlLCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCAwKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdEYXRlO1xuICAgIH07XG5cbiAgICB2YXIgc2V0Q3JlYXRpb25EYXRlID0gQVBJLl9fcHJpdmF0ZV9fLnNldENyZWF0aW9uRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICB2YXIgdG1wQ3JlYXRpb25EYXRlU3RyaW5nO1xuICAgICAgdmFyIHJlZ2V4UERGQ3JlYXRpb25EYXRlID0gL15EOigyMFswLTJdWzAtOV18MjAzWzAtN118MTlbNy05XVswLTldKSgwWzAtOV18MVswLTJdKShbMC0yXVswLTldfDNbMC0xXSkoMFswLTldfDFbMC05XXwyWzAtM10pKDBbMC05XXxbMS01XVswLTldKSgwWzAtOV18WzEtNV1bMC05XSkoXFwrMFswLTldfFxcKzFbMC00XXxcXC0wWzAtOV18XFwtMVswLTFdKVxcJygwWzAtOV18WzEtNV1bMC05XSlcXCc/JC87XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90eXBlb2YoZGF0ZSkgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGUpID09PSBcIltvYmplY3QgRGF0ZV1cIikge1xuICAgICAgICB0bXBDcmVhdGlvbkRhdGVTdHJpbmcgPSBjb252ZXJ0RGF0ZVRvUERGRGF0ZShkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAocmVnZXhQREZDcmVhdGlvbkRhdGUudGVzdChkYXRlKSkge1xuICAgICAgICB0bXBDcmVhdGlvbkRhdGVTdHJpbmcgPSBkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5zZXRDcmVhdGlvbkRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRpb25EYXRlID0gdG1wQ3JlYXRpb25EYXRlU3RyaW5nO1xuICAgICAgcmV0dXJuIGNyZWF0aW9uRGF0ZTtcbiAgICB9O1xuXG4gICAgdmFyIGdldENyZWF0aW9uRGF0ZSA9IEFQSS5fX3ByaXZhdGVfXy5nZXRDcmVhdGlvbkRhdGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0aW9uRGF0ZTtcblxuICAgICAgaWYgKHR5cGUgPT09IFwianNEYXRlXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gY29udmVydFBERkRhdGVUb0RhdGUoY3JlYXRpb25EYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBuYW1lIHNldENyZWF0aW9uRGF0ZVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqL1xuXG5cbiAgICBBUEkuc2V0Q3JlYXRpb25EYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHNldENyZWF0aW9uRGF0ZShkYXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG5hbWUgZ2V0Q3JlYXRpb25EYXRlXG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuXG5cbiAgICBBUEkuZ2V0Q3JlYXRpb25EYXRlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBnZXRDcmVhdGlvbkRhdGUodHlwZSk7XG4gICAgfTtcblxuICAgIHZhciBwYWRkMiA9IEFQSS5fX3ByaXZhdGVfXy5wYWRkMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgIHJldHVybiAoJzAnICsgcGFyc2VJbnQobnVtYmVyKSkuc2xpY2UoLTIpO1xuICAgIH07XG5cbiAgICB2YXIgb3V0VG9QYWdlcyA9ICExOyAvLyBzd2l0Y2hlcyB3aGVyZSBvdXQoKSBwcmludHMuIG91dFRvUGFnZXMgdHJ1ZSA9IHB1c2ggdG8gcGFnZXMgb2JqLiBvdXRUb1BhZ2VzIGZhbHNlID0gZG9jIGJ1aWxkZXIgY29udGVudFxuXG4gICAgdmFyIHBhZ2VzID0gW107XG4gICAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgICB2YXIgY3VycmVudFBhZ2U7XG4gICAgdmFyIGNvbnRlbnRfbGVuZ3RoID0gMDtcbiAgICB2YXIgY3VzdG9tT3V0cHV0RGVzdGluYXRpb247XG5cbiAgICB2YXIgc2V0T3V0cHV0RGVzdGluYXRpb24gPSBBUEkuX19wcml2YXRlX18uc2V0Q3VzdG9tT3V0cHV0RGVzdGluYXRpb24gPSBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgIGN1c3RvbU91dHB1dERlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfTtcblxuICAgIHZhciByZXNldE91dHB1dERlc3RpbmF0aW9uID0gQVBJLl9fcHJpdmF0ZV9fLnJlc2V0Q3VzdG9tT3V0cHV0RGVzdGluYXRpb24gPSBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgIGN1c3RvbU91dHB1dERlc3RpbmF0aW9uID0gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICB2YXIgb3V0ID0gQVBJLl9fcHJpdmF0ZV9fLm91dCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgIHZhciB3cml0ZUFycmF5O1xuICAgICAgc3RyaW5nID0gdHlwZW9mIHN0cmluZyA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZyA6IHN0cmluZy50b1N0cmluZygpO1xuXG4gICAgICBpZiAodHlwZW9mIGN1c3RvbU91dHB1dERlc3RpbmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHdyaXRlQXJyYXkgPSBvdXRUb1BhZ2VzID8gcGFnZXNbY3VycmVudFBhZ2VdIDogY29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQXJyYXkgPSBjdXN0b21PdXRwdXREZXN0aW5hdGlvbjtcbiAgICAgIH1cblxuICAgICAgd3JpdGVBcnJheS5wdXNoKHN0cmluZyk7XG5cbiAgICAgIGlmICghb3V0VG9QYWdlcykge1xuICAgICAgICBjb250ZW50X2xlbmd0aCArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdyaXRlQXJyYXk7XG4gICAgfTtcblxuICAgIHZhciB3cml0ZSA9IEFQSS5fX3ByaXZhdGVfXy53cml0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG91dChhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdmFsdWUudG9TdHJpbmcoKSA6IEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCAnICcpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEFycmF5QnVmZmVyID0gQVBJLl9fcHJpdmF0ZV9fLmdldEFycmF5QnVmZmVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBhYiA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pLFxuICAgICAgICAgIHU4ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgdThbbGVuXSA9IGRhdGEuY2hhckNvZGVBdChsZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWI7XG4gICAgfTtcblxuICAgIHZhciBzdGFuZGFyZEZvbnRzID0gW1snSGVsdmV0aWNhJywgXCJoZWx2ZXRpY2FcIiwgXCJub3JtYWxcIiwgJ1dpbkFuc2lFbmNvZGluZyddLCBbJ0hlbHZldGljYS1Cb2xkJywgXCJoZWx2ZXRpY2FcIiwgXCJib2xkXCIsICdXaW5BbnNpRW5jb2RpbmcnXSwgWydIZWx2ZXRpY2EtT2JsaXF1ZScsIFwiaGVsdmV0aWNhXCIsIFwiaXRhbGljXCIsICdXaW5BbnNpRW5jb2RpbmcnXSwgWydIZWx2ZXRpY2EtQm9sZE9ibGlxdWUnLCBcImhlbHZldGljYVwiLCBcImJvbGRpdGFsaWNcIiwgJ1dpbkFuc2lFbmNvZGluZyddLCBbJ0NvdXJpZXInLCBcImNvdXJpZXJcIiwgXCJub3JtYWxcIiwgJ1dpbkFuc2lFbmNvZGluZyddLCBbJ0NvdXJpZXItQm9sZCcsIFwiY291cmllclwiLCBcImJvbGRcIiwgJ1dpbkFuc2lFbmNvZGluZyddLCBbJ0NvdXJpZXItT2JsaXF1ZScsIFwiY291cmllclwiLCBcIml0YWxpY1wiLCAnV2luQW5zaUVuY29kaW5nJ10sIFsnQ291cmllci1Cb2xkT2JsaXF1ZScsIFwiY291cmllclwiLCBcImJvbGRpdGFsaWNcIiwgJ1dpbkFuc2lFbmNvZGluZyddLCBbJ1RpbWVzLVJvbWFuJywgXCJ0aW1lc1wiLCBcIm5vcm1hbFwiLCAnV2luQW5zaUVuY29kaW5nJ10sIFsnVGltZXMtQm9sZCcsIFwidGltZXNcIiwgXCJib2xkXCIsICdXaW5BbnNpRW5jb2RpbmcnXSwgWydUaW1lcy1JdGFsaWMnLCBcInRpbWVzXCIsIFwiaXRhbGljXCIsICdXaW5BbnNpRW5jb2RpbmcnXSwgWydUaW1lcy1Cb2xkSXRhbGljJywgXCJ0aW1lc1wiLCBcImJvbGRpdGFsaWNcIiwgJ1dpbkFuc2lFbmNvZGluZyddLCBbJ1phcGZEaW5nYmF0cycsIFwiemFwZmRpbmdiYXRzXCIsIFwibm9ybWFsXCIsIG51bGxdLCBbJ1N5bWJvbCcsIFwic3ltYm9sXCIsIFwibm9ybWFsXCIsIG51bGxdXTtcblxuICAgIHZhciBnZXRTdGFuZGFyZEZvbnRzID0gQVBJLl9fcHJpdmF0ZV9fLmdldFN0YW5kYXJkRm9udHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkRm9udHM7XG4gICAgfTtcblxuICAgIHZhciBhY3RpdmVGb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgMTY7XG4gICAgLyoqXG4gICAgICogU2V0cyBmb250IHNpemUgZm9yIHVwY29taW5nIHRleHQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBGb250IHNpemUgaW4gcG9pbnRzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBzZXRGb250U2l6ZVxuICAgICAqL1xuXG4gICAgdmFyIHNldEZvbnRTaXplID0gQVBJLl9fcHJpdmF0ZV9fLnNldEZvbnRTaXplID0gQVBJLnNldEZvbnRTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIGFjdGl2ZUZvbnRTaXplID0gc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZm9udHNpemUgZm9yIHVwY29taW5nIHRleHQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIGdldEZvbnRTaXplXG4gICAgICovXG5cblxuICAgIHZhciBnZXRGb250U2l6ZSA9IEFQSS5fX3ByaXZhdGVfXy5nZXRGb250U2l6ZSA9IEFQSS5nZXRGb250U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhY3RpdmVGb250U2l6ZTtcbiAgICB9O1xuXG4gICAgdmFyIFIyTCA9IG9wdGlvbnMuUjJMIHx8IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCB2YWx1ZSBvZiBSMkwgZnVuY3Rpb25hbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7anNQREZ9IGpzUERGLWluc3RhbmNlXG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgc2V0UjJMXG4gICAgICovXG5cbiAgICB2YXIgc2V0UjJMID0gQVBJLl9fcHJpdmF0ZV9fLnNldFIyTCA9IEFQSS5zZXRSMkwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIFIyTCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWUgb2YgUjJMIGZ1bmN0aW9uYWxpdHkuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0ganNQREYtaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBnZXRSMkxcbiAgICAgKi9cblxuXG4gICAgdmFyIGdldFIyTCA9IEFQSS5fX3ByaXZhdGVfXy5nZXRSMkwgPSBBUEkuZ2V0UjJMID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gUjJMO1xuICAgIH07XG5cbiAgICB2YXIgem9vbU1vZGU7IC8vIGRlZmF1bHQ6IDE7XG5cbiAgICB2YXIgc2V0Wm9vbU1vZGUgPSBBUEkuX19wcml2YXRlX18uc2V0Wm9vbU1vZGUgPSBmdW5jdGlvbiAoem9vbSkge1xuICAgICAgdmFyIHZhbGlkWm9vbU1vZGVzID0gW3VuZGVmaW5lZCwgbnVsbCwgJ2Z1bGx3aWR0aCcsICdmdWxsaGVpZ2h0JywgJ2Z1bGxwYWdlJywgJ29yaWdpbmFsJ107XG5cbiAgICAgIGlmICgvXlxcZCpcXC4/XFxkKlxcJSQvLnRlc3Qoem9vbSkpIHtcbiAgICAgICAgem9vbU1vZGUgPSB6b29tO1xuICAgICAgfSBlbHNlIGlmICghaXNOYU4oem9vbSkpIHtcbiAgICAgICAgem9vbU1vZGUgPSBwYXJzZUludCh6b29tLCAxMCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbGlkWm9vbU1vZGVzLmluZGV4T2Yoem9vbSkgIT09IC0xKSB7XG4gICAgICAgIHpvb21Nb2RlID0gem9vbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignem9vbSBtdXN0IGJlIEludGVnZXIgKGUuZy4gMiksIGEgcGVyY2VudGFnZSBWYWx1ZSAoZS5nLiAzMDAlKSBvciBmdWxsd2lkdGgsIGZ1bGxoZWlnaHQsIGZ1bGxwYWdlLCBvcmlnaW5hbC4gXCInICsgem9vbSArICdcIiBpcyBub3QgcmVjb2duaXplZC4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldFpvb21Nb2RlID0gQVBJLl9fcHJpdmF0ZV9fLmdldFpvb21Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHpvb21Nb2RlO1xuICAgIH07XG5cbiAgICB2YXIgcGFnZU1vZGU7IC8vIGRlZmF1bHQ6ICdVc2VPdXRsaW5lcyc7XG5cbiAgICB2YXIgc2V0UGFnZU1vZGUgPSBBUEkuX19wcml2YXRlX18uc2V0UGFnZU1vZGUgPSBmdW5jdGlvbiAocG1vZGUpIHtcbiAgICAgIHZhciB2YWxpZFBhZ2VNb2RlcyA9IFt1bmRlZmluZWQsIG51bGwsICdVc2VOb25lJywgJ1VzZU91dGxpbmVzJywgJ1VzZVRodW1icycsICdGdWxsU2NyZWVuJ107XG5cbiAgICAgIGlmICh2YWxpZFBhZ2VNb2Rlcy5pbmRleE9mKHBtb2RlKSA9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgbW9kZSBtdXN0IGJlIG9uZSBvZiBVc2VOb25lLCBVc2VPdXRsaW5lcywgVXNlVGh1bWJzLCBvciBGdWxsU2NyZWVuLiBcIicgKyBwbW9kZSArICdcIiBpcyBub3QgcmVjb2duaXplZC4nKTtcbiAgICAgIH1cblxuICAgICAgcGFnZU1vZGUgPSBwbW9kZTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFBhZ2VNb2RlID0gQVBJLl9fcHJpdmF0ZV9fLmdldFBhZ2VNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhZ2VNb2RlO1xuICAgIH07XG5cbiAgICB2YXIgbGF5b3V0TW9kZTsgLy8gZGVmYXVsdDogJ2NvbnRpbnVvdXMnO1xuXG4gICAgdmFyIHNldExheW91dE1vZGUgPSBBUEkuX19wcml2YXRlX18uc2V0TGF5b3V0TW9kZSA9IGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICAgIHZhciB2YWxpZExheW91dE1vZGVzID0gW3VuZGVmaW5lZCwgbnVsbCwgJ2NvbnRpbnVvdXMnLCAnc2luZ2xlJywgJ3R3b2xlZnQnLCAndHdvcmlnaHQnLCAndHdvJ107XG5cbiAgICAgIGlmICh2YWxpZExheW91dE1vZGVzLmluZGV4T2YobGF5b3V0KSA9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xheW91dCBtb2RlIG11c3QgYmUgb25lIG9mIGNvbnRpbnVvdXMsIHNpbmdsZSwgdHdvbGVmdCwgdHdvcmlnaHQuIFwiJyArIGxheW91dCArICdcIiBpcyBub3QgcmVjb2duaXplZC4nKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0TW9kZSA9IGxheW91dDtcbiAgICB9O1xuXG4gICAgdmFyIGdldExheW91dE1vZGUgPSBBUEkuX19wcml2YXRlX18uZ2V0TGF5b3V0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsYXlvdXRNb2RlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkaXNwbGF5IG1vZGUgb3B0aW9ucyBvZiB0aGUgcGFnZSBsaWtlIHpvb20gYW5kIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBuYW1lIHNldERpc3BsYXlNb2RlXG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQGZ1bmN0aW9uIFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7aW50ZWdlcnxTdHJpbmd9IHpvb20gICBZb3UgY2FuIHBhc3MgYW4gaW50ZWdlciBvciBwZXJjZW50YWdlIGFzXG4gICAgICogYSBzdHJpbmcuIDIgd2lsbCBzY2FsZSB0aGUgZG9jdW1lbnQgdXAgMngsICcyMDAlJyB3aWxsIHNjYWxlIHVwIGJ5IHRoZVxuICAgICAqIHNhbWUgYW1vdW50LiBZb3UgY2FuIGFsc28gc2V0IGl0IHRvICdmdWxsd2lkdGgnLCAnZnVsbGhlaWdodCcsXG4gICAgICogJ2Z1bGxwYWdlJywgb3IgJ29yaWdpbmFsJy5cbiAgICAgKlxuICAgICAqIE9ubHkgY2VydGFpbiBQREYgcmVhZGVycyBzdXBwb3J0IHRoaXMsIHN1Y2ggYXMgQWRvYmUgQWNyb2JhdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXlvdXQgTGF5b3V0IG1vZGUgY2FuIGJlOiAnY29udGludW91cycgLSB0aGlzIGlzIHRoZVxuICAgICAqIGRlZmF1bHQgY29udGludW91cyBzY3JvbGwuICdzaW5nbGUnIC0gdGhlIHNpbmdsZSBwYWdlIG1vZGUgb25seSBzaG93cyBvbmVcbiAgICAgKiBwYWdlIGF0IGEgdGltZS4gJ3R3b2xlZnQnIC0gdHdvIGNvbHVtbiBsZWZ0IG1vZGUsIGZpcnN0IHBhZ2Ugc3RhcnRzIG9uXG4gICAgICogdGhlIGxlZnQsIGFuZCAndHdvcmlnaHQnIC0gcGFnZXMgYXJlIGxhaWQgb3V0IGluIHR3byBjb2x1bW5zLCB3aXRoIHRoZVxuICAgICAqIGZpcnN0IHBhZ2Ugb24gdGhlIHJpZ2h0LiBUaGlzIHdvdWxkIGJlIHVzZWQgZm9yIGJvb2tzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwbW9kZSAnVXNlT3V0bGluZXMnIC0gaXQgc2hvd3MgdGhlXG4gICAgICogb3V0bGluZSBvZiB0aGUgZG9jdW1lbnQgb24gdGhlIGxlZnQuICdVc2VUaHVtYnMnIC0gc2hvd3MgdGh1bWJuYWlscyBhbG9uZ1xuICAgICAqIHRoZSBsZWZ0LiAnRnVsbFNjcmVlbicgLSBwcm9tcHRzIHRoZSB1c2VyIHRvIGVudGVyIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKi9cblxuXG4gICAgdmFyIHNldERpc3BsYXlNb2RlID0gQVBJLl9fcHJpdmF0ZV9fLnNldERpc3BsYXlNb2RlID0gQVBJLnNldERpc3BsYXlNb2RlID0gZnVuY3Rpb24gKHpvb20sIGxheW91dCwgcG1vZGUpIHtcbiAgICAgIHNldFpvb21Nb2RlKHpvb20pO1xuICAgICAgc2V0TGF5b3V0TW9kZShsYXlvdXQpO1xuICAgICAgc2V0UGFnZU1vZGUocG1vZGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBkb2N1bWVudFByb3BlcnRpZXMgPSB7XG4gICAgICAndGl0bGUnOiAnJyxcbiAgICAgICdzdWJqZWN0JzogJycsXG4gICAgICAnYXV0aG9yJzogJycsXG4gICAgICAna2V5d29yZHMnOiAnJyxcbiAgICAgICdjcmVhdG9yJzogJydcbiAgICB9O1xuXG4gICAgdmFyIGdldERvY3VtZW50UHJvcGVydHkgPSBBUEkuX19wcml2YXRlX18uZ2V0RG9jdW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhkb2N1bWVudFByb3BlcnRpZXMpLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5nZXREb2N1bWVudFByb3BlcnR5Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkb2N1bWVudFByb3BlcnRpZXNba2V5XTtcbiAgICB9O1xuXG4gICAgdmFyIGdldERvY3VtZW50UHJvcGVydGllcyA9IEFQSS5fX3ByaXZhdGVfXy5nZXREb2N1bWVudFByb3BlcnRpZXMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50UHJvcGVydGllcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwcm9wZXJ0aWVzIHRvIHRoZSBQREYgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gQSBwcm9wZXJ0eV9uYW1lLXRvLXByb3BlcnR5X3ZhbHVlIG9iamVjdCBzdHJ1Y3R1cmUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIHNldERvY3VtZW50UHJvcGVydGllc1xuICAgICAqL1xuXG5cbiAgICB2YXIgc2V0RG9jdW1lbnRQcm9wZXJ0aWVzID0gQVBJLl9fcHJpdmF0ZV9fLnNldERvY3VtZW50UHJvcGVydGllcyA9IEFQSS5zZXRQcm9wZXJ0aWVzID0gQVBJLnNldERvY3VtZW50UHJvcGVydGllcyA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAvLyBjb3B5aW5nIG9ubHkgdGhvc2UgcHJvcGVydGllcyB3ZSBjYW4gcmVuZGVyLlxuICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZG9jdW1lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChkb2N1bWVudFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmIHByb3BlcnRpZXNbcHJvcGVydHldKSB7XG4gICAgICAgICAgZG9jdW1lbnRQcm9wZXJ0aWVzW3Byb3BlcnR5XSA9IHByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgc2V0RG9jdW1lbnRQcm9wZXJ0eSA9IEFQSS5fX3ByaXZhdGVfXy5zZXREb2N1bWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhkb2N1bWVudFByb3BlcnRpZXMpLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuc2V0RG9jdW1lbnRQcm9wZXJ0eScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9jdW1lbnRQcm9wZXJ0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIG9iamVjdE51bWJlciA9IDA7IC8vICduJyBDdXJyZW50IG9iamVjdCBudW1iZXJcblxuICAgIHZhciBvZmZzZXRzID0gW107IC8vIExpc3Qgb2Ygb2Zmc2V0cy4gQWN0aXZhdGVkIGFuZCByZXNldCBieSBidWlsZERvY3VtZW50KCkuIFB1cHVsYXRlZCBieSB2YXJpb3VzIGNhbGxzIGJ1aWxkRG9jdW1lbnQgbWFrZXMuXG5cbiAgICB2YXIgZm9udHMgPSB7fTsgLy8gY29sbGVjdGlvbiBvZiBmb250IG9iamVjdHMsIHdoZXJlIGtleSBpcyBmb250S2V5IC0gYSBkeW5hbWljYWxseSBjcmVhdGVkIGxhYmVsIGZvciBhIGdpdmVuIGZvbnQuXG5cbiAgICB2YXIgZm9udG1hcCA9IHt9OyAvLyBtYXBwaW5nIHN0cnVjdHVyZSBmb250TmFtZSA+IGZvbnRTdHlsZSA+IGZvbnQga2V5IC0gcGVyZm9ybWFuY2UgbGF5ZXIuIFNlZSBhZGRGb250KClcblxuICAgIHZhciBhY3RpdmVGb250S2V5OyAvLyB3aWxsIGJlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIEtFWSBvZiB0aGUgZm9udCBhcyBjb21iaW5hdGlvbiBvZiBmb250TmFtZSArIGZvbnRTdHlsZVxuXG4gICAgdmFyIGs7IC8vIFNjYWxlIGZhY3RvclxuXG4gICAgdmFyIHBhZ2UgPSAwO1xuICAgIHZhciBwYWdlc0NvbnRleHQgPSBbXTtcbiAgICB2YXIgYWRkaXRpb25hbE9iamVjdHMgPSBbXTtcbiAgICB2YXIgZXZlbnRzID0gbmV3IFB1YlN1YihBUEkpO1xuICAgIHZhciBob3RmaXhlcyA9IG9wdGlvbnMuaG90Zml4ZXMgfHwgW107XG5cbiAgICB2YXIgbmV3T2JqZWN0ID0gQVBJLl9fcHJpdmF0ZV9fLm5ld09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvaWQgPSBuZXdPYmplY3REZWZlcnJlZCgpO1xuICAgICAgbmV3T2JqZWN0RGVmZXJyZWRCZWdpbihvaWQsIHRydWUpO1xuICAgICAgcmV0dXJuIG9pZDtcbiAgICB9OyAvLyBEb2VzIG5vdCBvdXRwdXQgdGhlIG9iamVjdC4gIFRoZSBjYWxsZXIgbXVzdCBjYWxsIG5ld09iamVjdERlZmVycmVkQmVnaW4ob2lkKSBiZWZvcmUgb3V0cHV0aW5nIGFueSBkYXRhXG5cblxuICAgIHZhciBuZXdPYmplY3REZWZlcnJlZCA9IEFQSS5fX3ByaXZhdGVfXy5uZXdPYmplY3REZWZlcnJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iamVjdE51bWJlcisrO1xuXG4gICAgICBvZmZzZXRzW29iamVjdE51bWJlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50X2xlbmd0aDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBvYmplY3ROdW1iZXI7XG4gICAgfTtcblxuICAgIHZhciBuZXdPYmplY3REZWZlcnJlZEJlZ2luID0gZnVuY3Rpb24gbmV3T2JqZWN0RGVmZXJyZWRCZWdpbihvaWQsIGRvT3V0cHV0KSB7XG4gICAgICBkb091dHB1dCA9IHR5cGVvZiBkb091dHB1dCA9PT0gJ2Jvb2xlYW4nID8gZG9PdXRwdXQgOiBmYWxzZTtcbiAgICAgIG9mZnNldHNbb2lkXSA9IGNvbnRlbnRfbGVuZ3RoO1xuXG4gICAgICBpZiAoZG9PdXRwdXQpIHtcbiAgICAgICAgb3V0KG9pZCArICcgMCBvYmonKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9pZDtcbiAgICB9OyAvLyBEb2VzIG5vdCBvdXRwdXQgdGhlIG9iamVjdCB1bnRpbCBhZnRlciB0aGUgcGFnZXMgaGF2ZSBiZWVuIG91dHB1dC5cbiAgICAvLyBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvYmplY3RJZCBhbmQgY29udGVudC5cbiAgICAvLyBBbGwgcGFnZXMgaGF2ZSBiZWVuIGFkZGVkIHNvIHRoZSBvYmplY3QgSUQgY2FuIGJlIGVzdGltYXRlZCB0byBzdGFydCByaWdodCBhZnRlci5cbiAgICAvLyBUaGlzIGRvZXMgbm90IG1vZGlmeSB0aGUgY3VycmVudCBvYmplY3ROdW1iZXI7ICBJdCBtdXN0IGJlIHVwZGF0ZWQgYWZ0ZXIgdGhlIG5ld09iamVjdHMgYXJlIG91dHB1dC5cblxuXG4gICAgdmFyIG5ld0FkZGl0aW9uYWxPYmplY3QgPSBBUEkuX19wcml2YXRlX18ubmV3QWRkaXRpb25hbE9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvYmpJZCA9IG5ld09iamVjdERlZmVycmVkKCk7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBvYmpJZDogb2JqSWQsXG4gICAgICAgIGNvbnRlbnQ6ICcnXG4gICAgICB9O1xuICAgICAgYWRkaXRpb25hbE9iamVjdHMucHVzaChvYmopO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIHJvb3REaWN0aW9uYXJ5T2JqSWQgPSBuZXdPYmplY3REZWZlcnJlZCgpO1xuICAgIHZhciByZXNvdXJjZURpY3Rpb25hcnlPYmpJZCA9IG5ld09iamVjdERlZmVycmVkKCk7IC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFByaXZhdGUgZnVuY3Rpb25zXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICB2YXIgZGVjb2RlQ29sb3JTdHJpbmcgPSBBUEkuX19wcml2YXRlX18uZGVjb2RlQ29sb3JTdHJpbmcgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgIHZhciBjb2xvckVuY29kZWQgPSBjb2xvci5zcGxpdCgnICcpO1xuXG4gICAgICBpZiAoY29sb3JFbmNvZGVkLmxlbmd0aCA9PT0gMiAmJiAoY29sb3JFbmNvZGVkWzFdID09PSAnZycgfHwgY29sb3JFbmNvZGVkWzFdID09PSAnRycpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgZ3JheXNjYWxlIHZhbHVlIHRvIHJnYiBzbyB0aGF0IGl0IGNhbiBiZSBjb252ZXJ0ZWQgdG8gaGV4IGZvciBjb25zaXN0ZW5jeVxuICAgICAgICB2YXIgZmxvYXRWYWwgPSBwYXJzZUZsb2F0KGNvbG9yRW5jb2RlZFswXSk7XG4gICAgICAgIGNvbG9yRW5jb2RlZCA9IFtmbG9hdFZhbCwgZmxvYXRWYWwsIGZsb2F0VmFsLCAnciddO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JBc1JHQiA9ICcjJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgY29sb3JBc1JHQiArPSAoJzAnICsgTWF0aC5mbG9vcihwYXJzZUZsb2F0KGNvbG9yRW5jb2RlZFtpXSkgKiAyNTUpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3JBc1JHQjtcbiAgICB9O1xuXG4gICAgdmFyIGVuY29kZUNvbG9yU3RyaW5nID0gQVBJLl9fcHJpdmF0ZV9fLmVuY29kZUNvbG9yU3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjb2xvcjtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgY2gxOiBvcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBjaDEgPSBvcHRpb25zLmNoMTtcbiAgICAgIHZhciBjaDIgPSBvcHRpb25zLmNoMjtcbiAgICAgIHZhciBjaDMgPSBvcHRpb25zLmNoMztcbiAgICAgIHZhciBjaDQgPSBvcHRpb25zLmNoNDtcbiAgICAgIHZhciBwcmVjaXNpb24gPSBvcHRpb25zLnByZWNpc2lvbjtcbiAgICAgIHZhciBsZXR0ZXJBcnJheSA9IG9wdGlvbnMucGRmQ29sb3JUeXBlID09PSBcImRyYXdcIiA/IFsnRycsICdSRycsICdLJ10gOiBbJ2cnLCAncmcnLCAnayddO1xuXG4gICAgICBpZiAodHlwZW9mIGNoMSA9PT0gXCJzdHJpbmdcIiAmJiBjaDEuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICAgICAgdmFyIHJnYkNvbG9yID0gbmV3IFJHQkNvbG9yKGNoMSk7XG5cbiAgICAgICAgaWYgKHJnYkNvbG9yLm9rKSB7XG4gICAgICAgICAgY2gxID0gcmdiQ29sb3IudG9IZXgoKTtcbiAgICAgICAgfSBlbHNlIGlmICghL15cXGQqXFwuP1xcZCokLy50ZXN0KGNoMSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sb3IgXCInICsgY2gxICsgJ1wiIHBhc3NlZCB0byBqc1BERi5lbmNvZGVDb2xvclN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgfSAvL2NvbnZlcnQgc2hvcnQgcmdiIHRvIGxvbmcgZm9ybVxuXG5cbiAgICAgIGlmICh0eXBlb2YgY2gxID09PSBcInN0cmluZ1wiICYmIC9eI1swLTlBLUZhLWZdezN9JC8udGVzdChjaDEpKSB7XG4gICAgICAgIGNoMSA9ICcjJyArIGNoMVsxXSArIGNoMVsxXSArIGNoMVsyXSArIGNoMVsyXSArIGNoMVszXSArIGNoMVszXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjaDEgPT09IFwic3RyaW5nXCIgJiYgL14jWzAtOUEtRmEtZl17Nn0kLy50ZXN0KGNoMSkpIHtcbiAgICAgICAgdmFyIGhleCA9IHBhcnNlSW50KGNoMS5zdWJzdHIoMSksIDE2KTtcbiAgICAgICAgY2gxID0gaGV4ID4+IDE2ICYgMjU1O1xuICAgICAgICBjaDIgPSBoZXggPj4gOCAmIDI1NTtcbiAgICAgICAgY2gzID0gaGV4ICYgMjU1O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNoMiA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgY2g0ID09PSBcInVuZGVmaW5lZFwiICYmIGNoMSA9PT0gY2gyICYmIGNoMiA9PT0gY2gzKSB7XG4gICAgICAgIC8vIEdyYXkgY29sb3Igc3BhY2UuXG4gICAgICAgIGlmICh0eXBlb2YgY2gxID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29sb3IgPSBjaDEgKyBcIiBcIiArIGxldHRlckFycmF5WzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5wcmVjaXNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY29sb3IgPSBmMihjaDEgLyAyNTUpICsgXCIgXCIgKyBsZXR0ZXJBcnJheVswXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbG9yID0gZjMoY2gxIC8gMjU1KSArIFwiIFwiICsgbGV0dGVyQXJyYXlbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaDQgPT09IFwidW5kZWZpbmVkXCIgfHwgX3R5cGVvZihjaDQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIGFzc3VtZSBSR0JBXG4gICAgICAgIGlmIChjaDQgJiYgIWlzTmFOKGNoNC5hKSkge1xuICAgICAgICAgIC8vVE9ETyBJbXBsZW1lbnQgdHJhbnNwYXJlbmN5LlxuICAgICAgICAgIC8vV09SS0FST1VORCB1c2Ugd2hpdGUgZm9yIG5vdywgaWYgdHJhbnNwYXJlbnQsIG90aGVyd2lzZSBoYW5kbGUgYXMgcmdiXG4gICAgICAgICAgaWYgKGNoNC5hID09PSAwKSB7XG4gICAgICAgICAgICBjb2xvciA9IFsnMS4wMDAnLCAnMS4wMDAnLCAnMS4wMDAnLCBsZXR0ZXJBcnJheVsxXV0uam9pbihcIiBcIik7XG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGFzc3VtZSBSR0JcblxuXG4gICAgICAgIGlmICh0eXBlb2YgY2gxID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29sb3IgPSBbY2gxLCBjaDIsIGNoMywgbGV0dGVyQXJyYXlbMV1dLmpvaW4oXCIgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5wcmVjaXNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY29sb3IgPSBbZjIoY2gxIC8gMjU1KSwgZjIoY2gyIC8gMjU1KSwgZjIoY2gzIC8gMjU1KSwgbGV0dGVyQXJyYXlbMV1dLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY29sb3IgPSBbZjMoY2gxIC8gMjU1KSwgZjMoY2gyIC8gMjU1KSwgZjMoY2gzIC8gMjU1KSwgbGV0dGVyQXJyYXlbMV1dLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXNzdW1lIENNWUtcbiAgICAgICAgaWYgKHR5cGVvZiBjaDEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29sb3IgPSBbY2gxLCBjaDIsIGNoMywgY2g0LCBsZXR0ZXJBcnJheVsyXV0uam9pbihcIiBcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChvcHRpb25zLnByZWNpc2lvbikge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjb2xvciA9IFtmMihjaDEgLyAyNTUpLCBmMihjaDIgLyAyNTUpLCBmMihjaDMgLyAyNTUpLCBmMihjaDQgLyAyNTUpLCBsZXR0ZXJBcnJheVsyXV0uam9pbihcIiBcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb2xvciA9IFtmMyhjaDEgLyAyNTUpLCBmMyhjaDIgLyAyNTUpLCBmMyhjaDMgLyAyNTUpLCBmMyhjaDQgLyAyNTUpLCBsZXR0ZXJBcnJheVsyXV0uam9pbihcIiBcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbHRlcnMgPSBBUEkuX19wcml2YXRlX18uZ2V0RmlsdGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJzO1xuICAgIH07XG5cbiAgICB2YXIgcHV0U3RyZWFtID0gQVBJLl9fcHJpdmF0ZV9fLnB1dFN0cmVhbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhIHx8ICcnO1xuICAgICAgdmFyIGZpbHRlcnMgPSBvcHRpb25zLmZpbHRlcnMgfHwgZ2V0RmlsdGVycygpO1xuICAgICAgdmFyIGFscmVhZHlBcHBsaWVkRmlsdGVycyA9IG9wdGlvbnMuYWxyZWFkeUFwcGxpZWRGaWx0ZXJzIHx8IFtdO1xuICAgICAgdmFyIGFkZExlbmd0aDEgPSBvcHRpb25zLmFkZExlbmd0aDEgfHwgZmFsc2U7XG4gICAgICB2YXIgdmFsdWVPZkxlbmd0aDEgPSBkYXRhLmxlbmd0aDtcbiAgICAgIHZhciBwcm9jZXNzZWREYXRhID0ge307XG5cbiAgICAgIGlmIChmaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgIGZpbHRlcnMgPSBbJ0ZsYXRlRW5jb2RlJ107XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlWYWx1ZXMgPSBvcHRpb25zLmFkZGl0aW9uYWxLZXlWYWx1ZXMgfHwgW107XG5cbiAgICAgIGlmICh0eXBlb2YganNQREYuQVBJLnByb2Nlc3NEYXRhQnlGaWx0ZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9jZXNzZWREYXRhID0ganNQREYuQVBJLnByb2Nlc3NEYXRhQnlGaWx0ZXJzKGRhdGEsIGZpbHRlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHJldmVyc2VDaGFpbjogW11cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbHRlckFzU3RyaW5nID0gcHJvY2Vzc2VkRGF0YS5yZXZlcnNlQ2hhaW4gKyAoQXJyYXkuaXNBcnJheShhbHJlYWR5QXBwbGllZEZpbHRlcnMpID8gYWxyZWFkeUFwcGxpZWRGaWx0ZXJzLmpvaW4oJyAnKSA6IGFscmVhZHlBcHBsaWVkRmlsdGVycy50b1N0cmluZygpKTtcblxuICAgICAgaWYgKHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAga2V5VmFsdWVzLnB1c2goe1xuICAgICAgICAgIGtleTogJ0xlbmd0aCcsXG4gICAgICAgICAgdmFsdWU6IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGFkZExlbmd0aDEgPT09IHRydWUpIHtcbiAgICAgICAgICBrZXlWYWx1ZXMucHVzaCh7XG4gICAgICAgICAgICBrZXk6ICdMZW5ndGgxJyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZU9mTGVuZ3RoMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJBc1N0cmluZy5sZW5ndGggIT0gMCkge1xuICAgICAgICAvL2lmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCAmJiBhbHJlYWR5QXBwbGllZEZpbHRlcnMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhbHJlYWR5QXBwbGllZEZpbHRlcnMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGZpbHRlckFzU3RyaW5nLnNwbGl0KCcvJykubGVuZ3RoIC0gMSA9PT0gMSkge1xuICAgICAgICAgIGtleVZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgIGtleTogJ0ZpbHRlcicsXG4gICAgICAgICAgICB2YWx1ZTogZmlsdGVyQXNTdHJpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlWYWx1ZXMucHVzaCh7XG4gICAgICAgICAgICBrZXk6ICdGaWx0ZXInLFxuICAgICAgICAgICAgdmFsdWU6ICdbJyArIGZpbHRlckFzU3RyaW5nICsgJ10nXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3V0KCc8PCcpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQoJy8nICsga2V5VmFsdWVzW2ldLmtleSArICcgJyArIGtleVZhbHVlc1tpXS52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIG91dCgnPj4nKTtcblxuICAgICAgaWYgKHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgb3V0KCdzdHJlYW0nKTtcbiAgICAgICAgb3V0KHByb2Nlc3NlZERhdGEuZGF0YSk7XG4gICAgICAgIG91dCgnZW5kc3RyZWFtJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwdXRQYWdlID0gQVBJLl9fcHJpdmF0ZV9fLnB1dFBhZ2UgPSBmdW5jdGlvbiAocGFnZSkge1xuICAgICAgdmFyIG1lZGlhQm94ID0gcGFnZS5tZWRpYUJveDtcbiAgICAgIHZhciBwYWdlTnVtYmVyID0gcGFnZS5udW1iZXI7XG4gICAgICB2YXIgZGF0YSA9IHBhZ2UuZGF0YTtcbiAgICAgIHZhciBwYWdlT2JqZWN0TnVtYmVyID0gcGFnZS5vYmpJZDtcbiAgICAgIHZhciBwYWdlQ29udGVudHNPYmpJZCA9IHBhZ2UuY29udGVudHNPYmpJZDtcbiAgICAgIG5ld09iamVjdERlZmVycmVkQmVnaW4ocGFnZU9iamVjdE51bWJlciwgdHJ1ZSk7XG4gICAgICB2YXIgd1B0ID0gcGFnZXNDb250ZXh0W2N1cnJlbnRQYWdlXS5tZWRpYUJveC50b3BSaWdodFggLSBwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm1lZGlhQm94LmJvdHRvbUxlZnRYO1xuICAgICAgdmFyIGhQdCA9IHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3gudG9wUmlnaHRZIC0gcGFnZXNDb250ZXh0W2N1cnJlbnRQYWdlXS5tZWRpYUJveC5ib3R0b21MZWZ0WTtcbiAgICAgIG91dCgnPDwvVHlwZSAvUGFnZScpO1xuICAgICAgb3V0KCcvUGFyZW50ICcgKyBwYWdlLnJvb3REaWN0aW9uYXJ5T2JqSWQgKyAnIDAgUicpO1xuICAgICAgb3V0KCcvUmVzb3VyY2VzICcgKyBwYWdlLnJlc291cmNlRGljdGlvbmFyeU9iaklkICsgJyAwIFInKTtcbiAgICAgIG91dCgnL01lZGlhQm94IFsnICsgcGFyc2VGbG9hdChmMihwYWdlLm1lZGlhQm94LmJvdHRvbUxlZnRYKSkgKyAnICcgKyBwYXJzZUZsb2F0KGYyKHBhZ2UubWVkaWFCb3guYm90dG9tTGVmdFkpKSArICcgJyArIGYyKHBhZ2UubWVkaWFCb3gudG9wUmlnaHRYKSArICcgJyArIGYyKHBhZ2UubWVkaWFCb3gudG9wUmlnaHRZKSArICddJyk7XG5cbiAgICAgIGlmIChwYWdlLmNyb3BCb3ggIT09IG51bGwpIHtcbiAgICAgICAgb3V0KCcvQ3JvcEJveCBbJyArIGYyKHBhZ2UuY3JvcEJveC5ib3R0b21MZWZ0WCkgKyAnICcgKyBmMihwYWdlLmNyb3BCb3guYm90dG9tTGVmdFkpICsgJyAnICsgZjIocGFnZS5jcm9wQm94LnRvcFJpZ2h0WCkgKyAnICcgKyBmMihwYWdlLmNyb3BCb3gudG9wUmlnaHRZKSArICddJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlLmJsZWVkQm94ICE9PSBudWxsKSB7XG4gICAgICAgIG91dCgnL0JsZWVkQm94IFsnICsgZjIocGFnZS5ibGVlZEJveC5ib3R0b21MZWZ0WCkgKyAnICcgKyBmMihwYWdlLmJsZWVkQm94LmJvdHRvbUxlZnRZKSArICcgJyArIGYyKHBhZ2UuYmxlZWRCb3gudG9wUmlnaHRYKSArICcgJyArIGYyKHBhZ2UuYmxlZWRCb3gudG9wUmlnaHRZKSArICddJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlLnRyaW1Cb3ggIT09IG51bGwpIHtcbiAgICAgICAgb3V0KCcvVHJpbUJveCBbJyArIGYyKHBhZ2UudHJpbUJveC5ib3R0b21MZWZ0WCkgKyAnICcgKyBmMihwYWdlLnRyaW1Cb3guYm90dG9tTGVmdFkpICsgJyAnICsgZjIocGFnZS50cmltQm94LnRvcFJpZ2h0WCkgKyAnICcgKyBmMihwYWdlLnRyaW1Cb3gudG9wUmlnaHRZKSArICddJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlLmFydEJveCAhPT0gbnVsbCkge1xuICAgICAgICBvdXQoJy9BcnRCb3ggWycgKyBmMihwYWdlLmFydEJveC5ib3R0b21MZWZ0WCkgKyAnICcgKyBmMihwYWdlLmFydEJveC5ib3R0b21MZWZ0WSkgKyAnICcgKyBmMihwYWdlLmFydEJveC50b3BSaWdodFgpICsgJyAnICsgZjIocGFnZS5hcnRCb3gudG9wUmlnaHRZKSArICddJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcGFnZS51c2VyVW5pdCA9PT0gXCJudW1iZXJcIiAmJiBwYWdlLnVzZXJVbml0ICE9PSAxLjApIHtcbiAgICAgICAgb3V0KCcvVXNlclVuaXQgJyArIHBhZ2UudXNlclVuaXQpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMucHVibGlzaCgncHV0UGFnZScsIHtcbiAgICAgICAgb2JqSWQ6IHBhZ2VPYmplY3ROdW1iZXIsXG4gICAgICAgIHBhZ2VDb250ZXh0OiBwYWdlc0NvbnRleHRbcGFnZU51bWJlcl0sXG4gICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXIsXG4gICAgICAgIHBhZ2U6IGRhdGFcbiAgICAgIH0pO1xuICAgICAgb3V0KCcvQ29udGVudHMgJyArIHBhZ2VDb250ZW50c09iaklkICsgJyAwIFInKTtcbiAgICAgIG91dCgnPj4nKTtcbiAgICAgIG91dCgnZW5kb2JqJyk7IC8vIFBhZ2UgY29udGVudFxuXG4gICAgICB2YXIgcGFnZUNvbnRlbnQgPSBkYXRhLmpvaW4oJ1xcbicpO1xuICAgICAgbmV3T2JqZWN0RGVmZXJyZWRCZWdpbihwYWdlQ29udGVudHNPYmpJZCwgdHJ1ZSk7XG4gICAgICBwdXRTdHJlYW0oe1xuICAgICAgICBkYXRhOiBwYWdlQ29udGVudCxcbiAgICAgICAgZmlsdGVyczogZ2V0RmlsdGVycygpXG4gICAgICB9KTtcbiAgICAgIG91dCgnZW5kb2JqJyk7XG4gICAgICByZXR1cm4gcGFnZU9iamVjdE51bWJlcjtcbiAgICB9O1xuXG4gICAgdmFyIHB1dFBhZ2VzID0gQVBJLl9fcHJpdmF0ZV9fLnB1dFBhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBwYWdlT2JqZWN0TnVtYmVycyA9IFtdO1xuXG4gICAgICBmb3IgKG4gPSAxOyBuIDw9IHBhZ2U7IG4rKykge1xuICAgICAgICBwYWdlc0NvbnRleHRbbl0ub2JqSWQgPSBuZXdPYmplY3REZWZlcnJlZCgpO1xuICAgICAgICBwYWdlc0NvbnRleHRbbl0uY29udGVudHNPYmpJZCA9IG5ld09iamVjdERlZmVycmVkKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobiA9IDE7IG4gPD0gcGFnZTsgbisrKSB7XG4gICAgICAgIHBhZ2VPYmplY3ROdW1iZXJzLnB1c2gocHV0UGFnZSh7XG4gICAgICAgICAgbnVtYmVyOiBuLFxuICAgICAgICAgIGRhdGE6IHBhZ2VzW25dLFxuICAgICAgICAgIG9iaklkOiBwYWdlc0NvbnRleHRbbl0ub2JqSWQsXG4gICAgICAgICAgY29udGVudHNPYmpJZDogcGFnZXNDb250ZXh0W25dLmNvbnRlbnRzT2JqSWQsXG4gICAgICAgICAgbWVkaWFCb3g6IHBhZ2VzQ29udGV4dFtuXS5tZWRpYUJveCxcbiAgICAgICAgICBjcm9wQm94OiBwYWdlc0NvbnRleHRbbl0uY3JvcEJveCxcbiAgICAgICAgICBibGVlZEJveDogcGFnZXNDb250ZXh0W25dLmJsZWVkQm94LFxuICAgICAgICAgIHRyaW1Cb3g6IHBhZ2VzQ29udGV4dFtuXS50cmltQm94LFxuICAgICAgICAgIGFydEJveDogcGFnZXNDb250ZXh0W25dLmFydEJveCxcbiAgICAgICAgICB1c2VyVW5pdDogcGFnZXNDb250ZXh0W25dLnVzZXJVbml0LFxuICAgICAgICAgIHJvb3REaWN0aW9uYXJ5T2JqSWQ6IHJvb3REaWN0aW9uYXJ5T2JqSWQsXG4gICAgICAgICAgcmVzb3VyY2VEaWN0aW9uYXJ5T2JqSWQ6IHJlc291cmNlRGljdGlvbmFyeU9iaklkXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgbmV3T2JqZWN0RGVmZXJyZWRCZWdpbihyb290RGljdGlvbmFyeU9iaklkLCB0cnVlKTtcbiAgICAgIG91dCgnPDwvVHlwZSAvUGFnZXMnKTtcbiAgICAgIHZhciBraWRzID0gJy9LaWRzIFsnO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcGFnZTsgaSsrKSB7XG4gICAgICAgIGtpZHMgKz0gcGFnZU9iamVjdE51bWJlcnNbaV0gKyAnIDAgUiAnO1xuICAgICAgfVxuXG4gICAgICBvdXQoa2lkcyArICddJyk7XG4gICAgICBvdXQoJy9Db3VudCAnICsgcGFnZSk7XG4gICAgICBvdXQoJz4+Jyk7XG4gICAgICBvdXQoJ2VuZG9iaicpO1xuICAgICAgZXZlbnRzLnB1Ymxpc2goJ3Bvc3RQdXRQYWdlcycpO1xuICAgIH07XG5cbiAgICB2YXIgcHV0Rm9udCA9IGZ1bmN0aW9uIHB1dEZvbnQoZm9udCkge1xuICAgICAgZXZlbnRzLnB1Ymxpc2goJ3B1dEZvbnQnLCB7XG4gICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgIG91dDogb3V0LFxuICAgICAgICBuZXdPYmplY3Q6IG5ld09iamVjdCxcbiAgICAgICAgcHV0U3RyZWFtOiBwdXRTdHJlYW1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZm9udC5pc0FscmVhZHlQdXR0ZWQgIT09IHRydWUpIHtcbiAgICAgICAgZm9udC5vYmplY3ROdW1iZXIgPSBuZXdPYmplY3QoKTtcbiAgICAgICAgb3V0KCc8PCcpO1xuICAgICAgICBvdXQoJy9UeXBlIC9Gb250Jyk7XG4gICAgICAgIG91dCgnL0Jhc2VGb250IC8nICsgZm9udC5wb3N0U2NyaXB0TmFtZSk7XG4gICAgICAgIG91dCgnL1N1YnR5cGUgL1R5cGUxJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb250LmVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG91dCgnL0VuY29kaW5nIC8nICsgZm9udC5lbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQoJy9GaXJzdENoYXIgMzInKTtcbiAgICAgICAgb3V0KCcvTGFzdENoYXIgMjU1Jyk7XG4gICAgICAgIG91dCgnPj4nKTtcbiAgICAgICAgb3V0KCdlbmRvYmonKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHB1dEZvbnRzID0gZnVuY3Rpb24gcHV0Rm9udHMoKSB7XG4gICAgICBmb3IgKHZhciBmb250S2V5IGluIGZvbnRzKSB7XG4gICAgICAgIGlmIChmb250cy5oYXNPd25Qcm9wZXJ0eShmb250S2V5KSkge1xuICAgICAgICAgIGlmIChwdXRPbmx5VXNlZEZvbnRzID09PSBmYWxzZSB8fCBwdXRPbmx5VXNlZEZvbnRzID09PSB0cnVlICYmIHVzZWRGb250cy5oYXNPd25Qcm9wZXJ0eShmb250S2V5KSkge1xuICAgICAgICAgICAgcHV0Rm9udChmb250c1tmb250S2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwdXRSZXNvdXJjZURpY3Rpb25hcnkgPSBmdW5jdGlvbiBwdXRSZXNvdXJjZURpY3Rpb25hcnkoKSB7XG4gICAgICBvdXQoJy9Qcm9jU2V0IFsvUERGIC9UZXh0IC9JbWFnZUIgL0ltYWdlQyAvSW1hZ2VJXScpO1xuICAgICAgb3V0KCcvRm9udCA8PCcpOyAvLyBEbyB0aGlzIGZvciBlYWNoIGZvbnQsIHRoZSAnMScgYml0IGlzIHRoZSBpbmRleCBvZiB0aGUgZm9udFxuXG4gICAgICBmb3IgKHZhciBmb250S2V5IGluIGZvbnRzKSB7XG4gICAgICAgIGlmIChmb250cy5oYXNPd25Qcm9wZXJ0eShmb250S2V5KSkge1xuICAgICAgICAgIGlmIChwdXRPbmx5VXNlZEZvbnRzID09PSBmYWxzZSB8fCBwdXRPbmx5VXNlZEZvbnRzID09PSB0cnVlICYmIHVzZWRGb250cy5oYXNPd25Qcm9wZXJ0eShmb250S2V5KSkge1xuICAgICAgICAgICAgb3V0KCcvJyArIGZvbnRLZXkgKyAnICcgKyBmb250c1tmb250S2V5XS5vYmplY3ROdW1iZXIgKyAnIDAgUicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvdXQoJz4+Jyk7XG4gICAgICBvdXQoJy9YT2JqZWN0IDw8Jyk7XG4gICAgICBldmVudHMucHVibGlzaCgncHV0WG9iamVjdERpY3QnKTtcbiAgICAgIG91dCgnPj4nKTtcbiAgICB9O1xuXG4gICAgdmFyIHB1dFJlc291cmNlcyA9IGZ1bmN0aW9uIHB1dFJlc291cmNlcygpIHtcbiAgICAgIHB1dEZvbnRzKCk7XG4gICAgICBldmVudHMucHVibGlzaCgncHV0UmVzb3VyY2VzJyk7XG4gICAgICBuZXdPYmplY3REZWZlcnJlZEJlZ2luKHJlc291cmNlRGljdGlvbmFyeU9iaklkLCB0cnVlKTtcbiAgICAgIG91dCgnPDwnKTtcbiAgICAgIHB1dFJlc291cmNlRGljdGlvbmFyeSgpO1xuICAgICAgb3V0KCc+PicpO1xuICAgICAgb3V0KCdlbmRvYmonKTtcbiAgICAgIGV2ZW50cy5wdWJsaXNoKCdwb3N0UHV0UmVzb3VyY2VzJyk7XG4gICAgfTtcblxuICAgIHZhciBwdXRBZGRpdGlvbmFsT2JqZWN0cyA9IGZ1bmN0aW9uIHB1dEFkZGl0aW9uYWxPYmplY3RzKCkge1xuICAgICAgZXZlbnRzLnB1Ymxpc2goJ3B1dEFkZGl0aW9uYWxPYmplY3RzJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkaXRpb25hbE9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IGFkZGl0aW9uYWxPYmplY3RzW2ldO1xuICAgICAgICBuZXdPYmplY3REZWZlcnJlZEJlZ2luKG9iai5vYmpJZCwgdHJ1ZSk7XG4gICAgICAgIG91dChvYmouY29udGVudCk7XG4gICAgICAgIG91dCgnZW5kb2JqJyk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5wdWJsaXNoKCdwb3N0UHV0QWRkaXRpb25hbE9iamVjdHMnKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFRvRm9udERpY3Rpb25hcnkgPSBmdW5jdGlvbiBhZGRUb0ZvbnREaWN0aW9uYXJ5KGZvbnRLZXksIGZvbnROYW1lLCBmb250U3R5bGUpIHtcbiAgICAgIC8vIHRoaXMgaXMgbWFwcGluZyBzdHJ1Y3R1cmUgZm9yIHF1aWNrIGZvbnQga2V5IGxvb2t1cC5cbiAgICAgIC8vIHJldHVybnMgdGhlIEtFWSBvZiB0aGUgZm9udCAoZXg6IFwiRjFcIikgZm9yIGEgZ2l2ZW5cbiAgICAgIC8vIHBhaXIgb2YgZm9udCBuYW1lIGFuZCB0eXBlIChleDogXCJBcmlhbFwiLiBcIkl0YWxpY1wiKVxuICAgICAgaWYgKCFmb250bWFwLmhhc093blByb3BlcnR5KGZvbnROYW1lKSkge1xuICAgICAgICBmb250bWFwW2ZvbnROYW1lXSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBmb250bWFwW2ZvbnROYW1lXVtmb250U3R5bGVdID0gZm9udEtleTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEZvbnQgPSBmdW5jdGlvbiBhZGRGb250KHBvc3RTY3JpcHROYW1lLCBmb250TmFtZSwgZm9udFN0eWxlLCBlbmNvZGluZywgaXNTdGFuZGFyZEZvbnQpIHtcbiAgICAgIGlzU3RhbmRhcmRGb250ID0gaXNTdGFuZGFyZEZvbnQgfHwgZmFsc2U7XG4gICAgICB2YXIgZm9udEtleSA9ICdGJyArIChPYmplY3Qua2V5cyhmb250cykubGVuZ3RoICsgMSkudG9TdHJpbmcoMTApLFxuICAgICAgICAgIC8vIFRoaXMgaXMgRm9udE9iamVjdFxuICAgICAgZm9udCA9IHtcbiAgICAgICAgJ2lkJzogZm9udEtleSxcbiAgICAgICAgJ3Bvc3RTY3JpcHROYW1lJzogcG9zdFNjcmlwdE5hbWUsXG4gICAgICAgICdmb250TmFtZSc6IGZvbnROYW1lLFxuICAgICAgICAnZm9udFN0eWxlJzogZm9udFN0eWxlLFxuICAgICAgICAnZW5jb2RpbmcnOiBlbmNvZGluZyxcbiAgICAgICAgJ2lzU3RhbmRhcmRGb250JzogaXNTdGFuZGFyZEZvbnQsXG4gICAgICAgICdtZXRhZGF0YSc6IHt9XG4gICAgICB9O1xuICAgICAgdmFyIGluc3RhbmNlID0gdGhpcztcbiAgICAgIGV2ZW50cy5wdWJsaXNoKCdhZGRGb250Jywge1xuICAgICAgICBmb250OiBmb250LFxuICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZm9udEtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvbnRzW2ZvbnRLZXldID0gZm9udDtcbiAgICAgICAgYWRkVG9Gb250RGljdGlvbmFyeShmb250S2V5LCBmb250TmFtZSwgZm9udFN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvbnRLZXk7XG4gICAgfTtcblxuICAgIHZhciBhZGRGb250cyA9IGZ1bmN0aW9uIGFkZEZvbnRzKGFycmF5T2ZGb250cykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFuZGFyZEZvbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgZm9udEtleSA9IGFkZEZvbnQoYXJyYXlPZkZvbnRzW2ldWzBdLCBhcnJheU9mRm9udHNbaV1bMV0sIGFycmF5T2ZGb250c1tpXVsyXSwgc3RhbmRhcmRGb250c1tpXVszXSwgdHJ1ZSk7XG4gICAgICAgIHVzZWRGb250c1tmb250S2V5XSA9IHRydWU7IC8vIGFkZGluZyBhbGlhc2VzIGZvciBzdGFuZGFyZCBmb250cywgdGhpcyB0aW1lIG1hdGNoaW5nIHRoZSBjYXBpdGFsaXphdGlvblxuXG4gICAgICAgIHZhciBwYXJ0cyA9IGFycmF5T2ZGb250c1tpXVswXS5zcGxpdCgnLScpO1xuICAgICAgICBhZGRUb0ZvbnREaWN0aW9uYXJ5KGZvbnRLZXksIHBhcnRzWzBdLCBwYXJ0c1sxXSB8fCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5wdWJsaXNoKCdhZGRGb250cycsIHtcbiAgICAgICAgZm9udHM6IGZvbnRzLFxuICAgICAgICBkaWN0aW9uYXJ5OiBmb250bWFwXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIFNBRkUgPSBmdW5jdGlvbiBfX3NhZmVDYWxsKGZuKSB7XG4gICAgICBmbi5mb28gPSBmdW5jdGlvbiBfX3NhZmVDYWxsV3JhcHBlcigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHZhciBzdGFjayA9IGUuc3RhY2sgfHwgJyc7XG4gICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKCcgYXQgJykpIHN0YWNrID0gc3RhY2suc3BsaXQoXCIgYXQgXCIpWzFdO1xuICAgICAgICAgIHZhciBtID0gXCJFcnJvciBpbiBmdW5jdGlvbiBcIiArIHN0YWNrLnNwbGl0KFwiXFxuXCIpWzBdLnNwbGl0KCc8JylbMF0gKyBcIjogXCIgKyBlLm1lc3NhZ2U7XG5cbiAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5jb25zb2xlLmVycm9yKG0sIGUpO1xuICAgICAgICAgICAgaWYgKGdsb2JhbC5hbGVydCkgYWxlcnQobSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZuLmZvby5iYXIgPSBmbjtcbiAgICAgIHJldHVybiBmbi5mb287XG4gICAgfTtcblxuICAgIHZhciB0bzhiaXRTdHJlYW0gPSBmdW5jdGlvbiB0bzhiaXRTdHJlYW0odGV4dCwgZmxhZ3MpIHtcbiAgICAgIC8qKlxuICAgICAgICogUERGIDEuMyBzcGVjOlxuICAgICAgICogXCJGb3IgdGV4dCBzdHJpbmdzIGVuY29kZWQgaW4gVW5pY29kZSwgdGhlIGZpcnN0IHR3byBieXRlcyBtdXN0IGJlIDI1NCBmb2xsb3dlZCBieVxuICAgICAgICogMjU1LCByZXByZXNlbnRpbmcgdGhlIFVuaWNvZGUgYnl0ZSBvcmRlciBtYXJrZXIsIFUrRkVGRi4gKFRoaXMgc2VxdWVuY2UgY29uZmxpY3RzXG4gICAgICAgKiB3aXRoIHRoZSBQREZEb2NFbmNvZGluZyBjaGFyYWN0ZXIgc2VxdWVuY2UgdGhvcm4geWRpZXJlc2lzLCB3aGljaCBpcyB1bmxpa2VseVxuICAgICAgICogdG8gYmUgYSBtZWFuaW5nZnVsIGJlZ2lubmluZyBvZiBhIHdvcmQgb3IgcGhyYXNlLikgVGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgICAgICAqIHN0cmluZyBjb25zaXN0cyBvZiBVbmljb2RlIGNoYXJhY3RlciBjb2RlcywgYWNjb3JkaW5nIHRvIHRoZSBVVEYtMTYgZW5jb2RpbmdcbiAgICAgICAqIHNwZWNpZmllZCBpbiB0aGUgVW5pY29kZSBzdGFuZGFyZCwgdmVyc2lvbiAyLjAuIENvbW1vbmx5IHVzZWQgVW5pY29kZSB2YWx1ZXNcbiAgICAgICAqIGFyZSByZXByZXNlbnRlZCBhcyAyIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIHdpdGggdGhlIGhpZ2gtb3JkZXIgYnl0ZSBhcHBlYXJpbmcgZmlyc3RcbiAgICAgICAqIGluIHRoZSBzdHJpbmcuXCJcbiAgICAgICAqXG4gICAgICAgKiBJbiBvdGhlciB3b3JkcywgaWYgdGhlcmUgYXJlIGNoYXJzIGluIGEgc3RyaW5nIHdpdGggY2hhciBjb2RlIGFib3ZlIDI1NSwgd2VcbiAgICAgICAqIHJlY29kZSB0aGUgc3RyaW5nIHRvIFVDUzIgQkUgLSBzdHJpbmcgZG91YmxlcyBpbiBsZW5ndGggYW5kIEJPTSBpcyBwcmVwZW5kZWQuXG4gICAgICAgKlxuICAgICAgICogSE9XRVZFUiFcbiAgICAgICAqIEFjdHVhbCAqY29udGVudCogKGJvZHkpIHRleHQgKGFzIG9wcG9zZWQgdG8gc3RyaW5ncyB1c2VkIGluIGRvY3VtZW50IHByb3BlcnRpZXMgZXRjKVxuICAgICAgICogZG9lcyBOT1QgZXhwZWN0IEJPTS4gVGhlcmUsIGl0IGlzIHRyZWF0ZWQgYXMgYSBsaXRlcmFsIEdJRCAoR2x5cGggSUQpXG4gICAgICAgKlxuICAgICAgICogQmVjYXVzZSBvZiBBZG9iZSdzIGZvY3VzIG9uIFwieW91IHN1YnNldCB5b3VyIGZvbnRzIVwiIHlvdSBhcmUgbm90IHN1cHBvc2VkIHRvIGhhdmVcbiAgICAgICAqIGEgZm9udCB0aGF0IG1hcHMgZGlyZWN0bHkgVW5pY29kZSAoVUNTMiAvIFVURjE2QkUpIGNvZGUgdG8gZm9udCBHSUQsIGJ1dCB5b3UgY291bGRcbiAgICAgICAqIGZ1ZGdlIGl0IHdpdGggXCJJZGVudGl0eS1IXCIgZW5jb2RpbmcgYW5kIGN1c3RvbSBDSUR0b0dJRCBtYXAgdGhhdCBtaW1pY3MgVW5pY29kZVxuICAgICAgICogY29kZSBwYWdlLiBUaGVyZSwgaG93ZXZlciwgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmVhbSBhcmUgdHJlYXRlZCBhcyBHSURzLFxuICAgICAgICogaW5jbHVkaW5nIEJPTSwgd2hpY2ggaXMgdGhlIHJlYXNvbiB3ZSBuZWVkIHRvIHNraXAgQk9NIGluIGNvbnRlbnQgdGV4dCAoaS5lLiB0aGF0XG4gICAgICAgKiB0aGF0IGlzIHRpZWQgdG8gYSBmb250KS5cbiAgICAgICAqXG4gICAgICAgKiBUbyBzaWduYWwgdGhpcyBcInNwZWNpYWxcIiBQREZFc2NhcGUgLyB0bzhiaXRTdHJlYW0gaGFuZGxpbmcgbW9kZSxcbiAgICAgICAqIEFQSS50ZXh0KCkgZnVuY3Rpb24gc2V0cyAodW5sZXNzIHlvdSBvdmVyd3JpdGUgaXQgd2l0aCBtYW51YWwgdmFsdWVzXG4gICAgICAgKiBnaXZlbiB0byBBUEkudGV4dCguLiwgZmxhZ3MpIClcbiAgICAgICAqIGZsYWdzLmF1dG9lbmNvZGUgPSB0cnVlXG4gICAgICAgKiBmbGFncy5ub0JPTSA9IHRydWVcbiAgICAgICAqXG4gICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICogYGZsYWdzYCBwcm9wZXJ0aWVzIHJlbGllZCB1cG9uOlxuICAgICAgICogICAuc291cmNlRW5jb2RpbmcgPSBzdHJpbmcgd2l0aCBlbmNvZGluZyBsYWJlbC5cbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgXCJVbmljb2RlXCIgYnkgZGVmYXVsdC4gPSBlbmNvZGluZyBvZiB0aGUgaW5jb21pbmcgdGV4dC5cbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgcGFzcyBzb21lIG5vbi1leGlzdGluZyBlbmNvZGluZyBuYW1lXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgIChleDogJ0RvIG5vdCB0b3VjaCBteSBzdHJpbmdzISBJIGtub3cgd2hhdCBJIGFtIGRvaW5nLicpXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgIHRvIG1ha2UgZW5jb2RpbmcgY29kZSBza2lwIHRoZSBlbmNvZGluZyBzdGVwLlxuICAgICAgICogICAub3V0cHV0RW5jb2RpbmcgPSBFaXRoZXIgdmFsaWQgUERGIGVuY29kaW5nIG5hbWVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgKG11c3QgYmUgc3VwcG9ydGVkIGJ5IGpzUERGIGZvbnQgbWV0cmljcywgb3RoZXJ3aXNlIG5vIGVuY29kaW5nKVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICBvciBhIEpTIG9iamVjdCwgd2hlcmUga2V5ID0gc291cmNlQ2hhckNvZGUsIHZhbHVlID0gb3V0cHV0Q2hhckNvZGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgbWlzc2luZyBrZXlzIHdpbGwgYmUgdHJlYXRlZCBhczogc291cmNlQ2hhckNvZGUgPT09IG91dHB1dENoYXJDb2RlXG4gICAgICAgKiAgIC5ub0JPTVxuICAgICAgICogICAgICAgU2VlIGNvbW1lbnQgaGlnaGVyIGFib3ZlIGZvciBleHBsYW5hdGlvbiBmb3Igd2h5IHRoaXMgaXMgaW1wb3J0YW50XG4gICAgICAgKiAgIC5hdXRvZW5jb2RlXG4gICAgICAgKiAgICAgICBTZWUgY29tbWVudCBoaWdoZXIgYWJvdmUgZm9yIGV4cGxhbmF0aW9uIGZvciB3aHkgdGhpcyBpcyBpbXBvcnRhbnRcbiAgICAgICAqL1xuICAgICAgdmFyIGksIGwsIHNvdXJjZUVuY29kaW5nLCBlbmNvZGluZ0Jsb2NrLCBvdXRwdXRFbmNvZGluZywgbmV3dGV4dCwgaXNVbmljb2RlLCBjaCwgYmNoO1xuICAgICAgZmxhZ3MgPSBmbGFncyB8fCB7fTtcbiAgICAgIHNvdXJjZUVuY29kaW5nID0gZmxhZ3Muc291cmNlRW5jb2RpbmcgfHwgJ1VuaWNvZGUnO1xuICAgICAgb3V0cHV0RW5jb2RpbmcgPSBmbGFncy5vdXRwdXRFbmNvZGluZzsgLy8gVGhpcyAnZW5jb2RpbmcnIHNlY3Rpb24gcmVsaWVzIG9uIGZvbnQgbWV0cmljcyBmb3JtYXRcbiAgICAgIC8vIGF0dGFjaGVkIHRvIGZvbnQgb2JqZWN0cyBieSwgYW1vbmcgb3RoZXJzLFxuICAgICAgLy8gXCJXaWxsb3cgU3lzdGVtcycgc3RhbmRhcmRfZm9udF9tZXRyaWNzIHBsdWdpblwiXG4gICAgICAvLyBzZWUganNwZGYucGx1Z2luLnN0YW5kYXJkX2ZvbnRfbWV0cmljcy5qcyBmb3IgZm9ybWF0XG4gICAgICAvLyBvZiB0aGUgZm9udC5tZXRhZGF0YS5lbmNvZGluZyBPYmplY3QuXG4gICAgICAvLyBJdCBzaG91bGQgYmUgc29tZXRoaW5nIGxpa2VcbiAgICAgIC8vICAgLmVuY29kaW5nID0geydjb2RlUGFnZXMnOlsnV2luQU5TSS4uLi4nXSwgJ1dpbkFOU0kuLi4nOntjb2RlOmNvZGUsIC4uLn19XG4gICAgICAvLyAgIC53aWR0aHMgPSB7MDp3aWR0aCwgY29kZTp3aWR0aCwgLi4uLCAnZm9mJzpkaXZpc29yfVxuICAgICAgLy8gICAua2VybmluZyA9IHtjb2RlOntwcmV2aW91c19jaGFyX2NvZGU6c2hpZnQsIC4uLiwgJ2ZvZic6LWRpdmlzb3J9LC4uLn1cblxuICAgICAgaWYgKChmbGFncy5hdXRvZW5jb2RlIHx8IG91dHB1dEVuY29kaW5nKSAmJiBmb250c1thY3RpdmVGb250S2V5XS5tZXRhZGF0YSAmJiBmb250c1thY3RpdmVGb250S2V5XS5tZXRhZGF0YVtzb3VyY2VFbmNvZGluZ10gJiYgZm9udHNbYWN0aXZlRm9udEtleV0ubWV0YWRhdGFbc291cmNlRW5jb2RpbmddLmVuY29kaW5nKSB7XG4gICAgICAgIGVuY29kaW5nQmxvY2sgPSBmb250c1thY3RpdmVGb250S2V5XS5tZXRhZGF0YVtzb3VyY2VFbmNvZGluZ10uZW5jb2Rpbmc7IC8vIGVhY2ggZm9udCBoYXMgZGVmYXVsdCBlbmNvZGluZy4gU29tZSBoYXZlIGl0IGNsZWFybHkgZGVmaW5lZC5cblxuICAgICAgICBpZiAoIW91dHB1dEVuY29kaW5nICYmIGZvbnRzW2FjdGl2ZUZvbnRLZXldLmVuY29kaW5nKSB7XG4gICAgICAgICAgb3V0cHV0RW5jb2RpbmcgPSBmb250c1thY3RpdmVGb250S2V5XS5lbmNvZGluZztcbiAgICAgICAgfSAvLyBIbW1tLCB0aGUgYWJvdmUgZGlkIG5vdCB3b3JrPyBMZXQncyB0cnkgYWdhaW4sIGluIGRpZmZlcmVudCBwbGFjZS5cblxuXG4gICAgICAgIGlmICghb3V0cHV0RW5jb2RpbmcgJiYgZW5jb2RpbmdCbG9jay5jb2RlUGFnZXMpIHtcbiAgICAgICAgICBvdXRwdXRFbmNvZGluZyA9IGVuY29kaW5nQmxvY2suY29kZVBhZ2VzWzBdOyAvLyBsZXQncyBzYXksIGZpcnN0IG9uZSBpcyB0aGUgZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXRFbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBvdXRwdXRFbmNvZGluZyA9IGVuY29kaW5nQmxvY2tbb3V0cHV0RW5jb2RpbmddO1xuICAgICAgICB9IC8vIHdlIHdhbnQgb3V0cHV0IGVuY29kaW5nIHRvIGJlIGEgSlMgT2JqZWN0LCB3aGVyZVxuICAgICAgICAvLyBrZXkgPSBzb3VyY2VFbmNvZGluZydzIGNoYXJhY3RlciBjb2RlIGFuZFxuICAgICAgICAvLyB2YWx1ZSA9IG91dHB1dEVuY29kaW5nJ3MgY2hhcmFjdGVyIGNvZGUuXG5cblxuICAgICAgICBpZiAob3V0cHV0RW5jb2RpbmcpIHtcbiAgICAgICAgICBpc1VuaWNvZGUgPSBmYWxzZTtcbiAgICAgICAgICBuZXd0ZXh0ID0gW107XG5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNoID0gb3V0cHV0RW5jb2RpbmdbdGV4dC5jaGFyQ29kZUF0KGkpXTtcblxuICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgIG5ld3RleHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXd0ZXh0LnB1c2godGV4dFtpXSk7XG4gICAgICAgICAgICB9IC8vIHNpbmNlIHdlIGFyZSBsb29waW5nIG92ZXIgY2hhcnMgYW55d2F5LCBtaWdodCBhcyB3ZWxsXG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgcmVzaWR1YWwgdW5pY29kZW5lc3NcblxuXG4gICAgICAgICAgICBpZiAobmV3dGV4dFtpXS5jaGFyQ29kZUF0KDApID4+IDgpIHtcbiAgICAgICAgICAgICAgLyogbW9yZSB0aGFuIDI1NSAqL1xuICAgICAgICAgICAgICBpc1VuaWNvZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRleHQgPSBuZXd0ZXh0LmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkgPSB0ZXh0Lmxlbmd0aDsgLy8gaXNVbmljb2RlIG1heSBiZSBzZXQgdG8gZmFsc2UgYWJvdmUuIEhlbmNlIHRoZSB0cmlwbGUtZXF1YWwgdG8gdW5kZWZpbmVkXG5cbiAgICAgIHdoaWxlIChpc1VuaWNvZGUgPT09IHVuZGVmaW5lZCAmJiBpICE9PSAwKSB7XG4gICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSAtIDEpID4+IDgpIHtcbiAgICAgICAgICAvKiBtb3JlIHRoYW4gMjU1ICovXG4gICAgICAgICAgaXNVbmljb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGktLTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1VuaWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG5cbiAgICAgIG5ld3RleHQgPSBmbGFncy5ub0JPTSA/IFtdIDogWzI1NCwgMjU1XTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IHRleHQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBiY2ggPSBjaCA+PiA4OyAvLyBkaXZpZGUgYnkgMjU2XG5cbiAgICAgICAgaWYgKGJjaCA+PiA4KSB7XG4gICAgICAgICAgLyogc29tZXRoaW5nIGxlZnQgYWZ0ZXIgZGl2aWRpbmcgYnkgMjU2IHNlY29uZCB0aW1lICovXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIFwiICsgaSArIFwiIG9mIHN0cmluZyAnXCIgKyB0ZXh0ICsgXCInIGV4Y2VlZHMgMTZiaXRzLiBDYW5ub3QgYmUgZW5jb2RlZCBpbnRvIFVDUy0yIEJFXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3dGV4dC5wdXNoKGJjaCk7XG4gICAgICAgIG5ld3RleHQucHVzaChjaCAtIChiY2ggPDwgOCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSh1bmRlZmluZWQsIG5ld3RleHQpO1xuICAgIH07XG5cbiAgICB2YXIgcGRmRXNjYXBlID0gQVBJLl9fcHJpdmF0ZV9fLnBkZkVzY2FwZSA9IEFQSS5wZGZFc2NhcGUgPSBmdW5jdGlvbiAodGV4dCwgZmxhZ3MpIHtcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSAnLycsICcoJywgYW5kICcpJyB3aXRoIHBkZi1zYWZlIHZlcnNpb25zXG4gICAgICAgKlxuICAgICAgICogRG9pbmcgdG84Yml0U3RyZWFtIGRvZXMgTk9UIG1ha2UgdGhpcyBQREYgZGlzcGxheSB1bmljb2RlIHRleHQuIEZvciB0aGF0XG4gICAgICAgKiB3ZSBhbHNvIG5lZWQgdG8gcmVmZXJlbmNlIGEgdW5pY29kZSBmb250IGFuZCBlbWJlZCBpdCAtIHJveWFsIHBhaW4gaW4gdGhlIHJlYXIuXG4gICAgICAgKlxuICAgICAgICogVGhlcmUgaXMgc3RpbGwgYSBiZW5lZml0IHRvIHRvOGJpdFN0cmVhbSAtIFBERiBzaW1wbHkgY2Fubm90IGhhbmRsZSAxNmJpdCBjaGFycyxcbiAgICAgICAqIHdoaWNoIEphdmFTY3JpcHQgU3RyaW5ncyBhcmUgaGFwcHkgdG8gcHJvdmlkZS4gU28sIHdoaWxlIHdlIHN0aWxsIGNhbm5vdCBkaXNwbGF5XG4gICAgICAgKiAyLWJ5dGUgY2hhcmFjdGVycyBwcm9wZXJ0eSwgYXQgbGVhc3QgQ09ORElUSU9OQUxMWSBjb252ZXJ0aW5nIChlbnRpcmUgc3RyaW5nIGNvbnRhaW5pbmcpXG4gICAgICAgKiAxNmJpdCBjaGFycyB0byAoVVNDLTItQkUpIDItYnl0ZXMgcGVyIGNoYXIgKyBCT00gc3RyZWFtcyB3ZSBlbnN1cmUgdGhhdCBlbnRpcmUgUERGXG4gICAgICAgKiBpcyBzdGlsbCBwYXJzZWFibGUuXG4gICAgICAgKiBUaGlzIHdpbGwgYWxsb3cgaW1tZWRpYXRlIHN1cHBvcnQgZm9yIHVuaWNvZGUgaW4gZG9jdW1lbnQgcHJvcGVydGllcyBzdHJpbmdzLlxuICAgICAgICovXG4gICAgICByZXR1cm4gdG84Yml0U3RyZWFtKHRleHQsIGZsYWdzKS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1xcKC9nLCAnXFxcXCgnKS5yZXBsYWNlKC9cXCkvZywgJ1xcXFwpJyk7XG4gICAgfTtcblxuICAgIHZhciBiZWdpblBhZ2UgPSBBUEkuX19wcml2YXRlX18uYmVnaW5QYWdlID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciB0bXA7IC8vIERpbWVuc2lvbnMgYXJlIHN0b3JlZCBhcyB1c2VyIHVuaXRzIGFuZCBjb252ZXJ0ZWQgdG8gcG9pbnRzIG9uIG91dHB1dFxuXG4gICAgICB2YXIgb3JpZW50YXRpb24gPSB0eXBlb2YgaGVpZ2h0ID09PSAnc3RyaW5nJyAmJiBoZWlnaHQudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKHR5cGVvZiB3aWR0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRtcCA9IGdldFBhZ2VGb3JtYXQod2lkdGgudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICB3aWR0aCA9IHRtcFswXTtcbiAgICAgICAgICBoZWlnaHQgPSB0bXBbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkod2lkdGgpKSB7XG4gICAgICAgIGhlaWdodCA9IHdpZHRoWzFdO1xuICAgICAgICB3aWR0aCA9IHdpZHRoWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOYU4od2lkdGgpIHx8IGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgd2lkdGggPSBmb3JtYXRbMF07XG4gICAgICAgIGhlaWdodCA9IGZvcm1hdFsxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9yaWVudGF0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAob3JpZW50YXRpb24uc3Vic3RyKDAsIDEpKSB7XG4gICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ID4gd2lkdGgpIG9yaWVudGF0aW9uID0gJ3MnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIGlmICh3aWR0aCA+IGhlaWdodCkgb3JpZW50YXRpb24gPSAncyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ3MnKSB7XG4gICAgICAgICAgdG1wID0gd2lkdGg7XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQ7XG4gICAgICAgICAgaGVpZ2h0ID0gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3aWR0aCA+IDE0NDAwIHx8IGhlaWdodCA+IDE0NDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQSBwYWdlIGluIGEgUERGIGNhbiBub3QgYmUgd2lkZXIgb3IgdGFsbGVyIHRoYW4gMTQ0MDAgdXNlclVuaXQuIGpzUERGIGxpbWl0cyB0aGUgd2lkdGgvaGVpZ2h0IHRvIDE0NDAwJyk7XG4gICAgICAgIHdpZHRoID0gTWF0aC5taW4oMTQ0MDAsIHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5taW4oMTQ0MDAsIGhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGZvcm1hdCA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIG91dFRvUGFnZXMgPSB0cnVlO1xuICAgICAgcGFnZXNbKytwYWdlXSA9IFtdO1xuICAgICAgcGFnZXNDb250ZXh0W3BhZ2VdID0ge1xuICAgICAgICBvYmpJZDogMCxcbiAgICAgICAgY29udGVudHNPYmpJZDogMCxcbiAgICAgICAgdXNlclVuaXQ6IE51bWJlcih1c2VyVW5pdCksXG4gICAgICAgIGFydEJveDogbnVsbCxcbiAgICAgICAgYmxlZWRCb3g6IG51bGwsXG4gICAgICAgIGNyb3BCb3g6IG51bGwsXG4gICAgICAgIHRyaW1Cb3g6IG51bGwsXG4gICAgICAgIG1lZGlhQm94OiB7XG4gICAgICAgICAgYm90dG9tTGVmdFg6IDAsXG4gICAgICAgICAgYm90dG9tTGVmdFk6IDAsXG4gICAgICAgICAgdG9wUmlnaHRYOiBOdW1iZXIod2lkdGgpLFxuICAgICAgICAgIHRvcFJpZ2h0WTogTnVtYmVyKGhlaWdodClcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3NldFBhZ2UocGFnZSk7XG4gICAgfTtcblxuICAgIHZhciBfYWRkUGFnZSA9IGZ1bmN0aW9uIF9hZGRQYWdlKCkge1xuICAgICAgYmVnaW5QYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFNldCBsaW5lIHdpZHRoXG5cbiAgICAgIHNldExpbmVXaWR0aChsaW5lV2lkdGgpOyAvLyBTZXQgZHJhdyBjb2xvclxuXG4gICAgICBvdXQoc3Ryb2tlQ29sb3IpOyAvLyByZXN1cnJlY3Rpbmcgbm9uLWRlZmF1bHQgbGluZSBjYXBzLCBqb2luc1xuXG4gICAgICBpZiAobGluZUNhcElEICE9PSAwKSB7XG4gICAgICAgIG91dChsaW5lQ2FwSUQgKyAnIEonKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmVKb2luSUQgIT09IDApIHtcbiAgICAgICAgb3V0KGxpbmVKb2luSUQgKyAnIGonKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzLnB1Ymxpc2goJ2FkZFBhZ2UnLCB7XG4gICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgX2RlbGV0ZVBhZ2UgPSBmdW5jdGlvbiBfZGVsZXRlUGFnZShuKSB7XG4gICAgICBpZiAobiA+IDAgJiYgbiA8PSBwYWdlKSB7XG4gICAgICAgIHBhZ2VzLnNwbGljZShuLCAxKTtcbiAgICAgICAgcGFnZS0tO1xuXG4gICAgICAgIGlmIChjdXJyZW50UGFnZSA+IHBhZ2UpIHtcbiAgICAgICAgICBjdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFBhZ2UoY3VycmVudFBhZ2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX3NldFBhZ2UgPSBmdW5jdGlvbiBfc2V0UGFnZShuKSB7XG4gICAgICBpZiAobiA+IDAgJiYgbiA8PSBwYWdlKSB7XG4gICAgICAgIGN1cnJlbnRQYWdlID0gbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldE51bWJlck9mUGFnZXMgPSBBUEkuX19wcml2YXRlX18uZ2V0TnVtYmVyT2ZQYWdlcyA9IEFQSS5nZXROdW1iZXJPZlBhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhZ2VzLmxlbmd0aCAtIDE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZG9jdW1lbnQtc3BlY2lmaWMgZm9udCBrZXkgLSBhIGxhYmVsIGFzc2lnbmVkIHRvIGFcbiAgICAgKiBmb250IG5hbWUgKyBmb250IHR5cGUgY29tYmluYXRpb24gYXQgdGhlIHRpbWUgdGhlIGZvbnQgd2FzIGFkZGVkXG4gICAgICogdG8gdGhlIGZvbnQgaW52ZW50b3J5LlxuICAgICAqXG4gICAgICogRm9udCBrZXkgaXMgdXNlZCBhcyBsYWJlbCBmb3IgdGhlIGRlc2lyZWQgZm9udCBmb3IgYSBibG9jayBvZiB0ZXh0XG4gICAgICogdG8gYmUgYWRkZWQgdG8gdGhlIFBERiBkb2N1bWVudCBzdHJlYW0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gZm9udE5hbWUge3N0cmluZ30gY2FuIGJlIHVuZGVmaW5lZCBvbiBcImZhbHRoeVwiIHRvIGluZGljYXRlIFwidXNlIGN1cnJlbnRcIlxuICAgICAqIEBwYXJhbSBmb250U3R5bGUge3N0cmluZ30gY2FuIGJlIHVuZGVmaW5lZCBvbiBcImZhbHRoeVwiIHRvIGluZGljYXRlIFwidXNlIGN1cnJlbnRcIlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEZvbnQga2V5LlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9nZXRGb250ID0gZnVuY3Rpb24gZ2V0Rm9udChmb250TmFtZSwgZm9udFN0eWxlLCBvcHRpb25zKSB7XG4gICAgICB2YXIga2V5ID0gdW5kZWZpbmVkLFxuICAgICAgICAgIGZvbnROYW1lTG93ZXJDYXNlO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBmb250TmFtZSA9IGZvbnROYW1lICE9PSB1bmRlZmluZWQgPyBmb250TmFtZSA6IGZvbnRzW2FjdGl2ZUZvbnRLZXldLmZvbnROYW1lO1xuICAgICAgZm9udFN0eWxlID0gZm9udFN0eWxlICE9PSB1bmRlZmluZWQgPyBmb250U3R5bGUgOiBmb250c1thY3RpdmVGb250S2V5XS5mb250U3R5bGU7XG4gICAgICBmb250TmFtZUxvd2VyQ2FzZSA9IGZvbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChmb250bWFwW2ZvbnROYW1lTG93ZXJDYXNlXSAhPT0gdW5kZWZpbmVkICYmIGZvbnRtYXBbZm9udE5hbWVMb3dlckNhc2VdW2ZvbnRTdHlsZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXkgPSBmb250bWFwW2ZvbnROYW1lTG93ZXJDYXNlXVtmb250U3R5bGVdO1xuICAgICAgfSBlbHNlIGlmIChmb250bWFwW2ZvbnROYW1lXSAhPT0gdW5kZWZpbmVkICYmIGZvbnRtYXBbZm9udE5hbWVdW2ZvbnRTdHlsZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXkgPSBmb250bWFwW2ZvbnROYW1lXVtmb250U3R5bGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZVdhcm5pbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIGxvb2sgdXAgZm9udCBsYWJlbCBmb3IgZm9udCAnXCIgKyBmb250TmFtZSArIFwiJywgJ1wiICsgZm9udFN0eWxlICsgXCInLiBSZWZlciB0byBnZXRGb250TGlzdCgpIGZvciBhdmFpbGFibGUgZm9udHMuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgha2V5ICYmICFvcHRpb25zLm5vRmFsbGJhY2spIHtcbiAgICAgICAga2V5ID0gZm9udG1hcFsndGltZXMnXVtmb250U3R5bGVdO1xuXG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgIGtleSA9IGZvbnRtYXBbJ3RpbWVzJ11bJ25vcm1hbCddO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcblxuICAgIHZhciBwdXRJbmZvID0gQVBJLl9fcHJpdmF0ZV9fLnB1dEluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBuZXdPYmplY3QoKTtcbiAgICAgIG91dCgnPDwnKTtcbiAgICAgIG91dCgnL1Byb2R1Y2VyIChqc1BERiAnICsganNQREYudmVyc2lvbiArICcpJyk7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBkb2N1bWVudFByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGRvY3VtZW50UHJvcGVydGllc1trZXldKSB7XG4gICAgICAgICAgb3V0KCcvJyArIGtleS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHIoMSkgKyAnICgnICsgcGRmRXNjYXBlKGRvY3VtZW50UHJvcGVydGllc1trZXldKSArICcpJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3V0KCcvQ3JlYXRpb25EYXRlICgnICsgY3JlYXRpb25EYXRlICsgJyknKTtcbiAgICAgIG91dCgnPj4nKTtcbiAgICAgIG91dCgnZW5kb2JqJyk7XG4gICAgfTtcblxuICAgIHZhciBwdXRDYXRhbG9nID0gQVBJLl9fcHJpdmF0ZV9fLnB1dENhdGFsb2cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgdG1wUm9vdERpY3Rpb25hcnlPYmpJZCA9IG9wdGlvbnMucm9vdERpY3Rpb25hcnlPYmpJZCB8fCByb290RGljdGlvbmFyeU9iaklkO1xuICAgICAgbmV3T2JqZWN0KCk7XG4gICAgICBvdXQoJzw8Jyk7XG4gICAgICBvdXQoJy9UeXBlIC9DYXRhbG9nJyk7XG4gICAgICBvdXQoJy9QYWdlcyAnICsgdG1wUm9vdERpY3Rpb25hcnlPYmpJZCArICcgMCBSJyk7IC8vIFBERjEzcmVmIFNlY3Rpb24gNy4yLjFcblxuICAgICAgaWYgKCF6b29tTW9kZSkgem9vbU1vZGUgPSAnZnVsbHdpZHRoJztcblxuICAgICAgc3dpdGNoICh6b29tTW9kZSkge1xuICAgICAgICBjYXNlICdmdWxsd2lkdGgnOlxuICAgICAgICAgIG91dCgnL09wZW5BY3Rpb24gWzMgMCBSIC9GaXRIIG51bGxdJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZnVsbGhlaWdodCc6XG4gICAgICAgICAgb3V0KCcvT3BlbkFjdGlvbiBbMyAwIFIgL0ZpdFYgbnVsbF0nKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmdWxscGFnZSc6XG4gICAgICAgICAgb3V0KCcvT3BlbkFjdGlvbiBbMyAwIFIgL0ZpdF0nKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvcmlnaW5hbCc6XG4gICAgICAgICAgb3V0KCcvT3BlbkFjdGlvbiBbMyAwIFIgL1hZWiBudWxsIG51bGwgMV0nKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhciBwY24gPSAnJyArIHpvb21Nb2RlO1xuICAgICAgICAgIGlmIChwY24uc3Vic3RyKHBjbi5sZW5ndGggLSAxKSA9PT0gJyUnKSB6b29tTW9kZSA9IHBhcnNlSW50KHpvb21Nb2RlKSAvIDEwMDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygem9vbU1vZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvdXQoJy9PcGVuQWN0aW9uIFszIDAgUiAvWFlaIG51bGwgbnVsbCAnICsgZjIoem9vbU1vZGUpICsgJ10nKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCFsYXlvdXRNb2RlKSBsYXlvdXRNb2RlID0gJ2NvbnRpbnVvdXMnO1xuXG4gICAgICBzd2l0Y2ggKGxheW91dE1vZGUpIHtcbiAgICAgICAgY2FzZSAnY29udGludW91cyc6XG4gICAgICAgICAgb3V0KCcvUGFnZUxheW91dCAvT25lQ29sdW1uJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICBvdXQoJy9QYWdlTGF5b3V0IC9TaW5nbGVQYWdlJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndHdvJzpcbiAgICAgICAgY2FzZSAndHdvbGVmdCc6XG4gICAgICAgICAgb3V0KCcvUGFnZUxheW91dCAvVHdvQ29sdW1uTGVmdCcpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3R3b3JpZ2h0JzpcbiAgICAgICAgICBvdXQoJy9QYWdlTGF5b3V0IC9Ud29Db2x1bW5SaWdodCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZU1vZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbmFtZSBvYmplY3Qgc3BlY2lmeWluZyBob3cgdGhlIGRvY3VtZW50IHNob3VsZCBiZSBkaXNwbGF5ZWQgd2hlbiBvcGVuZWQ6XG4gICAgICAgICAqIFVzZU5vbmUgICAgICA6IE5laXRoZXIgZG9jdW1lbnQgb3V0bGluZSBub3IgdGh1bWJuYWlsIGltYWdlcyB2aXNpYmxlIC0tIERFRkFVTFRcbiAgICAgICAgICogVXNlT3V0bGluZXMgIDogRG9jdW1lbnQgb3V0bGluZSB2aXNpYmxlXG4gICAgICAgICAqIFVzZVRodW1icyAgICA6IFRodW1ibmFpbCBpbWFnZXMgdmlzaWJsZVxuICAgICAgICAgKiBGdWxsU2NyZWVuICAgOiBGdWxsLXNjcmVlbiBtb2RlLCB3aXRoIG5vIG1lbnUgYmFyLCB3aW5kb3cgY29udHJvbHMsIG9yIGFueSBvdGhlciB3aW5kb3cgdmlzaWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgb3V0KCcvUGFnZU1vZGUgLycgKyBwYWdlTW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5wdWJsaXNoKCdwdXRDYXRhbG9nJyk7XG4gICAgICBvdXQoJz4+Jyk7XG4gICAgICBvdXQoJ2VuZG9iaicpO1xuICAgIH07XG5cbiAgICB2YXIgcHV0VHJhaWxlciA9IEFQSS5fX3ByaXZhdGVfXy5wdXRUcmFpbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgb3V0KCd0cmFpbGVyJyk7XG4gICAgICBvdXQoJzw8Jyk7XG4gICAgICBvdXQoJy9TaXplICcgKyAob2JqZWN0TnVtYmVyICsgMSkpO1xuICAgICAgb3V0KCcvUm9vdCAnICsgb2JqZWN0TnVtYmVyICsgJyAwIFInKTtcbiAgICAgIG91dCgnL0luZm8gJyArIChvYmplY3ROdW1iZXIgLSAxKSArICcgMCBSJyk7XG4gICAgICBvdXQoXCIvSUQgWyA8XCIgKyBmaWxlSWQgKyBcIj4gPFwiICsgZmlsZUlkICsgXCI+IF1cIik7XG4gICAgICBvdXQoJz4+Jyk7XG4gICAgfTtcblxuICAgIHZhciBwdXRIZWFkZXIgPSBBUEkuX19wcml2YXRlX18ucHV0SGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgb3V0KCclUERGLScgKyBwZGZWZXJzaW9uKTtcbiAgICAgIG91dChcIiVcXHhCQVxceERGXFx4QUNcXHhFMFwiKTtcbiAgICB9O1xuXG4gICAgdmFyIHB1dFhSZWYgPSBBUEkuX19wcml2YXRlX18ucHV0WFJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpID0gMTtcbiAgICAgIHZhciBwID0gXCIwMDAwMDAwMDAwXCI7XG4gICAgICBvdXQoJ3hyZWYnKTtcbiAgICAgIG91dCgnMCAnICsgKG9iamVjdE51bWJlciArIDEpKTtcbiAgICAgIG91dCgnMDAwMDAwMDAwMCA2NTUzNSBmICcpO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDw9IG9iamVjdE51bWJlcjsgaSsrKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRzW2ldO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb3V0KChwICsgb2Zmc2V0c1tpXSgpKS5zbGljZSgtMTApICsgJyAwMDAwMCBuICcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0c1tpXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgb3V0KChwICsgb2Zmc2V0c1tpXSkuc2xpY2UoLTEwKSArICcgMDAwMDAgbiAnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0KCcwMDAwMDAwMDAwIDAwMDAwIG4gJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBidWlsZERvY3VtZW50ID0gQVBJLl9fcHJpdmF0ZV9fLmJ1aWxkRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBvdXRUb1BhZ2VzID0gZmFsc2U7IC8vIHN3aXRjaGVzIG91dCgpIHRvIGNvbnRlbnRcbiAgICAgIC8vcmVzZXQgZmllbGRzIHJlbGV2YW50IGZvciBvYmplY3ROdW1iZXIgZ2VuZXJhdGlvbiBhbmQgeHJlZi5cblxuICAgICAgb2JqZWN0TnVtYmVyID0gMDtcbiAgICAgIGNvbnRlbnRfbGVuZ3RoID0gMDtcbiAgICAgIGNvbnRlbnQgPSBbXTtcbiAgICAgIG9mZnNldHMgPSBbXTtcbiAgICAgIGFkZGl0aW9uYWxPYmplY3RzID0gW107XG4gICAgICByb290RGljdGlvbmFyeU9iaklkID0gbmV3T2JqZWN0RGVmZXJyZWQoKTtcbiAgICAgIHJlc291cmNlRGljdGlvbmFyeU9iaklkID0gbmV3T2JqZWN0RGVmZXJyZWQoKTtcbiAgICAgIGV2ZW50cy5wdWJsaXNoKCdidWlsZERvY3VtZW50Jyk7XG4gICAgICBwdXRIZWFkZXIoKTtcbiAgICAgIHB1dFBhZ2VzKCk7XG4gICAgICBwdXRBZGRpdGlvbmFsT2JqZWN0cygpO1xuICAgICAgcHV0UmVzb3VyY2VzKCk7XG4gICAgICBwdXRJbmZvKCk7XG4gICAgICBwdXRDYXRhbG9nKCk7XG4gICAgICB2YXIgb2Zmc2V0T2ZYUmVmID0gY29udGVudF9sZW5ndGg7XG4gICAgICBwdXRYUmVmKCk7XG4gICAgICBwdXRUcmFpbGVyKCk7XG4gICAgICBvdXQoJ3N0YXJ0eHJlZicpO1xuICAgICAgb3V0KCcnICsgb2Zmc2V0T2ZYUmVmKTtcbiAgICAgIG91dCgnJSVFT0YnKTtcbiAgICAgIG91dFRvUGFnZXMgPSB0cnVlO1xuICAgICAgcmV0dXJuIGNvbnRlbnQuam9pbignXFxuJyk7XG4gICAgfTtcblxuICAgIHZhciBnZXRCbG9iID0gQVBJLl9fcHJpdmF0ZV9fLmdldEJsb2IgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBCbG9iKFtnZXRBcnJheUJ1ZmZlcihkYXRhKV0sIHtcbiAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIlxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIFBERiBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIElmIGB0eXBlYCBhcmd1bWVudCBpcyB1bmRlZmluZWQsIG91dHB1dCBpcyByYXcgYm9keSBvZiByZXN1bHRpbmcgUERGIHJldHVybmVkIGFzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgQSBzdHJpbmcgaWRlbnRpZnlpbmcgb25lIG9mIHRoZSBwb3NzaWJsZSBvdXRwdXQgdHlwZXMuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ2FycmF5YnVmZmVyJywgJ2Jsb2InLCAnYmxvYnVyaScvJ2Jsb2J1cmwnLCAnZGF0YXVyaXN0cmluZycvJ2RhdGF1cmxzdHJpbmcnLCAnZGF0YXVyaScvJ2RhdGF1cmwnLCAnZGF0YXVybG5ld3dpbmRvdycuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IHByb3ZpZGluZyBzb21lIGFkZGl0aW9uYWwgc2lnbmFsbGluZyB0byBQREYgZ2VuZXJhdG9yLiBQb3NzaWJsZSBvcHRpb25zIGFyZSAnZmlsZW5hbWUnLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIG91dHB1dFxuICAgICAqL1xuXG5cbiAgICB2YXIgb3V0cHV0ID0gQVBJLm91dHB1dCA9IEFQSS5fX3ByaXZhdGVfXy5vdXRwdXQgPSBTQUZFKGZ1bmN0aW9uIG91dHB1dCh0eXBlLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBwZGZEb2N1bWVudCA9IGJ1aWxkRG9jdW1lbnQoKTtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgZmlsZW5hbWU6IG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lIHx8ICdnZW5lcmF0ZWQucGRmJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgIHJldHVybiBwZGZEb2N1bWVudDtcblxuICAgICAgICBjYXNlICdzYXZlJzpcbiAgICAgICAgICBBUEkuc2F2ZShvcHRpb25zLmZpbGVuYW1lKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgcmV0dXJuIGdldEFycmF5QnVmZmVyKHBkZkRvY3VtZW50KTtcblxuICAgICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgICByZXR1cm4gZ2V0QmxvYihwZGZEb2N1bWVudCk7XG5cbiAgICAgICAgY2FzZSAnYmxvYnVyaSc6XG4gICAgICAgIGNhc2UgJ2Jsb2J1cmwnOlxuICAgICAgICAgIC8vIERldmVsb3BlciBpcyByZXNwb25zaWJsZSBvZiBjYWxsaW5nIHJldm9rZU9iamVjdFVSTFxuICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsLlVSTCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZ2xvYmFsLlVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbC5VUkwgJiYgZ2xvYmFsLlVSTC5jcmVhdGVPYmplY3RVUkwoZ2V0QmxvYihwZGZEb2N1bWVudCkpIHx8IHZvaWQgMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdibG9idXJsIGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBzeXN0ZW0sIGJlY2F1c2UgVVJMLmNyZWF0ZU9iamVjdFVSTCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3Nlci4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXRhdXJpc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnZGF0YXVybHN0cmluZyc6XG4gICAgICAgICAgcmV0dXJuICdkYXRhOmFwcGxpY2F0aW9uL3BkZjtmaWxlbmFtZT0nICsgb3B0aW9ucy5maWxlbmFtZSArICc7YmFzZTY0LCcgKyBidG9hKHBkZkRvY3VtZW50KTtcblxuICAgICAgICBjYXNlICdkYXRhdXJsbmV3d2luZG93JzpcbiAgICAgICAgICB2YXIgaHRtbEZvck5ld1dpbmRvdyA9ICc8aHRtbD4nICsgJzxzdHlsZT5odG1sLCBib2R5IHsgcGFkZGluZzogMDsgbWFyZ2luOiAwOyB9IGlmcmFtZSB7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IGJvcmRlcjogMDt9ICA8L3N0eWxlPicgKyAnPGJvZHk+JyArICc8aWZyYW1lIHNyYz1cIicgKyB0aGlzLm91dHB1dCgnZGF0YXVyaXN0cmluZycpICsgJ1wiPjwvaWZyYW1lPicgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgICAgICAgIHZhciBuVyA9IGdsb2JhbC5vcGVuKCk7XG5cbiAgICAgICAgICBpZiAoblcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5XLmRvY3VtZW50LndyaXRlKGh0bWxGb3JOZXdXaW5kb3cpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuVyB8fCB0eXBlb2Ygc2FmYXJpID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gblc7XG5cbiAgICAgICAgLyogcGFzcyB0aHJvdWdoICovXG5cbiAgICAgICAgY2FzZSAnZGF0YXVyaSc6XG4gICAgICAgIGNhc2UgJ2RhdGF1cmwnOlxuICAgICAgICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9ICdkYXRhOmFwcGxpY2F0aW9uL3BkZjtmaWxlbmFtZT0nICsgb3B0aW9ucy5maWxlbmFtZSArICc7YmFzZTY0LCcgKyBidG9hKHBkZkRvY3VtZW50KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc2VlIGlmIGEgc3VwcGxpZWQgaG90Zml4IHdhcyByZXF1ZXN0ZWQgd2hlbiB0aGUgcGRmIGluc3RhbmNlIHdhcyBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBob3RmaXhOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGhvdGZpeCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIHZhciBoYXNIb3RmaXggPSBmdW5jdGlvbiBoYXNIb3RmaXgoaG90Zml4TmFtZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaG90Zml4ZXMpID09PSB0cnVlICYmIGhvdGZpeGVzLmluZGV4T2YoaG90Zml4TmFtZSkgPiAtMTtcbiAgICB9O1xuXG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICdwdCc6XG4gICAgICAgIGsgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbW0nOlxuICAgICAgICBrID0gNzIgLyAyNS40O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY20nOlxuICAgICAgICBrID0gNzIgLyAyLjU0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW4nOlxuICAgICAgICBrID0gNzI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdweCc6XG4gICAgICAgIGlmIChoYXNIb3RmaXgoJ3B4X3NjYWxpbmcnKSA9PSB0cnVlKSB7XG4gICAgICAgICAgayA9IDcyIC8gOTY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgayA9IDk2IC8gNzI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncGMnOlxuICAgICAgICBrID0gMTI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlbSc6XG4gICAgICAgIGsgPSAxMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2V4JzpcbiAgICAgICAgayA9IDY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5pdDogJyArIHVuaXQpO1xuICAgIH1cblxuICAgIHNldENyZWF0aW9uRGF0ZSgpO1xuICAgIHNldEZpbGVJZCgpOyAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFB1YmxpYyBBUElcblxuICAgIHZhciBnZXRQYWdlSW5mbyA9IEFQSS5fX3ByaXZhdGVfXy5nZXRQYWdlSW5mbyA9IGZ1bmN0aW9uIChwYWdlTnVtYmVyT25lQmFzZWQpIHtcbiAgICAgIGlmIChpc05hTihwYWdlTnVtYmVyT25lQmFzZWQpIHx8IHBhZ2VOdW1iZXJPbmVCYXNlZCAlIDEgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5nZXRQYWdlSW5mbycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqSWQgPSBwYWdlc0NvbnRleHRbcGFnZU51bWJlck9uZUJhc2VkXS5vYmpJZDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9iaklkOiBvYmpJZCxcbiAgICAgICAgcGFnZU51bWJlcjogcGFnZU51bWJlck9uZUJhc2VkLFxuICAgICAgICBwYWdlQ29udGV4dDogcGFnZXNDb250ZXh0W3BhZ2VOdW1iZXJPbmVCYXNlZF1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBnZXRQYWdlSW5mb0J5T2JqSWQgPSBBUEkuX19wcml2YXRlX18uZ2V0UGFnZUluZm9CeU9iaklkID0gZnVuY3Rpb24gKG9iaklkKSB7XG5cbiAgICAgIGZvciAodmFyIHBhZ2VOdW1iZXIgaW4gcGFnZXNDb250ZXh0KSB7XG4gICAgICAgIGlmIChwYWdlc0NvbnRleHRbcGFnZU51bWJlcl0ub2JqSWQgPT09IG9iaklkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTmFOKG9iaklkKSB8fCBvYmpJZCAlIDEgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5nZXRQYWdlSW5mb0J5T2JqSWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFBhZ2VJbmZvKHBhZ2VOdW1iZXIpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0Q3VycmVudFBhZ2VJbmZvID0gQVBJLl9fcHJpdmF0ZV9fLmdldEN1cnJlbnRQYWdlSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9iaklkOiBwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm9iaklkLFxuICAgICAgICBwYWdlTnVtYmVyOiBjdXJyZW50UGFnZSxcbiAgICAgICAgcGFnZUNvbnRleHQ6IHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV1cbiAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIChhbmQgdHJhbnNmZXJzIHRoZSBmb2N1cyB0bykgbmV3IHBhZ2UgdG8gdGhlIFBERiBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IHtTdHJpbmcvQXJyYXl9IFRoZSBmb3JtYXQgb2YgdGhlIG5ldyBwYWdlLiBDYW4gYmU6IDx1bD48bGk+YTAgLSBhMTA8L2xpPjxsaT5iMCAtIGIxMDwvbGk+PGxpPmMwIC0gYzEwPC9saT48bGk+ZGw8L2xpPjxsaT5sZXR0ZXI8L2xpPjxsaT5nb3Zlcm5tZW50LWxldHRlcjwvbGk+PGxpPmxlZ2FsPC9saT48bGk+anVuaW9yLWxlZ2FsPC9saT48bGk+bGVkZ2VyPC9saT48bGk+dGFibG9pZDwvbGk+PGxpPmNyZWRpdC1jYXJkPC9saT48L3VsPjxiciAvPlxuICAgICAqIERlZmF1bHQgaXMgXCJhNFwiLiBJZiB5b3Ugd2FudCB0byB1c2UgeW91ciBvd24gZm9ybWF0IGp1c3QgcGFzcyBpbnN0ZWFkIG9mIG9uZSBvZiB0aGUgYWJvdmUgcHJlZGVmaW5lZCBmb3JtYXRzIHRoZSBzaXplIGFzIGFuIG51bWJlci1hcnJheSwgZS5nLiBbNTk1LjI4LCA4NDEuODldXG4gICAgICogQHBhcmFtIG9yaWVudGF0aW9uIHtzdHJpbmd9IE9yaWVudGF0aW9uIG9mIHRoZSBuZXcgcGFnZS4gUG9zc2libGUgdmFsdWVzIGFyZSBcInBvcnRyYWl0XCIgb3IgXCJsYW5kc2NhcGVcIiAob3Igc2hvcnRjdXRzIFwicFwiIChEZWZhdWx0KSwgXCJsXCIpLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIGFkZFBhZ2VcbiAgICAgKi9cblxuXG4gICAgQVBJLmFkZFBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfYWRkUGFnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgKGFuZCB0cmFuc2ZlcnMgdGhlIGZvY3VzIHRvKSBuZXcgcGFnZSB0byB0aGUgUERGIGRvY3VtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIHNldFBhZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZSBTd2l0Y2ggdGhlIGFjdGl2ZSBwYWdlIHRvIHRoZSBwYWdlIG51bWJlciBzcGVjaWZpZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkb2MgPSBqc1BERigpXG4gICAgICogZG9jLmFkZFBhZ2UoKVxuICAgICAqIGRvYy5hZGRQYWdlKClcbiAgICAgKiBkb2MudGV4dCgnSSBhbSBvbiBwYWdlIDMnLCAxMCwgMTApXG4gICAgICogZG9jLnNldFBhZ2UoMSlcbiAgICAgKiBkb2MudGV4dCgnSSBhbSBvbiBwYWdlIDEnLCAxMCwgMTApXG4gICAgICovXG5cblxuICAgIEFQSS5zZXRQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3NldFBhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbmFtZSBpbnNlcnRQYWdlXG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogXG4gICAgICogQGZ1bmN0aW9uIFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZWZvcmVQYWdlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqL1xuXG5cbiAgICBBUEkuaW5zZXJ0UGFnZSA9IGZ1bmN0aW9uIChiZWZvcmVQYWdlKSB7XG4gICAgICB0aGlzLmFkZFBhZ2UoKTtcbiAgICAgIHRoaXMubW92ZVBhZ2UoY3VycmVudFBhZ2UsIGJlZm9yZVBhZ2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbmFtZSBtb3ZlUGFnZVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRQYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJlZm9yZVBhZ2VcbiAgICAgKiBAcmV0dXJucyB7anNQREZ9XG4gICAgICovXG5cblxuICAgIEFQSS5tb3ZlUGFnZSA9IGZ1bmN0aW9uICh0YXJnZXRQYWdlLCBiZWZvcmVQYWdlKSB7XG4gICAgICBpZiAodGFyZ2V0UGFnZSA+IGJlZm9yZVBhZ2UpIHtcbiAgICAgICAgdmFyIHRtcFBhZ2VzID0gcGFnZXNbdGFyZ2V0UGFnZV07XG4gICAgICAgIHZhciB0bXBQYWdlc0NvbnRleHQgPSBwYWdlc0NvbnRleHRbdGFyZ2V0UGFnZV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHRhcmdldFBhZ2U7IGkgPiBiZWZvcmVQYWdlOyBpLS0pIHtcbiAgICAgICAgICBwYWdlc1tpXSA9IHBhZ2VzW2kgLSAxXTtcbiAgICAgICAgICBwYWdlc0NvbnRleHRbaV0gPSBwYWdlc0NvbnRleHRbaSAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFnZXNbYmVmb3JlUGFnZV0gPSB0bXBQYWdlcztcbiAgICAgICAgcGFnZXNDb250ZXh0W2JlZm9yZVBhZ2VdID0gdG1wUGFnZXNDb250ZXh0O1xuICAgICAgICB0aGlzLnNldFBhZ2UoYmVmb3JlUGFnZSk7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldFBhZ2UgPCBiZWZvcmVQYWdlKSB7XG4gICAgICAgIHZhciB0bXBQYWdlcyA9IHBhZ2VzW3RhcmdldFBhZ2VdO1xuICAgICAgICB2YXIgdG1wUGFnZXNDb250ZXh0ID0gcGFnZXNDb250ZXh0W3RhcmdldFBhZ2VdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSB0YXJnZXRQYWdlOyBpIDwgYmVmb3JlUGFnZTsgaSsrKSB7XG4gICAgICAgICAgcGFnZXNbaV0gPSBwYWdlc1tpICsgMV07XG4gICAgICAgICAgcGFnZXNDb250ZXh0W2ldID0gcGFnZXNDb250ZXh0W2kgKyAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhZ2VzW2JlZm9yZVBhZ2VdID0gdG1wUGFnZXM7XG4gICAgICAgIHBhZ2VzQ29udGV4dFtiZWZvcmVQYWdlXSA9IHRtcFBhZ2VzQ29udGV4dDtcbiAgICAgICAgdGhpcy5zZXRQYWdlKGJlZm9yZVBhZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBwYWdlIGZyb20gdGhlIFBERi5cbiAgICAgKiBAbmFtZSBkZWxldGVQYWdlXG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqL1xuXG5cbiAgICBBUEkuZGVsZXRlUGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9kZWxldGVQYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyB0ZXh0IHRvIHBhZ2UuIFN1cHBvcnRzIGFkZGluZyBtdWx0aWxpbmUgdGV4dCB3aGVuICd0ZXh0JyBhcmd1bWVudCBpcyBhbiBBcnJheSBvZiBTdHJpbmdzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRleHQgU3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gYmUgYWRkZWQgdG8gdGhlIHBhZ2UuIEVhY2ggbGluZSBpcyBzaGlmdGVkIG9uZSBsaW5lIGRvd24gcGVyIGZvbnQsIHNwYWNpbmcgc2V0dGluZ3MgZGVjbGFyZWQgYmVmb3JlIHRoaXMgY2FsbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBDb29yZGluYXRlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KSBhZ2FpbnN0IGxlZnQgZWRnZSBvZiB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBDb29yZGluYXRlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KSBhZ2FpbnN0IHVwcGVyIGVkZ2Ugb2YgdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIENvbGxlY3Rpb24gb2Ygc2V0dGluZ3Mgc2lnbmFsaW5nIGhvdyB0aGUgdGV4dCBtdXN0IGJlIGVuY29kZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFsaWduPWxlZnRdIC0gVGhlIGFsaWdubWVudCBvZiB0aGUgdGV4dCwgcG9zc2libGUgdmFsdWVzOiBsZWZ0LCBjZW50ZXIsIHJpZ2h0LCBqdXN0aWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5iYXNlbGluZT1hbHBoYWJldGljXSAtIFNldHMgdGV4dCBiYXNlbGluZSB1c2VkIHdoZW4gZHJhd2luZyB0aGUgdGV4dCwgcG9zc2libGUgdmFsdWVzOiBhbHBoYWJldGljLCBpZGVvZ3JhcGhpYywgYm90dG9tLCB0b3AsIG1pZGRsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYW5nbGU9MF0gLSBSb3RhdGUgdGhlIHRleHQgY291bnRlcmNsb2Nrd2lzZS4gRXhwZWN0cyB0aGUgYW5nbGUgaW4gZGVncmVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jaGFyU3BhY2U9MF0gLSBUaGUgc3BhY2UgYmV0d2VlbiBlYWNoIGxldHRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGluZUhlaWdodEZhY3Rvcj0xLjE1XSAtIFRoZSBsaW5laGVpZ2h0IG9mIGVhY2ggbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmxhZ3NdIC0gRmxhZ3MgZm9yIHRvOGJpdFN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmxhZ3Mubm9CT009dHJ1ZV0gLSBEb24ndCBhZGQgQk9NIHRvIFVuaWNvZGUtdGV4dC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmxhZ3MuYXV0b2VuY29kZT10cnVlXSAtIEF1dG9lbmNvZGUgdGhlIFRleHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1heFdpZHRoPTBdIC0gU3BsaXQgdGhlIHRleHQgYnkgZ2l2ZW4gd2lkdGgsIDAgPSBubyBzcGxpdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVuZGVyaW5nTW9kZT1maWxsXSAtIFNldCBob3cgdGhlIHRleHQgc2hvdWxkIGJlIHJlbmRlcmVkLCBwb3NzaWJsZSB2YWx1ZXM6IGZpbGwsIHN0cm9rZSwgZmlsbFRoZW5TdHJva2UsIGludmlzaWJsZSwgZmlsbEFuZEFkZEZvckNsaXBwaW5nLCBzdHJva2VBbmRBZGRQYXRoRm9yQ2xpcHBpbmcsIGZpbGxUaGVuU3Ryb2tlQW5kQWRkVG9QYXRoRm9yQ2xpcHBpbmcsIGFkZFRvUGF0aEZvckNsaXBwaW5nLlxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSB0ZXh0XG4gICAgICovXG5cblxuICAgIHZhciB0ZXh0ID0gQVBJLl9fcHJpdmF0ZV9fLnRleHQgPSBBUEkudGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB4LCB5LCBvcHRpb25zKSB7XG4gICAgICAvKipcbiAgICAgICAqIEluc2VydHMgc29tZXRoaW5nIGxpa2UgdGhpcyBpbnRvIFBERlxuICAgICAgICogICBCVFxuICAgICAgICogICAgL0YxIDE2IFRmICAlIEZvbnQgbmFtZSArIHNpemVcbiAgICAgICAqICAgIDE2IFRMICUgSG93IG1hbnkgdW5pdHMgZG93biBmb3IgbmV4dCBsaW5lIGluIG11bHRpbGluZSB0ZXh0XG4gICAgICAgKiAgICAwIGcgJSBjb2xvclxuICAgICAgICogICAgMjguMzUgODEzLjU0IFRkICUgcG9zaXRpb25cbiAgICAgICAqICAgIChsaW5lIG9uZSkgVGpcbiAgICAgICAqICAgIFQqIChsaW5lIHR3bykgVGpcbiAgICAgICAqICAgIFQqIChsaW5lIHRocmVlKSBUalxuICAgICAgICogICBFVFxuICAgICAgICovXG4gICAgICAvL2JhY2t3YXJkc0NvbXBhdGliaWxpdHlcbiAgICAgIHZhciB0bXA7IC8vIFByZS1BdWd1c3QtMjAxMiB0aGUgb3JkZXIgb2YgYXJndW1lbnRzIHdhcyBmdW5jdGlvbih4LCB5LCB0ZXh0LCBmbGFncylcbiAgICAgIC8vIGluIGVmZm9ydCB0byBtYWtlIGFsbCBjYWxscyBoYXZlIHNpbWlsYXIgc2lnbmF0dXJlIGxpa2VcbiAgICAgIC8vICAgZnVuY3Rpb24oZGF0YSwgY29vcmRpbmF0ZXMuLi4gLCBtaXNjZWxsYW5lb3VzKVxuICAgICAgLy8gdGhpcyBtZXRob2QgaGFkIGl0cyBhcmdzIGZsaXBwZWQuXG4gICAgICAvLyBjb2RlIGJlbG93IGFsbG93cyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGFyZyBvcmRlci5cblxuICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgKHR5cGVvZiB5ID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHkpKSkge1xuICAgICAgICB0bXAgPSB5O1xuICAgICAgICB5ID0geDtcbiAgICAgICAgeCA9IHRleHQ7XG4gICAgICAgIHRleHQgPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50c1szXTtcbiAgICAgIHZhciBhbmdsZSA9IGFyZ3VtZW50c1s0XTtcbiAgICAgIHZhciBhbGlnbiA9IGFyZ3VtZW50c1s1XTtcblxuICAgICAgaWYgKF90eXBlb2YoZmxhZ3MpICE9PSBcIm9iamVjdFwiIHx8IGZsYWdzID09PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5nbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYWxpZ24gPSBhbmdsZTtcbiAgICAgICAgICBhbmdsZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZsYWdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFsaWduID0gZmxhZ3M7XG4gICAgICAgICAgZmxhZ3MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhbmdsZSA9IGZsYWdzO1xuICAgICAgICAgIGZsYWdzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICBhbGlnbjogYWxpZ25cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZmxhZ3MgPSBmbGFncyB8fCB7fTtcbiAgICAgIGZsYWdzLm5vQk9NID0gZmxhZ3Mubm9CT00gfHwgdHJ1ZTtcbiAgICAgIGZsYWdzLmF1dG9lbmNvZGUgPSBmbGFncy5hdXRvZW5jb2RlIHx8IHRydWU7XG5cbiAgICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSB8fCB0eXBlb2YgdGV4dCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLnRleHQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHh0cmEgPSAnJztcbiAgICAgIHZhciBpc0hleCA9IGZhbHNlO1xuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0eXBlb2Ygb3B0aW9ucy5saW5lSGVpZ2h0RmFjdG9yID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubGluZUhlaWdodEZhY3RvciA6IGxpbmVIZWlnaHRGYWN0b3I7XG4gICAgICB2YXIgc2NvcGUgPSBvcHRpb25zLnNjb3BlIHx8IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIEVTQyhzKSB7XG4gICAgICAgIHMgPSBzLnNwbGl0KFwiXFx0XCIpLmpvaW4oQXJyYXkob3B0aW9ucy5UYWJMZW4gfHwgOSkuam9pbihcIiBcIikpO1xuICAgICAgICByZXR1cm4gcGRmRXNjYXBlKHMsIGZsYWdzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtVGV4dFRvU3BlY2lhbEFycmF5KHRleHQpIHtcbiAgICAgICAgLy93ZSBkb24ndCB3YW50IHRvIGRlc3Ryb3kgb3JpZ2luYWwgdGV4dCBhcnJheSwgc28gY2xvbmluZyBpdFxuICAgICAgICB2YXIgc2EgPSB0ZXh0LmNvbmNhdCgpO1xuICAgICAgICB2YXIgZGEgPSBbXTtcbiAgICAgICAgdmFyIGxlbiA9IHNhLmxlbmd0aDtcbiAgICAgICAgdmFyIGN1ckRhOyAvL3dlIGRvIGFycmF5LmpvaW4oJ3RleHQgdGhhdCBtdXN0IG5vdCBiZSBQREZlc2NhcGVkXCIpXG4gICAgICAgIC8vdGh1cywgcGRmRXNjYXBlIGVhY2ggY29tcG9uZW50IHNlcGFyYXRlbHlcblxuICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICBjdXJEYSA9IHNhLnNoaWZ0KCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGN1ckRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkYS5wdXNoKGN1ckRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dCkgJiYgY3VyRGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIGRhLnB1c2goY3VyRGFbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGEucHVzaChbY3VyRGFbMF0sIGN1ckRhWzFdLCBjdXJEYVsyXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJvY2Vzc1RleHRCeUZ1bmN0aW9uKHRleHQsIHByb2Nlc3NpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXN1bHQgPSBwcm9jZXNzaW5nRnVuY3Rpb24odGV4dClbMF07XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0KSkge1xuICAgICAgICAgIC8vd2UgZG9uJ3Qgd2FudCB0byBkZXN0cm95IG9yaWdpbmFsIHRleHQgYXJyYXksIHNvIGNsb25pbmcgaXRcbiAgICAgICAgICB2YXIgc2EgPSB0ZXh0LmNvbmNhdCgpO1xuICAgICAgICAgIHZhciBkYSA9IFtdO1xuICAgICAgICAgIHZhciBsZW4gPSBzYS5sZW5ndGg7XG4gICAgICAgICAgdmFyIGN1ckRhO1xuICAgICAgICAgIHZhciB0bXBSZXN1bHQ7IC8vd2UgZG8gYXJyYXkuam9pbigndGV4dCB0aGF0IG11c3Qgbm90IGJlIFBERmVzY2FwZWRcIilcbiAgICAgICAgICAvL3RodXMsIHBkZkVzY2FwZSBlYWNoIGNvbXBvbmVudCBzZXBhcmF0ZWx5XG5cbiAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgIGN1ckRhID0gc2Euc2hpZnQoKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJEYSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBkYS5wdXNoKHByb2Nlc3NpbmdGdW5jdGlvbihjdXJEYSlbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1ckRhKSAmJiBjdXJEYVswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB0bXBSZXN1bHQgPSBwcm9jZXNzaW5nRnVuY3Rpb24oY3VyRGFbMF0sIGN1ckRhWzFdLCBjdXJEYVsyXSk7XG4gICAgICAgICAgICAgIGRhLnB1c2goW3RtcFJlc3VsdFswXSwgdG1wUmVzdWx0WzFdLCB0bXBSZXN1bHRbMl1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSBkYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IC8vQ2hlY2sgaWYgdGV4dCBpcyBvZiB0eXBlIFN0cmluZ1xuXG5cbiAgICAgIHZhciB0ZXh0SXNPZlR5cGVTdHJpbmcgPSBmYWxzZTtcbiAgICAgIHZhciB0bXBUZXh0SXNPZlR5cGVTdHJpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRleHRJc09mVHlwZVN0cmluZyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgLy93ZSBkb24ndCB3YW50IHRvIGRlc3Ryb3kgb3JpZ2luYWwgdGV4dCBhcnJheSwgc28gY2xvbmluZyBpdFxuICAgICAgICB2YXIgc2EgPSB0ZXh0LmNvbmNhdCgpO1xuICAgICAgICB2YXIgZGEgPSBbXTtcbiAgICAgICAgdmFyIGxlbiA9IHNhLmxlbmd0aDtcbiAgICAgICAgdmFyIGN1ckRhOyAvL3dlIGRvIGFycmF5LmpvaW4oJ3RleHQgdGhhdCBtdXN0IG5vdCBiZSBQREZlc2NhcGVkXCIpXG4gICAgICAgIC8vdGh1cywgcGRmRXNjYXBlIGVhY2ggY29tcG9uZW50IHNlcGFyYXRlbHlcblxuICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICBjdXJEYSA9IHNhLnNoaWZ0KCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGN1ckRhICE9PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoY3VyRGEpICYmIHR5cGVvZiBjdXJEYVswXSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdG1wVGV4dElzT2ZUeXBlU3RyaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGV4dElzT2ZUeXBlU3RyaW5nID0gdG1wVGV4dElzT2ZUeXBlU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dElzT2ZUeXBlU3RyaW5nID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgb2YgdGV4dCBtdXN0IGJlIHN0cmluZyBvciBBcnJheS4gXCInICsgdGV4dCArICdcIiBpcyBub3QgcmVjb2duaXplZC4nKTtcbiAgICAgIH0gLy9Fc2NhcGluZyBcblxuXG4gICAgICB2YXIgYWN0aXZlRm9udEVuY29kaW5nID0gZm9udHNbYWN0aXZlRm9udEtleV0uZW5jb2Rpbmc7XG5cbiAgICAgIGlmIChhY3RpdmVGb250RW5jb2RpbmcgPT09IFwiV2luQW5zaUVuY29kaW5nXCIgfHwgYWN0aXZlRm9udEVuY29kaW5nID09PSBcIlN0YW5kYXJkRW5jb2RpbmdcIikge1xuICAgICAgICB0ZXh0ID0gcHJvY2Vzc1RleHRCeUZ1bmN0aW9uKHRleHQsIGZ1bmN0aW9uICh0ZXh0LCBwb3NYLCBwb3NZKSB7XG4gICAgICAgICAgcmV0dXJuIFtFU0ModGV4dCksIHBvc1gsIHBvc1ldO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy9JZiB0aGVyZSBhcmUgYW55IG5ld2xpbmVzIGluIHRleHQsIHdlIGFzc3VtZVxuICAgICAgLy90aGUgdXNlciB3YW50ZWQgdG8gcHJpbnQgbXVsdGlwbGUgbGluZXMsIHNvIGJyZWFrIHRoZVxuICAgICAgLy90ZXh0IHVwIGludG8gYW4gYXJyYXkuIElmIHRoZSB0ZXh0IGlzIGFscmVhZHkgYW4gYXJyYXksXG4gICAgICAvL3dlIGFzc3VtZSB0aGUgdXNlciBrbm93cyB3aGF0IHRoZXkgYXJlIGRvaW5nLlxuICAgICAgLy9Db252ZXJ0IHRleHQgaW50byBhbiBhcnJheSBhbnl3YXkgdG8gc2ltcGxpZnlcbiAgICAgIC8vbGF0ZXIgY29kZS5cblxuXG4gICAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZXh0Lm1hdGNoKC9bXFxyP1xcbl0vKSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gW3RleHRdO1xuICAgICAgICB9XG4gICAgICB9IC8vYmFzZWxpbmVcblxuXG4gICAgICB2YXIgaGVpZ2h0ID0gYWN0aXZlRm9udFNpemUgLyBzY29wZS5pbnRlcm5hbC5zY2FsZUZhY3RvcjtcbiAgICAgIHZhciBkZXNjZW50ID0gaGVpZ2h0ICogKGxpbmVIZWlnaHRGYWN0b3IgLSAxKTtcblxuICAgICAgc3dpdGNoIChvcHRpb25zLmJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgeSAtPSBkZXNjZW50O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgeSArPSBoZWlnaHQgLSBkZXNjZW50O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hhbmdpbmcnOlxuICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gMiAqIGRlc2NlbnQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB5ICs9IGhlaWdodCAvIDIgLSBkZXNjZW50O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2lkZW9ncmFwaGljJzpcbiAgICAgICAgY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gZG8gbm90aGluZywgZXZlcnl0aGluZyBpcyBmaW5lXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vbXVsdGlsaW5lXG5cblxuICAgICAgdmFyIG1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aCB8fCAwO1xuXG4gICAgICBpZiAobWF4V2lkdGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0ZXh0ID0gc2NvcGUuc3BsaXRUZXh0VG9TaXplKHRleHQsIG1heFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGV4dCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICB0ZXh0ID0gc2NvcGUuc3BsaXRUZXh0VG9TaXplKHRleHQuam9pbihcIiBcIiksIG1heFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfSAvL2NyZWF0aW5nIFBheWxvYWQtT2JqZWN0IHRvIG1ha2UgdGV4dCBieVJlZlxuXG5cbiAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBtdXRleDoge1xuICAgICAgICAgIHBkZkVzY2FwZTogcGRmRXNjYXBlLFxuICAgICAgICAgIGFjdGl2ZUZvbnRLZXk6IGFjdGl2ZUZvbnRLZXksXG4gICAgICAgICAgZm9udHM6IGZvbnRzLFxuICAgICAgICAgIGFjdGl2ZUZvbnRTaXplOiBhY3RpdmVGb250U2l6ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXZlbnRzLnB1Ymxpc2goJ3ByZVByb2Nlc3NUZXh0JywgcGF5bG9hZCk7XG4gICAgICB0ZXh0ID0gcGF5bG9hZC50ZXh0O1xuICAgICAgb3B0aW9ucyA9IHBheWxvYWQub3B0aW9uczsgLy9hbmdsZVxuXG4gICAgICB2YXIgYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgdmFyIGsgPSBzY29wZS5pbnRlcm5hbC5zY2FsZUZhY3RvcjtcbiAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbk1hdHJpeCA9IFtdO1xuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgYW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbk1hdHJpeCA9IFtmMihjKSwgZjIocyksIGYyKHMgKiAtMSksIGYyKGMpXTtcbiAgICAgIH0gLy9jaGFyU3BhY2VcblxuXG4gICAgICB2YXIgY2hhclNwYWNlID0gb3B0aW9ucy5jaGFyU3BhY2U7XG5cbiAgICAgIGlmICh0eXBlb2YgY2hhclNwYWNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB4dHJhICs9IGYzKGNoYXJTcGFjZSAqIGspICsgXCIgVGNcXG5cIjtcbiAgICAgIH0gLy9sYW5nXG5cblxuICAgICAgdmFyIGxhbmcgPSBvcHRpb25zLmxhbmc7XG4gICAgICB2YXIgdG1wUmVuZGVyaW5nTW9kZSA9IC0xO1xuICAgICAgdmFyIHBhcm1SZW5kZXJpbmdNb2RlID0gdHlwZW9mIG9wdGlvbnMucmVuZGVyaW5nTW9kZSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMucmVuZGVyaW5nTW9kZSA6IG9wdGlvbnMuc3Ryb2tlO1xuICAgICAgdmFyIHBhZ2VDb250ZXh0ID0gc2NvcGUuaW50ZXJuYWwuZ2V0Q3VycmVudFBhZ2VJbmZvKCkucGFnZUNvbnRleHQ7XG5cbiAgICAgIHN3aXRjaCAocGFybVJlbmRlcmluZ01vZGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICBjYXNlICdmaWxsJzpcbiAgICAgICAgICB0bXBSZW5kZXJpbmdNb2RlID0gMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgY2FzZSAnc3Ryb2tlJzpcbiAgICAgICAgICB0bXBSZW5kZXJpbmdNb2RlID0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgJ2ZpbGxUaGVuU3Ryb2tlJzpcbiAgICAgICAgICB0bXBSZW5kZXJpbmdNb2RlID0gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgJ2ludmlzaWJsZSc6XG4gICAgICAgICAgdG1wUmVuZGVyaW5nTW9kZSA9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlICdmaWxsQW5kQWRkRm9yQ2xpcHBpbmcnOlxuICAgICAgICAgIHRtcFJlbmRlcmluZ01vZGUgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSAnc3Ryb2tlQW5kQWRkUGF0aEZvckNsaXBwaW5nJzpcbiAgICAgICAgICB0bXBSZW5kZXJpbmdNb2RlID0gNTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgJ2ZpbGxUaGVuU3Ryb2tlQW5kQWRkVG9QYXRoRm9yQ2xpcHBpbmcnOlxuICAgICAgICAgIHRtcFJlbmRlcmluZ01vZGUgPSA2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSAnYWRkVG9QYXRoRm9yQ2xpcHBpbmcnOlxuICAgICAgICAgIHRtcFJlbmRlcmluZ01vZGUgPSA3O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXNlZFJlbmRlcmluZ01vZGUgPSB0eXBlb2YgcGFnZUNvbnRleHQudXNlZFJlbmRlcmluZ01vZGUgIT09ICd1bmRlZmluZWQnID8gcGFnZUNvbnRleHQudXNlZFJlbmRlcmluZ01vZGUgOiAtMTsgLy9pZiB0aGUgY29kZXIgd3JvdGUgaXQgZXhwbGljaXRseSB0byB1c2UgYSBzcGVjaWZpYyBcbiAgICAgIC8vcmVuZGVyaW5nTW9kZSwgdGhlbiB1c2UgaXRcblxuICAgICAgaWYgKHRtcFJlbmRlcmluZ01vZGUgIT09IC0xKSB7XG4gICAgICAgIHh0cmEgKz0gdG1wUmVuZGVyaW5nTW9kZSArIFwiIFRyXFxuXCI7IC8vb3RoZXJ3aXNlIGNoZWNrIGlmIHdlIHVzZWQgdGhlIHJlbmRlcmluZyBNb2RlIGFscmVhZHlcbiAgICAgICAgLy9pZiBzbyB0aGVuIHNldCB0aGUgcmVuZGVyaW5nIE1vZGUuLi5cbiAgICAgIH0gZWxzZSBpZiAodXNlZFJlbmRlcmluZ01vZGUgIT09IC0xKSB7XG4gICAgICAgIHh0cmEgKz0gXCIwIFRyXFxuXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0bXBSZW5kZXJpbmdNb2RlICE9PSAtMSkge1xuICAgICAgICBwYWdlQ29udGV4dC51c2VkUmVuZGVyaW5nTW9kZSA9IHRtcFJlbmRlcmluZ01vZGU7XG4gICAgICB9IC8vYWxpZ25cblxuXG4gICAgICB2YXIgYWxpZ24gPSBvcHRpb25zLmFsaWduIHx8ICdsZWZ0JztcbiAgICAgIHZhciBsZWFkaW5nID0gYWN0aXZlRm9udFNpemUgKiBsaW5lSGVpZ2h0O1xuICAgICAgdmFyIHBhZ2VXaWR0aCA9IHNjb3BlLmludGVybmFsLnBhZ2VTaXplLmdldFdpZHRoKCk7XG4gICAgICB2YXIgayA9IHNjb3BlLmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgICAgdmFyIGFjdGl2ZUZvbnQgPSBmb250c1thY3RpdmVGb250S2V5XTtcbiAgICAgIHZhciBjaGFyU3BhY2UgPSBvcHRpb25zLmNoYXJTcGFjZSB8fCBhY3RpdmVDaGFyU3BhY2U7XG4gICAgICB2YXIgbWF4V2lkdGggPSBvcHRpb25zLm1heFdpZHRoIHx8IDA7XG4gICAgICB2YXIgbGluZVdpZHRocztcbiAgICAgIHZhciBmbGFncyA9IHt9O1xuICAgICAgdmFyIHdvcmRTcGFjaW5nUGVyTGluZSA9IFtdO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRleHQpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHZhciBkYSA9IHRyYW5zZm9ybVRleHRUb1NwZWNpYWxBcnJheSh0ZXh0KTtcbiAgICAgICAgdmFyIG5ld1k7XG4gICAgICAgIHZhciBtYXhMaW5lTGVuZ3RoO1xuICAgICAgICB2YXIgbGluZVdpZHRocztcblxuICAgICAgICBpZiAoYWxpZ24gIT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgbGluZVdpZHRocyA9IGRhLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmdldFN0cmluZ1VuaXRXaWR0aCh2LCB7XG4gICAgICAgICAgICAgIGZvbnQ6IGFjdGl2ZUZvbnQsXG4gICAgICAgICAgICAgIGNoYXJTcGFjZTogY2hhclNwYWNlLFxuICAgICAgICAgICAgICBmb250U2l6ZTogYWN0aXZlRm9udFNpemVcbiAgICAgICAgICAgIH0pICogYWN0aXZlRm9udFNpemUgLyBrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heExpbmVMZW5ndGggPSBNYXRoLm1heC5hcHBseShNYXRoLCBsaW5lV2lkdGhzKTsgLy9UaGUgZmlyc3QgbGluZSB1c2VzIHRoZSBcIm1haW5cIiBUZCBzZXR0aW5nLFxuICAgICAgICAvL2FuZCB0aGUgc3Vic2VxdWVudCBsaW5lcyBhcmUgb2Zmc2V0IGJ5IHRoZVxuICAgICAgICAvL3ByZXZpb3VzIGxpbmUncyB4IGNvb3JkaW5hdGUuXG5cbiAgICAgICAgdmFyIHByZXZXaWR0aCA9IDA7XG4gICAgICAgIHZhciBkZWx0YTtcbiAgICAgICAgdmFyIG5ld1g7XG5cbiAgICAgICAgaWYgKGFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICB4IC09IGxpbmVXaWR0aHNbMF07XG4gICAgICAgICAgdGV4dCA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkZWx0YSA9IG1heExpbmVMZW5ndGggLSBsaW5lV2lkdGhzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICBuZXdYID0gZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUoeCk7XG4gICAgICAgICAgICAgIG5ld1kgPSBnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdYID0gKHByZXZXaWR0aCAtIGxpbmVXaWR0aHNbaV0pICogaztcbiAgICAgICAgICAgICAgbmV3WSA9IC1sZWFkaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0LnB1c2goW2RhW2ldLCBuZXdYLCBuZXdZXSk7XG4gICAgICAgICAgICBwcmV2V2lkdGggPSBsaW5lV2lkdGhzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIHggLT0gbGluZVdpZHRoc1swXSAvIDI7XG4gICAgICAgICAgdGV4dCA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkZWx0YSA9IChtYXhMaW5lTGVuZ3RoIC0gbGluZVdpZHRoc1tpXSkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICBuZXdYID0gZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUoeCk7XG4gICAgICAgICAgICAgIG5ld1kgPSBnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdYID0gKHByZXZXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMiAqIGs7XG4gICAgICAgICAgICAgIG5ld1kgPSAtbGVhZGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dC5wdXNoKFtkYVtpXSwgbmV3WCwgbmV3WV0pO1xuICAgICAgICAgICAgcHJldldpZHRoID0gbGluZVdpZHRoc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgdGV4dCA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBuZXdZID0gaSA9PT0gMCA/IGdldFZlcnRpY2FsQ29vcmRpbmF0ZSh5KSA6IC1sZWFkaW5nO1xuICAgICAgICAgICAgbmV3WCA9IGkgPT09IDAgPyBnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4KSA6IDA7IC8vdGV4dC5wdXNoKFtkYVtpXSwgbmV3WCwgbmV3WV0pO1xuXG4gICAgICAgICAgICB0ZXh0LnB1c2goZGFbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJqdXN0aWZ5XCIpIHtcbiAgICAgICAgICB0ZXh0ID0gW107XG4gICAgICAgICAgdmFyIG1heFdpZHRoID0gbWF4V2lkdGggIT09IDAgPyBtYXhXaWR0aCA6IHBhZ2VXaWR0aDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbmV3WSA9IGkgPT09IDAgPyBnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeSkgOiAtbGVhZGluZztcbiAgICAgICAgICAgIG5ld1ggPSBpID09PSAwID8gZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUoeCkgOiAwO1xuXG4gICAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgd29yZFNwYWNpbmdQZXJMaW5lLnB1c2goKChtYXhXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gKGRhW2ldLnNwbGl0KFwiIFwiKS5sZW5ndGggLSAxKSAqIGspLnRvRml4ZWQoMikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0LnB1c2goW2RhW2ldLCBuZXdYLCBuZXdZXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGFsaWdubWVudCBvcHRpb24sIHVzZSBcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiIG9yIFwianVzdGlmeVwiLicpO1xuICAgICAgICB9XG4gICAgICB9IC8vUjJMXG5cblxuICAgICAgdmFyIGRvUmV2ZXJzaW5nID0gdHlwZW9mIG9wdGlvbnMuUjJMID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMuUjJMIDogUjJMO1xuXG4gICAgICBpZiAoZG9SZXZlcnNpbmcgPT09IHRydWUpIHtcbiAgICAgICAgdGV4dCA9IHByb2Nlc3NUZXh0QnlGdW5jdGlvbih0ZXh0LCBmdW5jdGlvbiAodGV4dCwgcG9zWCwgcG9zWSkge1xuICAgICAgICAgIHJldHVybiBbdGV4dC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKSwgcG9zWCwgcG9zWV07XG4gICAgICAgIH0pO1xuICAgICAgfSAvL2NyZWF0aW5nIFBheWxvYWQtT2JqZWN0IHRvIG1ha2UgdGV4dCBieVJlZlxuXG5cbiAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBtdXRleDoge1xuICAgICAgICAgIHBkZkVzY2FwZTogcGRmRXNjYXBlLFxuICAgICAgICAgIGFjdGl2ZUZvbnRLZXk6IGFjdGl2ZUZvbnRLZXksXG4gICAgICAgICAgZm9udHM6IGZvbnRzLFxuICAgICAgICAgIGFjdGl2ZUZvbnRTaXplOiBhY3RpdmVGb250U2l6ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXZlbnRzLnB1Ymxpc2goJ3Bvc3RQcm9jZXNzVGV4dCcsIHBheWxvYWQpO1xuICAgICAgdGV4dCA9IHBheWxvYWQudGV4dDtcbiAgICAgIGlzSGV4ID0gcGF5bG9hZC5tdXRleC5pc0hleDtcbiAgICAgIHZhciBkYSA9IHRyYW5zZm9ybVRleHRUb1NwZWNpYWxBcnJheSh0ZXh0KTtcbiAgICAgIHRleHQgPSBbXTtcbiAgICAgIHZhciB2YXJpYW50ID0gMDtcbiAgICAgIHZhciBsZW4gPSBkYS5sZW5ndGg7XG4gICAgICB2YXIgcG9zWDtcbiAgICAgIHZhciBwb3NZO1xuICAgICAgdmFyIGNvbnRlbnQ7XG4gICAgICB2YXIgd29yZFNwYWNpbmcgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB3b3JkU3BhY2luZyA9ICcnO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYVtpXSkpIHtcbiAgICAgICAgICBwb3NYID0gZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUoeCk7XG4gICAgICAgICAgcG9zWSA9IGdldFZlcnRpY2FsQ29vcmRpbmF0ZSh5KTtcbiAgICAgICAgICBjb250ZW50ID0gKGlzSGV4ID8gXCI8XCIgOiBcIihcIikgKyBkYVtpXSArIChpc0hleCA/IFwiPlwiIDogXCIpXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc1ggPSBwYXJzZUZsb2F0KGRhW2ldWzFdKTtcbiAgICAgICAgICBwb3NZID0gcGFyc2VGbG9hdChkYVtpXVsyXSk7XG4gICAgICAgICAgY29udGVudCA9IChpc0hleCA/IFwiPFwiIDogXCIoXCIpICsgZGFbaV1bMF0gKyAoaXNIZXggPyBcIj5cIiA6IFwiKVwiKTtcbiAgICAgICAgICB2YXJpYW50ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3b3JkU3BhY2luZ1BlckxpbmUgIT09IHVuZGVmaW5lZCAmJiB3b3JkU3BhY2luZ1BlckxpbmVbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHdvcmRTcGFjaW5nID0gd29yZFNwYWNpbmdQZXJMaW5lW2ldICsgXCIgVHdcXG5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1hdGlvbk1hdHJpeC5sZW5ndGggIT09IDAgJiYgaSA9PT0gMCkge1xuICAgICAgICAgIHRleHQucHVzaCh3b3JkU3BhY2luZyArIHRyYW5zZm9ybWF0aW9uTWF0cml4LmpvaW4oXCIgXCIpICsgXCIgXCIgKyBwb3NYLnRvRml4ZWQoMikgKyBcIiBcIiArIHBvc1kudG9GaXhlZCgyKSArIFwiIFRtXFxuXCIgKyBjb250ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh2YXJpYW50ID09PSAxIHx8IHZhcmlhbnQgPT09IDAgJiYgaSA9PT0gMCkge1xuICAgICAgICAgIHRleHQucHVzaCh3b3JkU3BhY2luZyArIHBvc1gudG9GaXhlZCgyKSArIFwiIFwiICsgcG9zWS50b0ZpeGVkKDIpICsgXCIgVGRcXG5cIiArIGNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQucHVzaCh3b3JkU3BhY2luZyArIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YXJpYW50ID09PSAwKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LmpvaW4oXCIgVGpcXG5UKiBcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gdGV4dC5qb2luKFwiIFRqXFxuXCIpO1xuICAgICAgfVxuXG4gICAgICB0ZXh0ICs9IFwiIFRqXFxuXCI7XG4gICAgICB2YXIgcmVzdWx0ID0gJ0JUXFxuLycgKyBhY3RpdmVGb250S2V5ICsgJyAnICsgYWN0aXZlRm9udFNpemUgKyAnIFRmXFxuJyArIC8vIGZvbnQgZmFjZSwgc3R5bGUsIHNpemVcbiAgICAgIChhY3RpdmVGb250U2l6ZSAqIGxpbmVIZWlnaHQpLnRvRml4ZWQoMikgKyAnIFRMXFxuJyArIC8vIGxpbmUgc3BhY2luZ1xuICAgICAgdGV4dENvbG9yICsgJ1xcbic7XG4gICAgICByZXN1bHQgKz0geHRyYTtcbiAgICAgIHJlc3VsdCArPSB0ZXh0O1xuICAgICAgcmVzdWx0ICs9IFwiRVRcIjtcbiAgICAgIG91dChyZXN1bHQpO1xuICAgICAgdXNlZEZvbnRzW2FjdGl2ZUZvbnRLZXldID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExldHRlciBzcGFjaW5nIG1ldGhvZCB0byBwcmludCB0ZXh0IHdpdGggZ2Fwc1xuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRleHQgU3RyaW5nIHRvIGJlIGFkZGVkIHRvIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgbGVmdCBlZGdlIG9mIHRoZSBwYWdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCB1cHBlciBlZGdlIG9mIHRoZSBwYWdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmcgU3BhY2luZyAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uKVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBsc3RleHRcbiAgICAgKiBAZGVwcmVjYXRlZCBXZSdsbCBiZSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uLiBJdCBkb2Vzbid0IHRha2UgY2hhcmFjdGVyIHdpZHRoIGludG8gYWNjb3VudC5cbiAgICAgKi9cblxuXG4gICAgdmFyIGxzdGV4dCA9IEFQSS5fX3ByaXZhdGVfXy5sc3RleHQgPSBBUEkubHN0ZXh0ID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIGNoYXJTcGFjZSkge1xuICAgICAgY29uc29sZS53YXJuKCdqc1BERi5sc3RleHQgaXMgZGVwcmVjYXRlZCcpO1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCh0ZXh0LCB4LCB5LCB7XG4gICAgICAgIGNoYXJTcGFjZTogY2hhclNwYWNlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBuYW1lIGNsaXBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBcbiAgICAgKiBAcmV0dXJucyB7anNQREZ9XG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQGRlc2NyaXB0aW9uIEFsbCAuY2xpcCgpIGFmdGVyIGNhbGxpbmcgZHJhd2luZyBvcHMgd2l0aCBhIHN0eWxlIGFyZ3VtZW50IG9mIG51bGwuXG4gICAgICovXG5cblxuICAgIHZhciBjbGlwID0gQVBJLl9fcHJpdmF0ZV9fLmNsaXAgPSBBUEkuY2xpcCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAvLyBDYWxsIC5jbGlwKCkgYWZ0ZXIgY2FsbGluZyBkcmF3aW5nIG9wcyB3aXRoIGEgc3R5bGUgYXJndW1lbnQgb2YgbnVsbFxuICAgICAgLy8gVyBpcyB0aGUgUERGIGNsaXBwaW5nIG9wXG4gICAgICBpZiAoJ2V2ZW5vZGQnID09PSBydWxlKSB7XG4gICAgICAgIG91dCgnVyonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCgnVycpO1xuICAgICAgfSAvLyBFbmQgdGhlIHBhdGggb2JqZWN0IHdpdGhvdXQgZmlsbGluZyBvciBzdHJva2luZyBpdC5cbiAgICAgIC8vIFRoaXMgb3BlcmF0b3IgaXMgYSBwYXRoLXBhaW50aW5nIG5vLW9wLCB1c2VkIHByaW1hcmlseSBmb3IgdGhlIHNpZGUgZWZmZWN0IG9mIGNoYW5naW5nIHRoZSBjdXJyZW50IGNsaXBwaW5nIHBhdGhcbiAgICAgIC8vIChzZWUgU2VjdGlvbiA0LjQuMywg4oCcQ2xpcHBpbmcgUGF0aCBPcGVyYXRvcnPigJ0pXG5cblxuICAgICAgb3V0KCduJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZpeGVzIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBjbGlwKCkuIFBlcmhhcHMgdGhlICdzdHJva2UgcGF0aCcgaGFjayB3YXMgZHVlIHRvIHRoZSBtaXNzaW5nICduJyBpbnN0cnVjdGlvbj9cbiAgICAgKiBXZSBpbnRyb2R1Y2UgdGhlIGZpeGVkIHZlcnNpb24gc28gYXMgdG8gbm90IGJyZWFrIEFQSS5cbiAgICAgKiBAcGFyYW0gZmlsbFJ1bGVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG5cblxuICAgIHZhciBjbGlwX2ZpeGVkID0gQVBJLl9fcHJpdmF0ZV9fLmNsaXBfZml4ZWQgPSBBUEkuY2xpcF9maXhlZCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImNsaXBfZml4ZWQgaXMgZGVwcmVjYXRlZFwiKTtcbiAgICAgIEFQSS5jbGlwKHJ1bGUpO1xuICAgIH07XG5cbiAgICB2YXIgaXNWYWxpZFN0eWxlID0gQVBJLl9fcHJpdmF0ZV9fLmlzVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgdmFyIHZhbGlkU3R5bGVWYXJpYW50cyA9IFt1bmRlZmluZWQsIG51bGwsICdTJywgJ0YnLCAnREYnLCAnRkQnLCAnZicsICdmKicsICdCJywgJ0IqJ107XG4gICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIGlmICh2YWxpZFN0eWxlVmFyaWFudHMuaW5kZXhPZihzdHlsZSkgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBnZXRTdHlsZSA9IEFQSS5fX3ByaXZhdGVfXy5nZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgLy8gc2VlIHBhdGgtcGFpbnRpbmcgb3BlcmF0b3JzIGluIFBERiBzcGVjXG4gICAgICB2YXIgb3AgPSAnUyc7IC8vIHN0cm9rZVxuXG4gICAgICBpZiAoc3R5bGUgPT09ICdGJykge1xuICAgICAgICBvcCA9ICdmJzsgLy8gZmlsbFxuICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ0ZEJyB8fCBzdHlsZSA9PT0gJ0RGJykge1xuICAgICAgICBvcCA9ICdCJzsgLy8gYm90aFxuICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ2YnIHx8IHN0eWxlID09PSAnZionIHx8IHN0eWxlID09PSAnQicgfHwgc3R5bGUgPT09ICdCKicpIHtcbiAgICAgICAgLypcbiAgICAgICAgIEFsbG93IGRpcmVjdCB1c2Ugb2YgdGhlc2UgUERGIHBhdGgtcGFpbnRpbmcgb3BlcmF0b3JzOlxuICAgICAgICAgLSBmICAgIGZpbGwgdXNpbmcgbm9uemVybyB3aW5kaW5nIG51bWJlciBydWxlXG4gICAgICAgICAtIGYqICAgIGZpbGwgdXNpbmcgZXZlbi1vZGQgcnVsZVxuICAgICAgICAgLSBCICAgIGZpbGwgdGhlbiBzdHJva2Ugd2l0aCBmaWxsIHVzaW5nIG5vbi16ZXJvIHdpbmRpbmcgbnVtYmVyIHJ1bGVcbiAgICAgICAgIC0gQiogICAgZmlsbCB0aGVuIHN0cm9rZSB3aXRoIGZpbGwgdXNpbmcgZXZlbi1vZGQgcnVsZVxuICAgICAgICAgKi9cbiAgICAgICAgb3AgPSBzdHlsZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhdyBhIGxpbmUgb24gdGhlIGN1cnJlbnQgcGFnZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIGxpbmVcbiAgICAgKiBAZnVuY3Rpb24gXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqL1xuXG5cbiAgICB2YXIgbGluZSA9IEFQSS5fX3ByaXZhdGVfXy5saW5lID0gQVBJLmxpbmUgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIGlmIChpc05hTih4MSkgfHwgaXNOYU4oeTEpIHx8IGlzTmFOKHgyKSB8fCBpc05hTih5MikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYubGluZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5saW5lcyhbW3gyIC0geDEsIHkyIC0geTFdXSwgeDEsIHkxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgc2VyaWVzIG9mIGN1cnZlcyAoc3RyYWlnaHQgbGluZXMgb3IgY3ViaWMgYmV6aWVyIGN1cnZlcykgdG8gY2FudmFzLCBzdGFydGluZyBhdCBgeGAsIGB5YCBjb29yZGluYXRlcy5cbiAgICAgKiBBbGwgZGF0YSBwb2ludHMgaW4gYGxpbmVzYCBhcmUgcmVsYXRpdmUgdG8gbGFzdCBsaW5lIG9yaWdpbi5cbiAgICAgKiBgeGAsIGB5YCBiZWNvbWUgeDEseTEgZm9yIGZpcnN0IGxpbmUgLyBjdXJ2ZSBpbiB0aGUgc2V0LlxuICAgICAqIEZvciBsaW5lcyB5b3Ugb25seSBuZWVkIHRvIHNwZWNpZnkgW3gyLCB5Ml0gLSAoZW5kaW5nIHBvaW50KSB2ZWN0b3IgYWdhaW5zdCB4MSwgeTEgc3RhcnRpbmcgcG9pbnQuXG4gICAgICogRm9yIGJlemllciBjdXJ2ZXMgeW91IG5lZWQgdG8gc3BlY2lmeSBbeDIseTIseDMseTMseDQseTRdIC0gdmVjdG9ycyB0byBjb250cm9sIHBvaW50cyAxLCAyLCBlbmRpbmcgcG9pbnQuIEFsbCB2ZWN0b3JzIGFyZSBhZ2FpbnN0IHRoZSBzdGFydCBvZiB0aGUgY3VydmUgLSB4MSx5MS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIC5saW5lcyhbWzIsMl0sWy0yLDJdLFsxLDEsMiwyLDMsM10sWzIsMV1dLCAyMTIsMTEwLCBbMSwxXSwgJ0YnLCBmYWxzZSkgLy8gbGluZSwgbGluZSwgYmV6aWVyIGN1cnZlLCBsaW5lXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZXMgQXJyYXkgb2YgKnZlY3Rvciogc2hpZnRzIGFzIHBhaXJzIChsaW5lcykgb3Igc2V4dGV0cyAoY3ViaWMgYmV6aWVyIGN1cnZlcykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCBsZWZ0IGVkZ2Ugb2YgdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCB1cHBlciBlZGdlIG9mIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAoRGVmYXVsdHMgdG8gWzEuMCwxLjBdKSB4LHkgU2NhbGluZyBmYWN0b3IgZm9yIGFsbCB2ZWN0b3JzLiBFbGVtZW50cyBjYW4gYmUgYW55IGZsb2F0aW5nIG51bWJlciBTdWItb25lIG1ha2VzIGRyYXdpbmcgc21hbGxlci4gT3Zlci1vbmUgZ3Jvd3MgdGhlIGRyYXdpbmcuIE5lZ2F0aXZlIGZsaXBzIHRoZSBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlIEEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlIHBhaW50aW5nIHN0eWxlIG9yIG51bGwuICBWYWxpZCBzdHlsZXMgaW5jbHVkZTogJ1MnIFtkZWZhdWx0XSAtIHN0cm9rZSwgJ0YnIC0gZmlsbCwgIGFuZCAnREYnIChvciAnRkQnKSAtICBmaWxsIHRoZW4gc3Ryb2tlLiBBIG51bGwgdmFsdWUgcG9zdHBvbmVzIHNldHRpbmcgdGhlIHN0eWxlIHNvIHRoYXQgYSBzaGFwZSBtYXkgYmUgY29tcG9zZWQgdXNpbmcgbXVsdGlwbGUgbWV0aG9kIGNhbGxzLiBUaGUgbGFzdCBkcmF3aW5nIG1ldGhvZCBjYWxsIHVzZWQgdG8gZGVmaW5lIHRoZSBzaGFwZSBzaG91bGQgbm90IGhhdmUgYSBudWxsIHN0eWxlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VkIElmIHRydWUsIHRoZSBwYXRoIGlzIGNsb3NlZCB3aXRoIGEgc3RyYWlnaHQgbGluZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGxhc3QgY3VydmUgdG8gdGhlIHN0YXJ0aW5nIHBvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBsaW5lc1xuICAgICAqL1xuXG5cbiAgICB2YXIgbGluZXMgPSBBUEkuX19wcml2YXRlX18ubGluZXMgPSBBUEkubGluZXMgPSBmdW5jdGlvbiAobGluZXMsIHgsIHksIHNjYWxlLCBzdHlsZSwgY2xvc2VkKSB7XG4gICAgICB2YXIgc2NhbGV4LCBzY2FsZXksIGksIGwsIGxlZywgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgdG1wOyAvLyBQcmUtQXVndXN0LTIwMTIgdGhlIG9yZGVyIG9mIGFyZ3VtZW50cyB3YXMgZnVuY3Rpb24oeCwgeSwgbGluZXMsIHNjYWxlLCBzdHlsZSlcbiAgICAgIC8vIGluIGVmZm9ydCB0byBtYWtlIGFsbCBjYWxscyBoYXZlIHNpbWlsYXIgc2lnbmF0dXJlIGxpa2VcbiAgICAgIC8vICAgZnVuY3Rpb24oY29udGVudCwgY29vcmRpbmF0ZVgsIGNvb3JkaW5hdGVZICwgbWlzY2VsbGFuZW91cylcbiAgICAgIC8vIHRoaXMgbWV0aG9kIGhhZCBpdHMgYXJncyBmbGlwcGVkLlxuICAgICAgLy8gY29kZSBiZWxvdyBhbGxvd3MgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBhcmcgb3JkZXIuXG5cbiAgICAgIGlmICh0eXBlb2YgbGluZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRtcCA9IHk7XG4gICAgICAgIHkgPSB4O1xuICAgICAgICB4ID0gbGluZXM7XG4gICAgICAgIGxpbmVzID0gdG1wO1xuICAgICAgfVxuXG4gICAgICBzY2FsZSA9IHNjYWxlIHx8IFsxLCAxXTtcbiAgICAgIGNsb3NlZCA9IGNsb3NlZCB8fCBmYWxzZTtcblxuICAgICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpIHx8ICFBcnJheS5pc0FycmF5KGxpbmVzKSB8fCAhQXJyYXkuaXNBcnJheShzY2FsZSkgfHwgIWlzVmFsaWRTdHlsZShzdHlsZSkgfHwgdHlwZW9mIGNsb3NlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmxpbmVzJyk7XG4gICAgICB9IC8vIHN0YXJ0aW5nIHBvaW50XG5cblxuICAgICAgb3V0KGYzKGdldEhvcml6b250YWxDb29yZGluYXRlKHgpKSArICcgJyArIGYzKGdldFZlcnRpY2FsQ29vcmRpbmF0ZSh5KSkgKyAnIG0gJyk7XG4gICAgICBzY2FsZXggPSBzY2FsZVswXTtcbiAgICAgIHNjYWxleSA9IHNjYWxlWzFdO1xuICAgICAgbCA9IGxpbmVzLmxlbmd0aDsgLy8sIHgyLCB5MiAvLyBiZXppZXIgb25seS4gSW4gcGFnZSBkZWZhdWx0IG1lYXN1cmVtZW50IFwidW5pdHNcIiwgKmFmdGVyKiBzY2FsaW5nXG4gICAgICAvLywgeDMsIHkzIC8vIGJlemllciBvbmx5LiBJbiBwYWdlIGRlZmF1bHQgbWVhc3VyZW1lbnQgXCJ1bml0c1wiLCAqYWZ0ZXIqIHNjYWxpbmdcbiAgICAgIC8vIGVuZGluZyBwb2ludCBmb3IgYWxsLCBsaW5lcyBhbmQgYmV6aWVyLiAuIEluIHBhZ2UgZGVmYXVsdCBtZWFzdXJlbWVudCBcInVuaXRzXCIsICphZnRlciogc2NhbGluZ1xuXG4gICAgICB4NCA9IHg7IC8vIGxhc3QgLyBlbmRpbmcgcG9pbnQgPSBzdGFydGluZyBwb2ludCBmb3IgZmlyc3QgaXRlbS5cblxuICAgICAgeTQgPSB5OyAvLyBsYXN0IC8gZW5kaW5nIHBvaW50ID0gc3RhcnRpbmcgcG9pbnQgZm9yIGZpcnN0IGl0ZW0uXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbGVnID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKGxlZy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAvLyBzaW1wbGUgbGluZVxuICAgICAgICAgIHg0ID0gbGVnWzBdICogc2NhbGV4ICsgeDQ7IC8vIGhlcmUgbGFzdCB4NCB3YXMgcHJpb3IgZW5kaW5nIHBvaW50XG5cbiAgICAgICAgICB5NCA9IGxlZ1sxXSAqIHNjYWxleSArIHk0OyAvLyBoZXJlIGxhc3QgeTQgd2FzIHByaW9yIGVuZGluZyBwb2ludFxuXG4gICAgICAgICAgb3V0KGYzKGdldEhvcml6b250YWxDb29yZGluYXRlKHg0KSkgKyAnICcgKyBmMyhnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeTQpKSArICcgbCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJlemllciBjdXJ2ZVxuICAgICAgICAgIHgyID0gbGVnWzBdICogc2NhbGV4ICsgeDQ7IC8vIGhlcmUgbGFzdCB4NCBpcyBwcmlvciBlbmRpbmcgcG9pbnRcblxuICAgICAgICAgIHkyID0gbGVnWzFdICogc2NhbGV5ICsgeTQ7IC8vIGhlcmUgbGFzdCB5NCBpcyBwcmlvciBlbmRpbmcgcG9pbnRcblxuICAgICAgICAgIHgzID0gbGVnWzJdICogc2NhbGV4ICsgeDQ7IC8vIGhlcmUgbGFzdCB4NCBpcyBwcmlvciBlbmRpbmcgcG9pbnRcblxuICAgICAgICAgIHkzID0gbGVnWzNdICogc2NhbGV5ICsgeTQ7IC8vIGhlcmUgbGFzdCB5NCBpcyBwcmlvciBlbmRpbmcgcG9pbnRcblxuICAgICAgICAgIHg0ID0gbGVnWzRdICogc2NhbGV4ICsgeDQ7IC8vIGhlcmUgbGFzdCB4NCB3YXMgcHJpb3IgZW5kaW5nIHBvaW50XG5cbiAgICAgICAgICB5NCA9IGxlZ1s1XSAqIHNjYWxleSArIHk0OyAvLyBoZXJlIGxhc3QgeTQgd2FzIHByaW9yIGVuZGluZyBwb2ludFxuXG4gICAgICAgICAgb3V0KGYzKGdldEhvcml6b250YWxDb29yZGluYXRlKHgyKSkgKyAnICcgKyBmMyhnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeTIpKSArICcgJyArIGYzKGdldEhvcml6b250YWxDb29yZGluYXRlKHgzKSkgKyAnICcgKyBmMyhnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeTMpKSArICcgJyArIGYzKGdldEhvcml6b250YWxDb29yZGluYXRlKHg0KSkgKyAnICcgKyBmMyhnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeTQpKSArICcgYycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgb3V0KCcgaCcpO1xuICAgICAgfSAvLyBzdHJva2luZyAvIGZpbGxpbmcgLyBib3RoIHRoZSBwYXRoXG5cblxuICAgICAgaWYgKHN0eWxlICE9PSBudWxsKSB7XG4gICAgICAgIG91dChnZXRTdHlsZShzdHlsZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZWN0YW5nbGUgdG8gUERGLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCBsZWZ0IGVkZ2Ugb2YgdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCB1cHBlciBlZGdlIG9mIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3IFdpZHRoIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaCBIZWlnaHQgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSBBIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBwYWludGluZyBzdHlsZSBvciBudWxsLiAgVmFsaWQgc3R5bGVzIGluY2x1ZGU6ICdTJyBbZGVmYXVsdF0gLSBzdHJva2UsICdGJyAtIGZpbGwsICBhbmQgJ0RGJyAob3IgJ0ZEJykgLSAgZmlsbCB0aGVuIHN0cm9rZS4gQSBudWxsIHZhbHVlIHBvc3Rwb25lcyBzZXR0aW5nIHRoZSBzdHlsZSBzbyB0aGF0IGEgc2hhcGUgbWF5IGJlIGNvbXBvc2VkIHVzaW5nIG11bHRpcGxlIG1ldGhvZCBjYWxscy4gVGhlIGxhc3QgZHJhd2luZyBtZXRob2QgY2FsbCB1c2VkIHRvIGRlZmluZSB0aGUgc2hhcGUgc2hvdWxkIG5vdCBoYXZlIGEgbnVsbCBzdHlsZSBhcmd1bWVudC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7anNQREZ9XG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgcmVjdFxuICAgICAqL1xuXG5cbiAgICB2YXIgcmVjdCA9IEFQSS5fX3ByaXZhdGVfXy5yZWN0ID0gQVBJLnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc3R5bGUpIHtcbiAgICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSB8fCBpc05hTih3KSB8fCBpc05hTihoKSB8fCAhaXNWYWxpZFN0eWxlKHN0eWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5yZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIG91dChbZjIoZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUoeCkpLCBmMihnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeSkpLCBmMih3ICogayksIGYyKC1oICogayksICdyZSddLmpvaW4oJyAnKSk7XG5cbiAgICAgIGlmIChzdHlsZSAhPT0gbnVsbCkge1xuICAgICAgICBvdXQoZ2V0U3R5bGUoc3R5bGUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdHJpYW5nbGUgdG8gUERGLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgbGVmdCBlZGdlIG9mIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBDb29yZGluYXRlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KSBhZ2FpbnN0IHVwcGVyIGVkZ2Ugb2YgdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyIENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgbGVmdCBlZGdlIG9mIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MiBDb29yZGluYXRlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KSBhZ2FpbnN0IHVwcGVyIGVkZ2Ugb2YgdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzIENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgbGVmdCBlZGdlIG9mIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MyBDb29yZGluYXRlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KSBhZ2FpbnN0IHVwcGVyIGVkZ2Ugb2YgdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlIEEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlIHBhaW50aW5nIHN0eWxlIG9yIG51bGwuICBWYWxpZCBzdHlsZXMgaW5jbHVkZTogJ1MnIFtkZWZhdWx0XSAtIHN0cm9rZSwgJ0YnIC0gZmlsbCwgIGFuZCAnREYnIChvciAnRkQnKSAtICBmaWxsIHRoZW4gc3Ryb2tlLiBBIG51bGwgdmFsdWUgcG9zdHBvbmVzIHNldHRpbmcgdGhlIHN0eWxlIHNvIHRoYXQgYSBzaGFwZSBtYXkgYmUgY29tcG9zZWQgdXNpbmcgbXVsdGlwbGUgbWV0aG9kIGNhbGxzLiBUaGUgbGFzdCBkcmF3aW5nIG1ldGhvZCBjYWxsIHVzZWQgdG8gZGVmaW5lIHRoZSBzaGFwZSBzaG91bGQgbm90IGhhdmUgYSBudWxsIHN0eWxlIGFyZ3VtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSB0cmlhbmdsZVxuICAgICAqL1xuXG5cbiAgICB2YXIgdHJpYW5nbGUgPSBBUEkuX19wcml2YXRlX18udHJpYW5nbGUgPSBBUEkudHJpYW5nbGUgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mywgc3R5bGUpIHtcbiAgICAgIGlmIChpc05hTih4MSkgfHwgaXNOYU4oeTEpIHx8IGlzTmFOKHgyKSB8fCBpc05hTih5MikgfHwgaXNOYU4oeDMpIHx8IGlzTmFOKHkzKSB8fCAhaXNWYWxpZFN0eWxlKHN0eWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi50cmlhbmdsZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpbmVzKFtbeDIgLSB4MSwgeTIgLSB5MV0sIC8vIHZlY3RvciB0byBwb2ludCAyXG4gICAgICBbeDMgLSB4MiwgeTMgLSB5Ml0sIC8vIHZlY3RvciB0byBwb2ludCAzXG4gICAgICBbeDEgLSB4MywgeTEgLSB5M10gLy8gY2xvc2luZyB2ZWN0b3IgYmFjayB0byBwb2ludCAxXG4gICAgICBdLCB4MSwgeTEsIC8vIHN0YXJ0IG9mIHBhdGhcbiAgICAgIFsxLCAxXSwgc3R5bGUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIHRvIFBERi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgbGVmdCBlZGdlIG9mIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgdXBwZXIgZWRnZSBvZiB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyBXaWR0aCAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggSGVpZ2h0IChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnggUmFkaXVzIGFsb25nIHggYXhpcyAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJ5IFJhZGl1cyBhbG9uZyB5IGF4aXMgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSBBIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBwYWludGluZyBzdHlsZSBvciBudWxsLiAgVmFsaWQgc3R5bGVzIGluY2x1ZGU6ICdTJyBbZGVmYXVsdF0gLSBzdHJva2UsICdGJyAtIGZpbGwsICBhbmQgJ0RGJyAob3IgJ0ZEJykgLSAgZmlsbCB0aGVuIHN0cm9rZS4gQSBudWxsIHZhbHVlIHBvc3Rwb25lcyBzZXR0aW5nIHRoZSBzdHlsZSBzbyB0aGF0IGEgc2hhcGUgbWF5IGJlIGNvbXBvc2VkIHVzaW5nIG11bHRpcGxlIG1ldGhvZCBjYWxscy4gVGhlIGxhc3QgZHJhd2luZyBtZXRob2QgY2FsbCB1c2VkIHRvIGRlZmluZSB0aGUgc2hhcGUgc2hvdWxkIG5vdCBoYXZlIGEgbnVsbCBzdHlsZSBhcmd1bWVudC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7anNQREZ9XG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgcm91bmRlZFJlY3RcbiAgICAgKi9cblxuXG4gICAgdmFyIHJvdW5kZWRSZWN0ID0gQVBJLl9fcHJpdmF0ZV9fLnJvdW5kZWRSZWN0ID0gQVBJLnJvdW5kZWRSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIHJ4LCByeSwgc3R5bGUpIHtcbiAgICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSB8fCBpc05hTih3KSB8fCBpc05hTihoKSB8fCBpc05hTihyeCkgfHwgaXNOYU4ocnkpIHx8ICFpc1ZhbGlkU3R5bGUoc3R5bGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLnJvdW5kZWRSZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBNeUFyYyA9IDQgLyAzICogKE1hdGguU1FSVDIgLSAxKTtcbiAgICAgIHRoaXMubGluZXMoW1t3IC0gMiAqIHJ4LCAwXSwgW3J4ICogTXlBcmMsIDAsIHJ4LCByeSAtIHJ5ICogTXlBcmMsIHJ4LCByeV0sIFswLCBoIC0gMiAqIHJ5XSwgWzAsIHJ5ICogTXlBcmMsIC0ocnggKiBNeUFyYyksIHJ5LCAtcngsIHJ5XSwgWy13ICsgMiAqIHJ4LCAwXSwgWy0ocnggKiBNeUFyYyksIDAsIC1yeCwgLShyeSAqIE15QXJjKSwgLXJ4LCAtcnldLCBbMCwgLWggKyAyICogcnldLCBbMCwgLShyeSAqIE15QXJjKSwgcnggKiBNeUFyYywgLXJ5LCByeCwgLXJ5XV0sIHggKyByeCwgeSwgLy8gc3RhcnQgb2YgcGF0aFxuICAgICAgWzEsIDFdLCBzdHlsZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZWxsaXBzZSB0byBQREYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBDb29yZGluYXRlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KSBhZ2FpbnN0IGxlZnQgZWRnZSBvZiB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBDb29yZGluYXRlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KSBhZ2FpbnN0IHVwcGVyIGVkZ2Ugb2YgdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJ4IFJhZGl1cyBhbG9uZyB4IGF4aXMgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByeSBSYWRpdXMgYWxvbmcgeSBheGlzIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3R5bGUgQSBzdHJpbmcgc3BlY2lmeWluZyB0aGUgcGFpbnRpbmcgc3R5bGUgb3IgbnVsbC4gIFZhbGlkIHN0eWxlcyBpbmNsdWRlOiAnUycgW2RlZmF1bHRdIC0gc3Ryb2tlLCAnRicgLSBmaWxsLCAgYW5kICdERicgKG9yICdGRCcpIC0gIGZpbGwgdGhlbiBzdHJva2UuIEEgbnVsbCB2YWx1ZSBwb3N0cG9uZXMgc2V0dGluZyB0aGUgc3R5bGUgc28gdGhhdCBhIHNoYXBlIG1heSBiZSBjb21wb3NlZCB1c2luZyBtdWx0aXBsZSBtZXRob2QgY2FsbHMuIFRoZSBsYXN0IGRyYXdpbmcgbWV0aG9kIGNhbGwgdXNlZCB0byBkZWZpbmUgdGhlIHNoYXBlIHNob3VsZCBub3QgaGF2ZSBhIG51bGwgc3R5bGUgYXJndW1lbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIGVsbGlwc2VcbiAgICAgKi9cblxuXG4gICAgdmFyIGVsbGlzZSA9IEFQSS5fX3ByaXZhdGVfXy5lbGxpcHNlID0gQVBJLmVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgcngsIHJ5LCBzdHlsZSkge1xuICAgICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpIHx8IGlzTmFOKHJ4KSB8fCBpc05hTihyeSkgfHwgIWlzVmFsaWRTdHlsZShzdHlsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuZWxsaXBzZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbHggPSA0IC8gMyAqIChNYXRoLlNRUlQyIC0gMSkgKiByeCxcbiAgICAgICAgICBseSA9IDQgLyAzICogKE1hdGguU1FSVDIgLSAxKSAqIHJ5O1xuICAgICAgb3V0KFtmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4ICsgcngpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkpKSwgJ20nLCBmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4ICsgcngpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkgLSBseSkpLCBmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4ICsgbHgpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkgLSByeSkpLCBmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4KSksIGYyKGdldFZlcnRpY2FsQ29vcmRpbmF0ZSh5IC0gcnkpKSwgJ2MnXS5qb2luKCcgJykpO1xuICAgICAgb3V0KFtmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4IC0gbHgpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkgLSByeSkpLCBmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4IC0gcngpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkgLSBseSkpLCBmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4IC0gcngpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkpKSwgJ2MnXS5qb2luKCcgJykpO1xuICAgICAgb3V0KFtmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4IC0gcngpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkgKyBseSkpLCBmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4IC0gbHgpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkgKyByeSkpLCBmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4KSksIGYyKGdldFZlcnRpY2FsQ29vcmRpbmF0ZSh5ICsgcnkpKSwgJ2MnXS5qb2luKCcgJykpO1xuICAgICAgb3V0KFtmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4ICsgbHgpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkgKyByeSkpLCBmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4ICsgcngpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkgKyBseSkpLCBmMihnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSh4ICsgcngpKSwgZjIoZ2V0VmVydGljYWxDb29yZGluYXRlKHkpKSwgJ2MnXS5qb2luKCcgJykpO1xuXG4gICAgICBpZiAoc3R5bGUgIT09IG51bGwpIHtcbiAgICAgICAgb3V0KGdldFN0eWxlKHN0eWxlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBjaXJjbGUgdG8gUERGLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCBsZWZ0IGVkZ2Ugb2YgdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCB1cHBlciBlZGdlIG9mIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIFJhZGl1cyAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlIEEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlIHBhaW50aW5nIHN0eWxlIG9yIG51bGwuICBWYWxpZCBzdHlsZXMgaW5jbHVkZTogJ1MnIFtkZWZhdWx0XSAtIHN0cm9rZSwgJ0YnIC0gZmlsbCwgIGFuZCAnREYnIChvciAnRkQnKSAtICBmaWxsIHRoZW4gc3Ryb2tlLiBBIG51bGwgdmFsdWUgcG9zdHBvbmVzIHNldHRpbmcgdGhlIHN0eWxlIHNvIHRoYXQgYSBzaGFwZSBtYXkgYmUgY29tcG9zZWQgdXNpbmcgbXVsdGlwbGUgbWV0aG9kIGNhbGxzLiBUaGUgbGFzdCBkcmF3aW5nIG1ldGhvZCBjYWxsIHVzZWQgdG8gZGVmaW5lIHRoZSBzaGFwZSBzaG91bGQgbm90IGhhdmUgYSBudWxsIHN0eWxlIGFyZ3VtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBjaXJjbGVcbiAgICAgKi9cblxuXG4gICAgdmFyIGNpcmNsZSA9IEFQSS5fX3ByaXZhdGVfXy5jaXJjbGUgPSBBUEkuY2lyY2xlID0gZnVuY3Rpb24gKHgsIHksIHIsIHN0eWxlKSB7XG4gICAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkgfHwgaXNOYU4ocikgfHwgIWlzVmFsaWRTdHlsZShzdHlsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY2lyY2xlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVsbGlwc2UoeCwgeSwgciwgciwgc3R5bGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0ZXh0IGZvbnQgZmFjZSwgdmFyaWFudCBmb3IgdXBjb21pbmcgdGV4dCBlbGVtZW50cy5cbiAgICAgKiBTZWUgb3V0cHV0IG9mIGpzUERGLmdldEZvbnRMaXN0KCkgZm9yIHBvc3NpYmxlIGZvbnQgbmFtZXMsIHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250TmFtZSBGb250IG5hbWUgb3IgZmFtaWx5LiBFeGFtcGxlOiBcInRpbWVzXCIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTdHlsZSBGb250IHN0eWxlIG9yIHZhcmlhbnQuIEV4YW1wbGU6IFwiaXRhbGljXCIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIHNldEZvbnRcbiAgICAgKi9cblxuXG4gICAgQVBJLnNldEZvbnQgPSBmdW5jdGlvbiAoZm9udE5hbWUsIGZvbnRTdHlsZSkge1xuICAgICAgYWN0aXZlRm9udEtleSA9IF9nZXRGb250KGZvbnROYW1lLCBmb250U3R5bGUsIHtcbiAgICAgICAgZGlzYWJsZVdhcm5pbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3dpdGNoZXMgZm9udCBzdHlsZSBvciB2YXJpYW50IGZvciB1cGNvbWluZyB0ZXh0IGVsZW1lbnRzLFxuICAgICAqIHdoaWxlIGtlZXBpbmcgdGhlIGZvbnQgZmFjZSBvciBmYW1pbHkgc2FtZS5cbiAgICAgKiBTZWUgb3V0cHV0IG9mIGpzUERGLmdldEZvbnRMaXN0KCkgZm9yIHBvc3NpYmxlIGZvbnQgbmFtZXMsIHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSBGb250IHN0eWxlIG9yIHZhcmlhbnQuIEV4YW1wbGU6IFwiaXRhbGljXCIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIHNldEZvbnRTdHlsZVxuICAgICAqL1xuXG5cbiAgICBBUEkuc2V0Rm9udFN0eWxlID0gQVBJLnNldEZvbnRUeXBlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBhY3RpdmVGb250S2V5ID0gX2dldEZvbnQodW5kZWZpbmVkLCBzdHlsZSk7IC8vIGlmIGZvbnQgaXMgbm90IGZvdW5kLCB0aGUgYWJvdmUgbGluZSBibG93cyB1cCBhbmQgd2UgbmV2ZXIgZ28gZnVydGhlclxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IC0gYSB0cmVlIG9mIGZvbnROYW1lIHRvIGZvbnRTdHlsZSByZWxhdGlvbnNoaXBzIGF2YWlsYWJsZSB0b1xuICAgICAqIGFjdGl2ZSBQREYgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gTGlrZSB7J3RpbWVzJzpbJ25vcm1hbCcsICdpdGFsaWMnLCAuLi4gXSwgJ2FyaWFsJzpbJ25vcm1hbCcsICdib2xkJywgLi4uIF0sIC4uLiB9XG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgZ2V0Rm9udExpc3RcbiAgICAgKi9cblxuXG4gICAgdmFyIGdldEZvbnRMaXN0ID0gQVBJLl9fcHJpdmF0ZV9fLmdldEZvbnRMaXN0ID0gQVBJLmdldEZvbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogaXRlcmF0ZSBvdmVyIGZvbnRzIGFycmF5IG9yIHJldHVybiBjb3B5IG9mIGZvbnRtYXAgaW5zdGVhZCBpbiBjYXNlIG1vcmUgYXJlIGV2ZXIgYWRkZWQuXG4gICAgICB2YXIgbGlzdCA9IHt9LFxuICAgICAgICAgIGZvbnROYW1lLFxuICAgICAgICAgIGZvbnRTdHlsZSxcbiAgICAgICAgICB0bXA7XG5cbiAgICAgIGZvciAoZm9udE5hbWUgaW4gZm9udG1hcCkge1xuICAgICAgICBpZiAoZm9udG1hcC5oYXNPd25Qcm9wZXJ0eShmb250TmFtZSkpIHtcbiAgICAgICAgICBsaXN0W2ZvbnROYW1lXSA9IHRtcCA9IFtdO1xuXG4gICAgICAgICAgZm9yIChmb250U3R5bGUgaW4gZm9udG1hcFtmb250TmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChmb250bWFwW2ZvbnROYW1lXS5oYXNPd25Qcm9wZXJ0eShmb250U3R5bGUpKSB7XG4gICAgICAgICAgICAgIHRtcC5wdXNoKGZvbnRTdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgY3VzdG9tIGZvbnQgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcG9zdFNjcmlwdE5hbWUgUERGIHNwZWNpZmljYXRpb24gZnVsbCBuYW1lIGZvciB0aGUgZm9udC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaWQgUERGLWRvY3VtZW50LWluc3RhbmNlLXNwZWNpZmljIGxhYmVsIGFzc2luZ2VkIHRvIHRoZSBmb250LlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmb250U3R5bGUgU3R5bGUgb2YgdGhlIEZvbnQuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGVuY29kaW5nIEVuY29kaW5nX25hbWUtdG8tRm9udF9tZXRyaWNzX29iamVjdCBtYXBwaW5nLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIGFkZEZvbnRcbiAgICAgKi9cblxuXG4gICAgQVBJLmFkZEZvbnQgPSBmdW5jdGlvbiAocG9zdFNjcmlwdE5hbWUsIGZvbnROYW1lLCBmb250U3R5bGUsIGVuY29kaW5nKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICdJZGVudGl0eS1IJztcbiAgICAgIGFkZEZvbnQuY2FsbCh0aGlzLCBwb3N0U2NyaXB0TmFtZSwgZm9udE5hbWUsIGZvbnRTdHlsZSwgZW5jb2RpbmcpO1xuICAgIH07XG5cbiAgICB2YXIgbGluZVdpZHRoID0gb3B0aW9ucy5saW5lV2lkdGggfHwgMC4yMDAwMjU7IC8vIDJtbVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBsaW5lIHdpZHRoIGZvciB1cGNvbWluZyBsaW5lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBMaW5lIHdpZHRoIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7anNQREZ9XG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgc2V0TGluZVdpZHRoXG4gICAgICovXG5cbiAgICB2YXIgc2V0TGluZVdpZHRoID0gQVBJLl9fcHJpdmF0ZV9fLnNldExpbmVXaWR0aCA9IEFQSS5zZXRMaW5lV2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgIG91dCgod2lkdGggKiBrKS50b0ZpeGVkKDIpICsgJyB3Jyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhc2ggcGF0dGVybiBmb3IgdXBjb21pbmcgbGluZXMuXG4gICAgICogXG4gICAgICogVG8gcmVzZXQgdGhlIHNldHRpbmdzIHNpbXBseSBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhbnkgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBkYXNoQXJyYXkgVGhlIHBhdHRlcm4gb2YgdGhlIGxpbmUsIGV4cGVjdHMgbnVtYmVycy4gXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRhc2hQaGFzZSBUaGUgcGhhc2UgYXQgd2hpY2ggdGhlIGRhc2ggcGF0dGVybiBzdGFydHMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIHNldExpbmVEYXNoXG4gICAgICovXG5cblxuICAgIHZhciBzZXRMaW5lRGFzaCA9IEFQSS5fX3ByaXZhdGVfXy5zZXRMaW5lRGFzaCA9IGpzUERGLkFQSS5zZXRMaW5lRGFzaCA9IGZ1bmN0aW9uIChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgICAgZGFzaEFycmF5ID0gZGFzaEFycmF5IHx8IFtdO1xuICAgICAgZGFzaFBoYXNlID0gZGFzaFBoYXNlIHx8IDA7XG5cbiAgICAgIGlmIChpc05hTihkYXNoUGhhc2UpIHx8ICFBcnJheS5pc0FycmF5KGRhc2hBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuc2V0TGluZURhc2gnKTtcbiAgICAgIH1cblxuICAgICAgZGFzaEFycmF5ID0gZGFzaEFycmF5Lm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gKHggKiBrKS50b0ZpeGVkKDMpO1xuICAgICAgfSkuam9pbignICcpO1xuICAgICAgZGFzaFBoYXNlID0gcGFyc2VGbG9hdCgoZGFzaFBoYXNlICogaykudG9GaXhlZCgzKSk7XG4gICAgICBvdXQoJ1snICsgZGFzaEFycmF5ICsgJ10gJyArIGRhc2hQaGFzZSArICcgZCcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBsaW5lSGVpZ2h0RmFjdG9yO1xuXG4gICAgdmFyIGdldExpbmVIZWlnaHQgPSBBUEkuX19wcml2YXRlX18uZ2V0TGluZUhlaWdodCA9IEFQSS5nZXRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZUZvbnRTaXplICogbGluZUhlaWdodEZhY3RvcjtcbiAgICB9O1xuXG4gICAgdmFyIGxpbmVIZWlnaHRGYWN0b3I7XG5cbiAgICB2YXIgZ2V0TGluZUhlaWdodCA9IEFQSS5fX3ByaXZhdGVfXy5nZXRMaW5lSGVpZ2h0ID0gQVBJLmdldExpbmVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYWN0aXZlRm9udFNpemUgKiBsaW5lSGVpZ2h0RmFjdG9yO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgTGluZUhlaWdodEZhY3RvciBvZiBwcm9wb3J0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIExpbmVIZWlnaHRGYWN0b3IgdmFsdWUuIERlZmF1bHQ6IDEuMTUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIHNldExpbmVIZWlnaHRGYWN0b3JcbiAgICAgKi9cblxuXG4gICAgdmFyIHNldExpbmVIZWlnaHRGYWN0b3IgPSBBUEkuX19wcml2YXRlX18uc2V0TGluZUhlaWdodEZhY3RvciA9IEFQSS5zZXRMaW5lSGVpZ2h0RmFjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlIHx8IDEuMTU7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbGluZUhlaWdodEZhY3RvciA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIExpbmVIZWlnaHRGYWN0b3IsIGRlZmF1bHQ6IDEuMTUuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBsaW5lSGVpZ2h0RmFjdG9yXG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgZ2V0TGluZUhlaWdodEZhY3RvclxuICAgICAqL1xuXG5cbiAgICB2YXIgZ2V0TGluZUhlaWdodEZhY3RvciA9IEFQSS5fX3ByaXZhdGVfXy5nZXRMaW5lSGVpZ2h0RmFjdG9yID0gQVBJLmdldExpbmVIZWlnaHRGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbGluZUhlaWdodEZhY3RvcjtcbiAgICB9O1xuXG4gICAgc2V0TGluZUhlaWdodEZhY3RvcihvcHRpb25zLmxpbmVIZWlnaHQpO1xuXG4gICAgdmFyIGdldEhvcml6b250YWxDb29yZGluYXRlID0gQVBJLl9fcHJpdmF0ZV9fLmdldEhvcml6b250YWxDb29yZGluYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgKiBrO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VmVydGljYWxDb29yZGluYXRlID0gQVBJLl9fcHJpdmF0ZV9fLmdldFZlcnRpY2FsQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3gudG9wUmlnaHRZIC0gcGFnZXNDb250ZXh0W2N1cnJlbnRQYWdlXS5tZWRpYUJveC5ib3R0b21MZWZ0WSAtIHZhbHVlICogaztcbiAgICB9O1xuXG4gICAgdmFyIGdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nID0gQVBJLl9fcHJpdmF0ZV9fLmdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZjIodmFsdWUgKiBrKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZyA9IEFQSS5fX3ByaXZhdGVfXy5nZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBmMihwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm1lZGlhQm94LnRvcFJpZ2h0WSAtIHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3guYm90dG9tTGVmdFkgLSB2YWx1ZSAqIGspO1xuICAgIH07XG5cbiAgICB2YXIgc3Ryb2tlQ29sb3IgPSBvcHRpb25zLnN0cm9rZUNvbG9yIHx8ICcwIEcnO1xuICAgIC8qKlxuICAgICAqICBHZXRzIHRoZSBzdHJva2UgY29sb3IgZm9yIHVwY29taW5nIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29sb3JBc0hleFxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIGdldERyYXdDb2xvclxuICAgICAqL1xuXG4gICAgdmFyIGdldFN0cm9rZUNvbG9yID0gQVBJLl9fcHJpdmF0ZV9fLmdldFN0cm9rZUNvbG9yID0gQVBJLmdldERyYXdDb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkZWNvZGVDb2xvclN0cmluZyhzdHJva2VDb2xvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJva2UgY29sb3IgZm9yIHVwY29taW5nIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuLCBHcmF5LCBSR0IsIG9yIENNWUtcbiAgICAgKiBjb2xvciBzcGFjZSBpcyBpbXBsaWVkLlxuICAgICAqXG4gICAgICogV2hlbiBvbmx5IGNoMSBpcyBnaXZlbiwgXCJHcmF5XCIgY29sb3Igc3BhY2UgaXMgaW1wbGllZCBhbmQgaXRcbiAgICAgKiBtdXN0IGJlIGEgdmFsdWUgaW4gdGhlIHJhbmdlIGZyb20gMC4wMCAoc29saWQgYmxhY2spIHRvIHRvIDEuMDAgKHdoaXRlKVxuICAgICAqIGlmIHZhbHVlcyBhcmUgY29tbXVuaWNhdGVkIGFzIFN0cmluZyB0eXBlcywgb3IgaW4gcmFuZ2UgZnJvbSAwIChibGFjaylcbiAgICAgKiB0byAyNTUgKHdoaXRlKSBpZiBjb21tdW5pY2F0ZWQgYXMgTnVtYmVyIHR5cGUuXG4gICAgICogVGhlIFJHQi1saWtlIDAtMjU1IHJhbmdlIGlzIHByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogV2hlbiBvbmx5IGNoMSxjaDIsY2gzIGFyZSBnaXZlbiwgXCJSR0JcIiBjb2xvciBzcGFjZSBpcyBpbXBsaWVkIGFuZCBlYWNoXG4gICAgICogdmFsdWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgZnJvbSAwLjAwIChtaW5pbXVtIGludGVuc2l0eSkgdG8gdG8gMS4wMFxuICAgICAqIChtYXggaW50ZW5zaXR5KSBpZiB2YWx1ZXMgYXJlIGNvbW11bmljYXRlZCBhcyBTdHJpbmcgdHlwZXMsIG9yXG4gICAgICogZnJvbSAwIChtaW4gaW50ZW5zaXR5KSB0byB0byAyNTUgKG1heCBpbnRlbnNpdHkpIGlmIHZhbHVlcyBhcmUgY29tbXVuaWNhdGVkXG4gICAgICogYXMgTnVtYmVyIHR5cGVzLlxuICAgICAqIFRoZSBSR0ItbGlrZSAwLTI1NSByYW5nZSBpcyBwcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIFdoZW4gY2gxLGNoMixjaDMsY2g0IGFyZSBnaXZlbiwgXCJDTVlLXCIgY29sb3Igc3BhY2UgaXMgaW1wbGllZCBhbmQgZWFjaFxuICAgICAqIHZhbHVlIG11c3QgYmUgYSBpbiB0aGUgcmFuZ2UgZnJvbSAwLjAwICgwJSBjb25jZW50cmF0aW9uKSB0byB0b1xuICAgICAqIDEuMDAgKDEwMCUgY29uY2VudHJhdGlvbilcbiAgICAgKlxuICAgICAqIEJlY2F1c2UgSmF2YVNjcmlwdCB0cmVhdHMgZml4ZWQgcG9pbnQgbnVtYmVycyBiYWRseSAocm91bmRzIHRvXG4gICAgICogZmxvYXRpbmcgcG9pbnQgbmVhcmVzdCB0byBiaW5hcnkgcmVwcmVzZW50YXRpb24pIGl0IGlzIGhpZ2hseSBhZHZpc2VkIHRvXG4gICAgICogY29tbXVuaWNhdGUgdGhlIGZyYWN0aW9uYWwgbnVtYmVycyBhcyBTdHJpbmcgdHlwZXMsIG5vdCBKYXZhU2NyaXB0IE51bWJlciB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaDEgQ29sb3IgY2hhbm5lbCB2YWx1ZSBvciB7c3RyaW5nfSBjaDEgY29sb3IgdmFsdWUgaW4gaGV4YWRlY2ltYWwsIGV4YW1wbGU6ICcjRkZGRkZGJy5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoMiBDb2xvciBjaGFubmVsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2gzIENvbG9yIGNoYW5uZWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaDQgQ29sb3IgY2hhbm5lbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBzZXREcmF3Q29sb3JcbiAgICAgKi9cblxuXG4gICAgdmFyIHNldFN0cm9rZUNvbG9yID0gQVBJLl9fcHJpdmF0ZV9fLnNldFN0cm9rZUNvbG9yID0gQVBJLnNldERyYXdDb2xvciA9IGZ1bmN0aW9uIChjaDEsIGNoMiwgY2gzLCBjaDQpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBcImNoMVwiOiBjaDEsXG4gICAgICAgIFwiY2gyXCI6IGNoMixcbiAgICAgICAgXCJjaDNcIjogY2gzLFxuICAgICAgICBcImNoNFwiOiBjaDQsXG4gICAgICAgIFwicGRmQ29sb3JUeXBlXCI6IFwiZHJhd1wiLFxuICAgICAgICBcInByZWNpc2lvblwiOiAyXG4gICAgICB9O1xuICAgICAgc3Ryb2tlQ29sb3IgPSBlbmNvZGVDb2xvclN0cmluZyhvcHRpb25zKTtcbiAgICAgIG91dChzdHJva2VDb2xvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIGZpbGxDb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8ICcwIGcnO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpbGwgY29sb3IgZm9yIHVwY29taW5nIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29sb3JBc0hleFxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIGdldEZpbGxDb2xvclxuICAgICAqL1xuXG4gICAgdmFyIGdldEZpbGxDb2xvciA9IEFQSS5fX3ByaXZhdGVfXy5nZXRGaWxsQ29sb3IgPSBBUEkuZ2V0RmlsbENvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlY29kZUNvbG9yU3RyaW5nKGZpbGxDb2xvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmaWxsIGNvbG9yIGZvciB1cGNvbWluZyBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBnaXZlbiwgR3JheSwgUkdCLCBvciBDTVlLXG4gICAgICogY29sb3Igc3BhY2UgaXMgaW1wbGllZC5cbiAgICAgKlxuICAgICAqIFdoZW4gb25seSBjaDEgaXMgZ2l2ZW4sIFwiR3JheVwiIGNvbG9yIHNwYWNlIGlzIGltcGxpZWQgYW5kIGl0XG4gICAgICogbXVzdCBiZSBhIHZhbHVlIGluIHRoZSByYW5nZSBmcm9tIDAuMDAgKHNvbGlkIGJsYWNrKSB0byB0byAxLjAwICh3aGl0ZSlcbiAgICAgKiBpZiB2YWx1ZXMgYXJlIGNvbW11bmljYXRlZCBhcyBTdHJpbmcgdHlwZXMsIG9yIGluIHJhbmdlIGZyb20gMCAoYmxhY2spXG4gICAgICogdG8gMjU1ICh3aGl0ZSkgaWYgY29tbXVuaWNhdGVkIGFzIE51bWJlciB0eXBlLlxuICAgICAqIFRoZSBSR0ItbGlrZSAwLTI1NSByYW5nZSBpcyBwcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIFdoZW4gb25seSBjaDEsY2gyLGNoMyBhcmUgZ2l2ZW4sIFwiUkdCXCIgY29sb3Igc3BhY2UgaXMgaW1wbGllZCBhbmQgZWFjaFxuICAgICAqIHZhbHVlIG11c3QgYmUgaW4gdGhlIHJhbmdlIGZyb20gMC4wMCAobWluaW11bSBpbnRlbnNpdHkpIHRvIHRvIDEuMDBcbiAgICAgKiAobWF4IGludGVuc2l0eSkgaWYgdmFsdWVzIGFyZSBjb21tdW5pY2F0ZWQgYXMgU3RyaW5nIHR5cGVzLCBvclxuICAgICAqIGZyb20gMCAobWluIGludGVuc2l0eSkgdG8gdG8gMjU1IChtYXggaW50ZW5zaXR5KSBpZiB2YWx1ZXMgYXJlIGNvbW11bmljYXRlZFxuICAgICAqIGFzIE51bWJlciB0eXBlcy5cbiAgICAgKiBUaGUgUkdCLWxpa2UgMC0yNTUgcmFuZ2UgaXMgcHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBXaGVuIGNoMSxjaDIsY2gzLGNoNCBhcmUgZ2l2ZW4sIFwiQ01ZS1wiIGNvbG9yIHNwYWNlIGlzIGltcGxpZWQgYW5kIGVhY2hcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGEgaW4gdGhlIHJhbmdlIGZyb20gMC4wMCAoMCUgY29uY2VudHJhdGlvbikgdG8gdG9cbiAgICAgKiAxLjAwICgxMDAlIGNvbmNlbnRyYXRpb24pXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIEphdmFTY3JpcHQgdHJlYXRzIGZpeGVkIHBvaW50IG51bWJlcnMgYmFkbHkgKHJvdW5kcyB0b1xuICAgICAqIGZsb2F0aW5nIHBvaW50IG5lYXJlc3QgdG8gYmluYXJ5IHJlcHJlc2VudGF0aW9uKSBpdCBpcyBoaWdobHkgYWR2aXNlZCB0b1xuICAgICAqIGNvbW11bmljYXRlIHRoZSBmcmFjdGlvbmFsIG51bWJlcnMgYXMgU3RyaW5nIHR5cGVzLCBub3QgSmF2YVNjcmlwdCBOdW1iZXIgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2gxIENvbG9yIGNoYW5uZWwgdmFsdWUgb3Ige3N0cmluZ30gY2gxIGNvbG9yIHZhbHVlIGluIGhleGFkZWNpbWFsLCBleGFtcGxlOiAnI0ZGRkZGRicuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaDIgQ29sb3IgY2hhbm5lbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoMyBDb2xvciBjaGFubmVsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2g0IENvbG9yIGNoYW5uZWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7anNQREZ9XG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgc2V0RmlsbENvbG9yXG4gICAgICovXG5cblxuICAgIHZhciBzZXRGaWxsQ29sb3IgPSBBUEkuX19wcml2YXRlX18uc2V0RmlsbENvbG9yID0gQVBJLnNldEZpbGxDb2xvciA9IGZ1bmN0aW9uIChjaDEsIGNoMiwgY2gzLCBjaDQpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBcImNoMVwiOiBjaDEsXG4gICAgICAgIFwiY2gyXCI6IGNoMixcbiAgICAgICAgXCJjaDNcIjogY2gzLFxuICAgICAgICBcImNoNFwiOiBjaDQsXG4gICAgICAgIFwicGRmQ29sb3JUeXBlXCI6IFwiZmlsbFwiLFxuICAgICAgICBcInByZWNpc2lvblwiOiAyXG4gICAgICB9O1xuICAgICAgZmlsbENvbG9yID0gZW5jb2RlQ29sb3JTdHJpbmcob3B0aW9ucyk7XG4gICAgICBvdXQoZmlsbENvbG9yKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dENvbG9yID0gb3B0aW9ucy50ZXh0Q29sb3IgfHwgJzAgZyc7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdGV4dCBjb2xvciBmb3IgdXBjb21pbmcgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjb2xvckFzSGV4XG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgZ2V0VGV4dENvbG9yXG4gICAgICovXG5cbiAgICB2YXIgZ2V0VGV4dENvbG9yID0gQVBJLl9fcHJpdmF0ZV9fLmdldFRleHRDb2xvciA9IEFQSS5nZXRUZXh0Q29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGVjb2RlQ29sb3JTdHJpbmcodGV4dENvbG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRleHQgY29sb3IgZm9yIHVwY29taW5nIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuLCBHcmF5LCBSR0IsIG9yIENNWUtcbiAgICAgKiBjb2xvciBzcGFjZSBpcyBpbXBsaWVkLlxuICAgICAqXG4gICAgICogV2hlbiBvbmx5IGNoMSBpcyBnaXZlbiwgXCJHcmF5XCIgY29sb3Igc3BhY2UgaXMgaW1wbGllZCBhbmQgaXRcbiAgICAgKiBtdXN0IGJlIGEgdmFsdWUgaW4gdGhlIHJhbmdlIGZyb20gMC4wMCAoc29saWQgYmxhY2spIHRvIHRvIDEuMDAgKHdoaXRlKVxuICAgICAqIGlmIHZhbHVlcyBhcmUgY29tbXVuaWNhdGVkIGFzIFN0cmluZyB0eXBlcywgb3IgaW4gcmFuZ2UgZnJvbSAwIChibGFjaylcbiAgICAgKiB0byAyNTUgKHdoaXRlKSBpZiBjb21tdW5pY2F0ZWQgYXMgTnVtYmVyIHR5cGUuXG4gICAgICogVGhlIFJHQi1saWtlIDAtMjU1IHJhbmdlIGlzIHByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogV2hlbiBvbmx5IGNoMSxjaDIsY2gzIGFyZSBnaXZlbiwgXCJSR0JcIiBjb2xvciBzcGFjZSBpcyBpbXBsaWVkIGFuZCBlYWNoXG4gICAgICogdmFsdWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgZnJvbSAwLjAwIChtaW5pbXVtIGludGVuc2l0eSkgdG8gdG8gMS4wMFxuICAgICAqIChtYXggaW50ZW5zaXR5KSBpZiB2YWx1ZXMgYXJlIGNvbW11bmljYXRlZCBhcyBTdHJpbmcgdHlwZXMsIG9yXG4gICAgICogZnJvbSAwIChtaW4gaW50ZW5zaXR5KSB0byB0byAyNTUgKG1heCBpbnRlbnNpdHkpIGlmIHZhbHVlcyBhcmUgY29tbXVuaWNhdGVkXG4gICAgICogYXMgTnVtYmVyIHR5cGVzLlxuICAgICAqIFRoZSBSR0ItbGlrZSAwLTI1NSByYW5nZSBpcyBwcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIFdoZW4gY2gxLGNoMixjaDMsY2g0IGFyZSBnaXZlbiwgXCJDTVlLXCIgY29sb3Igc3BhY2UgaXMgaW1wbGllZCBhbmQgZWFjaFxuICAgICAqIHZhbHVlIG11c3QgYmUgYSBpbiB0aGUgcmFuZ2UgZnJvbSAwLjAwICgwJSBjb25jZW50cmF0aW9uKSB0byB0b1xuICAgICAqIDEuMDAgKDEwMCUgY29uY2VudHJhdGlvbilcbiAgICAgKlxuICAgICAqIEJlY2F1c2UgSmF2YVNjcmlwdCB0cmVhdHMgZml4ZWQgcG9pbnQgbnVtYmVycyBiYWRseSAocm91bmRzIHRvXG4gICAgICogZmxvYXRpbmcgcG9pbnQgbmVhcmVzdCB0byBiaW5hcnkgcmVwcmVzZW50YXRpb24pIGl0IGlzIGhpZ2hseSBhZHZpc2VkIHRvXG4gICAgICogY29tbXVuaWNhdGUgdGhlIGZyYWN0aW9uYWwgbnVtYmVycyBhcyBTdHJpbmcgdHlwZXMsIG5vdCBKYXZhU2NyaXB0IE51bWJlciB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaDEgQ29sb3IgY2hhbm5lbCB2YWx1ZSBvciB7c3RyaW5nfSBjaDEgY29sb3IgdmFsdWUgaW4gaGV4YWRlY2ltYWwsIGV4YW1wbGU6ICcjRkZGRkZGJy5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoMiBDb2xvciBjaGFubmVsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2gzIENvbG9yIGNoYW5uZWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaDQgQ29sb3IgY2hhbm5lbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBzZXRUZXh0Q29sb3JcbiAgICAgKi9cblxuXG4gICAgdmFyIHNldFRleHRDb2xvciA9IEFQSS5fX3ByaXZhdGVfXy5zZXRUZXh0Q29sb3IgPSBBUEkuc2V0VGV4dENvbG9yID0gZnVuY3Rpb24gKGNoMSwgY2gyLCBjaDMsIGNoNCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIFwiY2gxXCI6IGNoMSxcbiAgICAgICAgXCJjaDJcIjogY2gyLFxuICAgICAgICBcImNoM1wiOiBjaDMsXG4gICAgICAgIFwiY2g0XCI6IGNoNCxcbiAgICAgICAgXCJwZGZDb2xvclR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgICAgIFwicHJlY2lzaW9uXCI6IDNcbiAgICAgIH07XG4gICAgICB0ZXh0Q29sb3IgPSBlbmNvZGVDb2xvclN0cmluZyhvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgYWN0aXZlQ2hhclNwYWNlID0gb3B0aW9ucy5jaGFyU3BhY2UgfHwgMDtcbiAgICAvKipcbiAgICAgKiBHZXQgZ2xvYmFsIHZhbHVlIG9mIENoYXJTcGFjZS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGNoYXJTcGFjZVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIGdldENoYXJTcGFjZVxuICAgICAqL1xuXG4gICAgdmFyIGdldENoYXJTcGFjZSA9IEFQSS5fX3ByaXZhdGVfXy5nZXRDaGFyU3BhY2UgPSBBUEkuZ2V0Q2hhclNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZUNoYXJTcGFjZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBnbG9iYWwgdmFsdWUgb2YgQ2hhclNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJTcGFjZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn0ganNQREYtaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBzZXRDaGFyU3BhY2VcbiAgICAgKi9cblxuXG4gICAgdmFyIHNldENoYXJTcGFjZSA9IEFQSS5fX3ByaXZhdGVfXy5zZXRDaGFyU3BhY2UgPSBBUEkuc2V0Q2hhclNwYWNlID0gZnVuY3Rpb24gKGNoYXJTcGFjZSkge1xuICAgICAgaWYgKGlzTmFOKGNoYXJTcGFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5zZXRDaGFyU3BhY2UnKTtcbiAgICAgIH1cblxuICAgICAgYWN0aXZlQ2hhclNwYWNlID0gY2hhclNwYWNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBsaW5lQ2FwSUQgPSAwO1xuICAgIC8qKlxuICAgICAqIElzIGFuIE9iamVjdCBwcm92aWRpbmcgYSBtYXBwaW5nIGZyb20gaHVtYW4tcmVhZGFibGUgdG9cbiAgICAgKiBpbnRlZ2VyIGZsYWcgdmFsdWVzIGRlc2lnbmF0aW5nIHRoZSB2YXJpZXRpZXMgb2YgbGluZSBjYXBcbiAgICAgKiBhbmQgam9pbiBzdHlsZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBDYXBKb2luU3R5bGVzXG4gICAgICovXG5cbiAgICBBUEkuQ2FwSm9pblN0eWxlcyA9IHtcbiAgICAgIDA6IDAsXG4gICAgICAnYnV0dCc6IDAsXG4gICAgICAnYnV0JzogMCxcbiAgICAgICdtaXRlcic6IDAsXG4gICAgICAxOiAxLFxuICAgICAgJ3JvdW5kJzogMSxcbiAgICAgICdyb3VuZGVkJzogMSxcbiAgICAgICdjaXJjbGUnOiAxLFxuICAgICAgMjogMixcbiAgICAgICdwcm9qZWN0aW5nJzogMixcbiAgICAgICdwcm9qZWN0JzogMixcbiAgICAgICdzcXVhcmUnOiAyLFxuICAgICAgJ2JldmVsJzogMlxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGluZSBjYXAgc3R5bGVzLlxuICAgICAqIFNlZSB7anNQREYuQ2FwSm9pblN0eWxlc30gZm9yIHZhcmlhbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzdHlsZSBBIHN0cmluZyBvciBudW1iZXIgaWRlbnRpZnlpbmcgdGhlIHR5cGUgb2YgbGluZSBjYXAuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2pzUERGfVxuICAgICAqIEBtZW1iZXJPZiBqc1BERlxuICAgICAqIEBuYW1lIHNldExpbmVDYXBcbiAgICAgKi9cblxuICAgIHZhciBzZXRMaW5lQ2FwID0gQVBJLl9fcHJpdmF0ZV9fLnNldExpbmVDYXAgPSBBUEkuc2V0TGluZUNhcCA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgdmFyIGlkID0gQVBJLkNhcEpvaW5TdHlsZXNbc3R5bGVdO1xuXG4gICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaW5lIGNhcCBzdHlsZSBvZiAnXCIgKyBzdHlsZSArIFwiJyBpcyBub3QgcmVjb2duaXplZC4gU2VlIG9yIGV4dGVuZCAuQ2FwSm9pblN0eWxlcyBwcm9wZXJ0eSBmb3IgdmFsaWQgc3R5bGVzXCIpO1xuICAgICAgfVxuXG4gICAgICBsaW5lQ2FwSUQgPSBpZDtcbiAgICAgIG91dChpZCArICcgSicpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBsaW5lSm9pbklEID0gMDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaW5lIGpvaW4gc3R5bGVzLlxuICAgICAqIFNlZSB7anNQREYuQ2FwSm9pblN0eWxlc30gZm9yIHZhcmlhbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzdHlsZSBBIHN0cmluZyBvciBudW1iZXIgaWRlbnRpZnlpbmcgdGhlIHR5cGUgb2YgbGluZSBqb2luLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtqc1BERn1cbiAgICAgKiBAbWVtYmVyT2YganNQREZcbiAgICAgKiBAbmFtZSBzZXRMaW5lSm9pblxuICAgICAqL1xuXG4gICAgdmFyIHNldExpbmVKb2luID0gQVBJLl9fcHJpdmF0ZV9fLnNldExpbmVKb2luID0gQVBJLnNldExpbmVKb2luID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICB2YXIgaWQgPSBBUEkuQ2FwSm9pblN0eWxlc1tzdHlsZV07XG5cbiAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxpbmUgam9pbiBzdHlsZSBvZiAnXCIgKyBzdHlsZSArIFwiJyBpcyBub3QgcmVjb2duaXplZC4gU2VlIG9yIGV4dGVuZCAuQ2FwSm9pblN0eWxlcyBwcm9wZXJ0eSBmb3IgdmFsaWQgc3R5bGVzXCIpO1xuICAgICAgfVxuXG4gICAgICBsaW5lSm9pbklEID0gaWQ7XG4gICAgICBvdXQoaWQgKyAnIGonKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgbWl0ZXJMaW1pdDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtaXRlckxpbWl0IHByb3BlcnR5LCB3aGljaCBlZmZlY3RzIHRoZSBtYXhpbXVtIG1pdGVyIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgbWl0ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7anNQREZ9XG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgc2V0TWl0ZXJMaW1pdFxuICAgICAqL1xuXG4gICAgdmFyIHNldE1pdGVyTGltaXQgPSBBUEkuX19wcml2YXRlX18uc2V0TWl0ZXJMaW1pdCA9IEFQSS5zZXRNaXRlckxpbWl0ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHx8IDA7XG5cbiAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuc2V0TWl0ZXJMaW1pdCcpO1xuICAgICAgfVxuXG4gICAgICBtaXRlckxpbWl0ID0gcGFyc2VGbG9hdChmMihsZW5ndGggKiBrKSk7XG4gICAgICBvdXQobWl0ZXJMaW1pdCArICcgTScpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlcyBhcyBQREYgZG9jdW1lbnQuIEFuIGFsaWFzIG9mIGpzUERGLm91dHB1dCgnc2F2ZScsICdmaWxlbmFtZS5wZGYnKS5cbiAgICAgKiBVc2VzIEZpbGVTYXZlci5qcy1tZXRob2Qgc2F2ZUFzLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIGpzUERGXG4gICAgICogQG5hbWUgc2F2ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIGluY2x1ZGluZyBleHRlbnNpb24uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIEFuIE9iamVjdCB3aXRoIGFkZGl0aW9uYWwgb3B0aW9ucywgcG9zc2libGUgb3B0aW9uczogJ3JldHVyblByb21pc2UnLlxuICAgICAqIEByZXR1cm5zIHtqc1BERn0ganNQREYtaW5zdGFuY2VcbiAgICAgKi9cblxuXG4gICAgQVBJLnNhdmUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUgfHwgJ2dlbmVyYXRlZC5wZGYnO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLnJldHVyblByb21pc2UgPSBvcHRpb25zLnJldHVyblByb21pc2UgfHwgZmFsc2U7XG5cbiAgICAgIGlmIChvcHRpb25zLnJldHVyblByb21pc2UgPT09IGZhbHNlKSB7XG4gICAgICAgIHNhdmVBcyhnZXRCbG9iKGJ1aWxkRG9jdW1lbnQoKSksIGZpbGVuYW1lKTtcblxuICAgICAgICBpZiAodHlwZW9mIHNhdmVBcy51bmxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAoZ2xvYmFsLnNldFRpbWVvdXQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoc2F2ZUFzLnVubG9hZCwgOTExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzYXZlQXMoZ2V0QmxvYihidWlsZERvY3VtZW50KCkpLCBmaWxlbmFtZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2F2ZUFzLnVubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBpZiAoZ2xvYmFsLnNldFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHNhdmVBcy51bmxvYWQsIDkxMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTsgLy8gYXBwbHlpbmcgcGx1Z2lucyAobW9yZSBtZXRob2RzKSBPTiBUT1Agb2YgYnVpbHQtaW4gQVBJLlxuICAgIC8vIHRoaXMgaXMgaW50ZW50aW9uYWwgYXMgd2UgYWxsb3cgcGx1Z2lucyB0byBvdmVycmlkZVxuICAgIC8vIGJ1aWx0LWluc1xuXG5cbiAgICBmb3IgKHZhciBwbHVnaW4gaW4ganNQREYuQVBJKSB7XG4gICAgICBpZiAoanNQREYuQVBJLmhhc093blByb3BlcnR5KHBsdWdpbikpIHtcbiAgICAgICAgaWYgKHBsdWdpbiA9PT0gJ2V2ZW50cycgJiYganNQREYuQVBJLmV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKGV2ZW50cywgbmV3RXZlbnRzKSB7XG4gICAgICAgICAgICAvLyBqc1BERi5BUEkuZXZlbnRzIGlzIGEgSlMgQXJyYXkgb2YgQXJyYXlzXG4gICAgICAgICAgICAvLyB3aGVyZSBlYWNoIEFycmF5IGlzIGEgcGFpciBvZiBldmVudCBuYW1lLCBoYW5kbGVyXG4gICAgICAgICAgICAvLyBFdmVudHMgd2VyZSBhZGRlZCBieSBwbHVnaW5zIHRvIHRoZSBqc1BERiBpbnN0YW50aWF0b3IuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgYWx3YXlzIGFkZGVkIHRvIHRoZSBuZXcgaW5zdGFuY2UgYW5kIHNvbWUgcmFuXG4gICAgICAgICAgICAvLyBkdXJpbmcgaW5zdGFudGlhdGlvbi5cbiAgICAgICAgICAgIHZhciBldmVudG5hbWUsIGhhbmRsZXJfYW5kX2FyZ3MsIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IG5ld0V2ZW50cy5sZW5ndGggLSAxOyBpICE9PSAtMTsgaS0tKSB7XG4gICAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0YWtlcyAzIGFyZ3M6ICd0b3BpYycsIGZ1bmN0aW9uLCBydW5vbmNlX2ZsYWdcbiAgICAgICAgICAgICAgLy8gaWYgdW5kZWZpbmVkLCBydW5vbmNlIGlzIGZhbHNlLlxuICAgICAgICAgICAgICAvLyB1c2VycyBjYW4gYXR0YWNoIGNhbGxiYWNrIGRpcmVjdGx5LFxuICAgICAgICAgICAgICAvLyBvciB0aGV5IGNhbiBhdHRhY2ggYW4gYXJyYXkgd2l0aCBbY2FsbGJhY2ssIHJ1bm9uY2VfZmxhZ11cbiAgICAgICAgICAgICAgLy8gdGhhdCdzIHdoYXQgdGhlIFwiYXBwbHlcIiBtYWdpYyBpcyBmb3IgYmVsb3cuXG4gICAgICAgICAgICAgIGV2ZW50bmFtZSA9IG5ld0V2ZW50c1tpXVswXTtcbiAgICAgICAgICAgICAgaGFuZGxlcl9hbmRfYXJncyA9IG5ld0V2ZW50c1tpXVsxXTtcbiAgICAgICAgICAgICAgZXZlbnRzLnN1YnNjcmliZS5hcHBseShldmVudHMsIFtldmVudG5hbWVdLmNvbmNhdCh0eXBlb2YgaGFuZGxlcl9hbmRfYXJncyA9PT0gJ2Z1bmN0aW9uJyA/IFtoYW5kbGVyX2FuZF9hcmdzXSA6IGhhbmRsZXJfYW5kX2FyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KShldmVudHMsIGpzUERGLkFQSS5ldmVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFQSVtwbHVnaW5dID0ganNQREYuQVBJW3BsdWdpbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT2JqZWN0IGV4cG9zaW5nIGludGVybmFsIEFQSSB0byBwbHVnaW5zXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuXG4gICAgQVBJLmludGVybmFsID0ge1xuICAgICAgJ3BkZkVzY2FwZSc6IHBkZkVzY2FwZSxcbiAgICAgICdnZXRTdHlsZSc6IGdldFN0eWxlLFxuICAgICAgJ2dldEZvbnQnOiBmdW5jdGlvbiBnZXRGb250KCkge1xuICAgICAgICByZXR1cm4gZm9udHNbX2dldEZvbnQuYXBwbHkoQVBJLCBhcmd1bWVudHMpXTtcbiAgICAgIH0sXG4gICAgICAnZ2V0Rm9udFNpemUnOiBnZXRGb250U2l6ZSxcbiAgICAgICdnZXRDaGFyU3BhY2UnOiBnZXRDaGFyU3BhY2UsXG4gICAgICAnZ2V0VGV4dENvbG9yJzogZ2V0VGV4dENvbG9yLFxuICAgICAgJ2dldExpbmVIZWlnaHQnOiBnZXRMaW5lSGVpZ2h0LFxuICAgICAgJ2dldExpbmVIZWlnaHRGYWN0b3InOiBnZXRMaW5lSGVpZ2h0RmFjdG9yLFxuICAgICAgJ3dyaXRlJzogd3JpdGUsXG4gICAgICAnZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUnOiBnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSxcbiAgICAgICdnZXRWZXJ0aWNhbENvb3JkaW5hdGUnOiBnZXRWZXJ0aWNhbENvb3JkaW5hdGUsXG4gICAgICAnZ2V0Q29vcmRpbmF0ZVN0cmluZyc6IGdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nLFxuICAgICAgJ2dldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZyc6IGdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZyxcbiAgICAgICdjb2xsZWN0aW9ucyc6IHt9LFxuICAgICAgJ25ld09iamVjdCc6IG5ld09iamVjdCxcbiAgICAgICduZXdBZGRpdGlvbmFsT2JqZWN0JzogbmV3QWRkaXRpb25hbE9iamVjdCxcbiAgICAgICduZXdPYmplY3REZWZlcnJlZCc6IG5ld09iamVjdERlZmVycmVkLFxuICAgICAgJ25ld09iamVjdERlZmVycmVkQmVnaW4nOiBuZXdPYmplY3REZWZlcnJlZEJlZ2luLFxuICAgICAgJ2dldEZpbHRlcnMnOiBnZXRGaWx0ZXJzLFxuICAgICAgJ3B1dFN0cmVhbSc6IHB1dFN0cmVhbSxcbiAgICAgICdldmVudHMnOiBldmVudHMsXG4gICAgICAvLyByYXRpbyB0aGF0IHlvdSB1c2UgaW4gbXVsdGlwbGljYXRpb24gb2YgYSBnaXZlbiBcInNpemVcIiBudW1iZXIgdG8gYXJyaXZlIHRvICdwb2ludCdcbiAgICAgIC8vIHVuaXRzIG9mIG1lYXN1cmVtZW50LlxuICAgICAgLy8gc2NhbGVGYWN0b3IgaXMgc2V0IGF0IGluaXRpYWxpemF0aW9uIG9mIHRoZSBkb2N1bWVudCBhbmQgY2FsY3VsYXRlZCBhZ2FpbnN0IHRoZSBzdGF0ZWRcbiAgICAgIC8vIGRlZmF1bHQgbWVhc3VyZW1lbnQgdW5pdHMgZm9yIHRoZSBkb2N1bWVudC5cbiAgICAgIC8vIElmIGRlZmF1bHQgaXMgXCJtbVwiLCBrIGlzIHRoZSBudW1iZXIgdGhhdCB3aWxsIHR1cm4gbnVtYmVyIGluICdtbScgaW50byAncG9pbnRzJyBudW1iZXIuXG4gICAgICAvLyB0aHJvdWdoIG11bHRpcGxpY2F0aW9uLlxuICAgICAgJ3NjYWxlRmFjdG9yJzogayxcbiAgICAgICdwYWdlU2l6ZSc6IHtcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uIGdldFdpZHRoKCkge1xuICAgICAgICAgIHJldHVybiAocGFnZXNDb250ZXh0W2N1cnJlbnRQYWdlXS5tZWRpYUJveC50b3BSaWdodFggLSBwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm1lZGlhQm94LmJvdHRvbUxlZnRYKSAvIGs7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbiBzZXRXaWR0aCh2YWx1ZSkge1xuICAgICAgICAgIHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3gudG9wUmlnaHRYID0gdmFsdWUgKiBrICsgcGFnZXNDb250ZXh0W2N1cnJlbnRQYWdlXS5tZWRpYUJveC5ib3R0b21MZWZ0WDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgcmV0dXJuIChwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm1lZGlhQm94LnRvcFJpZ2h0WSAtIHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3guYm90dG9tTGVmdFkpIC8gaztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbiBzZXRIZWlnaHQodmFsdWUpIHtcbiAgICAgICAgICBwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm1lZGlhQm94LnRvcFJpZ2h0WSA9IHZhbHVlICogayArIHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3guYm90dG9tTGVmdFk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnb3V0cHV0Jzogb3V0cHV0LFxuICAgICAgJ2dldE51bWJlck9mUGFnZXMnOiBnZXROdW1iZXJPZlBhZ2VzLFxuICAgICAgJ3BhZ2VzJzogcGFnZXMsXG4gICAgICAnb3V0Jzogb3V0LFxuICAgICAgJ2YyJzogZjIsXG4gICAgICAnZjMnOiBmMyxcbiAgICAgICdnZXRQYWdlSW5mbyc6IGdldFBhZ2VJbmZvLFxuICAgICAgJ2dldFBhZ2VJbmZvQnlPYmpJZCc6IGdldFBhZ2VJbmZvQnlPYmpJZCxcbiAgICAgICdnZXRDdXJyZW50UGFnZUluZm8nOiBnZXRDdXJyZW50UGFnZUluZm8sXG4gICAgICAnZ2V0UERGVmVyc2lvbic6IGdldFBkZlZlcnNpb24sXG4gICAgICAnaGFzSG90Zml4JzogaGFzSG90Zml4IC8vRXhwb3NlIHRoZSBoYXNIb3RmaXggY2hlY2sgc28gcGx1Z2lucyBjYW4gYWxzbyBjaGVjayB0aGVtLlxuXG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQVBJLmludGVybmFsLnBhZ2VTaXplLCAnd2lkdGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIChwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm1lZGlhQm94LnRvcFJpZ2h0WCAtIHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3guYm90dG9tTGVmdFgpIC8gaztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm1lZGlhQm94LnRvcFJpZ2h0WCA9IHZhbHVlICogayArIHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3guYm90dG9tTGVmdFg7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBUEkuaW50ZXJuYWwucGFnZVNpemUsICdoZWlnaHQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIChwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm1lZGlhQm94LnRvcFJpZ2h0WSAtIHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3guYm90dG9tTGVmdFkpIC8gaztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBwYWdlc0NvbnRleHRbY3VycmVudFBhZ2VdLm1lZGlhQm94LnRvcFJpZ2h0WSA9IHZhbHVlICogayArIHBhZ2VzQ29udGV4dFtjdXJyZW50UGFnZV0ubWVkaWFCb3guYm90dG9tTGVmdFk7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBjb250aW51aW5nIGluaXRpYWxpemF0aW9uIG9mIGpzUERGIERvY3VtZW50IG9iamVjdFxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEFkZCB0aGUgZmlyc3QgcGFnZSBhdXRvbWF0aWNhbGx5XG5cbiAgICBhZGRGb250cyhzdGFuZGFyZEZvbnRzKTtcbiAgICBhY3RpdmVGb250S2V5ID0gJ0YxJztcblxuICAgIF9hZGRQYWdlKGZvcm1hdCwgb3JpZW50YXRpb24pO1xuXG4gICAgZXZlbnRzLnB1Ymxpc2goJ2luaXRpYWxpemVkJyk7XG4gICAgcmV0dXJuIEFQSTtcbiAgfVxuICAvKipcbiAgICoganNQREYuQVBJIGlzIGEgU1RBVElDIHByb3BlcnR5IG9mIGpzUERGIGNsYXNzLlxuICAgKiBqc1BERi5BUEkgaXMgYW4gb2JqZWN0IHlvdSBjYW4gYWRkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdG8uXG4gICAqIFRoZSBtZXRob2RzIC8gcHJvcGVydGllcyB5b3UgYWRkIHdpbGwgc2hvdyB1cCBpbiBuZXcganNQREYgb2JqZWN0cy5cbiAgICpcbiAgICogT25lIHByb3BlcnR5IGlzIHByZXBvcHVsYXRlZC4gSXQgaXMgdGhlICdldmVudHMnIE9iamVjdC4gUGx1Z2luIGF1dGhvcnMgY2FuIGFkZCB0b3BpY3MsXG4gICAqIGNhbGxiYWNrcyB0byB0aGlzIG9iamVjdC4gVGhlc2Ugd2lsbCBiZSByZWFzc2lnbmVkIHRvIGFsbCBuZXcgaW5zdGFuY2VzIG9mIGpzUERGLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBwdWJsaWNcbiAgICogQG1lbWJlck9mIGpzUERGXG4gICAqIEBuYW1lIEFQSVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBqc1BERi5BUEkubXltZXRob2QgPSBmdW5jdGlvbigpe1xuICAgKiAgIC8vICd0aGlzJyB3aWxsIGJlIHJlZiB0byBpbnRlcm5hbCBBUEkgb2JqZWN0LiBzZWUganNQREYgc291cmNlXG4gICAqICAgLy8gLCBzbyB5b3UgY2FuIHJlZmVyIHRvIGJ1aWx0LWluIG1ldGhvZHMgbGlrZSBzbzpcbiAgICogICAvLyAgICAgdGhpcy5saW5lKC4uLi4pXG4gICAqICAgLy8gICAgIHRoaXMudGV4dCguLi4uKVxuICAgKiB9XG4gICAqIHZhciBwZGZkb2MgPSBuZXcganNQREYoKVxuICAgKiBwZGZkb2MubXltZXRob2QoKSAvLyA8LSAhISEhISFcbiAgICovXG5cblxuICBqc1BERi5BUEkgPSB7XG4gICAgZXZlbnRzOiBbXVxuICB9O1xuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YganNQREYuXG4gICAqIEBuYW1lIHZlcnNpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlck9mIGpzUERGXG4gICAqL1xuXG4gIGpzUERGLnZlcnNpb24gPSAnMS41LjMnO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ2pzUERGJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGpzUERGO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqc1BERjtcbiAgICBtb2R1bGUuZXhwb3J0cy5qc1BERiA9IGpzUERGO1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbC5qc1BERiA9IGpzUERGO1xuICB9XG5cbiAgcmV0dXJuIGpzUERGO1xufSh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93IHx8IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgJiYgdGhpcy5jb250ZW50JykoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpKTsgLy8gYHNlbGZgIGlzIHVuZGVmaW5lZCBpbiBGaXJlZm94IGZvciBBbmRyb2lkIGNvbnRlbnQgc2NyaXB0IGNvbnRleHRcbi8vIHdoaWxlIGB0aGlzYCBpcyBuc0lDb250ZW50RnJhbWVNZXNzYWdlTWFuYWdlclxuLy8gd2l0aCBhbiBhdHRyaWJ1dGUgYGNvbnRlbnRgIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHdpbmRvd1xuXG4vKnJvbGx1cC1rZWVwZXItc3RhcnQqL1xuXG5cbndpbmRvdy50bXAgPSBqc1BERjtcbi8qcm9sbHVwLWtlZXBlci1lbmQqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgQWxleGFuZGVyIFdlaWR0LFxuICogaHR0cHM6Ly9naXRodWIuY29tL0JpZ2dBOTRcbiAqIFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqL1xuXG4vKiogXG4qIGpzUERGIEFjcm9Gb3JtIFBsdWdpblxuKiBAbW9kdWxlIEFjcm9Gb3JtXG4qL1xuKGZ1bmN0aW9uIChqc1BERkFQSSwgZ2xvYmFsT2JqKSB7XG5cbiAgdmFyIHNjb3BlO1xuICB2YXIgc2NhbGVGYWN0b3IgPSAxO1xuXG4gIHZhciBwZGZFc2NhcGUgPSBmdW5jdGlvbiBwZGZFc2NhcGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cXCgvZywgJ1xcXFwoJykucmVwbGFjZSgvXFwpL2csICdcXFxcKScpO1xuICB9O1xuXG4gIHZhciBwZGZVbmVzY2FwZSA9IGZ1bmN0aW9uIHBkZlVuZXNjYXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJykucmVwbGFjZSgvXFxcXFxcKC9nLCAnKCcpLnJlcGxhY2UoL1xcXFxcXCkvZywgJyknKTtcbiAgfTtcblxuICB2YXIgZjIgPSBmdW5jdGlvbiBmMihudW1iZXIpIHtcbiAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5mMicpO1xuICAgIH1cblxuICAgIHJldHVybiBudW1iZXIudG9GaXhlZCgyKTsgLy8gSWUsICUuMmZcbiAgfTtcblxuICB2YXIgZjUgPSBmdW5jdGlvbiBmNShudW1iZXIpIHtcbiAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5mMicpO1xuICAgIH1cblxuICAgIHJldHVybiBudW1iZXIudG9GaXhlZCg1KTsgLy8gSWUsICUuMmZcbiAgfTtcblxuICBqc1BERkFQSS5fX2Fjcm9mb3JtX18gPSB7fTtcblxuICB2YXIgaW5oZXJpdCA9IGZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgICBjaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgfTtcblxuICB2YXIgc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggKiBzY2FsZUZhY3RvcjtcbiAgfTtcblxuICB2YXIgYW50aVNjYWxlID0gZnVuY3Rpb24gYW50aVNjYWxlKHgpIHtcbiAgICByZXR1cm4geCAvIHNjYWxlRmFjdG9yO1xuICB9O1xuXG4gIHZhciBjcmVhdGVGb3JtWE9iamVjdCA9IGZ1bmN0aW9uIGNyZWF0ZUZvcm1YT2JqZWN0KGZvcm1PYmplY3QpIHtcbiAgICB2YXIgeG9iaiA9IG5ldyBBY3JvRm9ybVhPYmplY3QoKTtcbiAgICB2YXIgaGVpZ2h0ID0gQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldEhlaWdodChmb3JtT2JqZWN0KSB8fCAwO1xuICAgIHZhciB3aWR0aCA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRXaWR0aChmb3JtT2JqZWN0KSB8fCAwO1xuICAgIHhvYmouQkJveCA9IFswLCAwLCBOdW1iZXIoZjIod2lkdGgpKSwgTnVtYmVyKGYyKGhlaWdodCkpXTtcbiAgICByZXR1cm4geG9iajtcbiAgfTtcbiAgLyoqXG4gICogQml0LU9wZXJhdGlvbnNcbiAgKi9cblxuXG4gIHZhciBzZXRCaXQgPSBqc1BERkFQSS5fX2Fjcm9mb3JtX18uc2V0Qml0ID0gZnVuY3Rpb24gKG51bWJlciwgYml0UG9zaXRpb24pIHtcbiAgICBudW1iZXIgPSBudW1iZXIgfHwgMDtcbiAgICBiaXRQb3NpdGlvbiA9IGJpdFBvc2l0aW9uIHx8IDA7XG5cbiAgICBpZiAoaXNOYU4obnVtYmVyKSB8fCBpc05hTihiaXRQb3NpdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLkFQSS5fX2Fjcm9mb3JtX18uc2V0Qml0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGJpdE1hc2sgPSAxIDw8IGJpdFBvc2l0aW9uO1xuICAgIG51bWJlciB8PSBiaXRNYXNrO1xuICAgIHJldHVybiBudW1iZXI7XG4gIH07XG5cbiAgdmFyIGNsZWFyQml0ID0ganNQREZBUEkuX19hY3JvZm9ybV9fLmNsZWFyQml0ID0gZnVuY3Rpb24gKG51bWJlciwgYml0UG9zaXRpb24pIHtcbiAgICBudW1iZXIgPSBudW1iZXIgfHwgMDtcbiAgICBiaXRQb3NpdGlvbiA9IGJpdFBvc2l0aW9uIHx8IDA7XG5cbiAgICBpZiAoaXNOYU4obnVtYmVyKSB8fCBpc05hTihiaXRQb3NpdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLkFQSS5fX2Fjcm9mb3JtX18uY2xlYXJCaXQnKTtcbiAgICB9XG5cbiAgICB2YXIgYml0TWFzayA9IDEgPDwgYml0UG9zaXRpb247XG4gICAgbnVtYmVyICY9IH5iaXRNYXNrO1xuICAgIHJldHVybiBudW1iZXI7XG4gIH07XG5cbiAgdmFyIGdldEJpdCA9IGpzUERGQVBJLl9fYWNyb2Zvcm1fXy5nZXRCaXQgPSBmdW5jdGlvbiAobnVtYmVyLCBiaXRQb3NpdGlvbikge1xuICAgIGlmIChpc05hTihudW1iZXIpIHx8IGlzTmFOKGJpdFBvc2l0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuQVBJLl9fYWNyb2Zvcm1fXy5nZXRCaXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKG51bWJlciAmIDEgPDwgYml0UG9zaXRpb24pID09PSAwID8gMCA6IDE7XG4gIH07XG4gIC8qXG4gICogRmYgc3RhcnRzIGNvdW50aW5nIHRoZSBiaXQgcG9zaXRpb24gYXQgMSBhbmQgbm90IGxpa2UgamF2YXNjcmlwdCBhdCAwXG4gICovXG5cblxuICB2YXIgZ2V0Qml0Rm9yUGRmID0ganNQREZBUEkuX19hY3JvZm9ybV9fLmdldEJpdEZvclBkZiA9IGZ1bmN0aW9uIChudW1iZXIsIGJpdFBvc2l0aW9uKSB7XG4gICAgaWYgKGlzTmFOKG51bWJlcikgfHwgaXNOYU4oYml0UG9zaXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5BUEkuX19hY3JvZm9ybV9fLmdldEJpdEZvclBkZicpO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRCaXQobnVtYmVyLCBiaXRQb3NpdGlvbiAtIDEpO1xuICB9O1xuXG4gIHZhciBzZXRCaXRGb3JQZGYgPSBqc1BERkFQSS5fX2Fjcm9mb3JtX18uc2V0Qml0Rm9yUGRmID0gZnVuY3Rpb24gKG51bWJlciwgYml0UG9zaXRpb24pIHtcbiAgICBpZiAoaXNOYU4obnVtYmVyKSB8fCBpc05hTihiaXRQb3NpdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLkFQSS5fX2Fjcm9mb3JtX18uc2V0Qml0Rm9yUGRmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldEJpdChudW1iZXIsIGJpdFBvc2l0aW9uIC0gMSk7XG4gIH07XG5cbiAgdmFyIGNsZWFyQml0Rm9yUGRmID0ganNQREZBUEkuX19hY3JvZm9ybV9fLmNsZWFyQml0Rm9yUGRmID0gZnVuY3Rpb24gKG51bWJlciwgYml0UG9zaXRpb24sIHZhbHVlKSB7XG4gICAgaWYgKGlzTmFOKG51bWJlcikgfHwgaXNOYU4oYml0UG9zaXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5BUEkuX19hY3JvZm9ybV9fLmNsZWFyQml0Rm9yUGRmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsZWFyQml0KG51bWJlciwgYml0UG9zaXRpb24gLSAxKTtcbiAgfTtcblxuICB2YXIgY2FsY3VsYXRlQ29vcmRpbmF0ZXMgPSBqc1BERkFQSS5fX2Fjcm9mb3JtX18uY2FsY3VsYXRlQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSA9IHRoaXMuaW50ZXJuYWwuZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGU7XG4gICAgdmFyIGdldFZlcnRpY2FsQ29vcmRpbmF0ZSA9IHRoaXMuaW50ZXJuYWwuZ2V0VmVydGljYWxDb29yZGluYXRlO1xuICAgIHZhciB4ID0gYXJnc1swXTtcbiAgICB2YXIgeSA9IGFyZ3NbMV07XG4gICAgdmFyIHcgPSBhcmdzWzJdO1xuICAgIHZhciBoID0gYXJnc1szXTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSB7fTtcbiAgICBjb29yZGluYXRlcy5sb3dlckxlZnRfWCA9IGdldEhvcml6b250YWxDb29yZGluYXRlKHgpIHx8IDA7XG4gICAgY29vcmRpbmF0ZXMubG93ZXJMZWZ0X1kgPSBnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeSArIGgpIHx8IDA7XG4gICAgY29vcmRpbmF0ZXMudXBwZXJSaWdodF9YID0gZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUoeCArIHcpIHx8IDA7XG4gICAgY29vcmRpbmF0ZXMudXBwZXJSaWdodF9ZID0gZ2V0VmVydGljYWxDb29yZGluYXRlKHkpIHx8IDA7XG4gICAgcmV0dXJuIFtOdW1iZXIoZjIoY29vcmRpbmF0ZXMubG93ZXJMZWZ0X1gpKSwgTnVtYmVyKGYyKGNvb3JkaW5hdGVzLmxvd2VyTGVmdF9ZKSksIE51bWJlcihmMihjb29yZGluYXRlcy51cHBlclJpZ2h0X1gpKSwgTnVtYmVyKGYyKGNvb3JkaW5hdGVzLnVwcGVyUmlnaHRfWSkpXTtcbiAgfTtcblxuICB2YXIgY2FsY3VsYXRlQXBwZWFyYW5jZVN0cmVhbSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUFwcGVhcmFuY2VTdHJlYW0oZm9ybU9iamVjdCkge1xuICAgIGlmIChmb3JtT2JqZWN0LmFwcGVhcmFuY2VTdHJlYW1Db250ZW50KSB7XG4gICAgICByZXR1cm4gZm9ybU9iamVjdC5hcHBlYXJhbmNlU3RyZWFtQ29udGVudDtcbiAgICB9XG5cbiAgICBpZiAoIWZvcm1PYmplY3QuViAmJiAhZm9ybU9iamVjdC5EVikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZWxzZSBjYWxjdWxhdGUgaXRcblxuXG4gICAgdmFyIHN0cmVhbSA9IFtdO1xuICAgIHZhciB0ZXh0ID0gZm9ybU9iamVjdC5WIHx8IGZvcm1PYmplY3QuRFY7XG4gICAgdmFyIGNhbGNSZXMgPSBjYWxjdWxhdGVYKGZvcm1PYmplY3QsIHRleHQpO1xuICAgIHZhciBmb250S2V5ID0gc2NvcGUuaW50ZXJuYWwuZ2V0Rm9udChmb3JtT2JqZWN0LmZvbnROYW1lLCBmb3JtT2JqZWN0LmZvbnRTdHlsZSkuaWQ7IC8vUERGIDMyMDAwLTE6MjAwOCwgcGFnZSA0NDRcblxuICAgIHN0cmVhbS5wdXNoKCcvVHggQk1DJyk7XG4gICAgc3RyZWFtLnB1c2goJ3EnKTtcbiAgICBzdHJlYW0ucHVzaCgnQlQnKTsgLy8gQmVnaW4gVGV4dFxuXG4gICAgc3RyZWFtLnB1c2goc2NvcGUuX19wcml2YXRlX18uZW5jb2RlQ29sb3JTdHJpbmcoZm9ybU9iamVjdC5jb2xvcikpO1xuICAgIHN0cmVhbS5wdXNoKCcvJyArIGZvbnRLZXkgKyAnICcgKyBmMihjYWxjUmVzLmZvbnRTaXplKSArICcgVGYnKTtcbiAgICBzdHJlYW0ucHVzaCgnMSAwIDAgMSAwIDAgVG0nKTsgLy8gVHJhbnNmb3JtYXRpb24gTWF0cml4XG5cbiAgICBzdHJlYW0ucHVzaChjYWxjUmVzLnRleHQpO1xuICAgIHN0cmVhbS5wdXNoKCdFVCcpOyAvLyBFbmQgVGV4dCAgICBcblxuICAgIHN0cmVhbS5wdXNoKCdRJyk7XG4gICAgc3RyZWFtLnB1c2goJ0VNQycpO1xuICAgIHZhciBhcHBlYXJhbmNlU3RyZWFtQ29udGVudCA9IG5ldyBjcmVhdGVGb3JtWE9iamVjdChmb3JtT2JqZWN0KTtcbiAgICBhcHBlYXJhbmNlU3RyZWFtQ29udGVudC5zdHJlYW0gPSBzdHJlYW0uam9pbihcIlxcblwiKTtcbiAgICByZXR1cm4gYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQ7XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZVggPSBmdW5jdGlvbiBjYWxjdWxhdGVYKGZvcm1PYmplY3QsIHRleHQpIHtcbiAgICB2YXIgbWF4Rm9udFNpemUgPSBmb3JtT2JqZWN0Lm1heEZvbnRTaXplIHx8IDEyO1xuICAgIHZhciBmb250ID0gZm9ybU9iamVjdC5mb250TmFtZTtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSB7XG4gICAgICB0ZXh0OiBcIlwiLFxuICAgICAgZm9udFNpemU6IFwiXCJcbiAgICB9OyAvLyBSZW1vdmUgQnJhY2tldHNcblxuICAgIHRleHQgPSB0ZXh0LnN1YnN0cigwLCAxKSA9PSAnKCcgPyB0ZXh0LnN1YnN0cigxKSA6IHRleHQ7XG4gICAgdGV4dCA9IHRleHQuc3Vic3RyKHRleHQubGVuZ3RoIC0gMSkgPT0gJyknID8gdGV4dC5zdWJzdHIoMCwgdGV4dC5sZW5ndGggLSAxKSA6IHRleHQ7IC8vIHNwbGl0IGludG8gYXJyYXkgb2Ygd29yZHNcblxuICAgIHZhciB0ZXh0U3BsaXQgPSB0ZXh0LnNwbGl0KCcgJyk7XG5cbiAgICB2YXIgY29sb3IgPSBzY29wZS5fX3ByaXZhdGVfXy5lbmNvZGVDb2xvclN0cmluZyhmb3JtT2JqZWN0LmNvbG9yKTtcblxuICAgIHZhciBmb250U2l6ZSA9IG1heEZvbnRTaXplOyAvLyBUaGUgU3RhcnRpbmcgZm9udFNpemUgKFRoZSBNYXhpbXVtKVxuXG4gICAgdmFyIGxpbmVTcGFjaW5nID0gMjtcbiAgICB2YXIgYm9yZGVyUGFkZGluZyA9IDI7XG4gICAgdmFyIGhlaWdodCA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRIZWlnaHQoZm9ybU9iamVjdCkgfHwgMDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgPCAwID8gLWhlaWdodCA6IGhlaWdodDtcbiAgICB2YXIgd2lkdGggPSBBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0V2lkdGgoZm9ybU9iamVjdCkgfHwgMDtcbiAgICB3aWR0aCA9IHdpZHRoIDwgMCA/IC13aWR0aCA6IHdpZHRoO1xuXG4gICAgdmFyIGlzU21hbGxlclRoYW5XaWR0aCA9IGZ1bmN0aW9uIGlzU21hbGxlclRoYW5XaWR0aChpLCBsYXN0TGluZSwgZm9udFNpemUpIHtcbiAgICAgIGlmIChpICsgMSA8IHRleHRTcGxpdC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHRtcCA9IGxhc3RMaW5lICsgXCIgXCIgKyB0ZXh0U3BsaXRbaSArIDFdO1xuICAgICAgICB2YXIgVGV4dFdpZHRoID0gY2FsY3VsYXRlRm9udFNwYWNlKHRtcCwgZm9ybU9iamVjdCwgZm9udFNpemUpLndpZHRoO1xuICAgICAgICB2YXIgRmllbGRXaWR0aCA9IHdpZHRoIC0gMiAqIGJvcmRlclBhZGRpbmc7XG4gICAgICAgIHJldHVybiBUZXh0V2lkdGggPD0gRmllbGRXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9udFNpemUrKztcblxuICAgIEZvbnRTaXplOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHRleHQgPSBcIlwiO1xuICAgICAgZm9udFNpemUtLTtcbiAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gY2FsY3VsYXRlRm9udFNwYWNlKFwiM1wiLCBmb3JtT2JqZWN0LCBmb250U2l6ZSkuaGVpZ2h0O1xuICAgICAgdmFyIHN0YXJ0WSA9IGZvcm1PYmplY3QubXVsdGlsaW5lID8gaGVpZ2h0IC0gZm9udFNpemUgOiAoaGVpZ2h0IC0gdGV4dEhlaWdodCkgLyAyO1xuICAgICAgc3RhcnRZICs9IGxpbmVTcGFjaW5nO1xuICAgICAgdmFyIHN0YXJ0WCA9IC1ib3JkZXJQYWRkaW5nO1xuICAgICAgdmFyIGxhc3RZID0gc3RhcnRZO1xuICAgICAgdmFyIGZpcnN0V29yZEluTGluZSA9IDAsXG4gICAgICAgICAgbGFzdFdvcmRJbkxpbmUgPSAwO1xuICAgICAgdmFyIGxhc3RMZW5ndGggPSAwO1xuXG4gICAgICBpZiAoZm9udFNpemUgPD0gMCkge1xuICAgICAgICAvLyBJbiBjYXNlLCB0aGUgVGV4dCBkb2Vzbid0IGZpdCBhdCBhbGxcbiAgICAgICAgZm9udFNpemUgPSAxMjtcbiAgICAgICAgdGV4dCA9IFwiKC4uLikgVGpcXG5cIjtcbiAgICAgICAgdGV4dCArPSBcIiUgV2lkdGggb2YgVGV4dDogXCIgKyBjYWxjdWxhdGVGb250U3BhY2UodGV4dCwgZm9ybU9iamVjdCwgZm9udFNpemUpLndpZHRoICsgXCIsIEZpZWxkV2lkdGg6XCIgKyB3aWR0aCArIFwiXFxuXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsYXN0TGVuZ3RoID0gY2FsY3VsYXRlRm9udFNwYWNlKHRleHRTcGxpdFswXSArIFwiIFwiLCBmb3JtT2JqZWN0LCBmb250U2l6ZSkud2lkdGg7XG4gICAgICB2YXIgbGFzdExpbmUgPSBcIlwiO1xuICAgICAgdmFyIGxpbmVDb3VudCA9IDA7XG5cbiAgICAgIExpbmU6IGZvciAodmFyIGkgaW4gdGV4dFNwbGl0KSB7XG4gICAgICAgIGlmICh0ZXh0U3BsaXQuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBsYXN0TGluZSArPSB0ZXh0U3BsaXRbaV0gKyBcIiBcIjsgLy8gUmVtb3ZlIGxhc3QgYmxhbmtcblxuICAgICAgICAgIGxhc3RMaW5lID0gbGFzdExpbmUuc3Vic3RyKGxhc3RMaW5lLmxlbmd0aCAtIDEpID09IFwiIFwiID8gbGFzdExpbmUuc3Vic3RyKDAsIGxhc3RMaW5lLmxlbmd0aCAtIDEpIDogbGFzdExpbmU7XG4gICAgICAgICAgdmFyIGtleSA9IHBhcnNlSW50KGkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBjYWxjdWxhdGVGb250U3BhY2UobGFzdExpbmUgKyBcIiBcIiwgZm9ybU9iamVjdCwgZm9udFNpemUpLndpZHRoO1xuICAgICAgICAgIHZhciBuZXh0TGluZUlzU21hbGxlciA9IGlzU21hbGxlclRoYW5XaWR0aChrZXksIGxhc3RMaW5lLCBmb250U2l6ZSk7XG4gICAgICAgICAgdmFyIGlzTGFzdFdvcmQgPSBpID49IHRleHRTcGxpdC5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgaWYgKG5leHRMaW5lSXNTbWFsbGVyICYmICFpc0xhc3RXb3JkKSB7XG4gICAgICAgICAgICBsYXN0TGluZSArPSBcIiBcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBMaW5lXG4gICAgICAgICAgfSBlbHNlIGlmICghbmV4dExpbmVJc1NtYWxsZXIgJiYgIWlzTGFzdFdvcmQpIHtcbiAgICAgICAgICAgIGlmICghZm9ybU9iamVjdC5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgY29udGludWUgRm9udFNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoKHRleHRIZWlnaHQgKyBsaW5lU3BhY2luZykgKiAobGluZUNvdW50ICsgMikgKyBsaW5lU3BhY2luZyA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBUZXh0IGlzIGhpZ2hlciB0aGFuIHRoZVxuICAgICAgICAgICAgICAgIC8vIEZpZWxkT2JqZWN0XG4gICAgICAgICAgICAgICAgY29udGludWUgRm9udFNpemU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsYXN0V29yZEluTGluZSA9IGtleTsgLy8gZ28gb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTGFzdFdvcmQpIHtcbiAgICAgICAgICAgIGxhc3RXb3JkSW5MaW5lID0ga2V5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybU9iamVjdC5tdWx0aWxpbmUgJiYgKHRleHRIZWlnaHQgKyBsaW5lU3BhY2luZykgKiAobGluZUNvdW50ICsgMikgKyBsaW5lU3BhY2luZyA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgVGV4dCBpcyBoaWdoZXIgdGhhbiB0aGUgRmllbGRPYmplY3RcbiAgICAgICAgICAgICAgY29udGludWUgRm9udFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxpbmUgPSAnJztcblxuICAgICAgICAgIGZvciAodmFyIHggPSBmaXJzdFdvcmRJbkxpbmU7IHggPD0gbGFzdFdvcmRJbkxpbmU7IHgrKykge1xuICAgICAgICAgICAgbGluZSArPSB0ZXh0U3BsaXRbeF0gKyAnICc7XG4gICAgICAgICAgfSAvLyBSZW1vdmUgbGFzdCBibGFua1xuXG5cbiAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIobGluZS5sZW5ndGggLSAxKSA9PSBcIiBcIiA/IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gMSkgOiBsaW5lOyAvLyBsYXN0TGVuZ3RoIC09IGJsYW5rU3BhY2Uud2lkdGg7XG5cbiAgICAgICAgICBsYXN0TGVuZ3RoID0gY2FsY3VsYXRlRm9udFNwYWNlKGxpbmUsIGZvcm1PYmplY3QsIGZvbnRTaXplKS53aWR0aDsgLy8gQ2FsY3VsYXRlIHN0YXJ0WFxuXG4gICAgICAgICAgc3dpdGNoIChmb3JtT2JqZWN0LnRleHRBbGlnbikge1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICBzdGFydFggPSB3aWR0aCAtIGxhc3RMZW5ndGggLSBib3JkZXJQYWRkaW5nO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgc3RhcnRYID0gKHdpZHRoIC0gbGFzdExlbmd0aCkgLyAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzdGFydFggPSBib3JkZXJQYWRkaW5nO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ZXh0ICs9IGYyKHN0YXJ0WCkgKyAnICcgKyBmMihsYXN0WSkgKyAnIFRkXFxuJztcbiAgICAgICAgICB0ZXh0ICs9ICcoJyArIHBkZkVzY2FwZShsaW5lKSArICcpIFRqXFxuJzsgLy8gcmVzZXQgWCBpbiBQREZcblxuICAgICAgICAgIHRleHQgKz0gLWYyKHN0YXJ0WCkgKyAnIDAgVGRcXG4nOyAvLyBBZnRlciBhIExpbmUsIGFkanVzdCB5IHBvc2l0aW9uXG5cbiAgICAgICAgICBsYXN0WSA9IC0oZm9udFNpemUgKyBsaW5lU3BhY2luZyk7XG5cbiAgICAgICAgICBsYXN0TGVuZ3RoID0gMDtcbiAgICAgICAgICBmaXJzdFdvcmRJbkxpbmUgPSBsYXN0V29yZEluTGluZSArIDE7XG4gICAgICAgICAgbGluZUNvdW50Kys7XG4gICAgICAgICAgbGFzdExpbmUgPSBcIlwiO1xuICAgICAgICAgIGNvbnRpbnVlIExpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuVmFsdWUudGV4dCA9IHRleHQ7XG4gICAgcmV0dXJuVmFsdWUuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH07XG4gIC8qKlxuICAqIFNtYWxsIHdvcmthcm91bmQgZm9yIGNhbGN1bGF0aW5nIHRoZSBUZXh0TWV0cmljIGFwcHJveGltYXRlbHkuXG4gICogXG4gICogQHBhcmFtIHRleHRcbiAgKiBAcGFyYW0gZm9udHNpemVcbiAgKiBAcmV0dXJucyB7VGV4dE1ldHJpY3N9IChIYXMgSGVpZ2h0IGFuZCBXaWR0aClcbiAgKi9cblxuXG4gIHZhciBjYWxjdWxhdGVGb250U3BhY2UgPSBmdW5jdGlvbiBjYWxjdWxhdGVGb250U3BhY2UodGV4dCwgZm9ybU9iamVjdCwgZm9udFNpemUpIHtcbiAgICB2YXIgZm9udCA9IHNjb3BlLmludGVybmFsLmdldEZvbnQoZm9ybU9iamVjdC5mb250TmFtZSwgZm9ybU9iamVjdC5mb250U3R5bGUpO1xuICAgIHZhciB3aWR0aCA9IHNjb3BlLmdldFN0cmluZ1VuaXRXaWR0aCh0ZXh0LCB7XG4gICAgICBmb250OiBmb250LFxuICAgICAgZm9udFNpemU6IHBhcnNlRmxvYXQoZm9udFNpemUpLFxuICAgICAgY2hhclNwYWNlOiAwXG4gICAgfSkgKiBwYXJzZUZsb2F0KGZvbnRTaXplKTtcbiAgICB2YXIgaGVpZ2h0ID0gc2NvcGUuZ2V0U3RyaW5nVW5pdFdpZHRoKFwiM1wiLCB7XG4gICAgICBmb250OiBmb250LFxuICAgICAgZm9udFNpemU6IHBhcnNlRmxvYXQoZm9udFNpemUpLFxuICAgICAgY2hhclNwYWNlOiAwXG4gICAgfSkgKiBwYXJzZUZsb2F0KGZvbnRTaXplKSAqIDEuNTtcbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB3aWR0aDogd2lkdGhcbiAgICB9O1xuICB9O1xuXG4gIHZhciBhY3JvZm9ybVBsdWdpblRlbXBsYXRlID0ge1xuICAgIGZpZWxkczogW10sXG4gICAgeEZvcm1zOiBbXSxcblxuICAgIC8qKlxuICAgICogYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgQWNyb0Zvcm1cbiAgICAqIERpY3Rpb25hcnkgMDogVGhlIEV2ZW50LVRva2VuLCB0aGUgQWNyb0Zvcm1EaWN0aW9uYXJ5Q2FsbGJhY2sgaGFzXG4gICAgKiAxOiBUaGUgT2JqZWN0IElEIG9mIHRoZSBSb290XG4gICAgKi9cbiAgICBhY3JvRm9ybURpY3Rpb25hcnlSb290OiBudWxsLFxuXG4gICAgLyoqXG4gICAgKiBBZnRlciB0aGUgUERGIGdldHMgZXZhbHVhdGVkLCB0aGUgcmVmZXJlbmNlIHRvIHRoZSByb290IGhhcyB0byBiZVxuICAgICogcmVzZXQsIHRoaXMgaW5kaWNhdGVzLCB3aGV0aGVyIHRoZSByb290IGhhcyBhbHJlYWR5IGJlZW4gcHJpbnRlZFxuICAgICogb3V0XG4gICAgKi9cbiAgICBwcmludGVkT3V0OiBmYWxzZSxcbiAgICBpbnRlcm5hbDogbnVsbCxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9O1xuXG4gIHZhciBhbm5vdFJlZmVyZW5jZUNhbGxiYWNrID0gZnVuY3Rpb24gYW5ub3RSZWZlcmVuY2VDYWxsYmFjaygpIHtcbiAgICAvL3NldCBvYmpJZCB0byB1bmRlZmluZWQgYW5kIGZvcmNlIGl0IHRvIGdldCBhIG5ldyBvYmpJZCBvbiBidWlsZERvY3VtZW50XG4gICAgc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5vYmpJZCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZmllbGRzID0gc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5GaWVsZHM7XG5cbiAgICBmb3IgKHZhciBpIGluIGZpZWxkcykge1xuICAgICAgaWYgKGZpZWxkcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICB2YXIgZm9ybU9iamVjdCA9IGZpZWxkc1tpXTsgLy9zZXQgb2JqSWQgdG8gdW5kZWZpbmVkIGFuZCBmb3JjZSBpdCB0byBnZXQgYSBuZXcgb2JqSWQgb24gYnVpbGREb2N1bWVudFxuXG4gICAgICAgIGZvcm1PYmplY3Qub2JqSWQgPSB1bmRlZmluZWQ7IC8vIGFkZCBBbm5vdCBSZWZlcmVuY2UhXG5cbiAgICAgICAgaWYgKGZvcm1PYmplY3QuaGFzQW5ub3RhdGlvbikge1xuICAgICAgICAgIC8vIElmIHRoZXJlcyBhbiBBbm5vdGF0aW9uIFdpZGdldCBpbiB0aGUgRm9ybSBPYmplY3QsIHB1dCB0aGVcbiAgICAgICAgICAvLyBSZWZlcmVuY2UgaW4gdGhlIC9Bbm5vdCBhcnJheVxuICAgICAgICAgIGNyZWF0ZUFubm90YXRpb25SZWZlcmVuY2UuY2FsbChzY29wZSwgZm9ybU9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHB1dEZvcm0gPSBmdW5jdGlvbiBwdXRGb3JtKGZvcm1PYmplY3QpIHtcbiAgICBpZiAoc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ucHJpbnRlZE91dCkge1xuICAgICAgc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ucHJpbnRlZE91dCA9IGZhbHNlO1xuICAgICAgc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290KSB7XG4gICAgICBpbml0aWFsaXplQWNyb0Zvcm0uY2FsbChzY29wZSk7XG4gICAgfVxuXG4gICAgc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5GaWVsZHMucHVzaChmb3JtT2JqZWN0KTtcbiAgfTtcbiAgLyoqXG4gICogQ3JlYXRlIHRoZSBSZWZlcmVuY2UgdG8gdGhlIHdpZGdldEFubm90YXRpb24sIHNvIHRoYXQgaXQgZ2V0cyByZWZlcmVuY2VkXG4gICogaW4gdGhlIEFubm90W10gaW50IHRoZSsgKFJlcXVpcmVzIHRoZSBBbm5vdGF0aW9uIFBsdWdpbilcbiAgKi9cblxuXG4gIHZhciBjcmVhdGVBbm5vdGF0aW9uUmVmZXJlbmNlID0gZnVuY3Rpb24gY3JlYXRlQW5ub3RhdGlvblJlZmVyZW5jZShvYmplY3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdyZWZlcmVuY2UnLFxuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9O1xuXG4gICAgdmFyIGZpbmRFbnRyeSA9IGZ1bmN0aW9uIGZpbmRFbnRyeShlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LnR5cGUgPT09IG9wdGlvbnMudHlwZSAmJiBlbnRyeS5vYmplY3QgPT09IG9wdGlvbnMub2JqZWN0O1xuICAgIH07XG5cbiAgICBpZiAoc2NvcGUuaW50ZXJuYWwuZ2V0UGFnZUluZm8ob2JqZWN0LnBhZ2UpLnBhZ2VDb250ZXh0LmFubm90YXRpb25zLmZpbmQoZmluZEVudHJ5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY29wZS5pbnRlcm5hbC5nZXRQYWdlSW5mbyhvYmplY3QucGFnZSkucGFnZUNvbnRleHQuYW5ub3RhdGlvbnMucHVzaChvcHRpb25zKTtcbiAgICB9XG4gIH07IC8vIENhbGxiYWNrc1xuXG5cbiAgdmFyIHB1dENhdGFsb2dDYWxsYmFjayA9IGZ1bmN0aW9uIHB1dENhdGFsb2dDYWxsYmFjaygpIHtcbiAgICAvLyBQdXQgcmVmZXJlbmNlIHRvIEFjcm9Gb3JtIHRvIERvY3VtZW50Q2F0YWxvZ1xuICAgIGlmICh0eXBlb2Ygc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZm9yIHNhZmV0eSwgc2hvdWxkbid0IG5vcm1hbGx5IGJlIHRoZSBjYXNlXG4gICAgICBzY29wZS5pbnRlcm5hbC53cml0ZSgnL0Fjcm9Gb3JtICcgKyBzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290Lm9iaklkICsgJyAnICsgMCArICcgUicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1dENhdGFsb2dDYWxsYmFjazogUm9vdCBtaXNzaW5nLicpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICogQWRkcyAvQWNyb2Zvcm0gWCAwIFIgdG8gRG9jdW1lbnQgQ2F0YWxvZywgYW5kIGNyZWF0ZXMgdGhlIEFjcm9Gb3JtXG4gICogRGljdGlvbmFyeVxuICAqL1xuXG5cbiAgdmFyIEFjcm9Gb3JtRGljdGlvbmFyeUNhbGxiYWNrID0gZnVuY3Rpb24gQWNyb0Zvcm1EaWN0aW9uYXJ5Q2FsbGJhY2soKSB7XG4gICAgLy8gUmVtb3ZlIGV2ZW50XG4gICAgc2NvcGUuaW50ZXJuYWwuZXZlbnRzLnVuc3Vic2NyaWJlKHNjb3BlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3QuX2V2ZW50SUQpO1xuICAgIGRlbGV0ZSBzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290Ll9ldmVudElEO1xuICAgIHNjb3BlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLnByaW50ZWRPdXQgPSB0cnVlO1xuICB9O1xuICAvKipcbiAgKiBDcmVhdGVzIHRoZSBzaW5nbGUgRmllbGRzIGFuZCB3cml0ZXMgdGhlbSBpbnRvIHRoZSBEb2N1bWVudFxuICAqIFxuICAqIElmIGZpZWxkQXJyYXkgaXMgc2V0LCB1c2UgdGhlIGZpZWxkcyB0aGF0IGFyZSBpbnNpZGUgaXQgaW5zdGVhZCBvZiB0aGVcbiAgKiBmaWVsZHMgZnJvbSB0aGUgQWNyb1Jvb3QgKGZvciB0aGUgRm9ybVhPYmplY3RzLi4uKVxuICAqL1xuXG5cbiAgdmFyIGNyZWF0ZUZpZWxkQ2FsbGJhY2sgPSBmdW5jdGlvbiBjcmVhdGVGaWVsZENhbGxiYWNrKGZpZWxkQXJyYXkpIHtcbiAgICB2YXIgc3RhbmRhcmRGaWVsZHMgPSAhZmllbGRBcnJheTtcblxuICAgIGlmICghZmllbGRBcnJheSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBmaWVsZEFycmF5IHNwZWNpZmllZCwgd2Ugd2FudCB0byBwcmludCBvdXRcbiAgICAgIC8vIHRoZSBGaWVsZHMgb2YgdGhlIEFjcm9Gb3JtXG4gICAgICAvLyBQcmludCBvdXQgUm9vdFxuICAgICAgc2NvcGUuaW50ZXJuYWwubmV3T2JqZWN0RGVmZXJyZWRCZWdpbihzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290Lm9iaklkLCB0cnVlKTtcbiAgICAgIHNjb3BlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3QucHV0U3RyZWFtKCk7XG4gICAgfVxuXG4gICAgdmFyIGZpZWxkQXJyYXkgPSBmaWVsZEFycmF5IHx8IHNjb3BlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3QuS2lkcztcblxuICAgIGZvciAodmFyIGkgaW4gZmllbGRBcnJheSkge1xuICAgICAgaWYgKGZpZWxkQXJyYXkuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdmFyIGZpZWxkT2JqZWN0ID0gZmllbGRBcnJheVtpXTtcbiAgICAgICAgdmFyIGtleVZhbHVlTGlzdCA9IFtdO1xuICAgICAgICB2YXIgb2xkUmVjdCA9IGZpZWxkT2JqZWN0LlJlY3Q7XG5cbiAgICAgICAgaWYgKGZpZWxkT2JqZWN0LlJlY3QpIHtcbiAgICAgICAgICBmaWVsZE9iamVjdC5SZWN0ID0gY2FsY3VsYXRlQ29vcmRpbmF0ZXMuY2FsbCh0aGlzLCBmaWVsZE9iamVjdC5SZWN0KTtcbiAgICAgICAgfSAvLyBTdGFydCBXcml0aW5nIHRoZSBPYmplY3RcblxuXG4gICAgICAgIHNjb3BlLmludGVybmFsLm5ld09iamVjdERlZmVycmVkQmVnaW4oZmllbGRPYmplY3Qub2JqSWQsIHRydWUpO1xuICAgICAgICBmaWVsZE9iamVjdC5EQSA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5jcmVhdGVEZWZhdWx0QXBwZWFyYW5jZVN0cmVhbShmaWVsZE9iamVjdCk7XG5cbiAgICAgICAgaWYgKF90eXBlb2YoZmllbGRPYmplY3QpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBmaWVsZE9iamVjdC5nZXRLZXlWYWx1ZUxpc3RGb3JTdHJlYW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGtleVZhbHVlTGlzdCA9IGZpZWxkT2JqZWN0LmdldEtleVZhbHVlTGlzdEZvclN0cmVhbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmllbGRPYmplY3QuUmVjdCA9IG9sZFJlY3Q7XG5cbiAgICAgICAgaWYgKGZpZWxkT2JqZWN0Lmhhc0FwcGVhcmFuY2VTdHJlYW0gJiYgIWZpZWxkT2JqZWN0LmFwcGVhcmFuY2VTdHJlYW1Db250ZW50KSB7XG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIEFwcGVhcmFuY2VcbiAgICAgICAgICB2YXIgYXBwZWFyYW5jZSA9IGNhbGN1bGF0ZUFwcGVhcmFuY2VTdHJlYW0uY2FsbCh0aGlzLCBmaWVsZE9iamVjdCk7XG4gICAgICAgICAga2V5VmFsdWVMaXN0LnB1c2goe1xuICAgICAgICAgICAga2V5OiAnQVAnLFxuICAgICAgICAgICAgdmFsdWU6IFwiPDwvTiBcIiArIGFwcGVhcmFuY2UgKyBcIj4+XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi54Rm9ybXMucHVzaChhcHBlYXJhbmNlKTtcbiAgICAgICAgfSAvLyBBc3N1bWUgQXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQgaXMgYSBBcnJheSB3aXRoIE4sUixEIChhdCBsZWFzdFxuICAgICAgICAvLyBvbmUgb2YgdGhlbSEpXG5cblxuICAgICAgICBpZiAoZmllbGRPYmplY3QuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQpIHtcbiAgICAgICAgICB2YXIgYXBwZWFyYW5jZVN0cmVhbVN0cmluZyA9IFwiXCI7IC8vIEl0ZXJhdGUgb3ZlciBOLFIgYW5kIERcblxuICAgICAgICAgIGZvciAodmFyIGsgaW4gZmllbGRPYmplY3QuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZE9iamVjdC5hcHBlYXJhbmNlU3RyZWFtQ29udGVudC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmaWVsZE9iamVjdC5hcHBlYXJhbmNlU3RyZWFtQ29udGVudFtrXTtcbiAgICAgICAgICAgICAgYXBwZWFyYW5jZVN0cmVhbVN0cmluZyArPSBcIi9cIiArIGsgKyBcIiBcIjtcbiAgICAgICAgICAgICAgYXBwZWFyYW5jZVN0cmVhbVN0cmluZyArPSBcIjw8XCI7XG5cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPj0gMSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIGFwcGVhcmFuY2VTdHJlYW0gaXMgYW4gQXJyYXkgb3IgT2JqZWN0IVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gdmFsdWVbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBGdW5jdGlvbiBpcyByZWZlcmVuY2VkLCBjYWxsIGl0IGluIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdG8gZ2V0IHRoZSBGb3JtWE9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jYWxsKHRoaXMsIGZpZWxkT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFwcGVhcmFuY2VTdHJlYW1TdHJpbmcgKz0gXCIvXCIgKyBpICsgXCIgXCIgKyBvYmogKyBcIiBcIjsgLy8gSW4gY2FzZSB0aGUgWEZvcm0gaXMgYWxyZWFkeSB1c2VkLCBlLmcuIE9mZlN0YXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIENoZWNrQm94ZXMsIGRvbid0IGFkZCBpdFxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHNjb3BlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLnhGb3Jtcy5pbmRleE9mKG9iaikgPj0gMCkpIHNjb3BlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLnhGb3Jtcy5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBGdW5jdGlvbiBpcyByZWZlcmVuY2VkLCBjYWxsIGl0IGluIG9yZGVyIHRvXG4gICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIEZvcm1YT2JqZWN0XG4gICAgICAgICAgICAgICAgICBvYmogPSBvYmouY2FsbCh0aGlzLCBmaWVsZE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXBwZWFyYW5jZVN0cmVhbVN0cmluZyArPSBcIi9cIiArIGkgKyBcIiBcIiArIG9iajtcbiAgICAgICAgICAgICAgICBpZiAoIShzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi54Rm9ybXMuaW5kZXhPZihvYmopID49IDApKSBzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi54Rm9ybXMucHVzaChvYmopO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYXBwZWFyYW5jZVN0cmVhbVN0cmluZyArPSBcIj4+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBhcHBlYXJhbmNlIHN0cmVhbSBpcyBhIG5vcm1hbCBPYmplY3QuLlxuXG5cbiAgICAgICAgICBrZXlWYWx1ZUxpc3QucHVzaCh7XG4gICAgICAgICAgICBrZXk6ICdBUCcsXG4gICAgICAgICAgICB2YWx1ZTogXCI8PFxcblwiICsgYXBwZWFyYW5jZVN0cmVhbVN0cmluZyArIFwiPj5cIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUuaW50ZXJuYWwucHV0U3RyZWFtKHtcbiAgICAgICAgICBhZGRpdGlvbmFsS2V5VmFsdWVzOiBrZXlWYWx1ZUxpc3RcbiAgICAgICAgfSk7XG4gICAgICAgIHNjb3BlLmludGVybmFsLm91dChcImVuZG9ialwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhbmRhcmRGaWVsZHMpIHtcbiAgICAgIGNyZWF0ZVhGb3JtT2JqZWN0Q2FsbGJhY2suY2FsbCh0aGlzLCBzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi54Rm9ybXMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlWEZvcm1PYmplY3RDYWxsYmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVhGb3JtT2JqZWN0Q2FsbGJhY2soZmllbGRBcnJheSkge1xuICAgIGZvciAodmFyIGkgaW4gZmllbGRBcnJheSkge1xuICAgICAgaWYgKGZpZWxkQXJyYXkuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdmFyIGtleSA9IGk7XG4gICAgICAgIHZhciBmaWVsZE9iamVjdCA9IGZpZWxkQXJyYXlbaV07IC8vIFN0YXJ0IFdyaXRpbmcgdGhlIE9iamVjdFxuXG4gICAgICAgIHNjb3BlLmludGVybmFsLm5ld09iamVjdERlZmVycmVkQmVnaW4oZmllbGRPYmplY3QgJiYgZmllbGRPYmplY3Qub2JqSWQsIHRydWUpO1xuXG4gICAgICAgIGlmIChfdHlwZW9mKGZpZWxkT2JqZWN0KSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZmllbGRPYmplY3QucHV0U3RyZWFtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBmaWVsZE9iamVjdC5wdXRTdHJlYW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBmaWVsZEFycmF5W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsaXplQWNyb0Zvcm0gPSBmdW5jdGlvbiBpbml0aWFsaXplQWNyb0Zvcm0oKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJuYWwgIT09IHVuZGVmaW5lZCAmJiAodGhpcy5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uaXNJbml0aWFsaXplZCA9PT0gZmFsc2UpKSB7XG4gICAgICBzY29wZSA9IHRoaXM7XG4gICAgICBBY3JvRm9ybUZpZWxkLkZpZWxkTnVtID0gMDtcbiAgICAgIHRoaXMuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFjcm9mb3JtUGx1Z2luVGVtcGxhdGUpKTtcblxuICAgICAgaWYgKHRoaXMuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGNlcHRpb24gd2hpbGUgY3JlYXRpbmcgQWNyb2Zvcm1EaWN0aW9uYXJ5XCIpO1xuICAgICAgfVxuXG4gICAgICBzY2FsZUZhY3RvciA9IHNjb3BlLmludGVybmFsLnNjYWxlRmFjdG9yOyAvLyBUaGUgT2JqZWN0IE51bWJlciBvZiB0aGUgQWNyb0Zvcm0gRGljdGlvbmFyeVxuXG4gICAgICBzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290ID0gbmV3IEFjcm9Gb3JtRGljdGlvbmFyeSgpOyAvLyBhZGQgQ2FsbGJhY2sgZm9yIGNyZWF0aW5nIHRoZSBBY3JvRm9ybSBEaWN0aW9uYXJ5XG5cbiAgICAgIHNjb3BlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3QuX2V2ZW50SUQgPSBzY29wZS5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCdwb3N0UHV0UmVzb3VyY2VzJywgQWNyb0Zvcm1EaWN0aW9uYXJ5Q2FsbGJhY2spO1xuICAgICAgc2NvcGUuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgnYnVpbGREb2N1bWVudCcsIGFubm90UmVmZXJlbmNlQ2FsbGJhY2spOyAvLyBidWlsZERvY3VtZW50XG4gICAgICAvLyBSZWdpc3RlciBldmVudCwgdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgRG9jdW1lbnRDYXRhbG9nIGlzXG4gICAgICAvLyB3cml0dGVuLCBpbiBvcmRlciB0byBhZGQgL0Fjcm9Gb3JtXG5cbiAgICAgIHNjb3BlLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoJ3B1dENhdGFsb2cnLCBwdXRDYXRhbG9nQ2FsbGJhY2spOyAvLyBSZWdpc3RlciBldmVudCwgdGhhdCBjcmVhdGVzIGFsbCBGaWVsZHNcblxuICAgICAgc2NvcGUuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgncG9zdFB1dFBhZ2VzJywgY3JlYXRlRmllbGRDYWxsYmFjayk7XG4gICAgICBzY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH07IC8vUERGIDMyMDAwLTE6MjAwOCwgcGFnZSAyNiwgNy4zLjZcblxuXG4gIHZhciBhcnJheVRvUGRmQXJyYXkgPSBqc1BERkFQSS5fX2Fjcm9mb3JtX18uYXJyYXlUb1BkZkFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICB2YXIgY29udGVudCA9ICdbJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgIGNvbnRlbnQgKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChfdHlwZW9mKGFycmF5W2ldKSkge1xuICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYXJyYXlbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGlmIChhcnJheVtpXS5zdWJzdHIoMCwgMSkgIT09ICcvJykge1xuICAgICAgICAgICAgICBjb250ZW50ICs9ICcoJyArIHBkZkVzY2FwZShhcnJheVtpXS50b1N0cmluZygpKSArICcpJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgKz0gYXJyYXlbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSAnXSc7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGpzUERGLl9fYWNyb2Zvcm1fXy5hcnJheVRvUGRmQXJyYXknKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRNYXRjaGVzKHN0cmluZywgcmVnZXgsIGluZGV4KSB7XG4gICAgaW5kZXggfHwgKGluZGV4ID0gMSk7IC8vIGRlZmF1bHQgdG8gdGhlIGZpcnN0IGNhcHR1cmluZyBncm91cFxuXG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgbWF0Y2g7XG5cbiAgICB3aGlsZSAobWF0Y2ggPSByZWdleC5leGVjKHN0cmluZykpIHtcbiAgICAgIG1hdGNoZXMucHVzaChtYXRjaFtpbmRleF0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgdmFyIHBkZkFycmF5VG9TdHJpbmdBcnJheSA9IGZ1bmN0aW9uIHBkZkFycmF5VG9TdHJpbmdBcnJheShhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGlmICh0eXBlb2YgYXJyYXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlc3VsdCA9IGdldE1hdGNoZXMoYXJyYXksIC9cXCgoLio/KVxcKS9nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciB0b1BkZlN0cmluZyA9IGZ1bmN0aW9uIHRvUGRmU3RyaW5nKHN0cmluZykge1xuICAgIHN0cmluZyA9IHN0cmluZyB8fCBcIlwiO1xuICAgIHN0cmluZy50b1N0cmluZygpO1xuICAgIHN0cmluZyA9ICcoJyArIHBkZkVzY2FwZShzdHJpbmcpICsgJyknO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07IC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gIC8vIENsYXNzZXNcbiAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuICAvKipcbiAgKiBAY2xhc3MgQWNyb0Zvcm1QREZPYmplY3RcbiAgKiBAY2xhc3NkZXNjIEEgQWNyb0Zvcm1QREZPYmplY3RcbiAgKi9cblxuXG4gIHZhciBBY3JvRm9ybVBERk9iamVjdCA9IGZ1bmN0aW9uIEFjcm9Gb3JtUERGT2JqZWN0KCkge1xuICAgIHZhciBfb2JqSWQ7XG4gICAgLyoqICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtUERGT2JqZWN0I29iaklkXG4gICAgKiBAdHlwZSB7YW55fVxuICAgICovXG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnb2JqSWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKCFfb2JqSWQpIHtcbiAgICAgICAgICBfb2JqSWQgPSBzY29wZS5pbnRlcm5hbC5uZXdPYmplY3REZWZlcnJlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfb2JqSWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY3JvRm9ybVBERk9iamVjdDogQ291bGRuJ3QgY3JlYXRlIE9iamVjdCBJRFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfb2JqSWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX29iaklkID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAqIEBmdW5jdGlvbiBBY3JvRm9ybVBERk9iamVjdC50b1N0cmluZ1xuICAqL1xuXG5cbiAgQWNyb0Zvcm1QREZPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9iaklkICsgXCIgMCBSXCI7XG4gIH07XG5cbiAgQWNyb0Zvcm1QREZPYmplY3QucHJvdG90eXBlLnB1dFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIga2V5VmFsdWVMaXN0ID0gdGhpcy5nZXRLZXlWYWx1ZUxpc3RGb3JTdHJlYW0oKTtcbiAgICBzY29wZS5pbnRlcm5hbC5wdXRTdHJlYW0oe1xuICAgICAgZGF0YTogdGhpcy5zdHJlYW0sXG4gICAgICBhZGRpdGlvbmFsS2V5VmFsdWVzOiBrZXlWYWx1ZUxpc3RcbiAgICB9KTtcbiAgICBzY29wZS5pbnRlcm5hbC5vdXQoXCJlbmRvYmpcIik7XG4gIH07XG4gIC8qKlxuICAqIFJldHVybnMgYW4ga2V5LXZhbHVlLUxpc3Qgb2YgYWxsIG5vbi1jb25maWd1cmFibGUgVmFyaWFibGVzIGZyb20gdGhlIE9iamVjdFxuICAqIFxuICAqIEBuYW1lIGdldEtleVZhbHVlTGlzdEZvclN0cmVhbVxuICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICovXG5cblxuICBBY3JvRm9ybVBERk9iamVjdC5wcm90b3R5cGUuZ2V0S2V5VmFsdWVMaXN0Rm9yU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjcmVhdGVLZXlWYWx1ZUxpc3RGcm9tRmllbGRPYmplY3QgPSBmdW5jdGlvbiBjcmVhdGVLZXlWYWx1ZUxpc3RGcm9tRmllbGRPYmplY3QoZmllbGRPYmplY3QpIHtcbiAgICAgIHZhciBrZXlWYWx1ZUxpc3QgPSBbXTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZmllbGRPYmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgIT0gJ2NvbnRlbnQnICYmIGtleSAhPSAnYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQnICYmIGtleS5zdWJzdHJpbmcoMCwgMSkgIT0gXCJfXCI7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgaSBpbiBrZXlzKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZpZWxkT2JqZWN0LCBrZXlzW2ldKS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmllbGRPYmplY3Rba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGtleVZhbHVlTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXJyYXlUb1BkZkFycmF5KHZhbHVlKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBY3JvRm9ybVBERk9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBJbiBjYXNlIGl0IGlzIGEgcmVmZXJlbmNlIHRvIGFub3RoZXIgUERGT2JqZWN0LFxuICAgICAgICAgICAgICAvLyB0YWtlIHRoZSByZWZlcmVuY2UgbnVtYmVyXG4gICAgICAgICAgICAgIGtleVZhbHVlTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUub2JqSWQgKyBcIiAwIFJcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAga2V5VmFsdWVMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGtleVZhbHVlTGlzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNyZWF0ZUtleVZhbHVlTGlzdEZyb21GaWVsZE9iamVjdCh0aGlzKTtcbiAgfTtcblxuICB2YXIgQWNyb0Zvcm1YT2JqZWN0ID0gZnVuY3Rpb24gQWNyb0Zvcm1YT2JqZWN0KCkge1xuICAgIEFjcm9Gb3JtUERGT2JqZWN0LmNhbGwodGhpcyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdUeXBlJywge1xuICAgICAgdmFsdWU6IFwiL1hPYmplY3RcIixcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICB3cml0ZWFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ1N1YnR5cGUnLCB7XG4gICAgICB2YWx1ZTogXCIvRm9ybVwiLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRlYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnRm9ybVR5cGUnLCB7XG4gICAgICB2YWx1ZTogMSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICB3cml0ZWFibGU6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgX0JCb3ggPSBbXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ0JCb3gnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGVhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfQkJveDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfQkJveCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnUmVzb3VyY2VzJywge1xuICAgICAgdmFsdWU6IFwiMiAwIFJcIixcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICB3cml0ZWFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciBfc3RyZWFtO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdHJlYW0nLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9zdHJlYW0gPSB2YWx1ZS50cmltKCk7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmIChfc3RyZWFtKSB7XG4gICAgICAgICAgcmV0dXJuIF9zdHJlYW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpbmhlcml0KEFjcm9Gb3JtWE9iamVjdCwgQWNyb0Zvcm1QREZPYmplY3QpO1xuXG4gIHZhciBBY3JvRm9ybURpY3Rpb25hcnkgPSBmdW5jdGlvbiBBY3JvRm9ybURpY3Rpb25hcnkoKSB7XG4gICAgQWNyb0Zvcm1QREZPYmplY3QuY2FsbCh0aGlzKTtcbiAgICB2YXIgX0tpZHMgPSBbXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ0tpZHMnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoX0tpZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBfS2lkcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ0ZpZWxkcycsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX0tpZHM7XG4gICAgICB9XG4gICAgfSk7IC8vIERlZmF1bHQgQXBwZWFyYW5jZVxuXG4gICAgdmFyIF9EQTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnREEnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKCFfREEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJygnICsgX0RBICsgJyknO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9EQSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGluaGVyaXQoQWNyb0Zvcm1EaWN0aW9uYXJ5LCBBY3JvRm9ybVBERk9iamVjdCk7XG4gIC8qKlxuICAqIFRoZSBGaWVsZCBPYmplY3QgY29udGFpbnMgdGhlIFZhcmlhYmxlcywgdGhhdCBldmVyeSBGaWVsZCBuZWVkc1xuICAqIFxuICAqIEBjbGFzcyBBY3JvRm9ybUZpZWxkXG4gICogQGNsYXNzZGVzYyBBbiBBY3JvRm9ybSBGaWVsZE9iamVjdFxuICAqL1xuXG4gIHZhciBBY3JvRm9ybUZpZWxkID0gZnVuY3Rpb24gQWNyb0Zvcm1GaWVsZCgpIHtcbiAgICBBY3JvRm9ybVBERk9iamVjdC5jYWxsKHRoaXMpOyAvL0Fubm90YXRpb24tRmxhZyBTZWUgVGFibGUgMTY1XG5cbiAgICB2YXIgX0YgPSA0O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnRicsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX0Y7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICBfRiA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBmb3IgYXR0cmlidXRlIEYgc3VwcGxpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIChQREYgMS4yKSBJZiBzZXQsIHByaW50IHRoZSBhbm5vdGF0aW9uIHdoZW4gdGhlIHBhZ2UgaXMgcHJpbnRlZC4gSWYgY2xlYXIsIG5ldmVyIHByaW50IHRoZSBhbm5vdGF0aW9uLCByZWdhcmRsZXNzIG9mIHdldGhlciBpcyBpcyBkaXNwbGF5ZWQgb24gdGhlIHNjcmVlbi4gXG4gICAgKiBOT1RFIDIgVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBhbm5vdGF0aW9ucyByZXByZXNlbnRpbmcgaW50ZXJhY3RpdmUgcHVzaGJ1dHRvbnMsIHdoaWNoIHdvdWxkIHNlcnZlIG5vIG1lYW5pbmdmdWwgcHVycG9zZSBvbiB0aGUgcHJpbnRlZCBwYWdlLlxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtRmllbGQjc2hvd1doZW5QcmludGVkXG4gICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzaG93V2hlblByaW50ZWQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGdldEJpdEZvclBkZihfRiwgMykpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuRiA9IHNldEJpdEZvclBkZihfRiwgMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5GID0gY2xlYXJCaXRGb3JQZGYoX0YsIDMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9GZiA9IDA7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdGZicsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX0ZmO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgX0ZmID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGZvciBhdHRyaWJ1dGUgRmYgc3VwcGxpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX1JlY3QgPSBbXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ1JlY3QnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKF9SZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfUmVjdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgX1JlY3QgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfUmVjdCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBUaGUgeC1wb3NpdGlvbiBvZiB0aGUgZmllbGQuXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1GaWVsZCN4XG4gICAgKiBAZGVmYXVsdCBudWxsXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3gnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghX1JlY3QgfHwgaXNOYU4oX1JlY3RbMF0pKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW50aVNjYWxlKF9SZWN0WzBdKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfUmVjdFswXSA9IHNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIFRoZSB5LXBvc2l0aW9uIG9mIHRoZSBmaWVsZC5cbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybUZpZWxkI3lcbiAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAneScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKCFfUmVjdCB8fCBpc05hTihfUmVjdFsxXSkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbnRpU2NhbGUoX1JlY3RbMV0pO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9SZWN0WzFdID0gc2NhbGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogVGhlIHdpZHRoIG9mIHRoZSBmaWVsZC5cbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybUZpZWxkI3dpZHRoXG4gICAgKiBAZGVmYXVsdCBudWxsXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3dpZHRoJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoIV9SZWN0IHx8IGlzTmFOKF9SZWN0WzJdKSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFudGlTY2FsZShfUmVjdFsyXSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX1JlY3RbMl0gPSBzY2FsZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBmaWVsZC5cbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybUZpZWxkI2hlaWdodFxuICAgICogQGRlZmF1bHQgbnVsbFxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoZWlnaHQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghX1JlY3QgfHwgaXNOYU4oX1JlY3RbM10pKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW50aVNjYWxlKF9SZWN0WzNdKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfUmVjdFszXSA9IHNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX0ZUID0gXCJcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ0ZUJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9GVDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnL0J0bic6XG4gICAgICAgICAgY2FzZSAnL1R4JzpcbiAgICAgICAgICBjYXNlICcvQ2gnOlxuICAgICAgICAgIGNhc2UgJy9TaWcnOlxuICAgICAgICAgICAgX0ZUID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgZm9yIGF0dHJpYnV0ZSBGVCBzdXBwbGllZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfVCA9IG51bGw7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdUJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKCFfVCB8fCBfVC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSBvZiBhIENoaWxkIGZyb20gYSBSYWRpb8K0R3JvdXAsIHlvdSBkb24ndCBuZWVkIGEgRmllbGROYW1lXG4gICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBBY3JvRm9ybUNoaWxkQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfVCA9IFwiRmllbGRPYmplY3RcIiArIEFjcm9Gb3JtRmllbGQuRmllbGROdW0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnKCcgKyBwZGZFc2NhcGUoX1QpICsgJyknO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9UID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIChPcHRpb25hbCkgVGhlIHBhcnRpYWwgZmllbGQgbmFtZSAoc2VlIDEyLjcuMy4yLCDigJxGaWVsZCBOYW1lc+KAnSkuXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1GaWVsZCNmaWVsZE5hbWVcbiAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZmllbGROYW1lJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX1Q7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX1QgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2ZvbnROYW1lID0gJ2hlbHZldGljYSc7XG4gICAgLyoqXG4gICAgKiBUaGUgZm9udE5hbWUgb2YgdGhlIGZvbnQgdG8gYmUgdXNlZC5cbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybUZpZWxkI2ZvbnROYW1lXG4gICAgKiBAZGVmYXVsdCAnaGVsdmV0aWNhJ1xuICAgICogQHR5cGUge3N0cmluZ31cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdmb250TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9mb250TmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfZm9udE5hbWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2ZvbnRTdHlsZSA9ICdub3JtYWwnO1xuICAgIC8qKlxuICAgICogVGhlIGZvbnRTdHlsZSBvZiB0aGUgZm9udCB0byBiZSB1c2VkLlxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtRmllbGQjZm9udFN0eWxlXG4gICAgKiBAZGVmYXVsdCAnbm9ybWFsJ1xuICAgICogQHR5cGUge3N0cmluZ31cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdmb250U3R5bGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZm9udFN0eWxlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9mb250U3R5bGUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2ZvbnRTaXplID0gMDtcbiAgICAvKipcbiAgICAqIFRoZSBmb250U2l6ZSBvZiB0aGUgZm9udCB0byBiZSB1c2VkLlxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtRmllbGQjZm9udFNpemVcbiAgICAqIEBkZWZhdWx0IDAgKGZvciBhdXRvKVxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdmb250U2l6ZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGFudGlTY2FsZShfZm9udFNpemUpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9mb250U2l6ZSA9IHNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX21heEZvbnRTaXplID0gNTA7XG4gICAgLyoqXG4gICAgKiBUaGUgbWF4aW11bSBmb250U2l6ZSBvZiB0aGUgZm9udCB0byBiZSB1c2VkLlxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtRmllbGQjbWF4Rm9udFNpemVcbiAgICAqIEBkZWZhdWx0IDAgKGZvciBhdXRvKVxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtYXhGb250U2l6ZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGFudGlTY2FsZShfbWF4Rm9udFNpemUpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9tYXhGb250U2l6ZSA9IHNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2NvbG9yID0gJ2JsYWNrJztcbiAgICAvKipcbiAgICAqIFRoZSBjb2xvciBvZiB0aGUgdGV4dFxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtRmllbGQjY29sb3JcbiAgICAqIEBkZWZhdWx0ICdibGFjaydcbiAgICAqIEB0eXBlIHtzdHJpbmd8cmdiYX1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2xvcicsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9jb2xvcjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfY29sb3IgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX0RBID0gJy9GMSAwIFRmIDAgZyc7IC8vIERlZmluZXMgdGhlIGRlZmF1bHQgYXBwZWFyYW5jZSAoTmVlZGVkIGZvciB2YXJpYWJsZSBUZXh0KVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdEQScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghX0RBIHx8IHRoaXMgaW5zdGFuY2VvZiBBY3JvRm9ybUNoaWxkQ2xhc3MgfHwgdGhpcyBpbnN0YW5jZW9mIEFjcm9Gb3JtVGV4dEZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvUGRmU3RyaW5nKF9EQSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBfREEgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX0RWID0gbnVsbDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ0RWJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghX0RWKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBBY3JvRm9ybUJ1dHRvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdG9QZGZTdHJpbmcoX0RWKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfRFY7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQWNyb0Zvcm1CdXR0b24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLnN1YnN0cigwLCAxKSA9PT0gJygnKSB7XG4gICAgICAgICAgICBfRFYgPSBwZGZVbmVzY2FwZSh2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfRFYgPSBwZGZVbmVzY2FwZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9EViA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiAoT3B0aW9uYWw7IGluaGVyaXRhYmxlKSBUaGUgZGVmYXVsdCB2YWx1ZSB0byB3aGljaCB0aGUgZmllbGQgcmV2ZXJ0cyB3aGVuIGEgcmVzZXQtZm9ybSBhY3Rpb24gaXMgZXhlY3V0ZWQgKHNlZSAxMi43LjUuMywg4oCcUmVzZXQtRm9ybSBBY3Rpb27igJ0pLiBUaGUgZm9ybWF0IG9mIHRoaXMgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhhdCBvZiB2YWx1ZS4gXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1GaWVsZCNkZWZhdWx0VmFsdWVcbiAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAqIEB0eXBlIHthbnl9XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdFZhbHVlJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEFjcm9Gb3JtQnV0dG9uID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHBkZlVuZXNjYXBlKF9EVi5zdWJzdHIoMSwgX0RWLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX0RWO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQWNyb0Zvcm1CdXR0b24gPT09IHRydWUpIHtcbiAgICAgICAgICBfRFYgPSAnLycgKyB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfRFYgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfViA9IG51bGw7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdWJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghX1YpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEFjcm9Gb3JtQnV0dG9uID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB0b1BkZlN0cmluZyhfVik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX1Y7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQWNyb0Zvcm1CdXR0b24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLnN1YnN0cigwLCAxKSA9PT0gJygnKSB7XG4gICAgICAgICAgICBfViA9IHBkZlVuZXNjYXBlKHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9WID0gcGRmVW5lc2NhcGUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfViA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiAoT3B0aW9uYWw7IGluaGVyaXRhYmxlKSBUaGUgZmllbGTigJlzIHZhbHVlLCB3aG9zZSBmb3JtYXQgdmFyaWVzIGRlcGVuZGluZyBvbiB0aGUgZmllbGQgdHlwZS4gU2VlIHRoZSBkZXNjcmlwdGlvbnMgb2YgaW5kaXZpZHVhbCBmaWVsZCB0eXBlcyBmb3IgZnVydGhlciBpbmZvcm1hdGlvbi4gXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1GaWVsZCN2YWx1ZVxuICAgICogQGRlZmF1bHQgbnVsbFxuICAgICogQHR5cGUge2FueX1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd2YWx1ZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBBY3JvRm9ybUJ1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBwZGZVbmVzY2FwZShfVi5zdWJzdHIoMSwgX1YubGVuZ3RoIC0gMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfVjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEFjcm9Gb3JtQnV0dG9uID09PSB0cnVlKSB7XG4gICAgICAgICAgX1YgPSAnLycgKyB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfViA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBDaGVjayBpZiBmaWVsZCBoYXMgYW5ub3RhdGlvbnNcbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybUZpZWxkI2hhc0Fubm90YXRpb25cbiAgICAqIEByZWFkb25seVxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaGFzQW5ub3RhdGlvbicsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUmVjdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ1R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNBbm5vdGF0aW9uID8gXCIvQW5ub3RcIiA6IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdTdWJ0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQW5ub3RhdGlvbiA/IFwiL1dpZGdldFwiIDogbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2hhc0FwcGVhcmFuY2VTdHJlYW0gPSBmYWxzZTtcbiAgICAvKipcbiAgICAqIHRydWUgaWYgZmllbGQgaGFzIGFuIGFwcGVhcmFuY2VTdHJlYW1cbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybUZpZWxkI2hhc0FwcGVhcmFuY2VTdHJlYW1cbiAgICAqIEByZWFkb25seVxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaGFzQXBwZWFyYW5jZVN0cmVhbScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0ZWFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9oYXNBcHBlYXJhbmNlU3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIF9oYXNBcHBlYXJhbmNlU3RyZWFtID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBUaGUgcGFnZSBvbiB3aGljaCB0aGUgQWNyb0Zvcm1GaWVsZCBpcyBwbGFjZWRcbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybUZpZWxkI3BhZ2VcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKi9cblxuICAgIHZhciBfcGFnZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGFnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0ZWFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKCFfcGFnZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfcGFnZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfcGFnZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogSWYgc2V0LCB0aGUgdXNlciBtYXkgbm90IGNoYW5nZSB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkLiBBbnkgYXNzb2NpYXRlZCB3aWRnZXQgYW5ub3RhdGlvbnMgd2lsbCBub3QgaW50ZXJhY3Qgd2l0aCB0aGUgdXNlcjsgdGhhdCBpcywgdGhleSB3aWxsIG5vdCByZXNwb25kIHRvIG1vdXNlIGNsaWNrcyBvciBjaGFuZ2UgdGhlaXIgYXBwZWFyYW5jZSBpbiByZXNwb25zZSB0byBtb3VzZSBtb3Rpb25zLiBUaGlzIGZsYWcgaXMgdXNlZnVsIGZvciBmaWVsZHMgd2hvc2UgdmFsdWVzIGFyZSBjb21wdXRlZCBvciBpbXBvcnRlZCBmcm9tIGEgZGF0YWJhc2UuIFxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtRmllbGQjcmVhZE9ubHlcbiAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWFkT25seScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDEpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLkZmID0gc2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuRmYgPSBjbGVhckJpdEZvclBkZih0aGlzLkZmLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogSWYgc2V0LCB0aGUgZmllbGQgc2hhbGwgaGF2ZSBhIHZhbHVlIGF0IHRoZSB0aW1lIGl0IGlzIGV4cG9ydGVkIGJ5IGEgc3VibWl0Zm9ybSBhY3Rpb24gKHNlZSAxMi43LjUuMiwg4oCcU3VibWl0LUZvcm0gQWN0aW9u4oCdKS4gXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1GaWVsZCNyZXF1aXJlZFxuICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlcXVpcmVkJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihnZXRCaXRGb3JQZGYodGhpcy5GZiwgMikpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuRmYgPSBzZXRCaXRGb3JQZGYodGhpcy5GZiwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5GZiA9IGNsZWFyQml0Rm9yUGRmKHRoaXMuRmYsIDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBJZiBzZXQsIHRoZSBmaWVsZCBzaGFsbCBub3QgYmUgZXhwb3J0ZWQgYnkgYSBzdWJtaXQtZm9ybSBhY3Rpb24gKHNlZSAxMi43LjUuMiwg4oCcU3VibWl0LUZvcm0gQWN0aW9u4oCdKVxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtRmllbGQjbm9FeHBvcnRcbiAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdub0V4cG9ydCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDMpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLkZmID0gc2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuRmYgPSBjbGVhckJpdEZvclBkZih0aGlzLkZmLCAzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfUSA9IG51bGw7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdRJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKF9RID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9RO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChbMCwgMSwgMl0uaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgX1EgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgZm9yIGF0dHJpYnV0ZSBRIHN1cHBsaWVkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiAoT3B0aW9uYWw7IGluaGVyaXRhYmxlKSBBIGNvZGUgc3BlY2lmeWluZyB0aGUgZm9ybSBvZiBxdWFkZGluZyAoanVzdGlmaWNhdGlvbikgdGhhdCBzaGFsbCBiZSB1c2VkIGluIGRpc3BsYXlpbmcgdGhlIHRleHQ6XG4gICAgKiAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1GaWVsZCN0ZXh0QWxpZ25cbiAgICAqIEBkZWZhdWx0ICdsZWZ0J1xuICAgICogQHR5cGUge3N0cmluZ31cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0ZXh0QWxpZ24nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdsZWZ0JztcblxuICAgICAgICBzd2l0Y2ggKF9RKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQgPSAnbGVmdCc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJlc3VsdCA9ICdjZW50ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXN1bHQgPSAncmlnaHQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9RID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfUSA9IDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX1EgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaW5oZXJpdChBY3JvRm9ybUZpZWxkLCBBY3JvRm9ybVBERk9iamVjdCk7XG4gIC8qKlxuICAqIEBjbGFzcyBBY3JvRm9ybUNob2ljZUZpZWxkXG4gICogQGV4dGVuZHMgQWNyb0Zvcm1GaWVsZFxuICAqL1xuXG4gIHZhciBBY3JvRm9ybUNob2ljZUZpZWxkID0gZnVuY3Rpb24gQWNyb0Zvcm1DaG9pY2VGaWVsZCgpIHtcbiAgICBBY3JvRm9ybUZpZWxkLmNhbGwodGhpcyk7IC8vIEZpZWxkIFR5cGUgPSBDaG9pY2UgRmllbGRcblxuICAgIHRoaXMuRlQgPSBcIi9DaFwiOyAvLyBvcHRpb25zXG5cbiAgICB0aGlzLlYgPSAnKCknO1xuICAgIHRoaXMuZm9udE5hbWUgPSAnemFwZmRpbmdiYXRzJzsgLy8gVG9wIEluZGV4XG5cbiAgICB2YXIgX1RJID0gMDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ1RJJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9USTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfVEkgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIChPcHRpb25hbCkgRm9yIHNjcm9sbGFibGUgbGlzdCBib3hlcywgdGhlIHRvcCBpbmRleCAodGhlIGluZGV4IGluIHRoZSBPcHQgYXJyYXkgb2YgdGhlIGZpcnN0IG9wdGlvbiB2aXNpYmxlIGluIHRoZSBsaXN0KS4gRGVmYXVsdCB2YWx1ZTogMC5cbiAgICAqIFxuICAgICogQG5hbWUgQWNyb0Zvcm1DaG9pY2VGaWVsZCN0b3BJbmRleFxuICAgICogQGRlZmF1bHQgMFxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0b3BJbmRleCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9USTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfVEkgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX09wdCA9IFtdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnT3B0Jywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9QZGZBcnJheShfT3B0KTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfT3B0ID0gcGRmQXJyYXlUb1N0cmluZ0FycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIEBtZW1iZXJvZiBBY3JvRm9ybUNob2ljZUZpZWxkXG4gICAgKiBAbmFtZSBnZXRPcHRpb25zXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBpbnN0YW5jZVxuICAgICogQHJldHVybnMge2FycmF5fSBhcnJheSBvZiBPcHRpb25zXG4gICAgKi9cblxuICAgIHRoaXMuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfT3B0O1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBAbWVtYmVyb2YgQWNyb0Zvcm1DaG9pY2VGaWVsZFxuICAgICogQG5hbWUgc2V0T3B0aW9uc1xuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAaW5zdGFuY2VcbiAgICAqIEBwYXJhbSB7YXJyYXl9IHZhbHVlXG4gICAgKi9cblxuXG4gICAgdGhpcy5zZXRPcHRpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBfT3B0ID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnNvcnQpIHtcbiAgICAgICAgX09wdC5zb3J0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAqIEBtZW1iZXJvZiBBY3JvRm9ybUNob2ljZUZpZWxkXG4gICAgKiBAbmFtZSBhZGRPcHRpb25cbiAgICAqIEBmdW5jdGlvblxuICAgICogQGluc3RhbmNlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAqL1xuXG5cbiAgICB0aGlzLmFkZE9wdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSB8fCBcIlwiO1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICBfT3B0LnB1c2godmFsdWUpO1xuXG4gICAgICBpZiAodGhpcy5zb3J0KSB7XG4gICAgICAgIF9PcHQuc29ydCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgKiBAbWVtYmVyb2YgQWNyb0Zvcm1DaG9pY2VGaWVsZFxuICAgICogQG5hbWUgcmVtb3ZlT3B0aW9uXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBpbnN0YW5jZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbEVudHJpZXMgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICovXG5cblxuICAgIHRoaXMucmVtb3ZlT3B0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBhbGxFbnRyaWVzKSB7XG4gICAgICBhbGxFbnRyaWVzID0gYWxsRW50cmllcyB8fCBmYWxzZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgfHwgXCJcIjtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgd2hpbGUgKF9PcHQuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIF9PcHQuc3BsaWNlKF9PcHQuaW5kZXhPZih2YWx1ZSksIDEpO1xuXG4gICAgICAgIGlmIChhbGxFbnRyaWVzID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAqIElmIHNldCwgdGhlIGZpZWxkIGlzIGEgY29tYm8gYm94OyBpZiBjbGVhciwgdGhlIGZpZWxkIGlzIGEgbGlzdCBib3guIFxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtQ2hvaWNlRmllbGQjY29tYm9cbiAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbWJvJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihnZXRCaXRGb3JQZGYodGhpcy5GZiwgMTgpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLkZmID0gc2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDE4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLkZmID0gY2xlYXJCaXRGb3JQZGYodGhpcy5GZiwgMTgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBJZiBzZXQsIHRoZSBjb21ibyBib3ggc2hhbGwgaW5jbHVkZSBhbiBlZGl0YWJsZSB0ZXh0IGJveCBhcyB3ZWxsIGFzIGEgZHJvcC1kb3duIGxpc3Q7IGlmIGNsZWFyLCBpdCBzaGFsbCBpbmNsdWRlIG9ubHkgYSBkcm9wLWRvd24gbGlzdC4gVGhpcyBmbGFnIHNoYWxsIGJlIHVzZWQgb25seSBpZiB0aGUgQ29tYm8gZmxhZyBpcyBzZXQuIFxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtQ2hvaWNlRmllbGQjZWRpdFxuICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VkaXQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGdldEJpdEZvclBkZih0aGlzLkZmLCAxOSkpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIC8vUERGIDMyMDAwLTE6MjAwOCwgcGFnZSA0NDRcbiAgICAgICAgaWYgKHRoaXMuY29tYm8gPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuRmYgPSBzZXRCaXRGb3JQZGYodGhpcy5GZiwgMTkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLkZmID0gY2xlYXJCaXRGb3JQZGYodGhpcy5GZiwgMTkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogSWYgc2V0LCB0aGUgZmllbGTigJlzIG9wdGlvbiBpdGVtcyBzaGFsbCBiZSBzb3J0ZWQgYWxwaGFiZXRpY2FsbHkuIFRoaXMgZmxhZyBpcyBpbnRlbmRlZCBmb3IgdXNlIGJ5IHdyaXRlcnMsIG5vdCBieSByZWFkZXJzLiBDb25mb3JtaW5nIHJlYWRlcnMgc2hhbGwgZGlzcGxheSB0aGUgb3B0aW9ucyBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBvY2N1ciBpbiB0aGUgT3B0IGFycmF5IChzZWUgVGFibGUgMjMxKS4gXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1DaG9pY2VGaWVsZCNzb3J0XG4gICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc29ydCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDIwKSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKEJvb2xlYW4odmFsdWUpID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5GZiA9IHNldEJpdEZvclBkZih0aGlzLkZmLCAyMCk7XG5cbiAgICAgICAgICBfT3B0LnNvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLkZmID0gY2xlYXJCaXRGb3JQZGYodGhpcy5GZiwgMjApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiAoUERGIDEuNCkgSWYgc2V0LCBtb3JlIHRoYW4gb25lIG9mIHRoZSBmaWVsZOKAmXMgb3B0aW9uIGl0ZW1zIG1heSBiZSBzZWxlY3RlZCBzaW11bHRhbmVvdXNseTsgaWYgY2xlYXIsIGF0IG1vc3Qgb25lIGl0ZW0gc2hhbGwgYmUgc2VsZWN0ZWQgXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1DaG9pY2VGaWVsZCNtdWx0aVNlbGVjdFxuICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ211bHRpU2VsZWN0Jywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihnZXRCaXRGb3JQZGYodGhpcy5GZiwgMjIpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLkZmID0gc2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDIyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLkZmID0gY2xlYXJCaXRGb3JQZGYodGhpcy5GZiwgMjIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiAoUERGIDEuNCkgSWYgc2V0LCB0ZXh0IGVudGVyZWQgaW4gdGhlIGZpZWxkIHNoYWxsIG5vdCBiZSBzcGVsbGNoZWNrZWQuIFRoaXMgZmxhZyBzaGFsbCBub3QgYmUgdXNlZCB1bmxlc3MgdGhlIENvbWJvIGFuZCBFZGl0IGZsYWdzIGFyZSBib3RoIHNldC4gXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1DaG9pY2VGaWVsZCNkb05vdFNwZWxsQ2hlY2tcbiAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkb05vdFNwZWxsQ2hlY2snLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGdldEJpdEZvclBkZih0aGlzLkZmLCAyMykpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuRmYgPSBzZXRCaXRGb3JQZGYodGhpcy5GZiwgMjMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuRmYgPSBjbGVhckJpdEZvclBkZih0aGlzLkZmLCAyMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIChQREYgMS41KSBJZiBzZXQsIHRoZSBuZXcgdmFsdWUgc2hhbGwgYmUgY29tbWl0dGVkIGFzIHNvb24gYXMgYSBzZWxlY3Rpb24gaXMgbWFkZSAoY29tbW9ubHkgd2l0aCB0aGUgcG9pbnRpbmcgZGV2aWNlKS4gSW4gdGhpcyBjYXNlLCBzdXBwbHlpbmcgYSB2YWx1ZSBmb3IgYSBmaWVsZCBpbnZvbHZlcyB0aHJlZSBhY3Rpb25zOiBzZWxlY3RpbmcgdGhlIGZpZWxkIGZvciBmaWxsLWluLCBzZWxlY3RpbmcgYSBjaG9pY2UgZm9yIHRoZSBmaWxsLWluIHZhbHVlLCBhbmQgbGVhdmluZyB0aGF0IGZpZWxkLCB3aGljaCBmaW5hbGl6ZXMgb3Ig4oCcY29tbWl0c+KAnSB0aGUgZGF0YSBjaG9pY2UgYW5kIHRyaWdnZXJzIGFueSBhY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgZW50cnkgb3IgY2hhbmdpbmcgb2YgdGhpcyBkYXRhLiBJZiB0aGlzIGZsYWcgaXMgb24sIHRoZW4gcHJvY2Vzc2luZyBkb2VzIG5vdCB3YWl0IGZvciBsZWF2aW5nIHRoZSBmaWVsZCBhY3Rpb24gdG8gb2NjdXIsIGJ1dCBpbW1lZGlhdGVseSBwcm9jZWVkcyB0byB0aGUgdGhpcmQgc3RlcC5cbiAgICAqIFRoaXMgb3B0aW9uIGVuYWJsZXMgYXBwbGljYXRpb25zIHRvIHBlcmZvcm0gYW4gYWN0aW9uIG9uY2UgYSBzZWxlY3Rpb24gaXMgbWFkZSwgd2l0aG91dCByZXF1aXJpbmcgdGhlIHVzZXIgdG8gZXhpdCB0aGUgZmllbGQuIElmIGNsZWFyLCB0aGUgbmV3IHZhbHVlIGlzIG5vdCBjb21taXR0ZWQgdW50aWwgdGhlIHVzZXIgZXhpdHMgdGhlIGZpZWxkLlxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtQ2hvaWNlRmllbGQjY29tbWl0T25TZWxDaGFuZ2VcbiAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb21taXRPblNlbENoYW5nZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDI3KSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKEJvb2xlYW4odmFsdWUpID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5GZiA9IHNldEJpdEZvclBkZih0aGlzLkZmLCAyNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5GZiA9IGNsZWFyQml0Rm9yUGRmKHRoaXMuRmYsIDI3KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaGFzQXBwZWFyYW5jZVN0cmVhbSA9IGZhbHNlO1xuICB9O1xuXG4gIGluaGVyaXQoQWNyb0Zvcm1DaG9pY2VGaWVsZCwgQWNyb0Zvcm1GaWVsZCk7XG4gIC8qKlxuICAqIEBjbGFzcyBBY3JvRm9ybUxpc3RCb3hcbiAgKiBAZXh0ZW5kcyBBY3JvRm9ybUNob2ljZUZpZWxkXG4gICogQGV4dGVuZHMgQWNyb0Zvcm1GaWVsZFxuICAqL1xuXG4gIHZhciBBY3JvRm9ybUxpc3RCb3ggPSBmdW5jdGlvbiBBY3JvRm9ybUxpc3RCb3goKSB7XG4gICAgQWNyb0Zvcm1DaG9pY2VGaWVsZC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZm9udE5hbWUgPSAnaGVsdmV0aWNhJzsgLy9QREYgMzIwMDAtMToyMDA4LCBwYWdlIDQ0NFxuXG4gICAgdGhpcy5jb21ibyA9IGZhbHNlO1xuICB9O1xuXG4gIGluaGVyaXQoQWNyb0Zvcm1MaXN0Qm94LCBBY3JvRm9ybUNob2ljZUZpZWxkKTtcbiAgLyoqXG4gICogQGNsYXNzIEFjcm9Gb3JtQ29tYm9Cb3ggXG4gICogQGV4dGVuZHMgQWNyb0Zvcm1MaXN0Qm94XG4gICogQGV4dGVuZHMgQWNyb0Zvcm1DaG9pY2VGaWVsZFxuICAqIEBleHRlbmRzIEFjcm9Gb3JtRmllbGRcbiAgKi9cblxuICB2YXIgQWNyb0Zvcm1Db21ib0JveCA9IGZ1bmN0aW9uIEFjcm9Gb3JtQ29tYm9Cb3goKSB7XG4gICAgQWNyb0Zvcm1MaXN0Qm94LmNhbGwodGhpcyk7XG4gICAgdGhpcy5jb21ibyA9IHRydWU7XG4gIH07XG5cbiAgaW5oZXJpdChBY3JvRm9ybUNvbWJvQm94LCBBY3JvRm9ybUxpc3RCb3gpO1xuICAvKipcbiAgKiBAY2xhc3MgQWNyb0Zvcm1FZGl0Qm94IFxuICAqIEBleHRlbmRzIEFjcm9Gb3JtQ29tYm9Cb3hcbiAgKiBAZXh0ZW5kcyBBY3JvRm9ybUxpc3RCb3hcbiAgKiBAZXh0ZW5kcyBBY3JvRm9ybUNob2ljZUZpZWxkXG4gICogQGV4dGVuZHMgQWNyb0Zvcm1GaWVsZFxuICAqL1xuXG4gIHZhciBBY3JvRm9ybUVkaXRCb3ggPSBmdW5jdGlvbiBBY3JvRm9ybUVkaXRCb3goKSB7XG4gICAgQWNyb0Zvcm1Db21ib0JveC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZWRpdCA9IHRydWU7XG4gIH07XG5cbiAgaW5oZXJpdChBY3JvRm9ybUVkaXRCb3gsIEFjcm9Gb3JtQ29tYm9Cb3gpO1xuICAvKipcbiAgKiBAY2xhc3MgQWNyb0Zvcm1CdXR0b25cbiAgKiBAZXh0ZW5kcyBBY3JvRm9ybUZpZWxkXG4gICovXG5cbiAgdmFyIEFjcm9Gb3JtQnV0dG9uID0gZnVuY3Rpb24gQWNyb0Zvcm1CdXR0b24oKSB7XG4gICAgQWNyb0Zvcm1GaWVsZC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuRlQgPSBcIi9CdG5cIjtcbiAgICAvKipcbiAgICAqIChSYWRpbyBidXR0b25zIG9ubHkpIElmIHNldCwgZXhhY3RseSBvbmUgcmFkaW8gYnV0dG9uIHNoYWxsIGJlIHNlbGVjdGVkIGF0IGFsbCB0aW1lczsgc2VsZWN0aW5nIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgYnV0dG9uIGhhcyBubyBlZmZlY3QuIElmIGNsZWFyLCBjbGlja2luZyB0aGUgc2VsZWN0ZWQgYnV0dG9uIGRlc2VsZWN0cyBpdCwgbGVhdmluZyBubyBidXR0b24gc2VsZWN0ZWQuXG4gICAgKiBcbiAgICAqIEBuYW1lIEFjcm9Gb3JtQnV0dG9uI25vVG9nZ2xlVG9PZmZcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25vVG9nZ2xlVG9PZmYnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGdldEJpdEZvclBkZih0aGlzLkZmLCAxNSkpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuRmYgPSBzZXRCaXRGb3JQZGYodGhpcy5GZiwgMTUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuRmYgPSBjbGVhckJpdEZvclBkZih0aGlzLkZmLCAxNSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIElmIHNldCwgdGhlIGZpZWxkIGlzIGEgc2V0IG9mIHJhZGlvIGJ1dHRvbnM7IGlmIGNsZWFyLCB0aGUgZmllbGQgaXMgYSBjaGVja2JveC4gVGhpcyBmbGFnIG1heSBiZSBzZXQgb25seSBpZiB0aGUgUHVzaGJ1dHRvbiBmbGFnIGlzIGNsZWFyLiBcbiAgICAqIFxuICAgICogQG5hbWUgQWNyb0Zvcm1CdXR0b24jcmFkaW9cbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JhZGlvJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihnZXRCaXRGb3JQZGYodGhpcy5GZiwgMTYpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLkZmID0gc2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDE2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLkZmID0gY2xlYXJCaXRGb3JQZGYodGhpcy5GZiwgMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBJZiBzZXQsIHRoZSBmaWVsZCBpcyBhIHB1c2hidXR0b24gdGhhdCBkb2VzIG5vdCByZXRhaW4gYSBwZXJtYW5lbnQgdmFsdWUuIFxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtQnV0dG9uI3B1c2hCdXR0b25cbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3B1c2hCdXR0b24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGdldEJpdEZvclBkZih0aGlzLkZmLCAxNykpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuRmYgPSBzZXRCaXRGb3JQZGYodGhpcy5GZiwgMTcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuRmYgPSBjbGVhckJpdEZvclBkZih0aGlzLkZmLCAxNyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIChQREYgMS41KSBJZiBzZXQsIGEgZ3JvdXAgb2YgcmFkaW8gYnV0dG9ucyB3aXRoaW4gYSByYWRpbyBidXR0b24gZmllbGQgdGhhdCB1c2UgdGhlIHNhbWUgdmFsdWUgZm9yIHRoZSBvbiBzdGF0ZSB3aWxsIHR1cm4gb24gYW5kIG9mZiBpbiB1bmlzb247IHRoYXQgaXMgaWYgb25lIGlzIGNoZWNrZWQsIHRoZXkgYXJlIGFsbCBjaGVja2VkLiBJZiBjbGVhciwgdGhlIGJ1dHRvbnMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSAodGhlIHNhbWUgYmVoYXZpb3IgYXMgSFRNTCByYWRpbyBidXR0b25zKS5cbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybUJ1dHRvbiNyYWRpb0lzVW5pc29uXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyYWRpb0lzVW5pc29uJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihnZXRCaXRGb3JQZGYodGhpcy5GZiwgMjYpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLkZmID0gc2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDI2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLkZmID0gY2xlYXJCaXRGb3JQZGYodGhpcy5GZiwgMjYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9NSyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnTUsnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKF9NSykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCc8PCcpO1xuICAgICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgICBmb3IgKGtleSBpbiBfTUspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcvJyArIGtleSArICcgKCcgKyBfTUtba2V5XSArICcpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goJz4+Jyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoX3R5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBfTUsgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogRnJvbSB0aGUgUERGIHJlZmVyZW5jZTpcbiAgICAqIChPcHRpb25hbCwgYnV0dG9uIGZpZWxkcyBvbmx5KSBUaGUgd2lkZ2V0IGFubm90YXRpb24ncyBub3JtYWwgY2FwdGlvbiB3aGljaCBzaGFsbCBiZSBkaXNwbGF5ZWQgd2hlbiBpdCBpcyBub3QgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdXNlci4gXG4gICAgKiBVbmxpa2UgdGhlIHJlbWFpbmluZyBlbnRyaWVzIGxpc3RlZCBpbiB0aGlzIFRhYmxlIHdoaWNoIGFwcGx5IG9ubHkgdG8gd2lkZ2V0IGFubm90YXRpb25zIGFzc29jaWF0ZWQgd2l0aCBwdXNoYnV0dG9uIGZpZWxkcyAoc2VlIFB1c2hidXR0b25zIGluIDEyLjcuNC4yLCBcIkJ1dHRvbiBGaWVsZHNcIiksIHRoZSBDQSBlbnRyeSBtYXkgYmUgdXNlZCB3aXRoIGFueSB0eXBlIG9mIGJ1dHRvbiBmaWVsZCwgaW5jbHVkaW5nIGNoZWNrIGJveGVzIChzZWUgQ2hlY2sgQm94ZXMgaW4gMTIuNy40LjIsIFwiQnV0dG9uIEZpZWxkc1wiKSBhbmQgcmFkaW8gYnV0dG9ucyAoUmFkaW8gQnV0dG9ucyBpbiAxMi43LjQuMiwgXCJCdXR0b24gRmllbGRzXCIpLlxuICAgICpcbiAgICAqIC0gJzgnID0gQ3Jvc3MsIFxuICAgICogLSAnbCcgPSAgQ2lyY2xlLFxuICAgICogLSAnJyA9IG5vdGhpbmdcbiAgICAqIEBuYW1lIEFjcm9Gb3JtQnV0dG9uI2NhcHRpb25cbiAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2FwdGlvbicsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9NSy5DQSB8fCAnJztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgX01LLkNBID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBfQVM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ0FTJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfQVM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX0FTID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiAoUmVxdWlyZWQgaWYgdGhlIGFwcGVhcmFuY2UgZGljdGlvbmFyeSBBUCBjb250YWlucyBvbmUgb3IgbW9yZSBzdWJkaWN0aW9uYXJpZXM7IFBERiAxLjIpIFRoZSBhbm5vdGF0aW9uJ3MgYXBwZWFyYW5jZSBzdGF0ZSwgd2hpY2ggc2VsZWN0cyB0aGUgYXBwbGljYWJsZSBhcHBlYXJhbmNlIHN0cmVhbSBmcm9tIGFuIGFwcGVhcmFuY2Ugc3ViZGljdGlvbmFyeSAoc2VlIFNlY3Rpb24gMTIuNS41LCBcIkFwcGVhcmFuY2UgU3RyZWFtc1wiKVxuICAgICpcbiAgICAqIEBuYW1lIEFjcm9Gb3JtQnV0dG9uI2FwcGVhcmFuY2VTdGF0ZVxuICAgICogQHR5cGUge2FueX1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdhcHBlYXJhbmNlU3RhdGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfQVMuc3Vic3RyKDEsIF9BUy5sZW5ndGggLSAxKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfQVMgPSAnLycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpbmhlcml0KEFjcm9Gb3JtQnV0dG9uLCBBY3JvRm9ybUZpZWxkKTtcbiAgLyoqXG4gICogQGNsYXNzIEFjcm9Gb3JtUHVzaEJ1dHRvblxuICAqIEBleHRlbmRzIEFjcm9Gb3JtQnV0dG9uXG4gICogQGV4dGVuZHMgQWNyb0Zvcm1GaWVsZFxuICAqL1xuXG4gIHZhciBBY3JvRm9ybVB1c2hCdXR0b24gPSBmdW5jdGlvbiBBY3JvRm9ybVB1c2hCdXR0b24oKSB7XG4gICAgQWNyb0Zvcm1CdXR0b24uY2FsbCh0aGlzKTtcbiAgICB0aGlzLnB1c2hCdXR0b24gPSB0cnVlO1xuICB9O1xuXG4gIGluaGVyaXQoQWNyb0Zvcm1QdXNoQnV0dG9uLCBBY3JvRm9ybUJ1dHRvbik7XG4gIC8qKlxuICAqIEBjbGFzcyBBY3JvRm9ybVJhZGlvQnV0dG9uXG4gICogQGV4dGVuZHMgQWNyb0Zvcm1CdXR0b25cbiAgKiBAZXh0ZW5kcyBBY3JvRm9ybUZpZWxkXG4gICovXG5cbiAgdmFyIEFjcm9Gb3JtUmFkaW9CdXR0b24gPSBmdW5jdGlvbiBBY3JvRm9ybVJhZGlvQnV0dG9uKCkge1xuICAgIEFjcm9Gb3JtQnV0dG9uLmNhbGwodGhpcyk7XG4gICAgdGhpcy5yYWRpbyA9IHRydWU7XG4gICAgdGhpcy5wdXNoQnV0dG9uID0gZmFsc2U7XG4gICAgdmFyIF9LaWRzID0gW107XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdLaWRzJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9LaWRzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBfS2lkcyA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9LaWRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpbmhlcml0KEFjcm9Gb3JtUmFkaW9CdXR0b24sIEFjcm9Gb3JtQnV0dG9uKTtcbiAgLyoqXG4gICogVGhlIENoaWxkIGNsYXNzIG9mIGEgUmFkaW9CdXR0b24gKHRoZSByYWRpb0dyb3VwKSAtPiBUaGUgc2luZ2xlIEJ1dHRvbnNcbiAgKiBcbiAgKiBAY2xhc3MgQWNyb0Zvcm1DaGlsZENsYXNzXG4gICogQGV4dGVuZHMgQWNyb0Zvcm1GaWVsZFxuICAqIEBpZ25vcmVcbiAgKi9cblxuICB2YXIgQWNyb0Zvcm1DaGlsZENsYXNzID0gZnVuY3Rpb24gQWNyb0Zvcm1DaGlsZENsYXNzKCkge1xuICAgIEFjcm9Gb3JtRmllbGQuY2FsbCh0aGlzKTtcblxuICAgIHZhciBfcGFyZW50O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdQYXJlbnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9wYXJlbnQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX3BhcmVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIF9vcHRpb25OYW1lO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdvcHRpb25OYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9vcHRpb25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9vcHRpb25OYW1lID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9NSyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnTUsnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICByZXN1bHQucHVzaCgnPDwnKTtcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiBfTUspIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgnLycgKyBrZXkgKyAnICgnICsgX01LW2tleV0gKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goJz4+Jyk7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignXFxuJyk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKF90eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgX01LID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIEZyb20gdGhlIFBERiByZWZlcmVuY2U6XG4gICAgKiAoT3B0aW9uYWwsIGJ1dHRvbiBmaWVsZHMgb25seSkgVGhlIHdpZGdldCBhbm5vdGF0aW9uJ3Mgbm9ybWFsIGNhcHRpb24gd2hpY2ggc2hhbGwgYmUgZGlzcGxheWVkIHdoZW4gaXQgaXMgbm90IGludGVyYWN0aW5nIHdpdGggdGhlIHVzZXIuIFxuICAgICogVW5saWtlIHRoZSByZW1haW5pbmcgZW50cmllcyBsaXN0ZWQgaW4gdGhpcyBUYWJsZSB3aGljaCBhcHBseSBvbmx5IHRvIHdpZGdldCBhbm5vdGF0aW9ucyBhc3NvY2lhdGVkIHdpdGggcHVzaGJ1dHRvbiBmaWVsZHMgKHNlZSBQdXNoYnV0dG9ucyBpbiAxMi43LjQuMiwgXCJCdXR0b24gRmllbGRzXCIpLCB0aGUgQ0EgZW50cnkgbWF5IGJlIHVzZWQgd2l0aCBhbnkgdHlwZSBvZiBidXR0b24gZmllbGQsIGluY2x1ZGluZyBjaGVjayBib3hlcyAoc2VlIENoZWNrIEJveGVzIGluIDEyLjcuNC4yLCBcIkJ1dHRvbiBGaWVsZHNcIikgYW5kIHJhZGlvIGJ1dHRvbnMgKFJhZGlvIEJ1dHRvbnMgaW4gMTIuNy40LjIsIFwiQnV0dG9uIEZpZWxkc1wiKS5cbiAgICAqXG4gICAgKiAtICc4JyA9IENyb3NzLCBcbiAgICAqIC0gJ2wnID0gIENpcmNsZSxcbiAgICAqIC0gJycgPSBub3RoaW5nXG4gICAgKiBAbmFtZSBBY3JvRm9ybUJ1dHRvbiNjYXB0aW9uXG4gICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhcHRpb24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfTUsuQ0EgfHwgJyc7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIF9NSy5DQSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgX0FTO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdBUycsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX0FTO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9BUyA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogKFJlcXVpcmVkIGlmIHRoZSBhcHBlYXJhbmNlIGRpY3Rpb25hcnkgQVAgY29udGFpbnMgb25lIG9yIG1vcmUgc3ViZGljdGlvbmFyaWVzOyBQREYgMS4yKSBUaGUgYW5ub3RhdGlvbidzIGFwcGVhcmFuY2Ugc3RhdGUsIHdoaWNoIHNlbGVjdHMgdGhlIGFwcGxpY2FibGUgYXBwZWFyYW5jZSBzdHJlYW0gZnJvbSBhbiBhcHBlYXJhbmNlIHN1YmRpY3Rpb25hcnkgKHNlZSBTZWN0aW9uIDEyLjUuNSwgXCJBcHBlYXJhbmNlIFN0cmVhbXNcIilcbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybUJ1dHRvbiNhcHBlYXJhbmNlU3RhdGVcbiAgICAqIEB0eXBlIHthbnl9XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYXBwZWFyYW5jZVN0YXRlJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX0FTLnN1YnN0cigxLCBfQVMubGVuZ3RoIC0gMSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX0FTID0gJy8nICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vcHRpb25OYW1lID0gbmFtZTtcbiAgICB0aGlzLmNhcHRpb24gPSAnbCc7XG4gICAgdGhpcy5hcHBlYXJhbmNlU3RhdGUgPSAnT2ZmJzsgLy8gdG9kbzogc2V0IEFwcGVhcmFuY2VUeXBlIGFzIHZhcmlhYmxlIHRoYXQgY2FuIGJlIHNldCBmcm9tIHRoZVxuICAgIC8vIG91dHNpZGUuLi5cblxuICAgIHRoaXMuX0FwcGVhcmFuY2VUeXBlID0gQWNyb0Zvcm1BcHBlYXJhbmNlLlJhZGlvQnV0dG9uLkNpcmNsZTsgLy8gVGhlIERlZmF1bHQgYXBwZWFyYW5jZVR5cGUgaXMgdGhlIENpcmNsZVxuXG4gICAgdGhpcy5hcHBlYXJhbmNlU3RyZWFtQ29udGVudCA9IHRoaXMuX0FwcGVhcmFuY2VUeXBlLmNyZWF0ZUFwcGVhcmFuY2VTdHJlYW0obmFtZSk7XG4gIH07XG5cbiAgaW5oZXJpdChBY3JvRm9ybUNoaWxkQ2xhc3MsIEFjcm9Gb3JtRmllbGQpO1xuXG4gIEFjcm9Gb3JtUmFkaW9CdXR0b24ucHJvdG90eXBlLnNldEFwcGVhcmFuY2UgPSBmdW5jdGlvbiAoYXBwZWFyYW5jZSkge1xuICAgIGlmICghKCdjcmVhdGVBcHBlYXJhbmNlU3RyZWFtJyBpbiBhcHBlYXJhbmNlICYmICdnZXRDQScgaW4gYXBwZWFyYW5jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGFzc2lnbiBBcHBlYXJhbmNlIHRvIFJhZGlvQnV0dG9uLiBBcHBlYXJhbmNlIHdhcyBJbnZhbGlkIVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBvYmpJZCBpbiB0aGlzLktpZHMpIHtcbiAgICAgIGlmICh0aGlzLktpZHMuaGFzT3duUHJvcGVydHkob2JqSWQpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuS2lkc1tvYmpJZF07XG4gICAgICAgIGNoaWxkLmFwcGVhcmFuY2VTdHJlYW1Db250ZW50ID0gYXBwZWFyYW5jZS5jcmVhdGVBcHBlYXJhbmNlU3RyZWFtKGNoaWxkLm9wdGlvbk5hbWUpO1xuICAgICAgICBjaGlsZC5jYXB0aW9uID0gYXBwZWFyYW5jZS5nZXRDQSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBBY3JvRm9ybVJhZGlvQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVPcHRpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBraWRDb3VudCA9IHRoaXMuS2lkcy5sZW5ndGg7IC8vIENyZWF0ZSBuZXcgQ2hpbGQgZm9yIFJhZGlvR3JvdXBcblxuICAgIHZhciBjaGlsZCA9IG5ldyBBY3JvRm9ybUNoaWxkQ2xhc3MoKTtcbiAgICBjaGlsZC5QYXJlbnQgPSB0aGlzO1xuICAgIGNoaWxkLm9wdGlvbk5hbWUgPSBuYW1lOyAvLyBBZGQgdG8gUGFyZW50XG5cbiAgICB0aGlzLktpZHMucHVzaChjaGlsZCk7XG4gICAgYWRkRmllbGQuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuICAvKipcbiAgKiBAY2xhc3MgQWNyb0Zvcm1DaGVja0JveFxuICAqIEBleHRlbmRzIEFjcm9Gb3JtQnV0dG9uXG4gICogQGV4dGVuZHMgQWNyb0Zvcm1GaWVsZFxuICAqL1xuXG5cbiAgdmFyIEFjcm9Gb3JtQ2hlY2tCb3ggPSBmdW5jdGlvbiBBY3JvRm9ybUNoZWNrQm94KCkge1xuICAgIEFjcm9Gb3JtQnV0dG9uLmNhbGwodGhpcyk7XG4gICAgdGhpcy5mb250TmFtZSA9ICd6YXBmZGluZ2JhdHMnO1xuICAgIHRoaXMuY2FwdGlvbiA9ICczJztcbiAgICB0aGlzLmFwcGVhcmFuY2VTdGF0ZSA9ICdPbic7XG4gICAgdGhpcy52YWx1ZSA9IFwiT25cIjtcbiAgICB0aGlzLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIHRoaXMuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQgPSBBY3JvRm9ybUFwcGVhcmFuY2UuQ2hlY2tCb3guY3JlYXRlQXBwZWFyYW5jZVN0cmVhbSgpO1xuICB9O1xuXG4gIGluaGVyaXQoQWNyb0Zvcm1DaGVja0JveCwgQWNyb0Zvcm1CdXR0b24pO1xuICAvKipcbiAgKiBAY2xhc3MgQWNyb0Zvcm1UZXh0RmllbGRcbiAgKiBAZXh0ZW5kcyBBY3JvRm9ybUZpZWxkXG4gICovXG5cbiAgdmFyIEFjcm9Gb3JtVGV4dEZpZWxkID0gZnVuY3Rpb24gQWNyb0Zvcm1UZXh0RmllbGQoKSB7XG4gICAgQWNyb0Zvcm1GaWVsZC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuRlQgPSAnL1R4JztcbiAgICAvKipcbiAgICAqIElmIHNldCwgdGhlIGZpZWxkIG1heSBjb250YWluIG11bHRpcGxlIGxpbmVzIG9mIHRleHQ7IGlmIGNsZWFyLCB0aGUgZmllbGTigJlzIHRleHQgc2hhbGwgYmUgcmVzdHJpY3RlZCB0byBhIHNpbmdsZSBsaW5lLiBcbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybVRleHRGaWVsZCNtdWx0aWxpbmVcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ211bHRpbGluZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDEzKSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKEJvb2xlYW4odmFsdWUpID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5GZiA9IHNldEJpdEZvclBkZih0aGlzLkZmLCAxMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5GZiA9IGNsZWFyQml0Rm9yUGRmKHRoaXMuRmYsIDEzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogKFBERiAxLjQpIElmIHNldCwgdGhlIHRleHQgZW50ZXJlZCBpbiB0aGUgZmllbGQgcmVwcmVzZW50cyB0aGUgcGF0aG5hbWUgb2YgYSBmaWxlIHdob3NlIGNvbnRlbnRzIHNoYWxsIGJlIHN1Ym1pdHRlZCBhcyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkLiBcbiAgICAqIFxuICAgICogQG5hbWUgQWNyb0Zvcm1UZXh0RmllbGQjZmlsZVNlbGVjdFxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZmlsZVNlbGVjdCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDIxKSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKEJvb2xlYW4odmFsdWUpID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5GZiA9IHNldEJpdEZvclBkZih0aGlzLkZmLCAyMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5GZiA9IGNsZWFyQml0Rm9yUGRmKHRoaXMuRmYsIDIxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogKFBERiAxLjQpIElmIHNldCwgdGV4dCBlbnRlcmVkIGluIHRoZSBmaWVsZCBzaGFsbCBub3QgYmUgc3BlbGwtY2hlY2tlZC4gXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1UZXh0RmllbGQjZG9Ob3RTcGVsbENoZWNrXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkb05vdFNwZWxsQ2hlY2snLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGdldEJpdEZvclBkZih0aGlzLkZmLCAyMykpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuRmYgPSBzZXRCaXRGb3JQZGYodGhpcy5GZiwgMjMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuRmYgPSBjbGVhckJpdEZvclBkZih0aGlzLkZmLCAyMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIChQREYgMS40KSBJZiBzZXQsIHRoZSBmaWVsZCBzaGFsbCBub3Qgc2Nyb2xsIChob3Jpem9udGFsbHkgZm9yIHNpbmdsZS1saW5lIGZpZWxkcywgdmVydGljYWxseSBmb3IgbXVsdGlwbGUtbGluZSBmaWVsZHMpIHRvIGFjY29tbW9kYXRlIG1vcmUgdGV4dCB0aGFuIGZpdHMgd2l0aGluIGl0cyBhbm5vdGF0aW9uIHJlY3RhbmdsZS4gT25jZSB0aGUgZmllbGQgaXMgZnVsbCwgbm8gZnVydGhlciB0ZXh0IHNoYWxsIGJlIGFjY2VwdGVkIGZvciBpbnRlcmFjdGl2ZSBmb3JtIGZpbGxpbmc7IGZvciBub25pbnRlcmFjdGl2ZSBmb3JtIGZpbGxpbmcsIHRoZSBmaWxsZXIgc2hvdWxkIHRha2UgY2FyZSBub3QgdG8gYWRkIG1vcmUgY2hhcmFjdGVyIHRoYW4gd2lsbCB2aXNpYmx5IGZpdCBpbiB0aGUgZGVmaW5lZCBhcmVhLiBcbiAgICAqIFxuICAgICogQG5hbWUgQWNyb0Zvcm1UZXh0RmllbGQjZG9Ob3RTY3JvbGxcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RvTm90U2Nyb2xsJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihnZXRCaXRGb3JQZGYodGhpcy5GZiwgMjQpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLkZmID0gc2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDI0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLkZmID0gY2xlYXJCaXRGb3JQZGYodGhpcy5GZiwgMjQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiAoUERGIDEuNSkgTWF5IGJlIHNldCBvbmx5IGlmIHRoZSBNYXhMZW4gZW50cnkgaXMgcHJlc2VudCBpbiB0aGUgdGV4dCBmaWVsZCBkaWN0aW9uYXJ5IChzZWUgVGFibGUgMjI5KSBhbmQgaWYgdGhlIE11bHRpbGluZSwgUGFzc3dvcmQsIGFuZCBGaWxlU2VsZWN0IGZsYWdzIGFyZSBjbGVhci4gSWYgc2V0LCB0aGUgZmllbGQgc2hhbGwgYmUgYXV0b21hdGljYWxseSBkaXZpZGVkIGludG8gYXMgbWFueSBlcXVhbGx5IHNwYWNlZCBwb3NpdGlvbnMsIG9yIGNvbWJzLCBhcyB0aGUgdmFsdWUgb2YgTWF4TGVuLCBhbmQgdGhlIHRleHQgaXMgbGFpZCBvdXQgaW50byB0aG9zZSBjb21icy5cbiAgICAqIFxuICAgICogQG5hbWUgQWNyb0Zvcm1UZXh0RmllbGQjY29tYlxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29tYicsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDI1KSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKEJvb2xlYW4odmFsdWUpID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5GZiA9IHNldEJpdEZvclBkZih0aGlzLkZmLCAyNSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5GZiA9IGNsZWFyQml0Rm9yUGRmKHRoaXMuRmYsIDI1KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogKFBERiAxLjUpIElmIHNldCwgdGhlIHZhbHVlIG9mIHRoaXMgZmllbGQgc2hhbGwgYmUgYSByaWNoIHRleHQgc3RyaW5nIChzZWUgMTIuNy4zLjQsIOKAnFJpY2ggVGV4dCBTdHJpbmdz4oCdKS4gSWYgdGhlIGZpZWxkIGhhcyBhIHZhbHVlLCB0aGUgUlYgZW50cnkgb2YgdGhlIGZpZWxkIGRpY3Rpb25hcnkgKFRhYmxlIDIyMikgc2hhbGwgc3BlY2lmeSB0aGUgcmljaCB0ZXh0IHN0cmluZy5cbiAgICAqIFxuICAgICogQG5hbWUgQWNyb0Zvcm1UZXh0RmllbGQjcmljaFRleHRcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JpY2hUZXh0Jywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihnZXRCaXRGb3JQZGYodGhpcy5GZiwgMjYpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoQm9vbGVhbih2YWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLkZmID0gc2V0Qml0Rm9yUGRmKHRoaXMuRmYsIDI2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLkZmID0gY2xlYXJCaXRGb3JQZGYodGhpcy5GZiwgMjYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9NYXhMZW4gPSBudWxsO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnTWF4TGVuJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9NYXhMZW47XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX01heExlbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogKE9wdGlvbmFsOyBpbmhlcml0YWJsZSkgVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBmaWVsZOKAmXMgdGV4dCwgaW4gY2hhcmFjdGVycy4gXG4gICAgKlxuICAgICogQG5hbWUgQWNyb0Zvcm1UZXh0RmllbGQjbWF4TGVuZ3RoXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21heExlbmd0aCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9NYXhMZW47XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgX01heExlbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoYXNBcHBlYXJhbmNlU3RyZWFtJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5WIHx8IHRoaXMuRFY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaW5oZXJpdChBY3JvRm9ybVRleHRGaWVsZCwgQWNyb0Zvcm1GaWVsZCk7XG4gIC8qKlxuICAqIEBjbGFzcyBBY3JvRm9ybVBhc3N3b3JkRmllbGRcbiAgKiBAZXh0ZW5kcyBBY3JvRm9ybVRleHRGaWVsZFxuICAqIEBleHRlbmRzIEFjcm9Gb3JtRmllbGRcbiAgKi9cblxuICB2YXIgQWNyb0Zvcm1QYXNzd29yZEZpZWxkID0gZnVuY3Rpb24gQWNyb0Zvcm1QYXNzd29yZEZpZWxkKCkge1xuICAgIEFjcm9Gb3JtVGV4dEZpZWxkLmNhbGwodGhpcyk7XG4gICAgLyoqXG4gICAgKiBJZiBzZXQsIHRoZSBmaWVsZCBpcyBpbnRlbmRlZCBmb3IgZW50ZXJpbmcgYSBzZWN1cmUgcGFzc3dvcmQgdGhhdCBzaG91bGQgbm90IGJlIGVjaG9lZCB2aXNpYmx5IHRvIHRoZSBzY3JlZW4uIENoYXJhY3RlcnMgdHlwZWQgZnJvbSB0aGUga2V5Ym9hcmQgc2hhbGwgaW5zdGVhZCBiZSBlY2hvZWQgaW4gc29tZSB1bnJlYWRhYmxlIGZvcm0sIHN1Y2ggYXMgYXN0ZXJpc2tzIG9yIGJ1bGxldCBjaGFyYWN0ZXJzLlxuICAgICogTk9URSBUbyBwcm90ZWN0IHBhc3N3b3JkIGNvbmZpZGVudGlhbGl0eSwgcmVhZGVycyBzaG91bGQgbmV2ZXIgc3RvcmUgdGhlIHZhbHVlIG9mIHRoZSB0ZXh0IGZpZWxkIGluIHRoZSBQREYgZmlsZSBpZiB0aGlzIGZsYWcgaXMgc2V0LiBcbiAgICAqXG4gICAgKiBAbmFtZSBBY3JvRm9ybVRleHRGaWVsZCNwYXNzd29yZFxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGFzc3dvcmQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGdldEJpdEZvclBkZih0aGlzLkZmLCAxNCkpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuRmYgPSBzZXRCaXRGb3JQZGYodGhpcy5GZiwgMTQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuRmYgPSBjbGVhckJpdEZvclBkZih0aGlzLkZmLCAxNCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBhc3N3b3JkID0gdHJ1ZTtcbiAgfTtcblxuICBpbmhlcml0KEFjcm9Gb3JtUGFzc3dvcmRGaWVsZCwgQWNyb0Zvcm1UZXh0RmllbGQpOyAvLyBDb250YWlucyBNZXRob2RzIGZvciBjcmVhdGluZyBzdGFuZGFyZCBhcHBlYXJhbmNlc1xuXG4gIHZhciBBY3JvRm9ybUFwcGVhcmFuY2UgPSB7XG4gICAgQ2hlY2tCb3g6IHtcbiAgICAgIGNyZWF0ZUFwcGVhcmFuY2VTdHJlYW06IGZ1bmN0aW9uIGNyZWF0ZUFwcGVhcmFuY2VTdHJlYW0oKSB7XG4gICAgICAgIHZhciBhcHBlYXJhbmNlID0ge1xuICAgICAgICAgIE46IHtcbiAgICAgICAgICAgIE9uOiBBY3JvRm9ybUFwcGVhcmFuY2UuQ2hlY2tCb3guWWVzTm9ybWFsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBEOiB7XG4gICAgICAgICAgICBPbjogQWNyb0Zvcm1BcHBlYXJhbmNlLkNoZWNrQm94Llllc1B1c2hEb3duLFxuICAgICAgICAgICAgT2ZmOiBBY3JvRm9ybUFwcGVhcmFuY2UuQ2hlY2tCb3guT2ZmUHVzaERvd25cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhcHBlYXJhbmNlO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgICogUmV0dXJucyB0aGUgc3RhbmRhcmQgT24gQXBwZWFyYW5jZSBmb3IgYSBDaGVja0JveFxuICAgICAgICAqIFxuICAgICAgICAqIEByZXR1cm5zIHtBY3JvRm9ybVhPYmplY3R9XG4gICAgICAgICovXG4gICAgICBZZXNQdXNoRG93bjogZnVuY3Rpb24gWWVzUHVzaERvd24oZm9ybU9iamVjdCkge1xuICAgICAgICB2YXIgeG9iaiA9IGNyZWF0ZUZvcm1YT2JqZWN0KGZvcm1PYmplY3QpO1xuICAgICAgICB2YXIgc3RyZWFtID0gW107XG4gICAgICAgIHZhciBmb250S2V5ID0gc2NvcGUuaW50ZXJuYWwuZ2V0Rm9udChmb3JtT2JqZWN0LmZvbnROYW1lLCBmb3JtT2JqZWN0LmZvbnRTdHlsZSkuaWQ7XG5cbiAgICAgICAgdmFyIGVuY29kZWRDb2xvciA9IHNjb3BlLl9fcHJpdmF0ZV9fLmVuY29kZUNvbG9yU3RyaW5nKGZvcm1PYmplY3QuY29sb3IpO1xuXG4gICAgICAgIHZhciBjYWxjUmVzID0gY2FsY3VsYXRlWChmb3JtT2JqZWN0LCBmb3JtT2JqZWN0LmNhcHRpb24pO1xuICAgICAgICBzdHJlYW0ucHVzaChcIjAuNzQ5MDIzIGdcIik7XG4gICAgICAgIHN0cmVhbS5wdXNoKFwiMCAwIFwiICsgZjIoQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldFdpZHRoKGZvcm1PYmplY3QpKSArIFwiIFwiICsgZjIoQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldEhlaWdodChmb3JtT2JqZWN0KSkgKyBcIiByZVwiKTtcbiAgICAgICAgc3RyZWFtLnB1c2goXCJmXCIpO1xuICAgICAgICBzdHJlYW0ucHVzaChcIkJNQ1wiKTtcbiAgICAgICAgc3RyZWFtLnB1c2goXCJxXCIpO1xuICAgICAgICBzdHJlYW0ucHVzaChcIjAgMCAxIHJnXCIpO1xuICAgICAgICBzdHJlYW0ucHVzaChcIi9cIiArIGZvbnRLZXkgKyBcIiBcIiArIGYyKGNhbGNSZXMuZm9udFNpemUpICsgXCIgVGYgXCIgKyBlbmNvZGVkQ29sb3IpO1xuICAgICAgICBzdHJlYW0ucHVzaChcIkJUXCIpO1xuICAgICAgICBzdHJlYW0ucHVzaChjYWxjUmVzLnRleHQpO1xuICAgICAgICBzdHJlYW0ucHVzaChcIkVUXCIpO1xuICAgICAgICBzdHJlYW0ucHVzaChcIlFcIik7XG4gICAgICAgIHN0cmVhbS5wdXNoKFwiRU1DXCIpO1xuICAgICAgICB4b2JqLnN0cmVhbSA9IHN0cmVhbS5qb2luKFwiXFxuXCIpO1xuICAgICAgICByZXR1cm4geG9iajtcbiAgICAgIH0sXG4gICAgICBZZXNOb3JtYWw6IGZ1bmN0aW9uIFllc05vcm1hbChmb3JtT2JqZWN0KSB7XG4gICAgICAgIHZhciB4b2JqID0gY3JlYXRlRm9ybVhPYmplY3QoZm9ybU9iamVjdCk7XG4gICAgICAgIHZhciBmb250S2V5ID0gc2NvcGUuaW50ZXJuYWwuZ2V0Rm9udChmb3JtT2JqZWN0LmZvbnROYW1lLCBmb3JtT2JqZWN0LmZvbnRTdHlsZSkuaWQ7XG5cbiAgICAgICAgdmFyIGVuY29kZWRDb2xvciA9IHNjb3BlLl9fcHJpdmF0ZV9fLmVuY29kZUNvbG9yU3RyaW5nKGZvcm1PYmplY3QuY29sb3IpO1xuXG4gICAgICAgIHZhciBzdHJlYW0gPSBbXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRIZWlnaHQoZm9ybU9iamVjdCk7XG4gICAgICAgIHZhciB3aWR0aCA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRXaWR0aChmb3JtT2JqZWN0KTtcbiAgICAgICAgdmFyIGNhbGNSZXMgPSBjYWxjdWxhdGVYKGZvcm1PYmplY3QsIGZvcm1PYmplY3QuY2FwdGlvbik7XG4gICAgICAgIHN0cmVhbS5wdXNoKFwiMSBnXCIpO1xuICAgICAgICBzdHJlYW0ucHVzaChcIjAgMCBcIiArIGYyKHdpZHRoKSArIFwiIFwiICsgZjIoaGVpZ2h0KSArIFwiIHJlXCIpO1xuICAgICAgICBzdHJlYW0ucHVzaChcImZcIik7XG4gICAgICAgIHN0cmVhbS5wdXNoKFwicVwiKTtcbiAgICAgICAgc3RyZWFtLnB1c2goXCIwIDAgMSByZ1wiKTtcbiAgICAgICAgc3RyZWFtLnB1c2goXCIwIDAgXCIgKyBmMih3aWR0aCAtIDEpICsgXCIgXCIgKyBmMihoZWlnaHQgLSAxKSArIFwiIHJlXCIpO1xuICAgICAgICBzdHJlYW0ucHVzaChcIldcIik7XG4gICAgICAgIHN0cmVhbS5wdXNoKFwiblwiKTtcbiAgICAgICAgc3RyZWFtLnB1c2goXCIwIGdcIik7XG4gICAgICAgIHN0cmVhbS5wdXNoKFwiQlRcIik7XG4gICAgICAgIHN0cmVhbS5wdXNoKFwiL1wiICsgZm9udEtleSArIFwiIFwiICsgZjIoY2FsY1Jlcy5mb250U2l6ZSkgKyBcIiBUZiBcIiArIGVuY29kZWRDb2xvcik7XG4gICAgICAgIHN0cmVhbS5wdXNoKGNhbGNSZXMudGV4dCk7XG4gICAgICAgIHN0cmVhbS5wdXNoKFwiRVRcIik7XG4gICAgICAgIHN0cmVhbS5wdXNoKFwiUVwiKTtcbiAgICAgICAgeG9iai5zdHJlYW0gPSBzdHJlYW0uam9pbihcIlxcblwiKTtcbiAgICAgICAgcmV0dXJuIHhvYmo7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIHRoZSBzdGFuZGFyZCBPZmYgQXBwZWFyYW5jZSBmb3IgYSBDaGVja0JveFxuICAgICAgICAqIFxuICAgICAgICAqIEByZXR1cm5zIHtBY3JvRm9ybVhPYmplY3R9XG4gICAgICAgICovXG4gICAgICBPZmZQdXNoRG93bjogZnVuY3Rpb24gT2ZmUHVzaERvd24oZm9ybU9iamVjdCkge1xuICAgICAgICB2YXIgeG9iaiA9IGNyZWF0ZUZvcm1YT2JqZWN0KGZvcm1PYmplY3QpO1xuICAgICAgICB2YXIgc3RyZWFtID0gW107XG4gICAgICAgIHN0cmVhbS5wdXNoKFwiMC43NDkwMjMgZ1wiKTtcbiAgICAgICAgc3RyZWFtLnB1c2goXCIwIDAgXCIgKyBmMihBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0V2lkdGgoZm9ybU9iamVjdCkpICsgXCIgXCIgKyBmMihBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0SGVpZ2h0KGZvcm1PYmplY3QpKSArIFwiIHJlXCIpO1xuICAgICAgICBzdHJlYW0ucHVzaChcImZcIik7XG4gICAgICAgIHhvYmouc3RyZWFtID0gc3RyZWFtLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIHJldHVybiB4b2JqO1xuICAgICAgfVxuICAgIH0sXG4gICAgUmFkaW9CdXR0b246IHtcbiAgICAgIENpcmNsZToge1xuICAgICAgICBjcmVhdGVBcHBlYXJhbmNlU3RyZWFtOiBmdW5jdGlvbiBjcmVhdGVBcHBlYXJhbmNlU3RyZWFtKG5hbWUpIHtcbiAgICAgICAgICB2YXIgYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQgPSB7XG4gICAgICAgICAgICBEOiB7XG4gICAgICAgICAgICAgICdPZmYnOiBBY3JvRm9ybUFwcGVhcmFuY2UuUmFkaW9CdXR0b24uQ2lyY2xlLk9mZlB1c2hEb3duXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTjoge31cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFwcGVhcmFuY2VTdHJlYW1Db250ZW50Lk5bbmFtZV0gPSBBY3JvRm9ybUFwcGVhcmFuY2UuUmFkaW9CdXR0b24uQ2lyY2xlLlllc05vcm1hbDtcbiAgICAgICAgICBhcHBlYXJhbmNlU3RyZWFtQ29udGVudC5EW25hbWVdID0gQWNyb0Zvcm1BcHBlYXJhbmNlLlJhZGlvQnV0dG9uLkNpcmNsZS5ZZXNQdXNoRG93bjtcbiAgICAgICAgICByZXR1cm4gYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENBOiBmdW5jdGlvbiBnZXRDQSgpIHtcbiAgICAgICAgICByZXR1cm4gJ2wnO1xuICAgICAgICB9LFxuICAgICAgICBZZXNOb3JtYWw6IGZ1bmN0aW9uIFllc05vcm1hbChmb3JtT2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHhvYmogPSBjcmVhdGVGb3JtWE9iamVjdChmb3JtT2JqZWN0KTtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gW107IC8vIE1ha2UgdGhlIFJhZGl1cyBvZiB0aGUgQ2lyY2xlIHJlbGF0aXZlIHRvIG1pbihoZWlnaHQsIHdpZHRoKSBvZiBmb3JtT2JqZWN0XG5cbiAgICAgICAgICB2YXIgRG90UmFkaXVzID0gQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldFdpZHRoKGZvcm1PYmplY3QpIDw9IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRIZWlnaHQoZm9ybU9iamVjdCkgPyBBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0V2lkdGgoZm9ybU9iamVjdCkgLyA0IDogQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldEhlaWdodChmb3JtT2JqZWN0KSAvIDQ7IC8vIFRoZSBCb3JkZXJwYWRkaW5nLi4uXG5cbiAgICAgICAgICBEb3RSYWRpdXMgPSBOdW1iZXIoKERvdFJhZGl1cyAqIDAuOSkudG9GaXhlZCg1KSk7XG4gICAgICAgICAgdmFyIGMgPSBBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuQmV6aWVyX0M7XG4gICAgICAgICAgdmFyIERvdFJhZGl1c0JlemllciA9IE51bWJlcigoRG90UmFkaXVzICogYykudG9GaXhlZCg1KSk7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgICogVGhlIEZvbGxvd2luZyBpcyBhIENpcmNsZSBjcmVhdGVkIHdpdGggQmV6aWVyLUN1cnZlcy5cbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICBzdHJlYW0ucHVzaChcInFcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCIxIDAgMCAxIFwiICsgZjUoQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldFdpZHRoKGZvcm1PYmplY3QpIC8gMikgKyBcIiBcIiArIGY1KEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRIZWlnaHQoZm9ybU9iamVjdCkgLyAyKSArIFwiIGNtXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKERvdFJhZGl1cyArIFwiIDAgbVwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChEb3RSYWRpdXMgKyBcIiBcIiArIERvdFJhZGl1c0JlemllciArIFwiIFwiICsgRG90UmFkaXVzQmV6aWVyICsgXCIgXCIgKyBEb3RSYWRpdXMgKyBcIiAwIFwiICsgRG90UmFkaXVzICsgXCIgY1wiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIi1cIiArIERvdFJhZGl1c0JlemllciArIFwiIFwiICsgRG90UmFkaXVzICsgXCIgLVwiICsgRG90UmFkaXVzICsgXCIgXCIgKyBEb3RSYWRpdXNCZXppZXIgKyBcIiAtXCIgKyBEb3RSYWRpdXMgKyBcIiAwIGNcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCItXCIgKyBEb3RSYWRpdXMgKyBcIiAtXCIgKyBEb3RSYWRpdXNCZXppZXIgKyBcIiAtXCIgKyBEb3RSYWRpdXNCZXppZXIgKyBcIiAtXCIgKyBEb3RSYWRpdXMgKyBcIiAwIC1cIiArIERvdFJhZGl1cyArIFwiIGNcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goRG90UmFkaXVzQmV6aWVyICsgXCIgLVwiICsgRG90UmFkaXVzICsgXCIgXCIgKyBEb3RSYWRpdXMgKyBcIiAtXCIgKyBEb3RSYWRpdXNCZXppZXIgKyBcIiBcIiArIERvdFJhZGl1cyArIFwiIDAgY1wiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcImZcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCJRXCIpO1xuICAgICAgICAgIHhvYmouc3RyZWFtID0gc3RyZWFtLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgcmV0dXJuIHhvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIFllc1B1c2hEb3duOiBmdW5jdGlvbiBZZXNQdXNoRG93bihmb3JtT2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHhvYmogPSBjcmVhdGVGb3JtWE9iamVjdChmb3JtT2JqZWN0KTtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gW107XG4gICAgICAgICAgdmFyIERvdFJhZGl1cyA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRXaWR0aChmb3JtT2JqZWN0KSA8PSBBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0SGVpZ2h0KGZvcm1PYmplY3QpID8gQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldFdpZHRoKGZvcm1PYmplY3QpIC8gNCA6IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRIZWlnaHQoZm9ybU9iamVjdCkgLyA0OyAvLyBUaGUgQm9yZGVycGFkZGluZy4uLlxuXG4gICAgICAgICAgdmFyIERvdFJhZGl1cyA9IE51bWJlcigoRG90UmFkaXVzICogMC45KS50b0ZpeGVkKDUpKTsgLy8gU2F2ZSByZXN1bHRzIGZvciBsYXRlciB1c2U7IG5vIG5lZWQgdG8gd2FzdGVcbiAgICAgICAgICAvLyBwcm9jZXNzb3IgdGlja3Mgb24gZG9pbmcgbWF0aFxuXG4gICAgICAgICAgdmFyIGsgPSBOdW1iZXIoKERvdFJhZGl1cyAqIDIpLnRvRml4ZWQoNSkpO1xuICAgICAgICAgIHZhciBrYyA9IE51bWJlcigoayAqIEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5CZXppZXJfQykudG9GaXhlZCg1KSk7XG4gICAgICAgICAgdmFyIGRjID0gTnVtYmVyKChEb3RSYWRpdXMgKiBBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuQmV6aWVyX0MpLnRvRml4ZWQoNSkpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiMC43NDkwMjMgZ1wiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcInFcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCIxIDAgMCAxIFwiICsgZjUoQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldFdpZHRoKGZvcm1PYmplY3QpIC8gMikgKyBcIiBcIiArIGY1KEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRIZWlnaHQoZm9ybU9iamVjdCkgLyAyKSArIFwiIGNtXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKGsgKyBcIiAwIG1cIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goayArIFwiIFwiICsga2MgKyBcIiBcIiArIGtjICsgXCIgXCIgKyBrICsgXCIgMCBcIiArIGsgKyBcIiBjXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiLVwiICsga2MgKyBcIiBcIiArIGsgKyBcIiAtXCIgKyBrICsgXCIgXCIgKyBrYyArIFwiIC1cIiArIGsgKyBcIiAwIGNcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCItXCIgKyBrICsgXCIgLVwiICsga2MgKyBcIiAtXCIgKyBrYyArIFwiIC1cIiArIGsgKyBcIiAwIC1cIiArIGsgKyBcIiBjXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKGtjICsgXCIgLVwiICsgayArIFwiIFwiICsgayArIFwiIC1cIiArIGtjICsgXCIgXCIgKyBrICsgXCIgMCBjXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiZlwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIlFcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCIwIGdcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCJxXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiMSAwIDAgMSBcIiArIGY1KEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRXaWR0aChmb3JtT2JqZWN0KSAvIDIpICsgXCIgXCIgKyBmNShBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0SGVpZ2h0KGZvcm1PYmplY3QpIC8gMikgKyBcIiBjbVwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChEb3RSYWRpdXMgKyBcIiAwIG1cIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCJcIiArIERvdFJhZGl1cyArIFwiIFwiICsgZGMgKyBcIiBcIiArIGRjICsgXCIgXCIgKyBEb3RSYWRpdXMgKyBcIiAwIFwiICsgRG90UmFkaXVzICsgXCIgY1wiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIi1cIiArIGRjICsgXCIgXCIgKyBEb3RSYWRpdXMgKyBcIiAtXCIgKyBEb3RSYWRpdXMgKyBcIiBcIiArIGRjICsgXCIgLVwiICsgRG90UmFkaXVzICsgXCIgMCBjXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiLVwiICsgRG90UmFkaXVzICsgXCIgLVwiICsgZGMgKyBcIiAtXCIgKyBkYyArIFwiIC1cIiArIERvdFJhZGl1cyArIFwiIDAgLVwiICsgRG90UmFkaXVzICsgXCIgY1wiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChkYyArIFwiIC1cIiArIERvdFJhZGl1cyArIFwiIFwiICsgRG90UmFkaXVzICsgXCIgLVwiICsgZGMgKyBcIiBcIiArIERvdFJhZGl1cyArIFwiIDAgY1wiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcImZcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCJRXCIpO1xuICAgICAgICAgIHhvYmouc3RyZWFtID0gc3RyZWFtLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgcmV0dXJuIHhvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIE9mZlB1c2hEb3duOiBmdW5jdGlvbiBPZmZQdXNoRG93bihmb3JtT2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHhvYmogPSBjcmVhdGVGb3JtWE9iamVjdChmb3JtT2JqZWN0KTtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gW107XG4gICAgICAgICAgdmFyIERvdFJhZGl1cyA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRXaWR0aChmb3JtT2JqZWN0KSA8PSBBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0SGVpZ2h0KGZvcm1PYmplY3QpID8gQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldFdpZHRoKGZvcm1PYmplY3QpIC8gNCA6IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRIZWlnaHQoZm9ybU9iamVjdCkgLyA0OyAvLyBUaGUgQm9yZGVycGFkZGluZy4uLlxuXG4gICAgICAgICAgdmFyIERvdFJhZGl1cyA9IE51bWJlcigoRG90UmFkaXVzICogMC45KS50b0ZpeGVkKDUpKTsgLy8gU2F2ZSByZXN1bHRzIGZvciBsYXRlciB1c2U7IG5vIG5lZWQgdG8gd2FzdGVcbiAgICAgICAgICAvLyBwcm9jZXNzb3IgdGlja3Mgb24gZG9pbmcgbWF0aFxuXG4gICAgICAgICAgdmFyIGsgPSBOdW1iZXIoKERvdFJhZGl1cyAqIDIpLnRvRml4ZWQoNSkpO1xuICAgICAgICAgIHZhciBrYyA9IE51bWJlcigoayAqIEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5CZXppZXJfQykudG9GaXhlZCg1KSk7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCIwLjc0OTAyMyBnXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwicVwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIjEgMCAwIDEgXCIgKyBmNShBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0V2lkdGgoZm9ybU9iamVjdCkgLyAyKSArIFwiIFwiICsgZjUoQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldEhlaWdodChmb3JtT2JqZWN0KSAvIDIpICsgXCIgY21cIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goayArIFwiIDAgbVwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChrICsgXCIgXCIgKyBrYyArIFwiIFwiICsga2MgKyBcIiBcIiArIGsgKyBcIiAwIFwiICsgayArIFwiIGNcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCItXCIgKyBrYyArIFwiIFwiICsgayArIFwiIC1cIiArIGsgKyBcIiBcIiArIGtjICsgXCIgLVwiICsgayArIFwiIDAgY1wiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIi1cIiArIGsgKyBcIiAtXCIgKyBrYyArIFwiIC1cIiArIGtjICsgXCIgLVwiICsgayArIFwiIDAgLVwiICsgayArIFwiIGNcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goa2MgKyBcIiAtXCIgKyBrICsgXCIgXCIgKyBrICsgXCIgLVwiICsga2MgKyBcIiBcIiArIGsgKyBcIiAwIGNcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCJmXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiUVwiKTtcbiAgICAgICAgICB4b2JqLnN0cmVhbSA9IHN0cmVhbS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgIHJldHVybiB4b2JqO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ3Jvc3M6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgKiBDcmVhdGVzIHRoZSBBY3R1YWwgQXBwZWFyYW5jZURpY3Rpb25hcnktUmVmZXJlbmNlc1xuICAgICAgICAgICogXG4gICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICAqL1xuICAgICAgICBjcmVhdGVBcHBlYXJhbmNlU3RyZWFtOiBmdW5jdGlvbiBjcmVhdGVBcHBlYXJhbmNlU3RyZWFtKG5hbWUpIHtcbiAgICAgICAgICB2YXIgYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQgPSB7XG4gICAgICAgICAgICBEOiB7XG4gICAgICAgICAgICAgICdPZmYnOiBBY3JvRm9ybUFwcGVhcmFuY2UuUmFkaW9CdXR0b24uQ3Jvc3MuT2ZmUHVzaERvd25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBOOiB7fVxuICAgICAgICAgIH07XG4gICAgICAgICAgYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQuTltuYW1lXSA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5SYWRpb0J1dHRvbi5Dcm9zcy5ZZXNOb3JtYWw7XG4gICAgICAgICAgYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQuRFtuYW1lXSA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5SYWRpb0J1dHRvbi5Dcm9zcy5ZZXNQdXNoRG93bjtcbiAgICAgICAgICByZXR1cm4gYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENBOiBmdW5jdGlvbiBnZXRDQSgpIHtcbiAgICAgICAgICByZXR1cm4gJzgnO1xuICAgICAgICB9LFxuICAgICAgICBZZXNOb3JtYWw6IGZ1bmN0aW9uIFllc05vcm1hbChmb3JtT2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHhvYmogPSBjcmVhdGVGb3JtWE9iamVjdChmb3JtT2JqZWN0KTtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gW107XG4gICAgICAgICAgdmFyIGNyb3NzID0gQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmNhbGN1bGF0ZUNyb3NzKGZvcm1PYmplY3QpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwicVwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIjEgMSBcIiArIGYyKEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRXaWR0aChmb3JtT2JqZWN0KSAtIDIpICsgXCIgXCIgKyBmMihBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0SGVpZ2h0KGZvcm1PYmplY3QpIC0gMikgKyBcIiByZVwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIldcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCJuXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKGYyKGNyb3NzLngxLngpICsgXCIgXCIgKyBmMihjcm9zcy54MS55KSArIFwiIG1cIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goZjIoY3Jvc3MueDIueCkgKyBcIiBcIiArIGYyKGNyb3NzLngyLnkpICsgXCIgbFwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChmMihjcm9zcy54NC54KSArIFwiIFwiICsgZjIoY3Jvc3MueDQueSkgKyBcIiBtXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKGYyKGNyb3NzLngzLngpICsgXCIgXCIgKyBmMihjcm9zcy54My55KSArIFwiIGxcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCJzXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiUVwiKTtcbiAgICAgICAgICB4b2JqLnN0cmVhbSA9IHN0cmVhbS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgIHJldHVybiB4b2JqO1xuICAgICAgICB9LFxuICAgICAgICBZZXNQdXNoRG93bjogZnVuY3Rpb24gWWVzUHVzaERvd24oZm9ybU9iamVjdCkge1xuICAgICAgICAgIHZhciB4b2JqID0gY3JlYXRlRm9ybVhPYmplY3QoZm9ybU9iamVjdCk7XG4gICAgICAgICAgdmFyIGNyb3NzID0gQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmNhbGN1bGF0ZUNyb3NzKGZvcm1PYmplY3QpO1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBbXTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIjAuNzQ5MDIzIGdcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCIwIDAgXCIgKyBmMihBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0V2lkdGgoZm9ybU9iamVjdCkpICsgXCIgXCIgKyBmMihBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0SGVpZ2h0KGZvcm1PYmplY3QpKSArIFwiIHJlXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiZlwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcInFcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCIxIDEgXCIgKyBmMihBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0V2lkdGgoZm9ybU9iamVjdCkgLSAyKSArIFwiIFwiICsgZjIoQWNyb0Zvcm1BcHBlYXJhbmNlLmludGVybmFsLmdldEhlaWdodChmb3JtT2JqZWN0KSAtIDIpICsgXCIgcmVcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCJXXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiblwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChmMihjcm9zcy54MS54KSArIFwiIFwiICsgZjIoY3Jvc3MueDEueSkgKyBcIiBtXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKGYyKGNyb3NzLngyLngpICsgXCIgXCIgKyBmMihjcm9zcy54Mi55KSArIFwiIGxcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goZjIoY3Jvc3MueDQueCkgKyBcIiBcIiArIGYyKGNyb3NzLng0LnkpICsgXCIgbVwiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChmMihjcm9zcy54My54KSArIFwiIFwiICsgZjIoY3Jvc3MueDMueSkgKyBcIiBsXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwic1wiKTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIlFcIik7XG4gICAgICAgICAgeG9iai5zdHJlYW0gPSBzdHJlYW0uam9pbihcIlxcblwiKTtcbiAgICAgICAgICByZXR1cm4geG9iajtcbiAgICAgICAgfSxcbiAgICAgICAgT2ZmUHVzaERvd246IGZ1bmN0aW9uIE9mZlB1c2hEb3duKGZvcm1PYmplY3QpIHtcbiAgICAgICAgICB2YXIgeG9iaiA9IGNyZWF0ZUZvcm1YT2JqZWN0KGZvcm1PYmplY3QpO1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBbXTtcbiAgICAgICAgICBzdHJlYW0ucHVzaChcIjAuNzQ5MDIzIGdcIik7XG4gICAgICAgICAgc3RyZWFtLnB1c2goXCIwIDAgXCIgKyBmMihBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0V2lkdGgoZm9ybU9iamVjdCkpICsgXCIgXCIgKyBmMihBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0SGVpZ2h0KGZvcm1PYmplY3QpKSArIFwiIHJlXCIpO1xuICAgICAgICAgIHN0cmVhbS5wdXNoKFwiZlwiKTtcbiAgICAgICAgICB4b2JqLnN0cmVhbSA9IHN0cmVhbS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgIHJldHVybiB4b2JqO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAgKiBSZXR1cm5zIHRoZSBzdGFuZGFyZCBBcHBlYXJhbmNlXG4gICAgICAqIFxuICAgICAgKiBAcmV0dXJucyB7QWNyb0Zvcm1YT2JqZWN0fVxuICAgICAgKi9cbiAgICBjcmVhdGVEZWZhdWx0QXBwZWFyYW5jZVN0cmVhbTogZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEFwcGVhcmFuY2VTdHJlYW0oZm9ybU9iamVjdCkge1xuICAgICAgLy8gU2V0IEhlbHZldGljYSB0byBTdGFuZGFyZCBGb250IChzaXplOiBhdXRvKVxuICAgICAgLy8gQ29sb3I6IEJsYWNrXG4gICAgICB2YXIgZm9udEtleSA9IHNjb3BlLmludGVybmFsLmdldEZvbnQoZm9ybU9iamVjdC5mb250TmFtZSwgZm9ybU9iamVjdC5mb250U3R5bGUpLmlkO1xuXG4gICAgICB2YXIgZW5jb2RlZENvbG9yID0gc2NvcGUuX19wcml2YXRlX18uZW5jb2RlQ29sb3JTdHJpbmcoZm9ybU9iamVjdC5jb2xvcik7XG5cbiAgICAgIHZhciBmb250U2l6ZSA9IGZvcm1PYmplY3QuZm9udFNpemU7XG4gICAgICB2YXIgcmVzdWx0ID0gJy8nICsgZm9udEtleSArICcgJyArIGZvbnRTaXplICsgJyBUZiAnICsgZW5jb2RlZENvbG9yO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG4gIEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbCA9IHtcbiAgICBCZXppZXJfQzogMC41NTE5MTUwMjQ0OTQsXG4gICAgY2FsY3VsYXRlQ3Jvc3M6IGZ1bmN0aW9uIGNhbGN1bGF0ZUNyb3NzKGZvcm1PYmplY3QpIHtcbiAgICAgIHZhciB3aWR0aCA9IEFjcm9Gb3JtQXBwZWFyYW5jZS5pbnRlcm5hbC5nZXRXaWR0aChmb3JtT2JqZWN0KTtcbiAgICAgIHZhciBoZWlnaHQgPSBBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0SGVpZ2h0KGZvcm1PYmplY3QpO1xuICAgICAgdmFyIGEgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgdmFyIGNyb3NzID0ge1xuICAgICAgICB4MToge1xuICAgICAgICAgIC8vIHVwcGVyTGVmdFxuICAgICAgICAgIHg6ICh3aWR0aCAtIGEpIC8gMixcbiAgICAgICAgICB5OiAoaGVpZ2h0IC0gYSkgLyAyICsgYSAvLyBoZWlnaHQgLSBib3JkZXJQYWRkaW5nXG5cbiAgICAgICAgfSxcbiAgICAgICAgeDI6IHtcbiAgICAgICAgICAvLyBsb3dlclJpZ2h0XG4gICAgICAgICAgeDogKHdpZHRoIC0gYSkgLyAyICsgYSxcbiAgICAgICAgICB5OiAoaGVpZ2h0IC0gYSkgLyAyIC8vIGJvcmRlclBhZGRpbmdcblxuICAgICAgICB9LFxuICAgICAgICB4Mzoge1xuICAgICAgICAgIC8vIGxvd2VyTGVmdFxuICAgICAgICAgIHg6ICh3aWR0aCAtIGEpIC8gMixcbiAgICAgICAgICB5OiAoaGVpZ2h0IC0gYSkgLyAyIC8vIGJvcmRlclBhZGRpbmdcblxuICAgICAgICB9LFxuICAgICAgICB4NDoge1xuICAgICAgICAgIC8vIHVwcGVyUmlnaHRcbiAgICAgICAgICB4OiAod2lkdGggLSBhKSAvIDIgKyBhLFxuICAgICAgICAgIHk6IChoZWlnaHQgLSBhKSAvIDIgKyBhIC8vIGhlaWdodCAtIGJvcmRlclBhZGRpbmdcblxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNyb3NzO1xuICAgIH1cbiAgfTtcblxuICBBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0V2lkdGggPSBmdW5jdGlvbiAoZm9ybU9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSAwO1xuXG4gICAgaWYgKF90eXBlb2YoZm9ybU9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJlc3VsdCA9IHNjYWxlKGZvcm1PYmplY3QuUmVjdFsyXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBBY3JvRm9ybUFwcGVhcmFuY2UuaW50ZXJuYWwuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGZvcm1PYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcblxuICAgIGlmIChfdHlwZW9mKGZvcm1PYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXN1bHQgPSBzY2FsZShmb3JtT2JqZWN0LlJlY3RbM10pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07IC8vIFB1YmxpYzpcblxuICAvKipcbiAgKiBBZGQgYW4gQWNyb0Zvcm0tRmllbGQgdG8gdGhlIGpzUERGLWluc3RhbmNlXG4gICpcbiAgKiBAbmFtZSBhZGRGaWVsZFxuICAqIEBmdW5jdGlvbiBcbiAgKiBAaW5zdGFuY2VcbiAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRPYmplY3RcbiAgKiBAcmV0dXJucyB7anNQREZ9XG4gICovXG5cblxuICB2YXIgYWRkRmllbGQgPSBqc1BERkFQSS5hZGRGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZE9iamVjdCkge1xuICAgIGluaXRpYWxpemVBY3JvRm9ybS5jYWxsKHRoaXMpO1xuXG4gICAgaWYgKGZpZWxkT2JqZWN0IGluc3RhbmNlb2YgQWNyb0Zvcm1GaWVsZCkge1xuICAgICAgcHV0Rm9ybS5jYWxsKHRoaXMsIGZpZWxkT2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5hZGRGaWVsZC4nKTtcbiAgICB9XG5cbiAgICBmaWVsZE9iamVjdC5wYWdlID0gc2NvcGUuaW50ZXJuYWwuZ2V0Q3VycmVudFBhZ2VJbmZvKCkucGFnZU51bWJlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICogQG5hbWUgYWRkQnV0dG9uXG4gICogQGZ1bmN0aW9uXG4gICogQGluc3RhbmNlXG4gICogQHBhcmFtIHtBY3JvRm9ybUJ1dHRvbn0gb3B0aW9uc1xuICAqIEByZXR1cm5zIHtqc1BERn1cbiAgKiBAZGVwcmVjYXRlZFxuICAqL1xuXG5cbiAgdmFyIGFkZEJ1dHRvbiA9IGpzUERGQVBJLmFkZEJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b24pIHtcbiAgICBpZiAoYnV0dG9uIGluc3RhbmNlb2YgQWNyb0Zvcm1CdXR0b24gPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGpzUERGLmFkZEJ1dHRvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkRmllbGQuY2FsbCh0aGlzLCBidXR0b24pO1xuICB9O1xuICAvKipcbiAgKiBAbmFtZSBhZGRUZXh0RmllbGRcbiAgKiBAZnVuY3Rpb25cbiAgKiBAaW5zdGFuY2VcbiAgKiBAcGFyYW0ge0Fjcm9Gb3JtVGV4dEZpZWxkfSB0ZXh0RmllbGRcbiAgKiBAcmV0dXJucyB7anNQREZ9XG4gICogQGRlcHJlY2F0ZWRcbiAgKi9cblxuXG4gIHZhciBhZGRUZXh0RmllbGQgPSBqc1BERkFQSS5hZGRUZXh0RmllbGQgPSBmdW5jdGlvbiAodGV4dEZpZWxkKSB7XG4gICAgaWYgKHRleHRGaWVsZCBpbnN0YW5jZW9mIEFjcm9Gb3JtVGV4dEZpZWxkID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5hZGRUZXh0RmllbGQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZEZpZWxkLmNhbGwodGhpcywgdGV4dEZpZWxkKTtcbiAgfTtcbiAgLyoqXG4gICogQG5hbWUgYWRkQ2hvaWNlRmllbGRcbiAgKiBAZnVuY3Rpb25cbiAgKiBAaW5zdGFuY2VcbiAgKiBAcGFyYW0ge0Fjcm9Gb3JtQ2hvaWNlRmllbGR9IFxuICAqIEByZXR1cm5zIHtqc1BERn1cbiAgKiBAZGVwcmVjYXRlZFxuICAqL1xuXG5cbiAgdmFyIGFkZENob2ljZUZpZWxkID0ganNQREZBUEkuYWRkQ2hvaWNlRmllbGQgPSBmdW5jdGlvbiAoY2hvaWNlRmllbGQpIHtcbiAgICBpZiAoY2hvaWNlRmllbGQgaW5zdGFuY2VvZiBBY3JvRm9ybUNob2ljZUZpZWxkID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5hZGRDaG9pY2VGaWVsZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkRmllbGQuY2FsbCh0aGlzLCBjaG9pY2VGaWVsZCk7XG4gIH07XG5cbiAgaWYgKF90eXBlb2YoZ2xvYmFsT2JqKSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBnbG9iYWxPYmpbXCJDaG9pY2VGaWVsZFwiXSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZ2xvYmFsT2JqW1wiTGlzdEJveFwiXSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZ2xvYmFsT2JqW1wiQ29tYm9Cb3hcIl0gPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGdsb2JhbE9ialtcIkVkaXRCb3hcIl0gPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGdsb2JhbE9ialtcIkJ1dHRvblwiXSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZ2xvYmFsT2JqW1wiUHVzaEJ1dHRvblwiXSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZ2xvYmFsT2JqW1wiUmFkaW9CdXR0b25cIl0gPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGdsb2JhbE9ialtcIkNoZWNrQm94XCJdID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBnbG9iYWxPYmpbXCJUZXh0RmllbGRcIl0gPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGdsb2JhbE9ialtcIlBhc3N3b3JkRmllbGRcIl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBnbG9iYWxPYmpbXCJDaG9pY2VGaWVsZFwiXSA9IEFjcm9Gb3JtQ2hvaWNlRmllbGQ7XG4gICAgZ2xvYmFsT2JqW1wiTGlzdEJveFwiXSA9IEFjcm9Gb3JtTGlzdEJveDtcbiAgICBnbG9iYWxPYmpbXCJDb21ib0JveFwiXSA9IEFjcm9Gb3JtQ29tYm9Cb3g7XG4gICAgZ2xvYmFsT2JqW1wiRWRpdEJveFwiXSA9IEFjcm9Gb3JtRWRpdEJveDtcbiAgICBnbG9iYWxPYmpbXCJCdXR0b25cIl0gPSBBY3JvRm9ybUJ1dHRvbjtcbiAgICBnbG9iYWxPYmpbXCJQdXNoQnV0dG9uXCJdID0gQWNyb0Zvcm1QdXNoQnV0dG9uO1xuICAgIGdsb2JhbE9ialtcIlJhZGlvQnV0dG9uXCJdID0gQWNyb0Zvcm1SYWRpb0J1dHRvbjtcbiAgICBnbG9iYWxPYmpbXCJDaGVja0JveFwiXSA9IEFjcm9Gb3JtQ2hlY2tCb3g7XG4gICAgZ2xvYmFsT2JqW1wiVGV4dEZpZWxkXCJdID0gQWNyb0Zvcm1UZXh0RmllbGQ7XG4gICAgZ2xvYmFsT2JqW1wiUGFzc3dvcmRGaWVsZFwiXSA9IEFjcm9Gb3JtUGFzc3dvcmRGaWVsZDsgLy8gYmFja3dhcmRzQ29tcGF0aWJpbGl0eVxuXG4gICAgZ2xvYmFsT2JqW1wiQWNyb0Zvcm1cIl0gPSB7XG4gICAgICBBcHBlYXJhbmNlOiBBY3JvRm9ybUFwcGVhcmFuY2VcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcIkFjcm9Gb3JtLUNsYXNzZXMgYXJlIG5vdCBwb3B1bGF0ZWQgaW50byBnbG9iYWwtbmFtZXNwYWNlLCBiZWNhdXNlIHRoZSBjbGFzcy1OYW1lcyBleGlzdCBhbHJlYWR5LlwiKTtcbiAgfVxuXG4gIGpzUERGQVBJLkFjcm9Gb3JtQ2hvaWNlRmllbGQgPSBBY3JvRm9ybUNob2ljZUZpZWxkO1xuICBqc1BERkFQSS5BY3JvRm9ybUxpc3RCb3ggPSBBY3JvRm9ybUxpc3RCb3g7XG4gIGpzUERGQVBJLkFjcm9Gb3JtQ29tYm9Cb3ggPSBBY3JvRm9ybUNvbWJvQm94O1xuICBqc1BERkFQSS5BY3JvRm9ybUVkaXRCb3ggPSBBY3JvRm9ybUVkaXRCb3g7XG4gIGpzUERGQVBJLkFjcm9Gb3JtQnV0dG9uID0gQWNyb0Zvcm1CdXR0b247XG4gIGpzUERGQVBJLkFjcm9Gb3JtUHVzaEJ1dHRvbiA9IEFjcm9Gb3JtUHVzaEJ1dHRvbjtcbiAganNQREZBUEkuQWNyb0Zvcm1SYWRpb0J1dHRvbiA9IEFjcm9Gb3JtUmFkaW9CdXR0b247XG4gIGpzUERGQVBJLkFjcm9Gb3JtQ2hlY2tCb3ggPSBBY3JvRm9ybUNoZWNrQm94O1xuICBqc1BERkFQSS5BY3JvRm9ybVRleHRGaWVsZCA9IEFjcm9Gb3JtVGV4dEZpZWxkO1xuICBqc1BERkFQSS5BY3JvRm9ybVBhc3N3b3JkRmllbGQgPSBBY3JvRm9ybVBhc3N3b3JkRmllbGQ7XG4gIGpzUERGQVBJLkFjcm9Gb3JtQXBwZWFyYW5jZSA9IEFjcm9Gb3JtQXBwZWFyYW5jZTtcbiAganNQREZBUEkuQWNyb0Zvcm0gPSB7XG4gICAgQ2hvaWNlRmllbGQ6IEFjcm9Gb3JtQ2hvaWNlRmllbGQsXG4gICAgTGlzdEJveDogQWNyb0Zvcm1MaXN0Qm94LFxuICAgIENvbWJvQm94OiBBY3JvRm9ybUNvbWJvQm94LFxuICAgIEVkaXRCb3g6IEFjcm9Gb3JtRWRpdEJveCxcbiAgICBCdXR0b246IEFjcm9Gb3JtQnV0dG9uLFxuICAgIFB1c2hCdXR0b246IEFjcm9Gb3JtUHVzaEJ1dHRvbixcbiAgICBSYWRpb0J1dHRvbjogQWNyb0Zvcm1SYWRpb0J1dHRvbixcbiAgICBDaGVja0JveDogQWNyb0Zvcm1DaGVja0JveCxcbiAgICBUZXh0RmllbGQ6IEFjcm9Gb3JtVGV4dEZpZWxkLFxuICAgIFBhc3N3b3JkRmllbGQ6IEFjcm9Gb3JtUGFzc3dvcmRGaWVsZCxcbiAgICBBcHBlYXJhbmNlOiBBY3JvRm9ybUFwcGVhcmFuY2VcbiAgfTtcbn0pKGpzUERGLkFQSSwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpO1xuXG4vKiogQGxpY2Vuc2VcbiAqIGpzUERGIGFkZEltYWdlIHBsdWdpblxuICogQ29weXJpZ2h0IChjKSAyMDEyIEphc29uIFNpZWZrZW4sIGh0dHBzOi8vZ2l0aHViLmNvbS9zaWVma2Vuai9cbiAqICAgICAgICAgICAgICAgMjAxMyBDaHJpcyBEb3dsaW5nLCBodHRwczovL2dpdGh1Yi5jb20vZ2luZ2VyY2hyaXNcbiAqICAgICAgICAgICAgICAgMjAxMyBUcmluaCBIbywgaHR0cHM6Ly9naXRodWIuY29tL2luZWVkZmF0XG4gKiAgICAgICAgICAgICAgIDIwMTMgRWR3aW4gQWxlamFuZHJvIFBlcmV6LCBodHRwczovL2dpdGh1Yi5jb20vZWFwYXJhbmdvXG4gKiAgICAgICAgICAgICAgIDIwMTMgTm9yYWggU21pdGgsIGh0dHBzOi8vZ2l0aHViLmNvbS9idXJuYnVybnJvY2tldFxuICogICAgICAgICAgICAgICAyMDE0IERpZWdvIENhc29ycmFuLCBodHRwczovL2dpdGh1Yi5jb20vZGllZ29jclxuICogICAgICAgICAgICAgICAyMDE0IEphbWVzIFJvYmIsIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW1lc2Jyb2JiXG4gKlxuICogXG4gKi9cblxuLyoqXG4qIEBuYW1lIGFkZEltYWdlXG4qIEBtb2R1bGVcbiovXG4oZnVuY3Rpb24gKGpzUERGQVBJKSB7XG5cbiAgdmFyIG5hbWVzcGFjZSA9ICdhZGRJbWFnZV8nO1xuICB2YXIgaW1hZ2VGaWxlVHlwZUhlYWRlcnMgPSB7XG4gICAgUE5HOiBbWzB4ODksIDB4NTAsIDB4NGUsIDB4NDddXSxcbiAgICBUSUZGOiBbWzB4NEQsIDB4NEQsIDB4MDAsIDB4MkFdLCAvL01vdG9yb2xhXG4gICAgWzB4NDksIDB4NDksIDB4MkEsIDB4MDBdIC8vSW50ZWxcbiAgICBdLFxuICAgIEpQRUc6IFtbMHhGRiwgMHhEOCwgMHhGRiwgMHhFMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDB4NEEsIDB4NDYsIDB4NDksIDB4NDYsIDB4MDBdLCAvL0pGSUZcbiAgICBbMHhGRiwgMHhEOCwgMHhGRiwgMHhFMSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDB4NDUsIDB4NzgsIDB4NjksIDB4NjYsIDB4MDAsIDB4MDBdIC8vRXhpZlxuICAgIF0sXG4gICAgSlBFRzIwMDA6IFtbMHgwMCwgMHgwMCwgMHgwMCwgMHgwQywgMHg2QSwgMHg1MCwgMHgyMCwgMHgyMF1dLFxuICAgIEdJRjg3YTogW1sweDQ3LCAweDQ5LCAweDQ2LCAweDM4LCAweDM3LCAweDYxXV0sXG4gICAgR0lGODlhOiBbWzB4NDcsIDB4NDksIDB4NDYsIDB4MzgsIDB4MzksIDB4NjFdXSxcbiAgICBCTVA6IFtbMHg0MiwgMHg0RF0sIC8vQk0gLSBXaW5kb3dzIDMuMXgsIDk1LCBOVCwgLi4uIGV0Yy5cbiAgICBbMHg0MiwgMHg0MV0sIC8vQkEgLSBPUy8yIHN0cnVjdCBiaXRtYXAgYXJyYXlcbiAgICBbMHg0MywgMHg0OV0sIC8vQ0kgLSBPUy8yIHN0cnVjdCBjb2xvciBpY29uXG4gICAgWzB4NDMsIDB4NTBdLCAvL0NQIC0gT1MvMiBjb25zdCBjb2xvciBwb2ludGVyXG4gICAgWzB4NDksIDB4NDNdLCAvL0lDIC0gT1MvMiBzdHJ1Y3QgaWNvblxuICAgIFsweDUwLCAweDU0XSAvL1BUIC0gT1MvMiBwb2ludGVyXG4gICAgXVxuICB9O1xuICAvKipcbiAgKiBSZWNvZ25pemUgZmlsZXR5cGUgb2YgSW1hZ2UgYnkgbWFnaWMtYnl0ZXNcbiAgKiBcbiAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX2ZpbGVfc2lnbmF0dXJlc1xuICAqXG4gICogQG5hbWUgZ2V0SW1hZ2VGaWxlVHlwZUJ5SW1hZ2VEYXRhXG4gICogQHB1YmxpY1xuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5YnVmZmVyfSBpbWFnZURhdGEgaW1hZ2VEYXRhIGFzIGJpbmFyeSBTdHJpbmcgb3IgYXJyYXlidWZmZXJcbiAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IGZvcm1hdCBvZiBmaWxlIGlmIGZpbGV0eXBlLXJlY29nbml0aW9uIGZhaWxzLCBlLmcuICdKUEVHJ1xuICAqIFxuICAqIEByZXR1cm5zIHtzdHJpbmd9IGZpbGV0eXBlIG9mIEltYWdlXG4gICovXG5cbiAgdmFyIGdldEltYWdlRmlsZVR5cGVCeUltYWdlRGF0YSA9IGpzUERGQVBJLmdldEltYWdlRmlsZVR5cGVCeUltYWdlRGF0YSA9IGZ1bmN0aW9uIChpbWFnZURhdGEsIGZhbGxiYWNrRm9ybWF0KSB7XG4gICAgZmFsbGJhY2tGb3JtYXQgPSBmYWxsYmFja0Zvcm1hdCB8fCAnVU5LTk9XTic7XG4gICAgdmFyIGk7XG4gICAgdmFyIGo7XG4gICAgdmFyIHJlc3VsdCA9ICdVTktOT1dOJztcbiAgICB2YXIgaGVhZGVyU2NoZW1hdGE7XG4gICAgdmFyIGNvbXBhcmVSZXN1bHQ7XG4gICAgdmFyIGZpbGVUeXBlO1xuXG4gICAgaWYgKGpzUERGQVBJLmlzQXJyYXlCdWZmZXJWaWV3KGltYWdlRGF0YSkpIHtcbiAgICAgIGltYWdlRGF0YSA9IGpzUERGQVBJLmFycmF5QnVmZmVyVG9CaW5hcnlTdHJpbmcoaW1hZ2VEYXRhKTtcbiAgICB9XG5cbiAgICBmb3IgKGZpbGVUeXBlIGluIGltYWdlRmlsZVR5cGVIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJTY2hlbWF0YSA9IGltYWdlRmlsZVR5cGVIZWFkZXJzW2ZpbGVUeXBlXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGhlYWRlclNjaGVtYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbXBhcmVSZXN1bHQgPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBoZWFkZXJTY2hlbWF0YVtpXS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIGlmIChoZWFkZXJTY2hlbWF0YVtpXVtqXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGVhZGVyU2NoZW1hdGFbaV1bal0gIT09IGltYWdlRGF0YS5jaGFyQ29kZUF0KGopKSB7XG4gICAgICAgICAgICBjb21wYXJlUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZVJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZpbGVUeXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gJ1VOS05PV04nICYmIGZhbGxiYWNrRm9ybWF0ICE9PSAnVU5LTk9XTicpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmlsZVR5cGUgb2YgSW1hZ2Ugbm90IHJlY29nbml6ZWQuIFByb2Nlc3NpbmcgaW1hZ2UgYXMgXCInICsgZmFsbGJhY2tGb3JtYXQgKyAnXCIuJyk7XG4gICAgICByZXN1bHQgPSBmYWxsYmFja0Zvcm1hdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9OyAvLyBJbWFnZSBmdW5jdGlvbmFsaXR5IHBvcnRlZCBmcm9tIHBkZi5qc1xuXG5cbiAgdmFyIHB1dEltYWdlID0gZnVuY3Rpb24gcHV0SW1hZ2UoaW1nKSB7XG4gICAgdmFyIG9iamVjdE51bWJlciA9IHRoaXMuaW50ZXJuYWwubmV3T2JqZWN0KCksXG4gICAgICAgIG91dCA9IHRoaXMuaW50ZXJuYWwud3JpdGUsXG4gICAgICAgIHB1dFN0cmVhbSA9IHRoaXMuaW50ZXJuYWwucHV0U3RyZWFtLFxuICAgICAgICBnZXRGaWx0ZXJzID0gdGhpcy5pbnRlcm5hbC5nZXRGaWx0ZXJzO1xuICAgIHZhciBmaWx0ZXJzID0gZ2V0RmlsdGVycygpO1xuXG4gICAgd2hpbGUgKGZpbHRlcnMuaW5kZXhPZignRmxhdGVFbmNvZGUnKSAhPT0gLTEpIHtcbiAgICAgIGZpbHRlcnMuc3BsaWNlKGZpbHRlcnMuaW5kZXhPZignRmxhdGVFbmNvZGUnKSwgMSk7XG4gICAgfVxuXG4gICAgaW1nWyduJ10gPSBvYmplY3ROdW1iZXI7XG4gICAgdmFyIGFkZGl0aW9uYWxLZXlWYWx1ZXMgPSBbXTtcbiAgICBhZGRpdGlvbmFsS2V5VmFsdWVzLnB1c2goe1xuICAgICAga2V5OiAnVHlwZScsXG4gICAgICB2YWx1ZTogJy9YT2JqZWN0J1xuICAgIH0pO1xuICAgIGFkZGl0aW9uYWxLZXlWYWx1ZXMucHVzaCh7XG4gICAgICBrZXk6ICdTdWJ0eXBlJyxcbiAgICAgIHZhbHVlOiAnL0ltYWdlJ1xuICAgIH0pO1xuICAgIGFkZGl0aW9uYWxLZXlWYWx1ZXMucHVzaCh7XG4gICAgICBrZXk6ICdXaWR0aCcsXG4gICAgICB2YWx1ZTogaW1nWyd3J11cbiAgICB9KTtcbiAgICBhZGRpdGlvbmFsS2V5VmFsdWVzLnB1c2goe1xuICAgICAga2V5OiAnSGVpZ2h0JyxcbiAgICAgIHZhbHVlOiBpbWdbJ2gnXVxuICAgIH0pO1xuXG4gICAgaWYgKGltZ1snY3MnXSA9PT0gdGhpcy5jb2xvcl9zcGFjZXMuSU5ERVhFRCkge1xuICAgICAgYWRkaXRpb25hbEtleVZhbHVlcy5wdXNoKHtcbiAgICAgICAga2V5OiAnQ29sb3JTcGFjZScsXG4gICAgICAgIHZhbHVlOiAnWy9JbmRleGVkIC9EZXZpY2VSR0IgJyAvLyBpZiBhbiBpbmRleGVkIHBuZyBkZWZpbmVzIG1vcmUgdGhhbiBvbmUgY29sb3VyIHdpdGggdHJhbnNwYXJlbmN5LCB3ZSd2ZSBjcmVhdGVkIGEgc21hc2tcbiAgICAgICAgKyAoaW1nWydwYWwnXS5sZW5ndGggLyAzIC0gMSkgKyAnICcgKyAoJ3NtYXNrJyBpbiBpbWcgPyBvYmplY3ROdW1iZXIgKyAyIDogb2JqZWN0TnVtYmVyICsgMSkgKyAnIDAgUl0nXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkaXRpb25hbEtleVZhbHVlcy5wdXNoKHtcbiAgICAgICAga2V5OiAnQ29sb3JTcGFjZScsXG4gICAgICAgIHZhbHVlOiAnLycgKyBpbWdbJ2NzJ11cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW1nWydjcyddID09PSB0aGlzLmNvbG9yX3NwYWNlcy5ERVZJQ0VfQ01ZSykge1xuICAgICAgICBhZGRpdGlvbmFsS2V5VmFsdWVzLnB1c2goe1xuICAgICAgICAgIGtleTogJ0RlY29kZScsXG4gICAgICAgICAgdmFsdWU6ICdbMSAwIDEgMCAxIDAgMSAwXSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWRkaXRpb25hbEtleVZhbHVlcy5wdXNoKHtcbiAgICAgIGtleTogJ0JpdHNQZXJDb21wb25lbnQnLFxuICAgICAgdmFsdWU6IGltZ1snYnBjJ11cbiAgICB9KTtcblxuICAgIGlmICgnZHAnIGluIGltZykge1xuICAgICAgYWRkaXRpb25hbEtleVZhbHVlcy5wdXNoKHtcbiAgICAgICAga2V5OiAnRGVjb2RlUGFybXMnLFxuICAgICAgICB2YWx1ZTogJzw8JyArIGltZ1snZHAnXSArICc+PidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgndHJucycgaW4gaW1nICYmIGltZ1sndHJucyddLmNvbnN0cnVjdG9yID09IEFycmF5KSB7XG4gICAgICB2YXIgdHJucyA9ICcnLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGxlbiA9IGltZ1sndHJucyddLmxlbmd0aDtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0cm5zICs9IGltZ1sndHJucyddW2ldICsgJyAnICsgaW1nWyd0cm5zJ11baV0gKyAnICc7XG4gICAgICB9XG5cbiAgICAgIGFkZGl0aW9uYWxLZXlWYWx1ZXMucHVzaCh7XG4gICAgICAgIGtleTogJ01hc2snLFxuICAgICAgICB2YWx1ZTogJ1snICsgdHJucyArICddJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCdzbWFzaycgaW4gaW1nKSB7XG4gICAgICBhZGRpdGlvbmFsS2V5VmFsdWVzLnB1c2goe1xuICAgICAgICBrZXk6ICdTTWFzaycsXG4gICAgICAgIHZhbHVlOiBvYmplY3ROdW1iZXIgKyAxICsgJyAwIFInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUFwcGxpZWRGaWx0ZXJzID0gdHlwZW9mIGltZ1snZiddICE9PSBcInVuZGVmaW5lZFwiID8gWycvJyArIGltZ1snZiddXSA6IHVuZGVmaW5lZDtcbiAgICBwdXRTdHJlYW0oe1xuICAgICAgZGF0YTogaW1nWydkYXRhJ10sXG4gICAgICBhZGRpdGlvbmFsS2V5VmFsdWVzOiBhZGRpdGlvbmFsS2V5VmFsdWVzLFxuICAgICAgYWxyZWFkeUFwcGxpZWRGaWx0ZXJzOiBhbHJlYWR5QXBwbGllZEZpbHRlcnNcbiAgICB9KTtcbiAgICBvdXQoJ2VuZG9iaicpOyAvLyBTb2Z0IG1hc2tcblxuICAgIGlmICgnc21hc2snIGluIGltZykge1xuICAgICAgdmFyIGRwID0gJy9QcmVkaWN0b3IgJyArIGltZ1sncCddICsgJyAvQ29sb3JzIDEgL0JpdHNQZXJDb21wb25lbnQgJyArIGltZ1snYnBjJ10gKyAnIC9Db2x1bW5zICcgKyBpbWdbJ3cnXTtcbiAgICAgIHZhciBzbWFzayA9IHtcbiAgICAgICAgJ3cnOiBpbWdbJ3cnXSxcbiAgICAgICAgJ2gnOiBpbWdbJ2gnXSxcbiAgICAgICAgJ2NzJzogJ0RldmljZUdyYXknLFxuICAgICAgICAnYnBjJzogaW1nWydicGMnXSxcbiAgICAgICAgJ2RwJzogZHAsXG4gICAgICAgICdkYXRhJzogaW1nWydzbWFzayddXG4gICAgICB9O1xuICAgICAgaWYgKCdmJyBpbiBpbWcpIHNtYXNrLmYgPSBpbWdbJ2YnXTtcbiAgICAgIHB1dEltYWdlLmNhbGwodGhpcywgc21hc2spO1xuICAgIH0gLy9QYWxldHRlXG5cblxuICAgIGlmIChpbWdbJ2NzJ10gPT09IHRoaXMuY29sb3Jfc3BhY2VzLklOREVYRUQpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWwubmV3T2JqZWN0KCk7IC8vb3V0KCc8PCAvRmlsdGVyIC8gJyArIGltZ1snZiddICsnIC9MZW5ndGggJyArIGltZ1sncGFsJ10ubGVuZ3RoICsgJz4+Jyk7XG4gICAgICAvL3B1dFN0cmVhbSh6bGliLmNvbXByZXNzKGltZ1sncGFsJ10pKTtcblxuICAgICAgcHV0U3RyZWFtKHtcbiAgICAgICAgZGF0YTogdGhpcy5hcnJheUJ1ZmZlclRvQmluYXJ5U3RyaW5nKG5ldyBVaW50OEFycmF5KGltZ1sncGFsJ10pKVxuICAgICAgfSk7XG4gICAgICBvdXQoJ2VuZG9iaicpO1xuICAgIH1cbiAgfSxcbiAgICAgIHB1dFJlc291cmNlc0NhbGxiYWNrID0gZnVuY3Rpb24gcHV0UmVzb3VyY2VzQ2FsbGJhY2soKSB7XG4gICAgdmFyIGltYWdlcyA9IHRoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnNbbmFtZXNwYWNlICsgJ2ltYWdlcyddO1xuXG4gICAgZm9yICh2YXIgaSBpbiBpbWFnZXMpIHtcbiAgICAgIHB1dEltYWdlLmNhbGwodGhpcywgaW1hZ2VzW2ldKTtcbiAgICB9XG4gIH0sXG4gICAgICBwdXRYT2JqZWN0c0RpY3RDYWxsYmFjayA9IGZ1bmN0aW9uIHB1dFhPYmplY3RzRGljdENhbGxiYWNrKCkge1xuICAgIHZhciBpbWFnZXMgPSB0aGlzLmludGVybmFsLmNvbGxlY3Rpb25zW25hbWVzcGFjZSArICdpbWFnZXMnXSxcbiAgICAgICAgb3V0ID0gdGhpcy5pbnRlcm5hbC53cml0ZSxcbiAgICAgICAgaW1hZ2U7XG5cbiAgICBmb3IgKHZhciBpIGluIGltYWdlcykge1xuICAgICAgaW1hZ2UgPSBpbWFnZXNbaV07XG4gICAgICBvdXQoJy9JJyArIGltYWdlWydpJ10sIGltYWdlWyduJ10sICcwJywgJ1InKTtcbiAgICB9XG4gIH0sXG4gICAgICBjaGVja0NvbXByZXNzVmFsdWUgPSBmdW5jdGlvbiBjaGVja0NvbXByZXNzVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgdmFsdWUgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiB2YWx1ZSBpbiBqc1BERkFQSS5pbWFnZV9jb21wcmVzc2lvbiA/IHZhbHVlIDoganNQREZBUEkuaW1hZ2VfY29tcHJlc3Npb24uTk9ORTtcbiAgfSxcbiAgICAgIGdldEltYWdlcyA9IGZ1bmN0aW9uIGdldEltYWdlcygpIHtcbiAgICB2YXIgaW1hZ2VzID0gdGhpcy5pbnRlcm5hbC5jb2xsZWN0aW9uc1tuYW1lc3BhY2UgKyAnaW1hZ2VzJ107IC8vZmlyc3QgcnVuLCBzbyBpbml0aWFsaXNlIHN0dWZmXG5cbiAgICBpZiAoIWltYWdlcykge1xuICAgICAgdGhpcy5pbnRlcm5hbC5jb2xsZWN0aW9uc1tuYW1lc3BhY2UgKyAnaW1hZ2VzJ10gPSBpbWFnZXMgPSB7fTtcbiAgICAgIHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgncHV0UmVzb3VyY2VzJywgcHV0UmVzb3VyY2VzQ2FsbGJhY2spO1xuICAgICAgdGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCdwdXRYb2JqZWN0RGljdCcsIHB1dFhPYmplY3RzRGljdENhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VzO1xuICB9LFxuICAgICAgZ2V0SW1hZ2VJbmRleCA9IGZ1bmN0aW9uIGdldEltYWdlSW5kZXgoaW1hZ2VzKSB7XG4gICAgdmFyIGltYWdlSW5kZXggPSAwO1xuXG4gICAgaWYgKGltYWdlcykge1xuICAgICAgLy8gdGhpcyBpcyBOT1QgdGhlIGZpcnN0IHRpbWUgdGhpcyBtZXRob2QgaXMgcmFuIG9uIHRoaXMgaW5zdGFuY2Ugb2YganNQREYgb2JqZWN0LlxuICAgICAgaW1hZ2VJbmRleCA9IE9iamVjdC5rZXlzID8gT2JqZWN0LmtleXMoaW1hZ2VzKS5sZW5ndGggOiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgZSBpbiBvKSB7XG4gICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoZSkpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0oaW1hZ2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VJbmRleDtcbiAgfSxcbiAgICAgIG5vdERlZmluZWQgPSBmdW5jdGlvbiBub3REZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xuICB9LFxuICAgICAgZ2VuZXJhdGVBbGlhc0Zyb21JbWFnZURhdGEgPSBmdW5jdGlvbiBnZW5lcmF0ZUFsaWFzRnJvbUltYWdlRGF0YShpbWFnZURhdGEpIHtcbiAgICBpZiAodHlwZW9mIGltYWdlRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBqc1BERkFQSS5zSGFzaENvZGUoaW1hZ2VEYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoanNQREZBUEkuaXNBcnJheUJ1ZmZlclZpZXcoaW1hZ2VEYXRhKSkge1xuICAgICAgcmV0dXJuIGpzUERGQVBJLnNIYXNoQ29kZShqc1BERkFQSS5hcnJheUJ1ZmZlclRvQmluYXJ5U3RyaW5nKGltYWdlRGF0YSkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICAgICAgaXNJbWFnZVR5cGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc0ltYWdlVHlwZVN1cHBvcnRlZCh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBqc1BERkFQSVtcInByb2Nlc3NcIiArIHR5cGUudG9VcHBlckNhc2UoKV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgfSxcbiAgICAgIGlzRE9NRWxlbWVudCA9IGZ1bmN0aW9uIGlzRE9NRWxlbWVudChvYmplY3QpIHtcbiAgICByZXR1cm4gX3R5cGVvZihvYmplY3QpID09PSAnb2JqZWN0JyAmJiBvYmplY3Qubm9kZVR5cGUgPT09IDE7XG4gIH0sXG4gICAgICBjcmVhdGVEYXRhVVJJRnJvbUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVEYXRhVVJJRnJvbUVsZW1lbnQoZWxlbWVudCwgZm9ybWF0KSB7XG4gICAgLy9pZiBlbGVtZW50IGlzIGFuIGltYWdlIHdoaWNoIHVzZXMgZGF0YSB1cmwgZGVmaW5pdGlvbiwganVzdCByZXR1cm4gdGhlIGRhdGF1cmxcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0lNRycgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3NyYycpKSB7XG4gICAgICB2YXIgc3JjID0gJycgKyBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJyk7IC8vaXMgYmFzZTY0IGVuY29kZWQgZGF0YVVybCwgZGlyZWN0bHkgcHJvY2VzcyBpdFxuXG4gICAgICBpZiAoc3JjLmluZGV4T2YoJ2RhdGE6aW1hZ2UvJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlKHNyYyk7XG4gICAgICB9IC8vaXQgaXMgcHJvYmFibHkgYW4gdXJsLCB0cnkgdG8gbG9hZCBpdFxuXG5cbiAgICAgIHZhciB0bXBJbWFnZURhdGEgPSBqc1BERkFQSS5sb2FkRmlsZShzcmMpO1xuXG4gICAgICBpZiAodG1wSW1hZ2VEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGJ0b2EodG1wSW1hZ2VEYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0NBTlZBUycpIHtcbiAgICAgIHZhciBjYW52YXMgPSBlbGVtZW50O1xuICAgICAgcmV0dXJuIGVsZW1lbnQudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMS4wKTtcbiAgICB9IC8vYWJzb2x1dGUgZmFsbGJhY2sgbWV0aG9kXG5cblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoIHx8IGVsZW1lbnQud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGlmICghY3R4KSB7XG4gICAgICB0aHJvdyAnYWRkSW1hZ2UgcmVxdWlyZXMgY2FudmFzIHRvIGJlIHN1cHBvcnRlZCBieSBicm93c2VyLic7XG4gICAgfVxuXG4gICAgY3R4LmRyYXdJbWFnZShlbGVtZW50LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCgnJyArIGZvcm1hdCkudG9Mb3dlckNhc2UoKSA9PSAncG5nJyA/ICdpbWFnZS9wbmcnIDogJ2ltYWdlL2pwZWcnKTtcbiAgfSxcbiAgICAgIGNoZWNrSW1hZ2VzRm9yQWxpYXMgPSBmdW5jdGlvbiBjaGVja0ltYWdlc0ZvckFsaWFzKGFsaWFzLCBpbWFnZXMpIHtcbiAgICB2YXIgY2FjaGVkX2luZm87XG5cbiAgICBpZiAoaW1hZ2VzKSB7XG4gICAgICBmb3IgKHZhciBlIGluIGltYWdlcykge1xuICAgICAgICBpZiAoYWxpYXMgPT09IGltYWdlc1tlXS5hbGlhcykge1xuICAgICAgICAgIGNhY2hlZF9pbmZvID0gaW1hZ2VzW2VdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlZF9pbmZvO1xuICB9LFxuICAgICAgZGV0ZXJtaW5lV2lkdGhBbmRIZWlnaHQgPSBmdW5jdGlvbiBkZXRlcm1pbmVXaWR0aEFuZEhlaWdodCh3LCBoLCBpbmZvKSB7XG4gICAgaWYgKCF3ICYmICFoKSB7XG4gICAgICB3ID0gLTk2O1xuICAgICAgaCA9IC05NjtcbiAgICB9XG5cbiAgICBpZiAodyA8IDApIHtcbiAgICAgIHcgPSAtMSAqIGluZm9bJ3cnXSAqIDcyIC8gdyAvIHRoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3I7XG4gICAgfVxuXG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoID0gLTEgKiBpbmZvWydoJ10gKiA3MiAvIGggLyB0aGlzLmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgIH1cblxuICAgIGlmICh3ID09PSAwKSB7XG4gICAgICB3ID0gaCAqIGluZm9bJ3cnXSAvIGluZm9bJ2gnXTtcbiAgICB9XG5cbiAgICBpZiAoaCA9PT0gMCkge1xuICAgICAgaCA9IHcgKiBpbmZvWydoJ10gLyBpbmZvWyd3J107XG4gICAgfVxuXG4gICAgcmV0dXJuIFt3LCBoXTtcbiAgfSxcbiAgICAgIHdyaXRlSW1hZ2VUb1BERiA9IGZ1bmN0aW9uIHdyaXRlSW1hZ2VUb1BERih4LCB5LCB3LCBoLCBpbmZvLCBpbmRleCwgaW1hZ2VzLCByb3RhdGlvbikge1xuICAgIHZhciBkaW1zID0gZGV0ZXJtaW5lV2lkdGhBbmRIZWlnaHQuY2FsbCh0aGlzLCB3LCBoLCBpbmZvKSxcbiAgICAgICAgY29vcmQgPSB0aGlzLmludGVybmFsLmdldENvb3JkaW5hdGVTdHJpbmcsXG4gICAgICAgIHZjb29yZCA9IHRoaXMuaW50ZXJuYWwuZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nO1xuICAgIHcgPSBkaW1zWzBdO1xuICAgIGggPSBkaW1zWzFdO1xuICAgIGltYWdlc1tpbmRleF0gPSBpbmZvO1xuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByb3RhdGlvbiAqPSBNYXRoLlBJIC8gMTgwO1xuICAgICAgdmFyIGMgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKHJvdGF0aW9uKTsgLy9saWtlIGluIHBkZiBSZWZlcmVuY2UgZG8gaXQgNCBkaWdpdHMgaW5zdGVhZCBvZiAyXG5cbiAgICAgIHZhciBmNCA9IGZ1bmN0aW9uIGY0KG51bWJlcikge1xuICAgICAgICByZXR1cm4gbnVtYmVyLnRvRml4ZWQoNCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcm90YXRpb25UcmFuc2Zvcm1hdGlvbk1hdHJpeCA9IFtmNChjKSwgZjQocyksIGY0KHMgKiAtMSksIGY0KGMpLCAwLCAwLCAnY20nXTtcbiAgICB9XG5cbiAgICB0aGlzLmludGVybmFsLndyaXRlKCdxJyk7IC8vU2F2ZSBncmFwaGljcyBzdGF0ZVxuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICB0aGlzLmludGVybmFsLndyaXRlKFsxLCAnMCcsICcwJywgMSwgY29vcmQoeCksIHZjb29yZCh5ICsgaCksICdjbSddLmpvaW4oJyAnKSk7IC8vVHJhbnNsYXRlXG5cbiAgICAgIHRoaXMuaW50ZXJuYWwud3JpdGUocm90YXRpb25UcmFuc2Zvcm1hdGlvbk1hdHJpeC5qb2luKCcgJykpOyAvL1JvdGF0ZVxuXG4gICAgICB0aGlzLmludGVybmFsLndyaXRlKFtjb29yZCh3KSwgJzAnLCAnMCcsIGNvb3JkKGgpLCAnMCcsICcwJywgJ2NtJ10uam9pbignICcpKTsgLy9TY2FsZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludGVybmFsLndyaXRlKFtjb29yZCh3KSwgJzAnLCAnMCcsIGNvb3JkKGgpLCBjb29yZCh4KSwgdmNvb3JkKHkgKyBoKSwgJ2NtJ10uam9pbignICcpKTsgLy9UcmFuc2xhdGUgYW5kIFNjYWxlXG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcm5hbC53cml0ZSgnL0knICsgaW5mb1snaSddICsgJyBEbycpOyAvL1BhaW50IEltYWdlXG5cbiAgICB0aGlzLmludGVybmFsLndyaXRlKCdRJyk7IC8vUmVzdG9yZSBncmFwaGljcyBzdGF0ZVxuICB9O1xuICAvKipcbiAgICogQ09MT1IgU1BBQ0VTXG4gICAqL1xuXG5cbiAganNQREZBUEkuY29sb3Jfc3BhY2VzID0ge1xuICAgIERFVklDRV9SR0I6ICdEZXZpY2VSR0InLFxuICAgIERFVklDRV9HUkFZOiAnRGV2aWNlR3JheScsXG4gICAgREVWSUNFX0NNWUs6ICdEZXZpY2VDTVlLJyxcbiAgICBDQUxfR1JFWTogJ0NhbEdyYXknLFxuICAgIENBTF9SR0I6ICdDYWxSR0InLFxuICAgIExBQjogJ0xhYicsXG4gICAgSUNDX0JBU0VEOiAnSUNDQmFzZWQnLFxuICAgIElOREVYRUQ6ICdJbmRleGVkJyxcbiAgICBQQVRURVJOOiAnUGF0dGVybicsXG4gICAgU0VQQVJBVElPTjogJ1NlcGFyYXRpb24nLFxuICAgIERFVklDRV9OOiAnRGV2aWNlTidcbiAgfTtcbiAgLyoqXG4gICAqIERFQ09ERSBNRVRIT0RTXG4gICAqL1xuXG4gIGpzUERGQVBJLmRlY29kZSA9IHtcbiAgICBEQ1RfREVDT0RFOiAnRENURGVjb2RlJyxcbiAgICBGTEFURV9ERUNPREU6ICdGbGF0ZURlY29kZScsXG4gICAgTFpXX0RFQ09ERTogJ0xaV0RlY29kZScsXG4gICAgSlBYX0RFQ09ERTogJ0pQWERlY29kZScsXG4gICAgSkJJRzJfREVDT0RFOiAnSkJJRzJEZWNvZGUnLFxuICAgIEFTQ0lJODVfREVDT0RFOiAnQVNDSUk4NURlY29kZScsXG4gICAgQVNDSUlfSEVYX0RFQ09ERTogJ0FTQ0lJSGV4RGVjb2RlJyxcbiAgICBSVU5fTEVOR1RIX0RFQ09ERTogJ1J1bkxlbmd0aERlY29kZScsXG4gICAgQ0NJVFRfRkFYX0RFQ09ERTogJ0NDSVRURmF4RGVjb2RlJ1xuICB9O1xuICAvKipcbiAgICogSU1BR0UgQ09NUFJFU1NJT04gVFlQRVNcbiAgICovXG5cbiAganNQREZBUEkuaW1hZ2VfY29tcHJlc3Npb24gPSB7XG4gICAgTk9ORTogJ05PTkUnLFxuICAgIEZBU1Q6ICdGQVNUJyxcbiAgICBNRURJVU06ICdNRURJVU0nLFxuICAgIFNMT1c6ICdTTE9XJ1xuICB9O1xuICAvKipcbiAgKiBAbmFtZSBzSGFzaENvZGVcbiAgKiBAZnVuY3Rpb24gXG4gICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAqIEByZXR1cm5zIHtzdHJpbmd9IFxuICAqL1xuXG4gIGpzUERGQVBJLnNIYXNoQ29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBzdHIgPSBzdHIgfHwgXCJcIjtcbiAgICB2YXIgaGFzaCA9IDAsXG4gICAgICAgIGksXG4gICAgICAgIGNocjtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGhhc2g7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHI7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBoYXNoO1xuICB9O1xuICAvKipcbiAgKiBAbmFtZSBpc1N0cmluZ1xuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7YW55fSBvYmplY3RcbiAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gXG4gICovXG5cblxuICBqc1BERkFQSS5pc1N0cmluZyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZyc7XG4gIH07XG4gIC8qKlxuICAqIFZhbGlkYXRlcyBpZiBnaXZlbiBTdHJpbmcgaXMgYSB2YWxpZCBCYXNlNjQtU3RyaW5nXG4gICpcbiAgKiBAbmFtZSB2YWxpZGF0ZVN0cmluZ0FzQmFzZTY0XG4gICogQHB1YmxpY1xuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NzaWJsZSBCYXNlNjQtU3RyaW5nXG4gICogXG4gICogQHJldHVybnMge2Jvb2xlYW59XG4gICovXG5cblxuICBqc1BERkFQSS52YWxpZGF0ZVN0cmluZ0FzQmFzZTY0ID0gZnVuY3Rpb24gKHBvc3NpYmxlQmFzZTY0U3RyaW5nKSB7XG4gICAgcG9zc2libGVCYXNlNjRTdHJpbmcgPSBwb3NzaWJsZUJhc2U2NFN0cmluZyB8fCAnJztcbiAgICBwb3NzaWJsZUJhc2U2NFN0cmluZy50b1N0cmluZygpLnRyaW0oKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcblxuICAgIGlmIChwb3NzaWJsZUJhc2U2NFN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwb3NzaWJsZUJhc2U2NFN0cmluZy5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoL15bQS1aYS16MC05K1xcL10rJC8udGVzdChwb3NzaWJsZUJhc2U2NFN0cmluZy5zdWJzdHIoMCwgcG9zc2libGVCYXNlNjRTdHJpbmcubGVuZ3RoIC0gMikpID09PSBmYWxzZSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKC9eW0EtWmEtejAtOVxcL11bQS1aYS16MC05K1xcL118W0EtWmEtejAtOStcXC9dPXw9PSQvLnRlc3QocG9zc2libGVCYXNlNjRTdHJpbmcuc3Vic3RyKC0yKSkgPT09IGZhbHNlKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvKipcbiAgICogU3RyaXBzIG91dCBhbmQgcmV0dXJucyBpbmZvIGZyb20gYSB2YWxpZCBiYXNlNjQgZGF0YSBVUklcbiAgICpcbiAgICogQG5hbWUgZXh0cmFjdEluZm9Gcm9tQmFzZTY0RGF0YVVSSVxuICAgKiBAZnVuY3Rpb24gXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVXJsIGEgdmFsaWQgZGF0YSBVUkkgb2YgZm9ybWF0ICdkYXRhOls8TUlNRS10eXBlPl1bO2Jhc2U2NF0sPGRhdGE+J1xuICAgKiBAcmV0dXJucyB7QXJyYXl9YW4gQXJyYXkgY29udGFpbmluZyB0aGUgZm9sbG93aW5nXG4gICAqIFswXSB0aGUgY29tcGxldGUgZGF0YSBVUklcbiAgICogWzFdIDxNSU1FLXR5cGU+XG4gICAqIFsyXSBmb3JtYXQgLSB0aGUgc2Vjb25kIHBhcnQgb2YgdGhlIG1pbWUtdHlwZSBpLmUgJ3BuZycgaW4gJ2ltYWdlL3BuZydcbiAgICogWzRdIDxkYXRhPlxuICAgKi9cblxuXG4gIGpzUERGQVBJLmV4dHJhY3RJbmZvRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiAoZGF0YVVSSSkge1xuICAgIHJldHVybiAvXmRhdGE6KFtcXHddKz9cXC8oW1xcd10rPykpO1xcUyo7KmJhc2U2NCwoLispJC9nLmV4ZWMoZGF0YVVSSSk7XG4gIH07XG4gIC8qKlxuICAgKiBTdHJpcHMgb3V0IGFuZCByZXR1cm5zIGluZm8gZnJvbSBhIHZhbGlkIGJhc2U2NCBkYXRhIFVSSVxuICAgKlxuICAgKiBAbmFtZSBleHRyYWN0SW1hZ2VGcm9tRGF0YVVybFxuICAgKiBAZnVuY3Rpb24gXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVXJsIGEgdmFsaWQgZGF0YSBVUkkgb2YgZm9ybWF0ICdkYXRhOls8TUlNRS10eXBlPl1bO2Jhc2U2NF0sPGRhdGE+J1xuICAgKiBAcmV0dXJucyB7QXJyYXl9YW4gQXJyYXkgY29udGFpbmluZyB0aGUgZm9sbG93aW5nXG4gICAqIFswXSB0aGUgY29tcGxldGUgZGF0YSBVUklcbiAgICogWzFdIDxNSU1FLXR5cGU+XG4gICAqIFsyXSBmb3JtYXQgLSB0aGUgc2Vjb25kIHBhcnQgb2YgdGhlIG1pbWUtdHlwZSBpLmUgJ3BuZycgaW4gJ2ltYWdlL3BuZydcbiAgICogWzRdIDxkYXRhPlxuICAgKi9cblxuXG4gIGpzUERGQVBJLmV4dHJhY3RJbWFnZUZyb21EYXRhVXJsID0gZnVuY3Rpb24gKGRhdGFVcmwpIHtcbiAgICBkYXRhVXJsID0gZGF0YVVybCB8fCAnJztcbiAgICB2YXIgZGF0YVVybFBhcnRzID0gZGF0YVVybC5zcGxpdCgnYmFzZTY0LCcpO1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgaWYgKGRhdGFVcmxQYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBleHRyYWN0ZWRJbmZvID0gL15kYXRhOihcXHcqXFwvXFx3Kik7KihjaGFyc2V0PVtcXHc9LV0qKSo7KiQvLmV4ZWMoZGF0YVVybFBhcnRzWzBdKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0cmFjdGVkSW5mbykpIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIG1pbWVUeXBlOiBleHRyYWN0ZWRJbmZvWzFdLFxuICAgICAgICAgIGNoYXJzZXQ6IGV4dHJhY3RlZEluZm9bMl0sXG4gICAgICAgICAgZGF0YTogZGF0YVVybFBhcnRzWzFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiBBcnJheUJ1ZmZlciBpcyBzdXBwb3J0ZWRcbiAgICogXG4gICAqIEBuYW1lIHN1cHBvcnRzQXJyYXlCdWZmZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIGpzUERGQVBJLnN1cHBvcnRzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgc3VwcGxpZWQgb2JqZWN0IHRvIGRldGVybWluZSBpZiBBcnJheUJ1ZmZlclxuICAgKlxuICAgKiBAbmFtZSBpc0FycmF5QnVmZmVyXG4gICAqIEBmdW5jdGlvbiBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBhbiBPYmplY3RcbiAgICogXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIGpzUERGQVBJLmlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzQXJyYXlCdWZmZXIoKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIHN1cHBsaWVkIG9iamVjdCB0byBkZXRlcm1pbmUgaWYgaXQgaW1wbGVtZW50cyB0aGUgQXJyYXlCdWZmZXJWaWV3IChUeXBlZEFycmF5KSBpbnRlcmZhY2VcbiAgICpcbiAgICogQG5hbWUgaXNBcnJheUJ1ZmZlclZpZXdcbiAgICogQGZ1bmN0aW9uIFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IGFuIE9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBqc1BERkFQSS5pc0FycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHNBcnJheUJ1ZmZlcigpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgSW50OEFycmF5IHx8IG9iamVjdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCBvYmplY3QgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8IG9iamVjdCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8IG9iamVjdCBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHwgb2JqZWN0IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHwgb2JqZWN0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IG9iamVjdCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheTtcbiAgfTtcbiAgLyoqXG4gICogQ29udmVydCB0aGUgQnVmZmVyIHRvIGEgQmluYXJ5IFN0cmluZ1xuICAqXG4gICogQG5hbWUgYmluYXJ5U3RyaW5nVG9VaW50OEFycmF5XG4gICogQHB1YmxpY1xuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IEJpbmFyeVN0cmluZyB3aXRoIEltYWdlRGF0YVxuICAqIFxuICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAqL1xuXG5cbiAganNQREZBUEkuYmluYXJ5U3RyaW5nVG9VaW50OEFycmF5ID0gZnVuY3Rpb24gKGJpbmFyeV9zdHJpbmcpIHtcbiAgICAvKlxuICAgICAqIG5vdCBzdXJlIGhvdyBlZmZpY2llbnQgdGhpcyB3aWxsIGJlIHdpbGwgYmlnZ2VyIGZpbGVzLiBJcyB0aGVyZSBhIG5hdGl2ZSBtZXRob2Q/XG4gICAgICovXG4gICAgdmFyIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IGJpbmFyeV9zdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG4gIC8qKlxuICAqIENvbnZlcnQgdGhlIEJ1ZmZlciB0byBhIEJpbmFyeSBTdHJpbmdcbiAgKlxuICAqIEBuYW1lIGFycmF5QnVmZmVyVG9CaW5hcnlTdHJpbmdcbiAgKiBAcHVibGljXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gQXJyYXlCdWZmZXIgd2l0aCBJbWFnZURhdGFcbiAgKiBcbiAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAqL1xuXG5cbiAganNQREZBUEkuYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAvLyBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikucmVkdWNlKGZ1bmN0aW9uIChkYXRhLCBieXRlKSB7XG4gICAgLy8gcmV0dXJuIGRhdGEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKSwgZGF0YTtcbiAgICAvLyB9LCBbXSkuam9pbignJyk7XG4gICAgLy8gfVxuICAgIGlmICh0eXBlb2YgYXRvYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXRvYih0aGlzLmFycmF5QnVmZmVyVG9CYXNlNjQoYnVmZmVyKSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciBkaXJlY3RseSB0byBiYXNlNjRcbiAgKlxuICAqIFRha2VuIGZyb20gIGh0dHA6Ly9qc3BlcmYuY29tL2VuY29kaW5nLXhoci1pbWFnZS1kYXRhLzMxXG4gICpcbiAgKiBOZWVkIHRvIHRlc3QgaWYgdGhpcyBpcyBhIGJldHRlciBzb2x1dGlvbiBmb3IgbGFyZ2VyIGZpbGVzXG4gICpcbiAgKiBAbmFtZSBhcnJheUJ1ZmZlclRvQmFzZTY0XG4gICogQHBhcmFtIHthcnJheWJ1ZmZlcn0gYXJyYXlCdWZmZXJcbiAgKiBAcHVibGljXG4gICogQGZ1bmN0aW9uXG4gICogXG4gICogQHJldHVybnMge3N0cmluZ31cbiAgKi9cblxuXG4gIGpzUERGQVBJLmFycmF5QnVmZmVyVG9CYXNlNjQgPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgYmFzZTY0ID0gJyc7XG4gICAgdmFyIGVuY29kaW5ncyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIHZhciBieXRlUmVtYWluZGVyID0gYnl0ZUxlbmd0aCAlIDM7XG4gICAgdmFyIG1haW5MZW5ndGggPSBieXRlTGVuZ3RoIC0gYnl0ZVJlbWFpbmRlcjtcbiAgICB2YXIgYSwgYiwgYywgZDtcbiAgICB2YXIgY2h1bms7IC8vIE1haW4gbG9vcCBkZWFscyB3aXRoIGJ5dGVzIGluIGNodW5rcyBvZiAzXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1haW5MZW5ndGg7IGkgPSBpICsgMykge1xuICAgICAgLy8gQ29tYmluZSB0aGUgdGhyZWUgYnl0ZXMgaW50byBhIHNpbmdsZSBpbnRlZ2VyXG4gICAgICBjaHVuayA9IGJ5dGVzW2ldIDw8IDE2IHwgYnl0ZXNbaSArIDFdIDw8IDggfCBieXRlc1tpICsgMl07IC8vIFVzZSBiaXRtYXNrcyB0byBleHRyYWN0IDYtYml0IHNlZ21lbnRzIGZyb20gdGhlIHRyaXBsZXRcblxuICAgICAgYSA9IChjaHVuayAmIDE2NTE1MDcyKSA+PiAxODsgLy8gMTY1MTUwNzIgPSAoMl42IC0gMSkgPDwgMThcblxuICAgICAgYiA9IChjaHVuayAmIDI1ODA0OCkgPj4gMTI7IC8vIDI1ODA0OCAgID0gKDJeNiAtIDEpIDw8IDEyXG5cbiAgICAgIGMgPSAoY2h1bmsgJiA0MDMyKSA+PiA2OyAvLyA0MDMyICAgICA9ICgyXjYgLSAxKSA8PCA2XG5cbiAgICAgIGQgPSBjaHVuayAmIDYzOyAvLyA2MyAgICAgICA9IDJeNiAtIDFcbiAgICAgIC8vIENvbnZlcnQgdGhlIHJhdyBiaW5hcnkgc2VnbWVudHMgdG8gdGhlIGFwcHJvcHJpYXRlIEFTQ0lJIGVuY29kaW5nXG5cbiAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBlbmNvZGluZ3NbY10gKyBlbmNvZGluZ3NbZF07XG4gICAgfSAvLyBEZWFsIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcyBhbmQgcGFkZGluZ1xuXG5cbiAgICBpZiAoYnl0ZVJlbWFpbmRlciA9PSAxKSB7XG4gICAgICBjaHVuayA9IGJ5dGVzW21haW5MZW5ndGhdO1xuICAgICAgYSA9IChjaHVuayAmIDI1MikgPj4gMjsgLy8gMjUyID0gKDJeNiAtIDEpIDw8IDJcbiAgICAgIC8vIFNldCB0aGUgNCBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cblxuICAgICAgYiA9IChjaHVuayAmIDMpIDw8IDQ7IC8vIDMgICA9IDJeMiAtIDFcblxuICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArICc9PSc7XG4gICAgfSBlbHNlIGlmIChieXRlUmVtYWluZGVyID09IDIpIHtcbiAgICAgIGNodW5rID0gYnl0ZXNbbWFpbkxlbmd0aF0gPDwgOCB8IGJ5dGVzW21haW5MZW5ndGggKyAxXTtcbiAgICAgIGEgPSAoY2h1bmsgJiA2NDUxMikgPj4gMTA7IC8vIDY0NTEyID0gKDJeNiAtIDEpIDw8IDEwXG5cbiAgICAgIGIgPSAoY2h1bmsgJiAxMDA4KSA+PiA0OyAvLyAxMDA4ICA9ICgyXjYgLSAxKSA8PCA0XG4gICAgICAvLyBTZXQgdGhlIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB0byB6ZXJvXG5cbiAgICAgIGMgPSAoY2h1bmsgJiAxNSkgPDwgMjsgLy8gMTUgICAgPSAyXjQgLSAxXG5cbiAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBlbmNvZGluZ3NbY10gKyAnPSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcbiAgLyoqXG4gICogXG4gICogQG5hbWUgY3JlYXRlSW1hZ2VJbmZvXG4gICogQHBhcmFtIHtPYmplY3R9IGRhdGEgXG4gICogQHBhcmFtIHtudW1iZXJ9IHdkIHdpZHRoXG4gICogQHBhcmFtIHtudW1iZXJ9IGh0IGhlaWdodFxuICAqIEBwYXJhbSB7T2JqZWN0fSBjcyBjb2xvclNwYWNlXG4gICogQHBhcmFtIHtudW1iZXJ9IGJwYyBiaXRzIHBlciBjaGFubmVsXG4gICogQHBhcmFtIHthbnl9IGYgXG4gICogQHBhcmFtIHtudW1iZXJ9IGltYWdlSW5kZXhcbiAgKiBAcGFyYW0ge3N0cmluZ30gYWxpYXNcbiAgKiBAcGFyYW0ge2FueX0gZHBcbiAgKiBAcGFyYW0ge2FueX0gdHJuc1xuICAqIEBwYXJhbSB7YW55fSBwYWxcbiAgKiBAcGFyYW0ge2FueX0gc21hc2tcbiAgKiBAcGFyYW0ge2FueX0gcFxuICAqIEBwdWJsaWNcbiAgKiBAZnVuY3Rpb25cbiAgKiBcbiAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAqL1xuXG5cbiAganNQREZBUEkuY3JlYXRlSW1hZ2VJbmZvID0gZnVuY3Rpb24gKGRhdGEsIHdkLCBodCwgY3MsIGJwYywgZiwgaW1hZ2VJbmRleCwgYWxpYXMsIGRwLCB0cm5zLCBwYWwsIHNtYXNrLCBwKSB7XG4gICAgdmFyIGluZm8gPSB7XG4gICAgICBhbGlhczogYWxpYXMsXG4gICAgICB3OiB3ZCxcbiAgICAgIGg6IGh0LFxuICAgICAgY3M6IGNzLFxuICAgICAgYnBjOiBicGMsXG4gICAgICBpOiBpbWFnZUluZGV4LFxuICAgICAgZGF0YTogZGF0YSAvLyBuOiBvYmplY3ROdW1iZXIgd2lsbCBiZSBhZGRlZCBieSBwdXRJbWFnZSBjb2RlXG5cbiAgICB9O1xuICAgIGlmIChmKSBpbmZvLmYgPSBmO1xuICAgIGlmIChkcCkgaW5mby5kcCA9IGRwO1xuICAgIGlmICh0cm5zKSBpbmZvLnRybnMgPSB0cm5zO1xuICAgIGlmIChwYWwpIGluZm8ucGFsID0gcGFsO1xuICAgIGlmIChzbWFzaykgaW5mby5zbWFzayA9IHNtYXNrO1xuICAgIGlmIChwKSBpbmZvLnAgPSBwOyAvLyBwcmVkaWN0b3IgcGFyYW1ldGVyIGZvciBQTkcgY29tcHJlc3Npb25cblxuICAgIHJldHVybiBpbmZvO1xuICB9O1xuICAvKipcbiAgKiBBZGRzIGFuIEltYWdlIHRvIHRoZSBQREYuXG4gICpcbiAgKiBAbmFtZSBhZGRJbWFnZVxuICAqIEBwdWJsaWNcbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0ge3N0cmluZy9JbWFnZS1FbGVtZW50L0NhbnZhcy1FbGVtZW50L1VpbnQ4QXJyYXl9IGltYWdlRGF0YSBpbWFnZURhdGEgYXMgYmFzZTY0IGVuY29kZWQgRGF0YVVybCBvciBJbWFnZS1IVE1MRWxlbWVudCBvciBDYW52YXMtSFRNTEVsZW1lbnRcbiAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IGZvcm1hdCBvZiBmaWxlIGlmIGZpbGV0eXBlLXJlY29nbml0aW9uIGZhaWxzLCBlLmcuICdKUEVHJ1xuICAqIEBwYXJhbSB7bnVtYmVyfSB4IHggQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCBsZWZ0IGVkZ2Ugb2YgdGhlIHBhZ2VcbiAgKiBAcGFyYW0ge251bWJlcn0geSB5IENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgdXBwZXIgZWRnZSBvZiB0aGUgcGFnZVxuICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB3aWR0aCBvZiB0aGUgaW1hZ2UgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpXG4gICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2YgdGhlIEltYWdlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KVxuICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhcyBhbGlhcyBvZiB0aGUgaW1hZ2UgKGlmIHVzZWQgbXVsdGlwbGUgdGltZXMpXG4gICogQHBhcmFtIHtzdHJpbmd9IGNvbXByZXNzaW9uIGNvbXByZXNzaW9uIG9mIHRoZSBnZW5lcmF0ZWQgSlBFRywgY2FuIGhhdmUgdGhlIHZhbHVlcyAnTk9ORScsICdGQVNUJywgJ01FRElVTScgYW5kICdTTE9XJ1xuICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiByb3RhdGlvbiBvZiB0aGUgaW1hZ2UgaW4gZGVncmVlcyAoMC0zNTkpXG4gICogXG4gICogQHJldHVybnMganNQREZcbiAgKi9cblxuXG4gIGpzUERGQVBJLmFkZEltYWdlID0gZnVuY3Rpb24gKGltYWdlRGF0YSwgZm9ybWF0LCB4LCB5LCB3LCBoLCBhbGlhcywgY29tcHJlc3Npb24sIHJvdGF0aW9uKSB7XG5cbiAgICB2YXIgdG1wSW1hZ2VEYXRhID0gJyc7XG5cbiAgICBpZiAodHlwZW9mIGZvcm1hdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciB0bXAgPSBoO1xuICAgICAgaCA9IHc7XG4gICAgICB3ID0geTtcbiAgICAgIHkgPSB4O1xuICAgICAgeCA9IGZvcm1hdDtcbiAgICAgIGZvcm1hdCA9IHRtcDtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihpbWFnZURhdGEpID09PSAnb2JqZWN0JyAmJiAhaXNET01FbGVtZW50KGltYWdlRGF0YSkgJiYgXCJpbWFnZURhdGFcIiBpbiBpbWFnZURhdGEpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW1hZ2VEYXRhO1xuICAgICAgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGE7XG4gICAgICBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXQgfHwgJ1VOS05PV04nO1xuICAgICAgeCA9IG9wdGlvbnMueCB8fCB4IHx8IDA7XG4gICAgICB5ID0gb3B0aW9ucy55IHx8IHkgfHwgMDtcbiAgICAgIHcgPSBvcHRpb25zLncgfHwgdztcbiAgICAgIGggPSBvcHRpb25zLmggfHwgaDtcbiAgICAgIGFsaWFzID0gb3B0aW9ucy5hbGlhcyB8fCBhbGlhcztcbiAgICAgIGNvbXByZXNzaW9uID0gb3B0aW9ucy5jb21wcmVzc2lvbiB8fCBjb21wcmVzc2lvbjtcbiAgICAgIHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbiB8fCBvcHRpb25zLmFuZ2xlIHx8IHJvdGF0aW9uO1xuICAgIH0gLy9JZiBjb21wcmVzc2lvbiBpcyBub3QgZXhwbGljaXRseSBzZXQsIGRldGVybWluZSBpZiB3ZSBzaG91bGQgdXNlIGNvbXByZXNzaW9uXG5cblxuICAgIHZhciBmaWx0ZXJzID0gdGhpcy5pbnRlcm5hbC5nZXRGaWx0ZXJzKCk7XG5cbiAgICBpZiAoY29tcHJlc3Npb24gPT09IHVuZGVmaW5lZCAmJiBmaWx0ZXJzLmluZGV4T2YoJ0ZsYXRlRW5jb2RlJykgIT09IC0xKSB7XG4gICAgICBjb21wcmVzc2lvbiA9ICdTTE9XJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGltYWdlRGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaW1hZ2VEYXRhID0gdW5lc2NhcGUoaW1hZ2VEYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGLmFkZEltYWdlOiBJbnZhbGlkIGNvb3JkaW5hdGVzJywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29yZGluYXRlcyBwYXNzZWQgdG8ganNQREYuYWRkSW1hZ2UnKTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VzID0gZ2V0SW1hZ2VzLmNhbGwodGhpcyksXG4gICAgICAgIGluZm8sXG4gICAgICAgIGRhdGFBc0JpbmFyeVN0cmluZztcblxuICAgIGlmICghKGluZm8gPSBjaGVja0ltYWdlc0ZvckFsaWFzKGltYWdlRGF0YSwgaW1hZ2VzKSkpIHtcbiAgICAgIGlmIChpc0RPTUVsZW1lbnQoaW1hZ2VEYXRhKSkgaW1hZ2VEYXRhID0gY3JlYXRlRGF0YVVSSUZyb21FbGVtZW50KGltYWdlRGF0YSwgZm9ybWF0KTtcbiAgICAgIGlmIChub3REZWZpbmVkKGFsaWFzKSkgYWxpYXMgPSBnZW5lcmF0ZUFsaWFzRnJvbUltYWdlRGF0YShpbWFnZURhdGEpO1xuXG4gICAgICBpZiAoIShpbmZvID0gY2hlY2tJbWFnZXNGb3JBbGlhcyhhbGlhcywgaW1hZ2VzKSkpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdHJpbmcoaW1hZ2VEYXRhKSkge1xuICAgICAgICAgIHRtcEltYWdlRGF0YSA9IHRoaXMuY29udmVydFN0cmluZ1RvSW1hZ2VEYXRhKGltYWdlRGF0YSk7XG5cbiAgICAgICAgICBpZiAodG1wSW1hZ2VEYXRhICE9PSAnJykge1xuICAgICAgICAgICAgaW1hZ2VEYXRhID0gdG1wSW1hZ2VEYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXBJbWFnZURhdGEgPSBqc1BERkFQSS5sb2FkRmlsZShpbWFnZURhdGEpO1xuXG4gICAgICAgICAgICBpZiAodG1wSW1hZ2VEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaW1hZ2VEYXRhID0gdG1wSW1hZ2VEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IHRoaXMuZ2V0SW1hZ2VGaWxlVHlwZUJ5SW1hZ2VEYXRhKGltYWdlRGF0YSwgZm9ybWF0KTtcbiAgICAgICAgaWYgKCFpc0ltYWdlVHlwZVN1cHBvcnRlZChmb3JtYXQpKSB0aHJvdyBuZXcgRXJyb3IoJ2FkZEltYWdlIGRvZXMgbm90IHN1cHBvcnQgZmlsZXMgb2YgdHlwZSBcXCcnICsgZm9ybWF0ICsgJ1xcJywgcGxlYXNlIGVuc3VyZSB0aGF0IGEgcGx1Z2luIGZvciBcXCcnICsgZm9ybWF0ICsgJ1xcJyBzdXBwb3J0IGlzIGFkZGVkLicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogbmVlZCB0byB0ZXN0IGlmIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8gY29udmVydCBhbGwgYmluYXJ5IHN0cmluZ3NcbiAgICAgICAgICogdG8gVHlwZWRBcnJheSAtIG9yIHNob3VsZCB3ZSBqdXN0IGxlYXZlIGFuZCBwcm9jZXNzIGFzIHN0cmluZz9cbiAgICAgICAgICovXG5cbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNBcnJheUJ1ZmZlcigpKSB7XG4gICAgICAgICAgLy8gbm8gbmVlZCB0byBjb252ZXJ0IGlmIGltYWdlRGF0YSBpcyBhbHJlYWR5IHVpbnQ4YXJyYXlcbiAgICAgICAgICBpZiAoIShpbWFnZURhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgZGF0YUFzQmluYXJ5U3RyaW5nID0gaW1hZ2VEYXRhO1xuICAgICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5iaW5hcnlTdHJpbmdUb1VpbnQ4QXJyYXkoaW1hZ2VEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvID0gdGhpc1sncHJvY2VzcycgKyBmb3JtYXQudG9VcHBlckNhc2UoKV0oaW1hZ2VEYXRhLCBnZXRJbWFnZUluZGV4KGltYWdlcyksIGFsaWFzLCBjaGVja0NvbXByZXNzVmFsdWUoY29tcHJlc3Npb24pLCBkYXRhQXNCaW5hcnlTdHJpbmcpO1xuXG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsc3QgcHJvY2Vzc2luZyB0aGUgaW1hZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlSW1hZ2VUb1BERi5jYWxsKHRoaXMsIHgsIHksIHcsIGgsIGluZm8sIGluZm8uaSwgaW1hZ2VzLCByb3RhdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAqIEBuYW1lIGNvbnZlcnRTdHJpbmdUb0ltYWdlRGF0YVxuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdEYXRhXG4gICogQHJldHVybnMge3N0cmluZ30gYmluYXJ5IGRhdGFcbiAgKi9cblxuXG4gIGpzUERGQVBJLmNvbnZlcnRTdHJpbmdUb0ltYWdlRGF0YSA9IGZ1bmN0aW9uIChzdHJpbmdEYXRhKSB7XG4gICAgdmFyIGJhc2U2NEluZm87XG4gICAgdmFyIGltYWdlRGF0YSA9ICcnO1xuICAgIHZhciByYXdEYXRhO1xuXG4gICAgaWYgKHRoaXMuaXNTdHJpbmcoc3RyaW5nRGF0YSkpIHtcbiAgICAgIHZhciBiYXNlNjRJbmZvID0gdGhpcy5leHRyYWN0SW1hZ2VGcm9tRGF0YVVybChzdHJpbmdEYXRhKTtcbiAgICAgIHJhd0RhdGEgPSBiYXNlNjRJbmZvICE9PSBudWxsID8gYmFzZTY0SW5mby5kYXRhIDogc3RyaW5nRGF0YTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaW1hZ2VEYXRhID0gYXRvYihyYXdEYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCFqc1BERkFQSS52YWxpZGF0ZVN0cmluZ0FzQmFzZTY0KHJhd0RhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCBEYXRhIGlzIG5vdCBhIHZhbGlkIGJhc2U2NC1TdHJpbmcganNQREYuY29udmVydFN0cmluZ1RvSW1hZ2VEYXRhICcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXRvYi1FcnJvciBpbiBqc1BERi5jb252ZXJ0U3RyaW5nVG9JbWFnZURhdGEgJyArIGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xuICB9O1xuICAvKipcbiAgICogSlBFRyBTVVBQT1JUXG4gICAqKi9cbiAgLy90YWtlcyBhIHN0cmluZyBpbWdEYXRhIGNvbnRhaW5pbmcgdGhlIHJhdyBieXRlcyBvZlxuICAvL2EganBlZyBpbWFnZSBhbmQgcmV0dXJucyBbd2lkdGgsIGhlaWdodF1cbiAgLy9BbGdvcml0aG0gZnJvbTogaHR0cDovL3d3dy42NGxpbmVzLmNvbS9qcGVnLXdpZHRoLWhlaWdodFxuXG5cbiAgdmFyIGdldEpwZWdTaXplID0gZnVuY3Rpb24gZ2V0SnBlZ1NpemUoaW1nRGF0YSkge1xuXG4gICAgdmFyIHdpZHRoLCBoZWlnaHQsIG51bWNvbXBvbmVudHM7IC8vIFZlcmlmeSB3ZSBoYXZlIGEgdmFsaWQganBlZyBoZWFkZXIgMHhmZiwweGQ4LDB4ZmYsMHhlMCw/LD8sJ0onLCdGJywnSScsJ0YnLDB4MDBcblxuICAgIGlmIChnZXRJbWFnZUZpbGVUeXBlQnlJbWFnZURhdGEoaW1nRGF0YSkgIT09ICdKUEVHJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRKcGVnU2l6ZSByZXF1aXJlcyBhIGJpbmFyeSBzdHJpbmcganBlZyBmaWxlJyk7XG4gICAgfVxuXG4gICAgdmFyIGJsb2NrTGVuZ3RoID0gaW1nRGF0YS5jaGFyQ29kZUF0KDQpICogMjU2ICsgaW1nRGF0YS5jaGFyQ29kZUF0KDUpO1xuICAgIHZhciBpID0gNCxcbiAgICAgICAgbGVuID0gaW1nRGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaSArPSBibG9ja0xlbmd0aDtcblxuICAgICAgaWYgKGltZ0RhdGEuY2hhckNvZGVBdChpKSAhPT0gMHhmZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldEpwZWdTaXplIGNvdWxkIG5vdCBmaW5kIHRoZSBzaXplIG9mIHRoZSBpbWFnZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW1nRGF0YS5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMHhjMCB8fCAvLyhTT0YpIEh1ZmZtYW4gIC0gQmFzZWxpbmUgRENUXG4gICAgICBpbWdEYXRhLmNoYXJDb2RlQXQoaSArIDEpID09PSAweGMxIHx8IC8vKFNPRikgSHVmZm1hbiAgLSBFeHRlbmRlZCBzZXF1ZW50aWFsIERDVFxuICAgICAgaW1nRGF0YS5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMHhjMiB8fCAvLyBQcm9ncmVzc2l2ZSBEQ1QgKFNPRjIpXG4gICAgICBpbWdEYXRhLmNoYXJDb2RlQXQoaSArIDEpID09PSAweGMzIHx8IC8vIFNwYXRpYWwgKHNlcXVlbnRpYWwpIGxvc3NsZXNzIChTT0YzKVxuICAgICAgaW1nRGF0YS5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMHhjNCB8fCAvLyBEaWZmZXJlbnRpYWwgc2VxdWVudGlhbCBEQ1QgKFNPRjUpXG4gICAgICBpbWdEYXRhLmNoYXJDb2RlQXQoaSArIDEpID09PSAweGM1IHx8IC8vIERpZmZlcmVudGlhbCBwcm9ncmVzc2l2ZSBEQ1QgKFNPRjYpXG4gICAgICBpbWdEYXRhLmNoYXJDb2RlQXQoaSArIDEpID09PSAweGM2IHx8IC8vIERpZmZlcmVudGlhbCBzcGF0aWFsIChTT0Y3KVxuICAgICAgaW1nRGF0YS5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMHhjNykge1xuICAgICAgICBoZWlnaHQgPSBpbWdEYXRhLmNoYXJDb2RlQXQoaSArIDUpICogMjU2ICsgaW1nRGF0YS5jaGFyQ29kZUF0KGkgKyA2KTtcbiAgICAgICAgd2lkdGggPSBpbWdEYXRhLmNoYXJDb2RlQXQoaSArIDcpICogMjU2ICsgaW1nRGF0YS5jaGFyQ29kZUF0KGkgKyA4KTtcbiAgICAgICAgbnVtY29tcG9uZW50cyA9IGltZ0RhdGEuY2hhckNvZGVBdChpICsgOSk7XG4gICAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodCwgbnVtY29tcG9uZW50c107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGJsb2NrTGVuZ3RoID0gaW1nRGF0YS5jaGFyQ29kZUF0KGkpICogMjU2ICsgaW1nRGF0YS5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICAgICBnZXRKcGVnU2l6ZUZyb21CeXRlcyA9IGZ1bmN0aW9uIGdldEpwZWdTaXplRnJvbUJ5dGVzKGRhdGEpIHtcbiAgICB2YXIgaGRyID0gZGF0YVswXSA8PCA4IHwgZGF0YVsxXTtcbiAgICBpZiAoaGRyICE9PSAweEZGRDgpIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgZGF0YSBpcyBub3QgYSBKUEVHJyk7XG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBibG9jayA9IChkYXRhWzRdIDw8IDgpICsgZGF0YVs1XSxcbiAgICAgICAgcG9zID0gNCxcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIG51bWNvbXBvbmVudHM7XG5cbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICBwb3MgKz0gYmxvY2s7XG4gICAgICBieXRlcyA9IHJlYWRCeXRlcyhkYXRhLCBwb3MpO1xuICAgICAgYmxvY2sgPSAoYnl0ZXNbMl0gPDwgOCkgKyBieXRlc1szXTtcblxuICAgICAgaWYgKChieXRlc1sxXSA9PT0gMHhDMCB8fCBieXRlc1sxXSA9PT0gMHhDMikgJiYgYnl0ZXNbMF0gPT09IDB4RkYgJiYgYmxvY2sgPiA3KSB7XG4gICAgICAgIGJ5dGVzID0gcmVhZEJ5dGVzKGRhdGEsIHBvcyArIDUpO1xuICAgICAgICB3aWR0aCA9IChieXRlc1syXSA8PCA4KSArIGJ5dGVzWzNdO1xuICAgICAgICBoZWlnaHQgPSAoYnl0ZXNbMF0gPDwgOCkgKyBieXRlc1sxXTtcbiAgICAgICAgbnVtY29tcG9uZW50cyA9IGJ5dGVzWzRdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBudW1jb21wb25lbnRzOiBudW1jb21wb25lbnRzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHBvcyArPSAyO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignZ2V0SnBlZ1NpemVGcm9tQnl0ZXMgY291bGQgbm90IGZpbmQgdGhlIHNpemUgb2YgdGhlIGltYWdlJyk7XG4gIH0sXG4gICAgICByZWFkQnl0ZXMgPSBmdW5jdGlvbiByZWFkQnl0ZXMoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyA1KTtcbiAgfTtcbiAgLyoqXG4gICogQGlnbm9yZVxuICAqL1xuXG5cbiAganNQREZBUEkucHJvY2Vzc0pQRUcgPSBmdW5jdGlvbiAoZGF0YSwgaW5kZXgsIGFsaWFzLCBjb21wcmVzc2lvbiwgZGF0YUFzQmluYXJ5U3RyaW5nLCBjb2xvclNwYWNlKSB7XG5cbiAgICB2YXIgZmlsdGVyID0gdGhpcy5kZWNvZGUuRENUX0RFQ09ERSxcbiAgICAgICAgYnBjID0gOCxcbiAgICAgICAgZGltcztcblxuICAgIGlmICghdGhpcy5pc1N0cmluZyhkYXRhKSAmJiAhdGhpcy5pc0FycmF5QnVmZmVyKGRhdGEpICYmICF0aGlzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgZGltcyA9IGdldEpwZWdTaXplKGRhdGEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgZGltcyA9IGdldEpwZWdTaXplRnJvbUJ5dGVzKGRhdGEpOyAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdG9yZWQgYmluYXJ5IHN0cmluZyByZXAgdXNlIHRoYXRcblxuICAgICAgZGF0YSA9IGRhdGFBc0JpbmFyeVN0cmluZyB8fCB0aGlzLmFycmF5QnVmZmVyVG9CaW5hcnlTdHJpbmcoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbG9yU3BhY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3dpdGNoIChkaW1zLm51bWNvbXBvbmVudHMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNvbG9yU3BhY2UgPSB0aGlzLmNvbG9yX3NwYWNlcy5ERVZJQ0VfR1JBWTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY29sb3JTcGFjZSA9IHRoaXMuY29sb3Jfc3BhY2VzLkRFVklDRV9DTVlLO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjb2xvclNwYWNlID0gdGhpcy5jb2xvcl9zcGFjZXMuREVWSUNFX1JHQjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJbWFnZUluZm8oZGF0YSwgZGltcy53aWR0aCwgZGltcy5oZWlnaHQsIGNvbG9yU3BhY2UsIGJwYywgZmlsdGVyLCBpbmRleCwgYWxpYXMpO1xuICB9O1xuICAvKipcbiAgKiBAaWdub3JlXG4gICovXG5cblxuICBqc1BERkFQSS5wcm9jZXNzSlBHID0gZnVuY3Rpb24gKClcbiAgLypkYXRhLCBpbmRleCwgYWxpYXMsIGNvbXByZXNzaW9uLCBkYXRhQXNCaW5hcnlTdHJpbmcqL1xuICB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0pQRUcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgLyoqXG4gICogQG5hbWUgZ2V0SW1hZ2VQcm9wZXJ0aWVzXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICovXG5cblxuICBqc1BERkFQSS5nZXRJbWFnZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGluZm87XG4gICAgdmFyIHRtcEltYWdlRGF0YSA9ICcnO1xuICAgIHZhciBmb3JtYXQ7XG5cbiAgICBpZiAoaXNET01FbGVtZW50KGltYWdlRGF0YSkpIHtcbiAgICAgIGltYWdlRGF0YSA9IGNyZWF0ZURhdGFVUklGcm9tRWxlbWVudChpbWFnZURhdGEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU3RyaW5nKGltYWdlRGF0YSkpIHtcbiAgICAgIHRtcEltYWdlRGF0YSA9IHRoaXMuY29udmVydFN0cmluZ1RvSW1hZ2VEYXRhKGltYWdlRGF0YSk7XG5cbiAgICAgIGlmICh0bXBJbWFnZURhdGEgIT09ICcnKSB7XG4gICAgICAgIGltYWdlRGF0YSA9IHRtcEltYWdlRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRtcEltYWdlRGF0YSA9IGpzUERGQVBJLmxvYWRGaWxlKGltYWdlRGF0YSk7XG5cbiAgICAgICAgaWYgKHRtcEltYWdlRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW1hZ2VEYXRhID0gdG1wSW1hZ2VEYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gdGhpcy5nZXRJbWFnZUZpbGVUeXBlQnlJbWFnZURhdGEoaW1hZ2VEYXRhKTtcblxuICAgIGlmICghaXNJbWFnZVR5cGVTdXBwb3J0ZWQoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRJbWFnZSBkb2VzIG5vdCBzdXBwb3J0IGZpbGVzIG9mIHR5cGUgXFwnJyArIGZvcm1hdCArICdcXCcsIHBsZWFzZSBlbnN1cmUgdGhhdCBhIHBsdWdpbiBmb3IgXFwnJyArIGZvcm1hdCArICdcXCcgc3VwcG9ydCBpcyBhZGRlZC4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbmVlZCB0byB0ZXN0IGlmIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8gY29udmVydCBhbGwgYmluYXJ5IHN0cmluZ3NcbiAgICAgKiB0byBUeXBlZEFycmF5IC0gb3Igc2hvdWxkIHdlIGp1c3QgbGVhdmUgYW5kIHByb2Nlc3MgYXMgc3RyaW5nP1xuICAgICAqL1xuXG5cbiAgICBpZiAodGhpcy5zdXBwb3J0c0FycmF5QnVmZmVyKCkpIHtcbiAgICAgIC8vIG5vIG5lZWQgdG8gY29udmVydCBpZiBpbWFnZURhdGEgaXMgYWxyZWFkeSB1aW50OGFycmF5XG4gICAgICBpZiAoIShpbWFnZURhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmJpbmFyeVN0cmluZ1RvVWludDhBcnJheShpbWFnZURhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluZm8gPSB0aGlzWydwcm9jZXNzJyArIGZvcm1hdC50b1VwcGVyQ2FzZSgpXShpbWFnZURhdGEpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbHN0IHByb2Nlc3NpbmcgdGhlIGltYWdlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGVUeXBlOiBmb3JtYXQsXG4gICAgICB3aWR0aDogaW5mby53LFxuICAgICAgaGVpZ2h0OiBpbmZvLmgsXG4gICAgICBjb2xvclNwYWNlOiBpbmZvLmNzLFxuICAgICAgY29tcHJlc3Npb25Nb2RlOiBpbmZvLmYsXG4gICAgICBiaXRzUGVyQ29tcG9uZW50OiBpbmZvLmJwY1xuICAgIH07XG4gIH07XG59KShqc1BERi5BUEkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgU3RldmVuIFNwdW5naW4gKFR3ZWx2ZVRvbmUgTExDKSAgc3RldmVuQHR3ZWx2ZXRvbmUudHZcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIGpzUERGIEFubm90YXRpb25zIFBsdWdJblxuICpcbiAqIFRoZXJlIGFyZSBtYW55IHR5cGVzIG9mIGFubm90YXRpb25zIGluIGEgUERGIGRvY3VtZW50LiBBbm5vdGF0aW9ucyBhcmUgcGxhY2VkXG4gKiBvbiBhIHBhZ2UgYXQgYSBwYXJ0aWN1bGFyIGxvY2F0aW9uLiBUaGV5IGFyZSBub3QgJ2F0dGFjaGVkJyB0byBhbiBvYmplY3QuXG4gKiA8YnIgLz5cbiAqIFRoaXMgcGx1Z2luIGN1cnJlbnQgc3VwcG9ydHMgPGJyIC8+XG4gKiA8bGk+IEdvdG8gUGFnZSAoc2V0IHBhZ2VOdW1iZXIgYW5kIHRvcCBpbiBvcHRpb25zKVxuICogPGxpPiBHb3RvIE5hbWUgKHNldCBuYW1lIGFuZCB0b3AgaW4gb3B0aW9ucylcbiAqIDxsaT4gR290byBVUkwgKHNldCB1cmwgaW4gb3B0aW9ucylcbiAqIDxwPlxuICogXHRUaGUgZGVzdGluYXRpb24gbWFnbmlmaWNhdGlvbiBmYWN0b3IgY2FuIGFsc28gYmUgc3BlY2lmaWVkIHdoZW4gZ290byBpcyBhIHBhZ2UgbnVtYmVyIG9yIGEgbmFtZWQgZGVzdGluYXRpb24uIChzZWUgZG9jdW1lbnRhdGlvbiBiZWxvdylcbiAqICAoc2V0IG1hZ0ZhY3RvciBpbiBvcHRpb25zKS4gIFhZWiBpcyB0aGUgZGVmYXVsdC5cbiAqIDwvcD5cbiAqIDxwPlxuICogIExpbmtzLCBUZXh0LCBQb3B1cCwgYW5kIEZyZWVUZXh0IGFyZSBzdXBwb3J0ZWQuXG4gKiA8L3A+XG4gKiA8cD5cbiAqIE9wdGlvbnMgSW4gUERGIHNwZWMgTm90IEltcGxlbWVudGVkIFlldFxuICogPGxpPiBsaW5rIGJvcmRlclxuICogPGxpPiBuYW1lZCB0YXJnZXRcbiAqIDxsaT4gcGFnZSBjb29yZGluYXRlc1xuICogPGxpPiBkZXN0aW5hdGlvbiBwYWdlIHNjYWxpbmcgYW5kIGxheW91dFxuICogPGxpPiBhY3Rpb25zIG90aGVyIHRoYW4gVVJMIGFuZCBHb3RvUGFnZVxuICogPGxpPiBiYWNrZ3JvdW5kIC8gaG92ZXIgYWN0aW9uc1xuICogPC9wPlxuICogQG5hbWUgYW5ub3RhdGlvbnNcbiAqIEBtb2R1bGVcbiAqL1xuXG4vKlxuICAgIERlc3RpbmF0aW9uIE1hZ25pZmljYXRpb24gRmFjdG9yc1xuICAgIFNlZSBQREYgMS4zIFBhZ2UgMzg2IGZvciBtZWFuaW5ncyBhbmQgb3B0aW9uc1xuXG4gICAgW3N1cHBvcnRlZF1cblx0WFlaIChvcHRpb25zOyBsZWZ0IHRvcCB6b29tKVxuXHRGaXQgKG5vIG9wdGlvbnMpXG5cdEZpdEggKG9wdGlvbnM6IHRvcClcblx0Rml0ViAob3B0aW9uczogbGVmdClcblxuXHRbbm90IHN1cHBvcnRlZF1cblx0Rml0UlxuXHRGaXRCXG5cdEZpdEJIXG5cdEZpdEJWXG4gKi9cbihmdW5jdGlvbiAoanNQREZBUEkpIHtcblxuICBqc1BERi5BUEkuZXZlbnRzLnB1c2goWydhZGRQYWdlJywgZnVuY3Rpb24gKGFkZFBhZ2VEYXRhKSB7XG4gICAgdmFyIHBhZ2VJbmZvID0gdGhpcy5pbnRlcm5hbC5nZXRQYWdlSW5mbyhhZGRQYWdlRGF0YS5wYWdlTnVtYmVyKTtcbiAgICBwYWdlSW5mby5wYWdlQ29udGV4dC5hbm5vdGF0aW9ucyA9IFtdO1xuICB9XSk7XG4gIGpzUERGQVBJLmV2ZW50cy5wdXNoKFsncHV0UGFnZScsIGZ1bmN0aW9uIChwdXRQYWdlRGF0YSkge1xuICAgIHZhciBwYWdlSW5mbyA9IHRoaXMuaW50ZXJuYWwuZ2V0UGFnZUluZm9CeU9iaklkKHB1dFBhZ2VEYXRhLm9iaklkKTtcbiAgICB2YXIgcGFnZUFubm9zID0gcHV0UGFnZURhdGEucGFnZUNvbnRleHQuYW5ub3RhdGlvbnM7XG5cbiAgICB2YXIgbm90RW1wdHkgPSBmdW5jdGlvbiBub3RFbXB0eShvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChvYmogIT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGEgPSAwOyBhIDwgcGFnZUFubm9zLmxlbmd0aCAmJiAhZm91bmQ7IGErKykge1xuICAgICAgdmFyIGFubm8gPSBwYWdlQW5ub3NbYV07XG5cbiAgICAgIHN3aXRjaCAoYW5uby50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICAgIGlmIChub3RFbXB0eShhbm5vLm9wdGlvbnMudXJsKSB8fCBub3RFbXB0eShhbm5vLm9wdGlvbnMucGFnZU51bWJlcikpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZWZlcmVuY2UnOlxuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgY2FzZSAnZnJlZXRleHQnOlxuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm91bmQgPT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmludGVybmFsLndyaXRlKFwiL0Fubm90cyBbXCIpO1xuICAgIHZhciBwYWdlSGVpZ2h0ID0gdGhpcy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQ7XG4gICAgdmFyIGdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nID0gdGhpcy5pbnRlcm5hbC5nZXRDb29yZGluYXRlU3RyaW5nO1xuICAgIHZhciBnZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcgPSB0aGlzLmludGVybmFsLmdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZztcblxuICAgIGZvciAodmFyIGEgPSAwOyBhIDwgcGFnZUFubm9zLmxlbmd0aDsgYSsrKSB7XG4gICAgICB2YXIgYW5ubyA9IHBhZ2VBbm5vc1thXTtcblxuICAgICAgc3dpdGNoIChhbm5vLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgICAgICAvLyBSZWZlcmVuY2VzIHRvIFdpZGdldCBBbm5vdGF0aW9ucyAoZm9yIEFjcm9Gb3JtIEZpZWxkcylcbiAgICAgICAgICB0aGlzLmludGVybmFsLndyaXRlKCcgJyArIGFubm8ub2JqZWN0Lm9iaklkICsgJyAwIFIgJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgYW4gb2JqZWN0IGZvciBib3RoIHRoZSB0ZXh0IGFuZCB0aGUgcG9wdXBcbiAgICAgICAgICB2YXIgb2JqVGV4dCA9IHRoaXMuaW50ZXJuYWwubmV3QWRkaXRpb25hbE9iamVjdCgpO1xuICAgICAgICAgIHZhciBvYmpQb3B1cCA9IHRoaXMuaW50ZXJuYWwubmV3QWRkaXRpb25hbE9iamVjdCgpO1xuICAgICAgICAgIHZhciB0aXRsZSA9IGFubm8udGl0bGUgfHwgJ05vdGUnO1xuICAgICAgICAgIHZhciByZWN0ID0gXCIvUmVjdCBbXCIgKyBnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZVN0cmluZyhhbm5vLmJvdW5kcy54KSArIFwiIFwiICsgZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nKGFubm8uYm91bmRzLnkgKyBhbm5vLmJvdW5kcy5oKSArIFwiIFwiICsgZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGVTdHJpbmcoYW5uby5ib3VuZHMueCArIGFubm8uYm91bmRzLncpICsgXCIgXCIgKyBnZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcoYW5uby5ib3VuZHMueSkgKyBcIl0gXCI7XG4gICAgICAgICAgbGluZSA9ICc8PC9UeXBlIC9Bbm5vdCAvU3VidHlwZSAvJyArICdUZXh0JyArICcgJyArIHJlY3QgKyAnL0NvbnRlbnRzICgnICsgYW5uby5jb250ZW50cyArICcpJztcbiAgICAgICAgICBsaW5lICs9ICcgL1BvcHVwICcgKyBvYmpQb3B1cC5vYmpJZCArIFwiIDAgUlwiO1xuICAgICAgICAgIGxpbmUgKz0gJyAvUCAnICsgcGFnZUluZm8ub2JqSWQgKyBcIiAwIFJcIjtcbiAgICAgICAgICBsaW5lICs9ICcgL1QgKCcgKyB0aXRsZSArICcpID4+JztcbiAgICAgICAgICBvYmpUZXh0LmNvbnRlbnQgPSBsaW5lO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBvYmpUZXh0Lm9iaklkICsgJyAwIFInO1xuICAgICAgICAgIHZhciBwb3BvZmYgPSAzMDtcbiAgICAgICAgICB2YXIgcmVjdCA9IFwiL1JlY3QgW1wiICsgZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGVTdHJpbmcoYW5uby5ib3VuZHMueCArIHBvcG9mZikgKyBcIiBcIiArIGdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZyhhbm5vLmJvdW5kcy55ICsgYW5uby5ib3VuZHMuaCkgKyBcIiBcIiArIGdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nKGFubm8uYm91bmRzLnggKyBhbm5vLmJvdW5kcy53ICsgcG9wb2ZmKSArIFwiIFwiICsgZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nKGFubm8uYm91bmRzLnkpICsgXCJdIFwiO1xuICAgICAgICAgIGxpbmUgPSAnPDwvVHlwZSAvQW5ub3QgL1N1YnR5cGUgLycgKyAnUG9wdXAnICsgJyAnICsgcmVjdCArICcgL1BhcmVudCAnICsgcGFyZW50O1xuXG4gICAgICAgICAgaWYgKGFubm8ub3Blbikge1xuICAgICAgICAgICAgbGluZSArPSAnIC9PcGVuIHRydWUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpbmUgKz0gJyA+Pic7XG4gICAgICAgICAgb2JqUG9wdXAuY29udGVudCA9IGxpbmU7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbC53cml0ZShvYmpUZXh0Lm9iaklkLCAnMCBSJywgb2JqUG9wdXAub2JqSWQsICcwIFInKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmcmVldGV4dCc6XG4gICAgICAgICAgdmFyIHJlY3QgPSBcIi9SZWN0IFtcIiArIGdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nKGFubm8uYm91bmRzLngpICsgXCIgXCIgKyBnZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcoYW5uby5ib3VuZHMueSkgKyBcIiBcIiArIGdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nKGFubm8uYm91bmRzLnggKyBhbm5vLmJvdW5kcy53KSArIFwiIFwiICsgZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nKGFubm8uYm91bmRzLnkgKyBhbm5vLmJvdW5kcy5oKSArIFwiXSBcIjtcbiAgICAgICAgICB2YXIgY29sb3IgPSBhbm5vLmNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgICAgICBsaW5lID0gJzw8L1R5cGUgL0Fubm90IC9TdWJ0eXBlIC8nICsgJ0ZyZWVUZXh0JyArICcgJyArIHJlY3QgKyAnL0NvbnRlbnRzICgnICsgYW5uby5jb250ZW50cyArICcpJztcbiAgICAgICAgICBsaW5lICs9ICcgL0RTKGZvbnQ6IEhlbHZldGljYSxzYW5zLXNlcmlmIDEyLjBwdDsgdGV4dC1hbGlnbjpsZWZ0OyBjb2xvcjojJyArIGNvbG9yICsgJyknO1xuICAgICAgICAgIGxpbmUgKz0gJyAvQm9yZGVyIFswIDAgMF0nO1xuICAgICAgICAgIGxpbmUgKz0gJyA+Pic7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbC53cml0ZShsaW5lKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICBpZiAoYW5uby5vcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSB0aGlzLmFubm90YXRpb25zLl9uYW1lTWFwW2Fubm8ub3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgIGFubm8ub3B0aW9ucy5wYWdlTnVtYmVyID0gbG9jLnBhZ2U7XG4gICAgICAgICAgICBhbm5vLm9wdGlvbnMudG9wID0gbG9jLnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghYW5uby5vcHRpb25zLnRvcCkge1xuICAgICAgICAgICAgICBhbm5vLm9wdGlvbnMudG9wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjdCA9IFwiL1JlY3QgW1wiICsgZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGVTdHJpbmcoYW5uby54KSArIFwiIFwiICsgZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nKGFubm8ueSkgKyBcIiBcIiArIGdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nKGFubm8ueCArIGFubm8udykgKyBcIiBcIiArIGdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZyhhbm5vLnkgKyBhbm5vLmgpICsgXCJdIFwiO1xuICAgICAgICAgIHZhciBsaW5lID0gJyc7XG5cbiAgICAgICAgICBpZiAoYW5uby5vcHRpb25zLnVybCkge1xuICAgICAgICAgICAgbGluZSA9ICc8PC9UeXBlIC9Bbm5vdCAvU3VidHlwZSAvTGluayAnICsgcmVjdCArICcvQm9yZGVyIFswIDAgMF0gL0EgPDwvUyAvVVJJIC9VUkkgKCcgKyBhbm5vLm9wdGlvbnMudXJsICsgJykgPj4nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYW5uby5vcHRpb25zLnBhZ2VOdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHBhZ2UgaXMgMFxuICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLmludGVybmFsLmdldFBhZ2VJbmZvKGFubm8ub3B0aW9ucy5wYWdlTnVtYmVyKTtcbiAgICAgICAgICAgIGxpbmUgPSAnPDwvVHlwZSAvQW5ub3QgL1N1YnR5cGUgL0xpbmsgJyArIHJlY3QgKyAnL0JvcmRlciBbMCAwIDBdIC9EZXN0IFsnICsgaW5mby5vYmpJZCArIFwiIDAgUlwiO1xuICAgICAgICAgICAgYW5uby5vcHRpb25zLm1hZ0ZhY3RvciA9IGFubm8ub3B0aW9ucy5tYWdGYWN0b3IgfHwgXCJYWVpcIjtcblxuICAgICAgICAgICAgc3dpdGNoIChhbm5vLm9wdGlvbnMubWFnRmFjdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ0ZpdCc6XG4gICAgICAgICAgICAgICAgbGluZSArPSAnIC9GaXRdJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdGaXRIJzpcbiAgICAgICAgICAgICAgICBsaW5lICs9ICcgL0ZpdEggJyArIGFubm8ub3B0aW9ucy50b3AgKyAnXSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnRml0Vic6XG4gICAgICAgICAgICAgICAgYW5uby5vcHRpb25zLmxlZnQgPSBhbm5vLm9wdGlvbnMubGVmdCB8fCAwO1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gJyAvRml0ViAnICsgYW5uby5vcHRpb25zLmxlZnQgKyAnXSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnWFlaJzpcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nKGFubm8ub3B0aW9ucy50b3ApO1xuICAgICAgICAgICAgICAgIGFubm8ub3B0aW9ucy5sZWZ0ID0gYW5uby5vcHRpb25zLmxlZnQgfHwgMDsgLy8gMCBvciBudWxsIHpvb20gd2lsbCBub3QgY2hhbmdlIHpvb20gZmFjdG9yXG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFubm8ub3B0aW9ucy56b29tID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgYW5uby5vcHRpb25zLnpvb20gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmUgKz0gJyAvWFlaICcgKyBhbm5vLm9wdGlvbnMubGVmdCArICcgJyArIHRvcCArICcgJyArIGFubm8ub3B0aW9ucy56b29tICsgJ10nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaW5lICE9ICcnKSB7XG4gICAgICAgICAgICBsaW5lICs9IFwiID4+XCI7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsLndyaXRlKGxpbmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW50ZXJuYWwud3JpdGUoXCJdXCIpO1xuICB9XSk7XG4gIC8qKlxuICAqIEBuYW1lIGNyZWF0ZUFubm90YXRpb25cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBcbiAgKi9cblxuICBqc1BERkFQSS5jcmVhdGVBbm5vdGF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcGFnZUluZm8gPSB0aGlzLmludGVybmFsLmdldEN1cnJlbnRQYWdlSW5mbygpO1xuXG4gICAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICB0aGlzLmxpbmsob3B0aW9ucy5ib3VuZHMueCwgb3B0aW9ucy5ib3VuZHMueSwgb3B0aW9ucy5ib3VuZHMudywgb3B0aW9ucy5ib3VuZHMuaCwgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0ZXh0JzpcbiAgICAgIGNhc2UgJ2ZyZWV0ZXh0JzpcbiAgICAgICAgcGFnZUluZm8ucGFnZUNvbnRleHQuYW5ub3RhdGlvbnMucHVzaChvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ3JlYXRlIGEgbGlua1xuICAgKlxuICAgKiB2YWxpZCBvcHRpb25zXG4gICAqIDxsaT4gcGFnZU51bWJlciBvciB1cmwgW3JlcXVpcmVkXVxuICAgKiA8cD5JZiBwYWdlTnVtYmVyIGlzIHNwZWNpZmllZCwgdG9wIGFuZCB6b29tIG1heSBhbHNvIGJlIHNwZWNpZmllZDwvcD5cbiAgICogQG5hbWUgbGlua1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBqc1BERkFQSS5saW5rID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFnZUluZm8gPSB0aGlzLmludGVybmFsLmdldEN1cnJlbnRQYWdlSW5mbygpO1xuICAgIHBhZ2VJbmZvLnBhZ2VDb250ZXh0LmFubm90YXRpb25zLnB1c2goe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3OiB3LFxuICAgICAgaDogaCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICB0eXBlOiAnbGluaydcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHNpbmdsZSBsaW5lIHRleHQuXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0L2xpbmtcbiAgICpcbiAgICogQG5hbWUgdGV4dFdpdGhMaW5rXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB3aWR0aCB0aGUgd2lkdGggb2YgdGhlIHRleHQvbGlua1xuICAgKi9cblxuXG4gIGpzUERGQVBJLnRleHRXaXRoTGluayA9IGZ1bmN0aW9uICh0ZXh0LCB4LCB5LCBvcHRpb25zKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRUZXh0V2lkdGgodGV4dCk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaW50ZXJuYWwuZ2V0TGluZUhlaWdodCgpIC8gdGhpcy5pbnRlcm5hbC5zY2FsZUZhY3RvcjtcbiAgICB0aGlzLnRleHQodGV4dCwgeCwgeSk7IC8vVE9ETyBXZSByZWFsbHkgbmVlZCB0aGUgdGV4dCBiYXNlbGluZSBoZWlnaHQgdG8gZG8gdGhpcyBjb3JyZWN0bHkuXG4gICAgLy8gT3IgYWJpbGl0eSB0byBkcmF3IHRleHQgb24gdG9wLCBib3R0b20sIGNlbnRlciwgb3IgYmFzZWxpbmUuXG5cbiAgICB5ICs9IGhlaWdodCAqIC4yO1xuICAgIHRoaXMubGluayh4LCB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gd2lkdGg7XG4gIH07IC8vVE9ETyBtb3ZlIGludG8gZXh0ZXJuYWwgbGlicmFyeVxuXG4gIC8qKlxuICAqIEBuYW1lIGdldFRleHRXaWR0aFxuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICogQHJldHVybnMge251bWJlcn0gdHh0V2lkdGhcbiAgKi9cblxuXG4gIGpzUERGQVBJLmdldFRleHRXaWR0aCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpO1xuICAgIHZhciB0eHRXaWR0aCA9IHRoaXMuZ2V0U3RyaW5nVW5pdFdpZHRoKHRleHQpICogZm9udFNpemUgLyB0aGlzLmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgIHJldHVybiB0eHRXaWR0aDtcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn0pKGpzUERGLkFQSSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBBcmFzIEFiYmFzaSBcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqL1xuXG4vKipcbioganNQREYgYXJhYmljIHBhcnNlciBQbHVnSW5cbipcbiogQG5hbWUgYXJhYmljXG4qIEBtb2R1bGVcbiovXG4oZnVuY3Rpb24gKGpzUERGQVBJKSB7XG4gIC8qKlxuICAgKiBBcmFiaWMgc2hhcGUgc3Vic3RpdHV0aW9uczogY2hhciBjb2RlID0+IChpc29sYXRlZCwgZmluYWwsIGluaXRpYWwsIG1lZGlhbCkuXG4gICAqIEFyYWJpYyBTdWJzdGl0aW9uIEFcbiAgICovXG5cbiAgdmFyIGFyYWJpY1N1YnN0aXRpb25BID0ge1xuICAgIDB4MDYyMTogWzB4RkU4MF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBIQU1aQSBcbiAgICAweDA2MjI6IFsweEZFODEsIDB4RkU4Ml0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBBTEVGIFdJVEggTUFEREEgQUJPVkVcbiAgICAweDA2MjM6IFsweEZFODMsIDB4RkU4NF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBBTEVGIFdJVEggSEFNWkEgQUJPVkVcbiAgICAweDA2MjQ6IFsweEZFODUsIDB4RkU4Nl0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBXQVcgV0lUSCBIQU1aQSBBQk9WRVxuICAgIDB4MDYyNTogWzB4RkU4NywgMHhGRTg4XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEFMRUYgV0lUSCBIQU1aQSBCRUxPV1xuICAgIDB4MDYyNjogWzB4RkU4OSwgMHhGRThBLCAweEZFOEIsIDB4RkU4Q10sXG4gICAgLy8gQVJBQklDIExFVFRFUiBZRUggV0lUSCBIQU1aQSBBQk9WRSBcbiAgICAweDA2Mjc6IFsweEZFOEQsIDB4RkU4RV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBBTEVGXG4gICAgMHgwNjI4OiBbMHhGRThGLCAweEZFOTAsIDB4RkU5MSwgMHhGRTkyXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEJFSFxuICAgIDB4MDYyOTogWzB4RkU5MywgMHhGRTk0XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIFRFSCBNQVJCVVRBIFxuICAgIDB4MDYyQTogWzB4RkU5NSwgMHhGRTk2LCAweEZFOTcsIDB4RkU5OF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBURUhcbiAgICAweDA2MkI6IFsweEZFOTksIDB4RkU5QSwgMHhGRTlCLCAweEZFOUNdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgVEhFSFxuICAgIDB4MDYyQzogWzB4RkU5RCwgMHhGRTlFLCAweEZFOUYsIDB4RkVBMF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBKRUVNXG4gICAgMHgwNjJEOiBbMHhGRUExLCAweEZFQTIsIDB4RkVBMywgMHhGRUE0XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEhBSFxuICAgIDB4MDYyRTogWzB4RkVBNSwgMHhGRUE2LCAweEZFQTcsIDB4RkVBOF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBLSEFIXG4gICAgMHgwNjJGOiBbMHhGRUE5LCAweEZFQUFdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgREFMXG4gICAgMHgwNjMwOiBbMHhGRUFCLCAweEZFQUNdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgVEhBTFxuICAgIDB4MDYzMTogWzB4RkVBRCwgMHhGRUFFXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIFJFSFxuICAgIDB4MDYzMjogWzB4RkVBRiwgMHhGRUIwXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIFpBSU5cbiAgICAweDA2MzM6IFsweEZFQjEsIDB4RkVCMiwgMHhGRUIzLCAweEZFQjRdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgU0VFTlxuICAgIDB4MDYzNDogWzB4RkVCNSwgMHhGRUI2LCAweEZFQjcsIDB4RkVCOF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBTSEVFTiBcbiAgICAweDA2MzU6IFsweEZFQjksIDB4RkVCQSwgMHhGRUJCLCAweEZFQkNdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgU0FEXG4gICAgMHgwNjM2OiBbMHhGRUJELCAweEZFQkUsIDB4RkVCRiwgMHhGRUMwXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIERBRFxuICAgIDB4MDYzNzogWzB4RkVDMSwgMHhGRUMyLCAweEZFQzMsIDB4RkVDNF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBUQUhcbiAgICAweDA2Mzg6IFsweEZFQzUsIDB4RkVDNiwgMHhGRUM3LCAweEZFQzhdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgWkFIXG4gICAgMHgwNjM5OiBbMHhGRUM5LCAweEZFQ0EsIDB4RkVDQiwgMHhGRUNDXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEFJTlxuICAgIDB4MDYzQTogWzB4RkVDRCwgMHhGRUNFLCAweEZFQ0YsIDB4RkVEMF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBHSEFJTiBcbiAgICAweDA2NDE6IFsweEZFRDEsIDB4RkVEMiwgMHhGRUQzLCAweEZFRDRdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgRkVIXG4gICAgMHgwNjQyOiBbMHhGRUQ1LCAweEZFRDYsIDB4RkVENywgMHhGRUQ4XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIFFBRlxuICAgIDB4MDY0MzogWzB4RkVEOSwgMHhGRURBLCAweEZFREIsIDB4RkVEQ10sXG4gICAgLy8gQVJBQklDIExFVFRFUiBLQUZcbiAgICAweDA2NDQ6IFsweEZFREQsIDB4RkVERSwgMHhGRURGLCAweEZFRTBdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgTEFNXG4gICAgMHgwNjQ1OiBbMHhGRUUxLCAweEZFRTIsIDB4RkVFMywgMHhGRUU0XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIE1FRU1cbiAgICAweDA2NDY6IFsweEZFRTUsIDB4RkVFNiwgMHhGRUU3LCAweEZFRThdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgTk9PTiBcbiAgICAweDA2NDc6IFsweEZFRTksIDB4RkVFQSwgMHhGRUVCLCAweEZFRUNdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgSEVIXG4gICAgMHgwNjQ4OiBbMHhGRUVELCAweEZFRUVdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgV0FXXG4gICAgMHgwNjQ5OiBbMHhGRUVGLCAweEZFRjAsIDY0NDg4LCA2NDQ4OV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBBTEVGIE1BS1NVUkEgXG4gICAgMHgwNjRBOiBbMHhGRUYxLCAweEZFRjIsIDB4RkVGMywgMHhGRUY0XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIFlFSFxuICAgIDB4MDY3MTogWzB4RkI1MCwgMHhGQjUxXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEFMRUYgV0FTTEFcbiAgICAweDA2Nzc6IFsweEZCRERdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgVSBXSVRIIEhBTVpBIEFCT1ZFXG4gICAgMHgwNjc5OiBbMHhGQjY2LCAweEZCNjcsIDB4RkI2OCwgMHhGQjY5XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIFRURUhcbiAgICAweDA2N0E6IFsweEZCNUUsIDB4RkI1RiwgMHhGQjYwLCAweEZCNjFdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgVFRFSEVIXG4gICAgMHgwNjdCOiBbMHhGQjUyLCAweEZCNTMsIDB4RkI1NCwgMHhGQjU1XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEJFRUhcbiAgICAweDA2N0U6IFsweEZCNTYsIDB4RkI1NywgMHhGQjU4LCAweEZCNTldLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgUEVIIFxuICAgIDB4MDY3RjogWzB4RkI2MiwgMHhGQjYzLCAweEZCNjQsIDB4RkI2NV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBURUhFSFxuICAgIDB4MDY4MDogWzB4RkI1QSwgMHhGQjVCLCAweEZCNUMsIDB4RkI1RF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBCRUhFSFxuICAgIDB4MDY4MzogWzB4RkI3NiwgMHhGQjc3LCAweEZCNzgsIDB4RkI3OV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBOWUVIXG4gICAgMHgwNjg0OiBbMHhGQjcyLCAweEZCNzMsIDB4RkI3NCwgMHhGQjc1XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIERZRUhcbiAgICAweDA2ODY6IFsweEZCN0EsIDB4RkI3QiwgMHhGQjdDLCAweEZCN0RdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgVENIRUhcbiAgICAweDA2ODc6IFsweEZCN0UsIDB4RkI3RiwgMHhGQjgwLCAweEZCODFdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgVENIRUhFSFxuICAgIDB4MDY4ODogWzB4RkI4OCwgMHhGQjg5XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEREQUxcbiAgICAweDA2OEM6IFsweEZCODQsIDB4RkI4NV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBEQUhBTFxuICAgIDB4MDY4RDogWzB4RkI4MiwgMHhGQjgzXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEREQUhBTFxuICAgIDB4MDY4RTogWzB4RkI4NiwgMHhGQjg3XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIERVTCBcbiAgICAweDA2OTE6IFsweEZCOEMsIDB4RkI4RF0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBSUkVIXG4gICAgMHgwNjk4OiBbMHhGQjhBLCAweEZCOEJdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgSkVIXG4gICAgMHgwNkE0OiBbMHhGQjZBLCAweEZCNkIsIDB4RkI2QywgMHhGQjZEXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIFZFSFxuICAgIDB4MDZBNjogWzB4RkI2RSwgMHhGQjZGLCAweEZCNzAsIDB4RkI3MV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBQRUhFSFxuICAgIDB4MDZBOTogWzB4RkI4RSwgMHhGQjhGLCAweEZCOTAsIDB4RkI5MV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBLRUhFSFxuICAgIDB4MDZBRDogWzB4RkJEMywgMHhGQkQ0LCAweEZCRDUsIDB4RkJENl0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBOR1xuICAgIDB4MDZBRjogWzB4RkI5MiwgMHhGQjkzLCAweEZCOTQsIDB4RkI5NV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBHQUZcbiAgICAweDA2QjE6IFsweEZCOUEsIDB4RkI5QiwgMHhGQjlDLCAweEZCOURdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgTkdPRUhcbiAgICAweDA2QjM6IFsweEZCOTYsIDB4RkI5NywgMHhGQjk4LCAweEZCOTldLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgR1VFSFxuICAgIDB4MDZCQTogWzB4RkI5RSwgMHhGQjlGXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIE5PT04gR0hVTk5BXG4gICAgMHgwNkJCOiBbMHhGQkEwLCAweEZCQTEsIDB4RkJBMiwgMHhGQkEzXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIFJOT09OXG4gICAgMHgwNkJFOiBbMHhGQkFBLCAweEZCQUIsIDB4RkJBQywgMHhGQkFEXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEhFSCBET0FDSEFTSE1FRVxuICAgIDB4MDZDMDogWzB4RkJBNCwgMHhGQkE1XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEhFSCBXSVRIIFlFSCBBQk9WRVxuICAgIDB4MDZDMTogWzB4RkJBNiwgMHhGQkE3LCAweEZCQTgsIDB4RkJBOV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBIRUggR09BTFxuICAgIDB4MDZDNTogWzB4RkJFMCwgMHhGQkUxXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEtJUkdISVogT0VcbiAgICAweDA2QzY6IFsweEZCRDksIDB4RkJEQV0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBPRVxuICAgIDB4MDZDNzogWzB4RkJENywgMHhGQkQ4XSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIFVcbiAgICAweDA2Qzg6IFsweEZCREIsIDB4RkJEQ10sXG4gICAgLy8gQVJBQklDIExFVFRFUiBZVVxuICAgIDB4MDZDOTogWzB4RkJFMiwgMHhGQkUzXSxcbiAgICAvLyBBUkFCSUMgTEVUVEVSIEtJUkdISVogWVVcbiAgICAweDA2Q0I6IFsweEZCREUsIDB4RkJERl0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBWRVxuICAgIDB4MDZDQzogWzB4RkJGQywgMHhGQkZELCAweEZCRkUsIDB4RkJGRl0sXG4gICAgLy8gQVJBQklDIExFVFRFUiBGQVJTSSBZRUhcbiAgICAweDA2RDA6IFsweEZCRTQsIDB4RkJFNSwgMHhGQkU2LCAweEZCRTddLFxuICAgIC8vQVJBQklDIExFVFRFUiBFXG4gICAgMHgwNkQyOiBbMHhGQkFFLCAweEZCQUZdLFxuICAgIC8vIEFSQUJJQyBMRVRURVIgWUVIIEJBUlJFRVxuICAgIDB4MDZEMzogWzB4RkJCMCwgMHhGQkIxXSAvLyBBUkFCSUMgTEVUVEVSIFlFSCBCQVJSRUUgV0lUSCBIQU1aQSBBQk9WRVxuXG4gIH07XG4gIHZhciBsaWdhdHVyZXMgPSB7XG4gICAgMHhGRURGOiB7XG4gICAgICAweEZFODI6IDB4RkVGNSxcbiAgICAgIC8vIEFSQUJJQyBMSUdBVFVSRSBMQU0gV0lUSCBBTEVGIFdJVEggTUFEREEgQUJPVkUgSVNPTEFURUQgRk9STVxuICAgICAgMHhGRTg0OiAweEZFRjcsXG4gICAgICAvLyBBUkFCSUMgTElHQVRVUkUgTEFNIFdJVEggQUxFRiBXSVRIIEhBTVpBIEFCT1ZFIElTT0xBVEVEIEZPUk1cbiAgICAgIDB4RkU4ODogMHhGRUY5LFxuICAgICAgLy8gQVJBQklDIExJR0FUVVJFIExBTSBXSVRIIEFMRUYgV0lUSCBIQU1aQSBCRUxPVyBJU09MQVRFRCBGT1JNXG4gICAgICAweEZFOEU6IDB4RkVGQiAvLyBBUkFCSUMgTElHQVRVUkUgTEFNIFdJVEggQUxFRiBJU09MQVRFRCBGT1JNXG5cbiAgICB9LFxuICAgIDB4RkVFMDoge1xuICAgICAgMHhGRTgyOiAweEZFRjYsXG4gICAgICAvLyBBUkFCSUMgTElHQVRVUkUgTEFNIFdJVEggQUxFRiBXSVRIIE1BRERBIEFCT1ZFIEZJTkFMIEZPUk1cbiAgICAgIDB4RkU4NDogMHhGRUY4LFxuICAgICAgLy8gQVJBQklDIExJR0FUVVJFIExBTSBXSVRIIEFMRUYgV0lUSCBIQU1aQSBBQk9WRSBGSU5BTCBGT1JNXG4gICAgICAweEZFODg6IDB4RkVGQSxcbiAgICAgIC8vIEFSQUJJQyBMSUdBVFVSRSBMQU0gV0lUSCBBTEVGIFdJVEggSEFNWkEgQkVMT1cgRklOQUwgRk9STVxuICAgICAgMHhGRThFOiAweEZFRkMgLy8gQVJBQklDIExJR0FUVVJFIExBTSBXSVRIIEFMRUYgRklOQUwgRk9STVxuXG4gICAgfSxcbiAgICAweEZFOEQ6IHtcbiAgICAgIDB4RkVERjoge1xuICAgICAgICAweEZFRTA6IHtcbiAgICAgICAgICAweEZFRUE6IDB4RkRGMlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBTExBSFxuICAgIDB4MDY1MToge1xuICAgICAgMHgwNjRDOiAweEZDNUUsXG4gICAgICAvLyBTaGFkZGEgKyBEYW1tYXRhblxuICAgICAgMHgwNjREOiAweEZDNUYsXG4gICAgICAvLyBTaGFkZGEgKyBLYXNyYXRhblxuICAgICAgMHgwNjRFOiAweEZDNjAsXG4gICAgICAvLyBTaGFkZGEgKyBGYXRoYVxuICAgICAgMHgwNjRGOiAweEZDNjEsXG4gICAgICAvLyBTaGFkZGEgKyBEYW1tYVxuICAgICAgMHgwNjUwOiAweEZDNjIgLy8gU2hhZGRhICsgS2FzcmFcblxuICAgIH1cbiAgfTtcbiAgdmFyIGFyYWJpY19kaWFjcml0aWNzID0ge1xuICAgIDE2MTI6IDY0NjA2LFxuICAgIC8vIFNoYWRkYSArIERhbW1hdGFuXG4gICAgMTYxMzogNjQ2MDcsXG4gICAgLy8gU2hhZGRhICsgS2FzcmF0YW5cbiAgICAxNjE0OiA2NDYwOCxcbiAgICAvLyBTaGFkZGEgKyBGYXRoYVxuICAgIDE2MTU6IDY0NjA5LFxuICAgIC8vIFNoYWRkYSArIERhbW1hXG4gICAgMTYxNjogNjQ2MTAgLy8gU2hhZGRhICsgS2FzcmFcblxuICB9O1xuICB2YXIgYWxmbGV0dGVyID0gWzE1NzAsIDE1NzEsIDE1NzMsIDE1NzVdO1xuICB2YXIgbm9DaGFuZ2VJbkZvcm0gPSAtMTtcbiAgdmFyIGlzb2xhdGVkRm9ybSA9IDA7XG4gIHZhciBmaW5hbEZvcm0gPSAxO1xuICB2YXIgaW5pdGlhbEZvcm0gPSAyO1xuICB2YXIgbWVkaWFsRm9ybSA9IDM7XG4gIGpzUERGQVBJLl9fYXJhYmljUGFyc2VyX18gPSB7fTsgLy9wcml2YXRlXG5cbiAgdmFyIGlzSW5BcmFiaWNTdWJzdGl0dXRpb25BID0ganNQREZBUEkuX19hcmFiaWNQYXJzZXJfXy5pc0luQXJhYmljU3Vic3RpdHV0aW9uQSA9IGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyYWJpY1N1YnN0aXRpb25BW2xldHRlci5jaGFyQ29kZUF0KDApXSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgfTtcblxuICB2YXIgaXNBcmFiaWNMZXR0ZXIgPSBqc1BERkFQSS5fX2FyYWJpY1BhcnNlcl9fLmlzQXJhYmljTGV0dGVyID0gZnVuY3Rpb24gKGxldHRlcikge1xuICAgIHJldHVybiB0eXBlb2YgbGV0dGVyID09PSBcInN0cmluZ1wiICYmIC9eW1xcdTA2MDAtXFx1MDZGRlxcdTA3NTAtXFx1MDc3RlxcdTA4QTAtXFx1MDhGRlxcdUZCNTAtXFx1RkRGRlxcdUZFNzAtXFx1RkVGRl0rJC8udGVzdChsZXR0ZXIpO1xuICB9O1xuXG4gIHZhciBpc0FyYWJpY0VuZExldHRlciA9IGpzUERGQVBJLl9fYXJhYmljUGFyc2VyX18uaXNBcmFiaWNFbmRMZXR0ZXIgPSBmdW5jdGlvbiAobGV0dGVyKSB7XG4gICAgcmV0dXJuIGlzQXJhYmljTGV0dGVyKGxldHRlcikgJiYgaXNJbkFyYWJpY1N1YnN0aXR1dGlvbkEobGV0dGVyKSAmJiBhcmFiaWNTdWJzdGl0aW9uQVtsZXR0ZXIuY2hhckNvZGVBdCgwKV0ubGVuZ3RoIDw9IDI7XG4gIH07XG5cbiAgdmFyIGlzQXJhYmljQWxmTGV0dGVyID0ganNQREZBUEkuX19hcmFiaWNQYXJzZXJfXy5pc0FyYWJpY0FsZkxldHRlciA9IGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICByZXR1cm4gaXNBcmFiaWNMZXR0ZXIobGV0dGVyKSAmJiBhbGZsZXR0ZXIuaW5kZXhPZihsZXR0ZXIuY2hhckNvZGVBdCgwKSkgPj0gMDtcbiAgfTtcblxuICB2YXIgYXJhYmljTGV0dGVySGFzSXNvbGF0ZWRGb3JtID0ganNQREZBUEkuX19hcmFiaWNQYXJzZXJfXy5hcmFiaWNMZXR0ZXJIYXNJc29sYXRlZEZvcm0gPSBmdW5jdGlvbiAobGV0dGVyKSB7XG4gICAgcmV0dXJuIGlzQXJhYmljTGV0dGVyKGxldHRlcikgJiYgaXNJbkFyYWJpY1N1YnN0aXR1dGlvbkEobGV0dGVyKSAmJiBhcmFiaWNTdWJzdGl0aW9uQVtsZXR0ZXIuY2hhckNvZGVBdCgwKV0ubGVuZ3RoID49IDE7XG4gIH07XG5cbiAgdmFyIGFyYWJpY0xldHRlckhhc0ZpbmFsRm9ybSA9IGpzUERGQVBJLl9fYXJhYmljUGFyc2VyX18uYXJhYmljTGV0dGVySGFzRmluYWxGb3JtID0gZnVuY3Rpb24gKGxldHRlcikge1xuICAgIHJldHVybiBpc0FyYWJpY0xldHRlcihsZXR0ZXIpICYmIGlzSW5BcmFiaWNTdWJzdGl0dXRpb25BKGxldHRlcikgJiYgYXJhYmljU3Vic3RpdGlvbkFbbGV0dGVyLmNoYXJDb2RlQXQoMCldLmxlbmd0aCA+PSAyO1xuICB9O1xuXG4gIHZhciBhcmFiaWNMZXR0ZXJIYXNJbml0aWFsRm9ybSA9IGpzUERGQVBJLl9fYXJhYmljUGFyc2VyX18uYXJhYmljTGV0dGVySGFzSW5pdGlhbEZvcm0gPSBmdW5jdGlvbiAobGV0dGVyKSB7XG4gICAgcmV0dXJuIGlzQXJhYmljTGV0dGVyKGxldHRlcikgJiYgaXNJbkFyYWJpY1N1YnN0aXR1dGlvbkEobGV0dGVyKSAmJiBhcmFiaWNTdWJzdGl0aW9uQVtsZXR0ZXIuY2hhckNvZGVBdCgwKV0ubGVuZ3RoID49IDM7XG4gIH07XG5cbiAgdmFyIGFyYWJpY0xldHRlckhhc01lZGlhbEZvcm0gPSBqc1BERkFQSS5fX2FyYWJpY1BhcnNlcl9fLmFyYWJpY0xldHRlckhhc01lZGlhbEZvcm0gPSBmdW5jdGlvbiAobGV0dGVyKSB7XG4gICAgcmV0dXJuIGlzQXJhYmljTGV0dGVyKGxldHRlcikgJiYgaXNJbkFyYWJpY1N1YnN0aXR1dGlvbkEobGV0dGVyKSAmJiBhcmFiaWNTdWJzdGl0aW9uQVtsZXR0ZXIuY2hhckNvZGVBdCgwKV0ubGVuZ3RoID09IDQ7XG4gIH07XG5cbiAgdmFyIHJlc29sdmVMaWdhdHVyZXMgPSBqc1BERkFQSS5fX2FyYWJpY1BhcnNlcl9fLnJlc29sdmVMaWdhdHVyZXMgPSBmdW5jdGlvbiAobGV0dGVycykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdG1wTGlnYXR1cmVzID0gbGlnYXR1cmVzO1xuICAgIHZhciBwb3NpdGlvbiA9IGlzb2xhdGVkRm9ybTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGVmZmVjdGVkTGV0dGVycyA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiB0bXBMaWdhdHVyZXNbbGV0dGVycy5jaGFyQ29kZUF0KGkpXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBlZmZlY3RlZExldHRlcnMrKztcbiAgICAgICAgdG1wTGlnYXR1cmVzID0gdG1wTGlnYXR1cmVzW2xldHRlcnMuY2hhckNvZGVBdChpKV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0bXBMaWdhdHVyZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IGdldENvcnJlY3RGb3JtKGxldHRlcnMuY2hhckF0KGkpLCBsZXR0ZXJzLmNoYXJBdChpIC0gZWZmZWN0ZWRMZXR0ZXJzKSwgbGV0dGVycy5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICE9PSAtMSA/IHBvc2l0aW9uIDogMDtcbiAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0bXBMaWdhdHVyZXMpO1xuICAgICAgICAgIHRtcExpZ2F0dXJlcyA9IGxpZ2F0dXJlcztcbiAgICAgICAgICBlZmZlY3RlZExldHRlcnMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09IGxldHRlcnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRtcExpZ2F0dXJlcyA9IGxpZ2F0dXJlcztcbiAgICAgICAgICByZXN1bHQgKz0gbGV0dGVycy5jaGFyQXQoaSAtIChlZmZlY3RlZExldHRlcnMgLSAxKSk7XG4gICAgICAgICAgaSA9IGkgLSAoZWZmZWN0ZWRMZXR0ZXJzIC0gMSk7XG4gICAgICAgICAgZWZmZWN0ZWRMZXR0ZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wTGlnYXR1cmVzID0gbGlnYXR1cmVzO1xuICAgICAgICByZXN1bHQgKz0gbGV0dGVycy5jaGFyQXQoaSAtIGVmZmVjdGVkTGV0dGVycyk7XG4gICAgICAgIGkgPSBpIC0gZWZmZWN0ZWRMZXR0ZXJzO1xuICAgICAgICBlZmZlY3RlZExldHRlcnMgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGlzQXJhYmljRGlhY3JpdGljID0ganNQREZBUEkuX19hcmFiaWNQYXJzZXJfXy5pc0FyYWJpY0RpYWNyaXRpYyA9IGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICByZXR1cm4gbGV0dGVyICE9PSB1bmRlZmluZWQgJiYgYXJhYmljX2RpYWNyaXRpY3NbbGV0dGVyLmNoYXJDb2RlQXQoMCldICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIGdldENvcnJlY3RGb3JtID0ganNQREZBUEkuX19hcmFiaWNQYXJzZXJfXy5nZXRDb3JyZWN0Rm9ybSA9IGZ1bmN0aW9uIChjdXJyZW50Q2hhciwgYmVmb3JlQ2hhciwgbmV4dENoYXIpIHtcblxuICAgIGlmICghaXNBcmFiaWNMZXR0ZXIoY3VycmVudENoYXIpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKGlzSW5BcmFiaWNTdWJzdGl0dXRpb25BKGN1cnJlbnRDaGFyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBub0NoYW5nZUluRm9ybTtcbiAgICB9XG5cbiAgICBpZiAoIWFyYWJpY0xldHRlckhhc0ZpbmFsRm9ybShjdXJyZW50Q2hhcikgfHwgIWlzQXJhYmljTGV0dGVyKGJlZm9yZUNoYXIpICYmICFpc0FyYWJpY0xldHRlcihuZXh0Q2hhcikgfHwgIWlzQXJhYmljTGV0dGVyKG5leHRDaGFyKSAmJiBpc0FyYWJpY0VuZExldHRlcihiZWZvcmVDaGFyKSB8fCBpc0FyYWJpY0VuZExldHRlcihjdXJyZW50Q2hhcikgJiYgIWlzQXJhYmljTGV0dGVyKGJlZm9yZUNoYXIpIHx8IGlzQXJhYmljRW5kTGV0dGVyKGN1cnJlbnRDaGFyKSAmJiBpc0FyYWJpY0FsZkxldHRlcihiZWZvcmVDaGFyKSB8fCBpc0FyYWJpY0VuZExldHRlcihjdXJyZW50Q2hhcikgJiYgaXNBcmFiaWNFbmRMZXR0ZXIoYmVmb3JlQ2hhcikpIHtcbiAgICAgIHJldHVybiBpc29sYXRlZEZvcm07XG4gICAgfVxuXG4gICAgaWYgKGFyYWJpY0xldHRlckhhc01lZGlhbEZvcm0oY3VycmVudENoYXIpICYmIGlzQXJhYmljTGV0dGVyKGJlZm9yZUNoYXIpICYmICFpc0FyYWJpY0VuZExldHRlcihiZWZvcmVDaGFyKSAmJiBpc0FyYWJpY0xldHRlcihuZXh0Q2hhcikgJiYgYXJhYmljTGV0dGVySGFzRmluYWxGb3JtKG5leHRDaGFyKSkge1xuICAgICAgcmV0dXJuIG1lZGlhbEZvcm07XG4gICAgfVxuXG4gICAgaWYgKGlzQXJhYmljRW5kTGV0dGVyKGN1cnJlbnRDaGFyKSB8fCAhaXNBcmFiaWNMZXR0ZXIobmV4dENoYXIpKSB7XG4gICAgICByZXR1cm4gZmluYWxGb3JtO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0aWFsRm9ybTtcbiAgfTtcbiAgLyoqXG4gICogQG5hbWUgcHJvY2Vzc0FyYWJpY1xuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlXG4gICogQHJldHVybnMge3N0cmluZ31cbiAgKi9cblxuXG4gIHZhciBwcm9jZXNzQXJhYmljID0ganNQREZBUEkuX19hcmFiaWNQYXJzZXJfXy5wcm9jZXNzQXJhYmljID0ganNQREZBUEkucHJvY2Vzc0FyYWJpYyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdGV4dCA9IHRleHQgfHwgXCJcIjtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZXR0ZXIgPSBcIlwiO1xuICAgIHZhciBwcmV2TGV0dGVyID0gXCJcIjtcbiAgICB2YXIgbmV4dExldHRlciA9IFwiXCI7XG4gICAgdmFyIHdvcmRzID0gdGV4dC5zcGxpdChcIlxcXFxzK1wiKTtcbiAgICB2YXIgbmV3V29yZHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbmV3V29yZHMucHVzaCgnJyk7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCB3b3Jkc1tpXS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBjdXJyZW50TGV0dGVyID0gd29yZHNbaV1bal07XG4gICAgICAgIHByZXZMZXR0ZXIgPSB3b3Jkc1tpXVtqIC0gMV07XG4gICAgICAgIG5leHRMZXR0ZXIgPSB3b3Jkc1tpXVtqICsgMV07XG5cbiAgICAgICAgaWYgKGlzQXJhYmljTGV0dGVyKGN1cnJlbnRMZXR0ZXIpKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBnZXRDb3JyZWN0Rm9ybShjdXJyZW50TGV0dGVyLCBwcmV2TGV0dGVyLCBuZXh0TGV0dGVyKTtcblxuICAgICAgICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5ld1dvcmRzW2ldICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJhYmljU3Vic3RpdGlvbkFbY3VycmVudExldHRlci5jaGFyQ29kZUF0KDApXVtwb3NpdGlvbl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdXb3Jkc1tpXSArPSBjdXJyZW50TGV0dGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdXb3Jkc1tpXSArPSBjdXJyZW50TGV0dGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld1dvcmRzW2ldID0gcmVzb2x2ZUxpZ2F0dXJlcyhuZXdXb3Jkc1tpXSk7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gbmV3V29yZHMuam9pbignICcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFyYWJpY1BhcnNlckZ1bmN0aW9uID0gZnVuY3Rpb24gYXJhYmljUGFyc2VyRnVuY3Rpb24oYXJncykge1xuICAgIHZhciB0ZXh0ID0gYXJncy50ZXh0O1xuICAgIHZhciB4ID0gYXJncy54O1xuICAgIHZhciB5ID0gYXJncy55O1xuICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zIHx8IHt9O1xuICAgIHZhciBtdXRleCA9IGFyZ3MubXV0ZXggfHwge307XG4gICAgdmFyIGxhbmcgPSBvcHRpb25zLmxhbmc7XG4gICAgdmFyIHRtcFRleHQgPSBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGV4dCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHRtcFRleHQgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0ZXh0W2ldKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgIHRtcFRleHQucHVzaChbcHJvY2Vzc0FyYWJpYyh0ZXh0W2ldWzBdKSwgdGV4dFtpXVsxXSwgdGV4dFtpXVsyXV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRtcFRleHQucHVzaChbcHJvY2Vzc0FyYWJpYyh0ZXh0W2ldKV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFyZ3MudGV4dCA9IHRtcFRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MudGV4dCA9IHByb2Nlc3NBcmFiaWModGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIGpzUERGQVBJLmV2ZW50cy5wdXNoKFsncHJlUHJvY2Vzc1RleHQnLCBhcmFiaWNQYXJzZXJGdW5jdGlvbl0pO1xufSkoanNQREYuQVBJKTtcblxuLyoqIEBsaWNlbnNlXG4gKiBqc1BERiBBdXRvcHJpbnQgUGx1Z2luXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlXG4gKi9cblxuLyoqXG4qIEBuYW1lIGF1dG9wcmludFxuKiBAbW9kdWxlXG4qL1xuKGZ1bmN0aW9uIChqc1BERkFQSSkge1xuICAvKipcbiAgKiBNYWtlcyB0aGUgUERGIGF1dG9tYXRpY2FsbHkgcHJpbnQuIFRoaXMgd29ya3MgaW4gQ2hyb21lLCBGaXJlZm94LCBBY3JvYmF0XG4gICogUmVhZGVyLlxuICAqXG4gICogQG5hbWUgYXV0b1ByaW50XG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgKG9wdGlvbmFsKSBTZXQgdGhlIGF0dHJpYnV0ZSB2YXJpYW50IHRvICdub24tY29uZm9ybScgKGRlZmF1bHQpIG9yICdqYXZhc2NyaXB0JyB0byBhY3RpdmF0ZSBkaWZmZXJlbnQgbWV0aG9kcyBvZiBhdXRvbWF0aWMgcHJpbnRpbmcgd2hlbiBvcGVuaW5nIGluIGEgUERGLXZpZXdlciAuXG4gICogQHJldHVybnMge2pzUERGfVxuICAqIEBleGFtcGxlXG4gICogdmFyIGRvYyA9IG5ldyBqc1BERigpO1xuICAqIGRvYy50ZXh0KDEwLCAxMCwgJ1RoaXMgaXMgYSB0ZXN0Jyk7XG4gICogZG9jLmF1dG9QcmludCh7dmFyaWFudDogJ25vbi1jb25mb3JtJ30pO1xuICAqIGRvYy5zYXZlKCdhdXRvcHJpbnQucGRmJyk7XG4gICovXG5cbiAganNQREZBUEkuYXV0b1ByaW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIHZhciByZWZBdXRvUHJpbnRUYWc7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy52YXJpYW50ID0gb3B0aW9ucy52YXJpYW50IHx8ICdub24tY29uZm9ybSc7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMudmFyaWFudCkge1xuICAgICAgY2FzZSAnamF2YXNjcmlwdCc6XG4gICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL1JvYi0tVy9wZGYuanMvY29tbWl0L2M2NzZlY2I1YTBmNTQ2NzdiOWYzMzQwYzNlZjJjZjQyMjI1NDUzYmJcbiAgICAgICAgdGhpcy5hZGRKUygncHJpbnQoe30pOycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbm9uLWNvbmZvcm0nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCdwb3N0UHV0UmVzb3VyY2VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlZkF1dG9QcmludFRhZyA9IHRoaXMuaW50ZXJuYWwubmV3T2JqZWN0KCk7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbC5vdXQoXCI8PFwiKTtcbiAgICAgICAgICB0aGlzLmludGVybmFsLm91dChcIi9TIC9OYW1lZFwiKTtcbiAgICAgICAgICB0aGlzLmludGVybmFsLm91dChcIi9UeXBlIC9BY3Rpb25cIik7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbC5vdXQoXCIvTiAvUHJpbnRcIik7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbC5vdXQoXCI+PlwiKTtcbiAgICAgICAgICB0aGlzLmludGVybmFsLm91dChcImVuZG9ialwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZShcInB1dENhdGFsb2dcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuaW50ZXJuYWwub3V0KFwiL09wZW5BY3Rpb24gXCIgKyByZWZBdXRvUHJpbnRUYWcgKyBcIiAwIFJcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKGpzUERGLkFQSSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNCBTdGV2ZW4gU3B1bmdpbiAoVHdlbHZlVG9uZSBMTEMpICBzdGV2ZW5AdHdlbHZldG9uZS50dlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICovXG5cbi8qKlxuICoganNQREYgQ2FudmFzIFBsdWdJblxuICogVGhpcyBwbHVnaW4gbWltaWNzIHRoZSBIVE1MNSBDYW52YXNcbiAqIFxuICogVGhlIGdvYWwgaXMgdG8gcHJvdmlkZSBhIHdheSBmb3IgY3VycmVudCBjYW52YXMgdXNlcnMgdG8gcHJpbnQgZGlyZWN0bHkgdG8gYSBQREYuXG4gKiBAbmFtZSBjYW52YXNcbiAqIEBtb2R1bGVcbiAqL1xuKGZ1bmN0aW9uIChqc1BERkFQSSkge1xuICAvKipcbiAgKiBAY2xhc3MgQ2FudmFzXG4gICogQGNsYXNzZGVzYyBBIENhbnZhcyBXcmFwcGVyIGZvciBqc1BERlxuICAqL1xuXG4gIHZhciBDYW52YXMgPSBmdW5jdGlvbiBDYW52YXMoKSB7XG4gICAgdmFyIGpzUGRmSW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwZGYnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGpzUGRmSW5zdGFuY2U7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAganNQZGZJbnN0YW5jZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfd2lkdGggPSAxNTA7XG4gICAgLyoqXG4gICAgKiBUaGUgaGVpZ2h0IHByb3BlcnR5IGlzIGEgcG9zaXRpdmUgaW50ZWdlciByZWZsZWN0aW5nIHRoZSBoZWlnaHQgSFRNTCBhdHRyaWJ1dGUgb2YgdGhlIDxjYW52YXM+IGVsZW1lbnQgaW50ZXJwcmV0ZWQgaW4gQ1NTIHBpeGVscy4gV2hlbiB0aGUgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWQsIG9yIGlmIGl0IGlzIHNldCB0byBhbiBpbnZhbGlkIHZhbHVlLCBsaWtlIGEgbmVnYXRpdmUsIHRoZSBkZWZhdWx0IHZhbHVlIG9mIDE1MCBpcyB1c2VkLlxuICAgICogVGhpcyBpcyBvbmUgb2YgdGhlIHR3byBwcm9wZXJ0aWVzLCB0aGUgb3RoZXIgYmVpbmcgd2lkdGgsIHRoYXQgY29udHJvbHMgdGhlIHNpemUgb2YgdGhlIGNhbnZhcy5cbiAgICAqXG4gICAgKiBAbmFtZSB3aWR0aFxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3dpZHRoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfd2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSA9PT0gZmFsc2UgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgX3dpZHRoID0gMTUwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF93aWR0aCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0Q29udGV4dCgnMmQnKS5wYWdlV3JhcFhFbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5nZXRDb250ZXh0KCcyZCcpLnBhZ2VXcmFwWCA9IF93aWR0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2hlaWdodCA9IDMwMDtcbiAgICAvKipcbiAgICAqIFRoZSB3aWR0aCBwcm9wZXJ0eSBpcyBhIHBvc2l0aXZlIGludGVnZXIgcmVmbGVjdGluZyB0aGUgd2lkdGggSFRNTCBhdHRyaWJ1dGUgb2YgdGhlIDxjYW52YXM+IGVsZW1lbnQgaW50ZXJwcmV0ZWQgaW4gQ1NTIHBpeGVscy4gV2hlbiB0aGUgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWQsIG9yIGlmIGl0IGlzIHNldCB0byBhbiBpbnZhbGlkIHZhbHVlLCBsaWtlIGEgbmVnYXRpdmUsIHRoZSBkZWZhdWx0IHZhbHVlIG9mIDMwMCBpcyB1c2VkLlxuICAgICogVGhpcyBpcyBvbmUgb2YgdGhlIHR3byBwcm9wZXJ0aWVzLCB0aGUgb3RoZXIgYmVpbmcgaGVpZ2h0LCB0aGF0IGNvbnRyb2xzIHRoZSBzaXplIG9mIHRoZSBjYW52YXMuXG4gICAgKlxuICAgICogQG5hbWUgaGVpZ2h0XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaGVpZ2h0Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfaGVpZ2h0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgPT09IGZhbHNlIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgIF9oZWlnaHQgPSAzMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0Q29udGV4dCgnMmQnKS5wYWdlV3JhcFlFbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5nZXRDb250ZXh0KCcyZCcpLnBhZ2VXcmFwWSA9IF9oZWlnaHQgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9jaGlsZE5vZGVzID0gW107XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjaGlsZE5vZGVzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfY2hpbGROb2RlcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfY2hpbGROb2RlcyA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfc3R5bGUgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0eWxlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfc3R5bGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX3N0eWxlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXJlbnROb2RlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICogVGhlIGdldENvbnRleHQoKSBtZXRob2QgcmV0dXJucyBhIGRyYXdpbmcgY29udGV4dCBvbiB0aGUgY2FudmFzLCBvciBudWxsIGlmIHRoZSBjb250ZXh0IGlkZW50aWZpZXIgaXMgbm90IHN1cHBvcnRlZC5cbiAgKiBcbiAgKiBAbmFtZSBnZXRDb250ZXh0XG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRUeXBlIElzIGEgU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbnRleHQgaWRlbnRpZmllciBkZWZpbmluZyB0aGUgZHJhd2luZyBjb250ZXh0IGFzc29jaWF0ZWQgdG8gdGhlIGNhbnZhcy4gUG9zc2libGUgdmFsdWUgaXMgXCIyZFwiLCBsZWFkaW5nIHRvIHRoZSBjcmVhdGlvbiBvZiBhIENvbnRleHQyRCBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHdvLWRpbWVuc2lvbmFsIHJlbmRlcmluZyBjb250ZXh0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0QXR0cmlidXRlc1xuICAqL1xuXG5cbiAgQ2FudmFzLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHRUeXBlLCBjb250ZXh0QXR0cmlidXRlcykge1xuICAgIGNvbnRleHRUeXBlID0gY29udGV4dFR5cGUgfHwgJzJkJztcbiAgICB2YXIga2V5O1xuXG4gICAgaWYgKGNvbnRleHRUeXBlICE9PSAnMmQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBjb250ZXh0QXR0cmlidXRlcykge1xuICAgICAgaWYgKHRoaXMucGRmLmNvbnRleHQyZC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHRoaXMucGRmLmNvbnRleHQyZFtrZXldID0gY29udGV4dEF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBkZi5jb250ZXh0MmQuX2NhbnZhcyA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMucGRmLmNvbnRleHQyZDtcbiAgfTtcbiAgLyoqXG4gICogVGhlIHRvRGF0YVVSTCgpIG1ldGhvZCBpcyBqdXN0IGEgc3R1YiB0byB0aHJvdyBhbiBlcnJvciBpZiBhY2NpZGVudGx5IGNhbGxlZC5cbiAgKiBcbiAgKiBAbmFtZSB0b0RhdGFVUkxcbiAgKiBAZnVuY3Rpb25cbiAgKi9cblxuXG4gIENhbnZhcy5wcm90b3R5cGUudG9EYXRhVVJMID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9EYXRhVVJMIGlzIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfTtcblxuICBqc1BERkFQSS5ldmVudHMucHVzaChbJ2luaXRpYWxpemVkJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FudmFzID0gbmV3IENhbnZhcygpO1xuICAgIHRoaXMuY2FudmFzLnBkZiA9IHRoaXM7XG4gIH1dKTtcbiAgcmV0dXJuIHRoaXM7XG59KShqc1BERi5BUEkpO1xuXG4vKiogXG4gKiBAbGljZW5zZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAoYykgMjAxMyBZb3Vzc2VmIEJlZGRhZCwgeW91c3NlZi5iZWRkYWRAZ21haWwuY29tXG4gKiAgICAgICAgICAgICAgIDIwMTMgRWR1YXJkbyBNZW5lemVzIGRlIE1vcmFpcywgZWR1YXJkby5tb3JhaXNAdXNwLmJyXG4gKiAgICAgICAgICAgICAgIDIwMTMgTGVlIERyaXNjb2xsLCBodHRwczovL2dpdGh1Yi5jb20vbHNkcmlzY29sbFxuICogICAgICAgICAgICAgICAyMDE0IEp1YW4gUGFibG8gR2F2aXJpYSwgaHR0cHM6Ly9naXRodWIuY29tL2p1YW5wZ2F2aXJpYVxuICogICAgICAgICAgICAgICAyMDE0IEphbWVzIEhhbGwsIGphbWVzQHBhcmFsbC5heFxuICogICAgICAgICAgICAgICAyMDE0IERpZWdvIENhc29ycmFuLCBodHRwczovL2dpdGh1Yi5jb20vZGllZ29jclxuICpcbiAqIFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiogQG5hbWUgY2VsbFxuKiBAbW9kdWxlXG4qL1xuKGZ1bmN0aW9uIChqc1BERkFQSSkge1xuICAvKmpzbGludCBicm93c2VyOnRydWUgKi9cblxuICAvKmdsb2JhbCBkb2N1bWVudDogZmFsc2UsIGpzUERGICovXG5cbiAgdmFyIHBhZGRpbmcgPSAzLFxuICAgICAgbWFyZ2luID0gMTMsXG4gICAgICBoZWFkZXJGdW5jdGlvbixcbiAgICAgIGxhc3RDZWxsUG9zID0ge1xuICAgIHg6IHVuZGVmaW5lZCxcbiAgICB5OiB1bmRlZmluZWQsXG4gICAgdzogdW5kZWZpbmVkLFxuICAgIGg6IHVuZGVmaW5lZCxcbiAgICBsbjogdW5kZWZpbmVkXG4gIH0sXG4gICAgICBwYWdlcyA9IDEsXG4gICAgICBzZXRMYXN0Q2VsbFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0TGFzdENlbGxQb3NpdGlvbih4LCB5LCB3LCBoLCBsbikge1xuICAgIGxhc3RDZWxsUG9zID0ge1xuICAgICAgJ3gnOiB4LFxuICAgICAgJ3knOiB5LFxuICAgICAgJ3cnOiB3LFxuICAgICAgJ2gnOiBoLFxuICAgICAgJ2xuJzogbG5cbiAgICB9O1xuICB9LFxuICAgICAgZ2V0TGFzdENlbGxQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldExhc3RDZWxsUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIGxhc3RDZWxsUG9zO1xuICB9LFxuICAgICAgTk9fTUFSR0lOUyA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDBcbiAgfTtcbiAgLyoqXG4gICogQG5hbWUgc2V0SGVhZGVyRnVuY3Rpb25cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICovXG5cblxuICBqc1BERkFQSS5zZXRIZWFkZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaGVhZGVyRnVuY3Rpb24gPSBmdW5jO1xuICB9O1xuICAvKipcbiAgKiBAbmFtZSBnZXRUZXh0RGltZW5zaW9uc1xuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7c3RyaW5nfSB0eHRcbiAgKiBAcmV0dXJucyB7T2JqZWN0fSBkaW1lbnNpb25zXG4gICovXG5cblxuICBqc1BERkFQSS5nZXRUZXh0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICh0ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy50YWJsZV9mb250X3NpemUgfHwgdGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpO1xuICAgIHZhciBmb250U3R5bGUgPSB0aGlzLmludGVybmFsLmdldEZvbnQoKS5mb250U3R5bGU7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHNjYWxlRmFjdG9yID0gb3B0aW9ucy5zY2FsZUZhY3RvciB8fCB0aGlzLmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGFtb3VudE9mTGluZXMgPSAwO1xuICAgIHZhciBoZWlnaHQgPSAwO1xuICAgIHZhciB0ZW1wV2lkdGggPSAwO1xuXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgd2lkdGggPSB0aGlzLmdldFN0cmluZ1VuaXRXaWR0aCh0ZXh0KSAqIGZvbnRTaXplO1xuXG4gICAgICBpZiAod2lkdGggIT09IDApIHtcbiAgICAgICAgYW1vdW50T2ZMaW5lcyA9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGV4dCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZW1wV2lkdGggPSB0aGlzLmdldFN0cmluZ1VuaXRXaWR0aCh0ZXh0W2ldKSAqIGZvbnRTaXplO1xuXG4gICAgICAgIGlmICh3aWR0aCA8IHRlbXBXaWR0aCkge1xuICAgICAgICAgIHdpZHRoID0gdGVtcFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3aWR0aCAhPT0gMCkge1xuICAgICAgICBhbW91bnRPZkxpbmVzID0gdGV4dC5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0VGV4dERpbWVuc2lvbnMgZXhwZWN0cyB0ZXh0LXBhcmFtZXRlciB0byBiZSBvZiB0eXBlIFN0cmluZyBvciBhbiBBcnJheSBvZiBTdHJpbmdzLicpO1xuICAgIH1cblxuICAgIHdpZHRoID0gd2lkdGggLyBzY2FsZUZhY3RvcjtcbiAgICBoZWlnaHQgPSBNYXRoLm1heCgoYW1vdW50T2ZMaW5lcyAqIGZvbnRTaXplICogdGhpcy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCkgLSBmb250U2l6ZSAqICh0aGlzLmdldExpbmVIZWlnaHRGYWN0b3IoKSAtIDEpKSAvIHNjYWxlRmFjdG9yLCAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHRcbiAgICB9O1xuICB9O1xuICAvKipcbiAgKiBAbmFtZSBjZWxsQWRkUGFnZVxuICAqIEBmdW5jdGlvblxuICAqL1xuXG5cbiAganNQREZBUEkuY2VsbEFkZFBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcmdpbnMgPSB0aGlzLm1hcmdpbnMgfHwgTk9fTUFSR0lOUztcbiAgICB0aGlzLmFkZFBhZ2UoKTtcbiAgICBzZXRMYXN0Q2VsbFBvc2l0aW9uKG1hcmdpbnMubGVmdCwgbWFyZ2lucy50b3AsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTsgLy9zZXRMYXN0Q2VsbFBvc2l0aW9uKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcblxuICAgIHBhZ2VzICs9IDE7XG4gIH07XG4gIC8qKlxuICAqIEBuYW1lIGNlbGxJbml0aWFsaXplXG4gICogQGZ1bmN0aW9uXG4gICovXG5cblxuICBqc1BERkFQSS5jZWxsSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsYXN0Q2VsbFBvcyA9IHtcbiAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgIHk6IHVuZGVmaW5lZCxcbiAgICAgIHc6IHVuZGVmaW5lZCxcbiAgICAgIGg6IHVuZGVmaW5lZCxcbiAgICAgIGxuOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHBhZ2VzID0gMTtcbiAgfTtcbiAgLyoqXG4gICogQG5hbWUgY2VsbFxuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICogQHBhcmFtIHtzdHJpbmd9IHR4dFxuICAqIEBwYXJhbSB7bnVtYmVyfSBsbiBsaW5lTnVtYmVyXG4gICogQHBhcmFtIHtzdHJpbmd9IGFsaWduXG4gICogQHJldHVybiB7anNQREZ9IGpzUERGLWluc3RhbmNlXG4gICovXG5cblxuICBqc1BERkFQSS5jZWxsID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIHR4dCwgbG4sIGFsaWduKSB7XG4gICAgdmFyIGN1ckNlbGwgPSBnZXRMYXN0Q2VsbFBvc2l0aW9uKCk7XG4gICAgdmFyIHBnQWRkZWQgPSBmYWxzZTsgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGZpcnN0IGNlbGwsIHdlIG11c3QgY2hhbmdlIGl0cyBwb3NpdGlvblxuXG4gICAgaWYgKGN1ckNlbGwubG4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGN1ckNlbGwubG4gPT09IGxuKSB7XG4gICAgICAgIC8vU2FtZSBsaW5lXG4gICAgICAgIHggPSBjdXJDZWxsLnggKyBjdXJDZWxsLnc7XG4gICAgICAgIHkgPSBjdXJDZWxsLnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL05ldyBsaW5lXG4gICAgICAgIHZhciBtYXJnaW5zID0gdGhpcy5tYXJnaW5zIHx8IE5PX01BUkdJTlM7XG5cbiAgICAgICAgaWYgKGN1ckNlbGwueSArIGN1ckNlbGwuaCArIGggKyBtYXJnaW4gPj0gdGhpcy5pbnRlcm5hbC5wYWdlU2l6ZS5nZXRIZWlnaHQoKSAtIG1hcmdpbnMuYm90dG9tKSB7XG4gICAgICAgICAgdGhpcy5jZWxsQWRkUGFnZSgpO1xuICAgICAgICAgIHBnQWRkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHRoaXMucHJpbnRIZWFkZXJzICYmIHRoaXMudGFibGVIZWFkZXJSb3cpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRIZWFkZXJSb3cobG4sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvL1dlIGlnbm9yZSB0aGUgcGFzc2VkIHk6IHRoZSBsaW5lcyBtYXkgaGF2ZSBkaWZmZXJlbnQgaGVpZ2h0c1xuXG5cbiAgICAgICAgeSA9IGdldExhc3RDZWxsUG9zaXRpb24oKS55ICsgZ2V0TGFzdENlbGxQb3NpdGlvbigpLmg7XG4gICAgICAgIGlmIChwZ0FkZGVkKSB5ID0gbWFyZ2luICsgMTA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR4dFswXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5wcmludGluZ0hlYWRlclJvdykge1xuICAgICAgICB0aGlzLnJlY3QoeCwgeSwgdywgaCwgJ0ZEJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBpZiAoISh0eHQgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICB0eHQgPSBbdHh0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gdHh0W2ldO1xuICAgICAgICAgIHZhciB0ZXh0U2l6ZSA9IHRoaXMuZ2V0U3RyaW5nVW5pdFdpZHRoKGN1cnJlbnRMaW5lKSAqIHRoaXMuaW50ZXJuYWwuZ2V0Rm9udFNpemUoKSAvIHRoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3I7XG4gICAgICAgICAgdGhpcy50ZXh0KGN1cnJlbnRMaW5lLCB4ICsgdyAtIHRleHRTaXplIC0gcGFkZGluZywgeSArIHRoaXMuaW50ZXJuYWwuZ2V0TGluZUhlaWdodCgpICogKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGV4dCh0eHQsIHggKyBwYWRkaW5nLCB5ICsgdGhpcy5pbnRlcm5hbC5nZXRMaW5lSGVpZ2h0KCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldExhc3RDZWxsUG9zaXRpb24oeCwgeSwgdywgaCwgbG4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBtYXhpbXVtIHZhbHVlIGZyb20gYW4gYXJyYXlcbiAgICogXG4gICAqIEBuYW1lIGFycmF5TWF4XG4gICAqIEBmdW5jdGlvbiBcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHBhcmFtIGNvbXBhcmlzb25GblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuXG4gIGpzUERGQVBJLmFycmF5TWF4ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJpc29uRm4pIHtcbiAgICB2YXIgbWF4ID0gYXJyYXlbMF0sXG4gICAgICAgIGksXG4gICAgICAgIGxuLFxuICAgICAgICBpdGVtO1xuXG4gICAgZm9yIChpID0gMCwgbG4gPSBhcnJheS5sZW5ndGg7IGkgPCBsbjsgaSArPSAxKSB7XG4gICAgICBpdGVtID0gYXJyYXlbaV07XG5cbiAgICAgIGlmIChjb21wYXJpc29uRm4pIHtcbiAgICAgICAgaWYgKGNvbXBhcmlzb25GbihtYXgsIGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgIG1heCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXg7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0YWJsZSBmcm9tIGEgc2V0IG9mIGRhdGEuXG4gICAqIEBuYW1lIHRhYmxlXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IFt4XSA6IGxlZnQtcG9zaXRpb24gZm9yIHRvcC1sZWZ0IGNvcm5lciBvZiB0YWJsZVxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IFt5XSB0b3AtcG9zaXRpb24gZm9yIHRvcC1sZWZ0IGNvcm5lciBvZiB0YWJsZVxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBbZGF0YV0gQXMgYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGtleS12YWx1ZSBwYWlycyBjb3JyZXNwb25kaW5nIHRvIGEgcm93IG9mIGRhdGEuXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IFtoZWFkZXJzXSBPbWl0IG9yIG51bGwgdG8gYXV0by1nZW5lcmF0ZSBoZWFkZXJzIGF0IGEgcGVyZm9ybWFuY2UgY29zdFxuICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcucHJpbnRIZWFkZXJzXSBUcnVlIHRvIHByaW50IGNvbHVtbiBoZWFkZXJzIGF0IHRoZSB0b3Agb2YgZXZlcnkgcGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5hdXRvU2l6ZV0gVHJ1ZSB0byBkeW5hbWljYWxseSBzZXQgdGhlIGNvbHVtbiB3aWR0aHMgdG8gbWF0Y2ggdGhlIHdpZGVzdCBjZWxsIHZhbHVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm1hcmdpbnNdIG1hcmdpbiB2YWx1ZXMgZm9yIGxlZnQsIHRvcCwgYm90dG9tLCBhbmQgd2lkdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZm9udFNpemVdIEludGVnZXIgZm9udFNpemUgdG8gdXNlIChvcHRpb25hbClcbiAgICogQHJldHVybnMge2pzUERGfSBqc1BERi1pbnN0YW5jZVxuICAgKi9cblxuXG4gIGpzUERGQVBJLnRhYmxlID0gZnVuY3Rpb24gKHgsIHksIGRhdGEsIGhlYWRlcnMsIGNvbmZpZykge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhyb3cgJ05vIGRhdGEgZm9yIFBERiB0YWJsZSc7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlck5hbWVzID0gW10sXG4gICAgICAgIGhlYWRlclByb21wdHMgPSBbXSxcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBpLFxuICAgICAgICBsbixcbiAgICAgICAgY2xuLFxuICAgICAgICBjb2x1bW5NYXRyaXggPSB7fSxcbiAgICAgICAgY29sdW1uV2lkdGhzID0ge30sXG4gICAgICAgIGNvbHVtbkRhdGEsXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgY29sdW1uTWluV2lkdGhzID0gW10sXG4gICAgICAgIGosXG4gICAgICAgIHRhYmxlSGVhZGVyQ29uZmlncyA9IFtdLFxuICAgICAgICBtb2RlbCxcbiAgICAgICAgamxuLFxuICAgICAgICBmdW5jLFxuICAgICAgICAvL3NldCB1cCBkZWZhdWx0cy4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBpbiBjb25maWcsIGRlZmF1bHRzIHdpbGwgYmUgb3ZlcndyaXR0ZW46XG4gICAgYXV0b1NpemUgPSBmYWxzZSxcbiAgICAgICAgcHJpbnRIZWFkZXJzID0gdHJ1ZSxcbiAgICAgICAgZm9udFNpemUgPSAxMixcbiAgICAgICAgbWFyZ2lucyA9IE5PX01BUkdJTlM7XG4gICAgbWFyZ2lucy53aWR0aCA9IHRoaXMuaW50ZXJuYWwucGFnZVNpemUuZ2V0V2lkdGgoKTtcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIC8vb3ZlcnJpZGUgY29uZmlnIGRlZmF1bHRzIGlmIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgbm9uLWRlZmF1bHQgYmVoYXZpb3I6XG4gICAgICBpZiAoY29uZmlnLmF1dG9TaXplID09PSB0cnVlKSB7XG4gICAgICAgIGF1dG9TaXplID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5wcmludEhlYWRlcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIHByaW50SGVhZGVycyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmZvbnRTaXplKSB7XG4gICAgICAgIGZvbnRTaXplID0gY29uZmlnLmZvbnRTaXplO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmNzcyAmJiB0eXBlb2YgY29uZmlnLmNzc1snZm9udC1zaXplJ10gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZm9udFNpemUgPSBjb25maWcuY3NzWydmb250LXNpemUnXSAqIDE2O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLm1hcmdpbnMpIHtcbiAgICAgICAgbWFyZ2lucyA9IGNvbmZpZy5tYXJnaW5zO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbG5Nb2RcbiAgICAgKiBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IGxpbmUgbnVtYmVyIG1vZGlmaWVyIHVzZWQgd2hlbiBjcmVhdGluZyBjZWxsc1xuICAgICAqL1xuXG5cbiAgICB0aGlzLmxuTW9kID0gMDtcbiAgICBsYXN0Q2VsbFBvcyA9IHtcbiAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgIHk6IHVuZGVmaW5lZCxcbiAgICAgIHc6IHVuZGVmaW5lZCxcbiAgICAgIGg6IHVuZGVmaW5lZCxcbiAgICAgIGxuOiB1bmRlZmluZWRcbiAgICB9LCBwYWdlcyA9IDE7XG4gICAgdGhpcy5wcmludEhlYWRlcnMgPSBwcmludEhlYWRlcnM7XG4gICAgdGhpcy5tYXJnaW5zID0gbWFyZ2lucztcbiAgICB0aGlzLnNldEZvbnRTaXplKGZvbnRTaXplKTtcbiAgICB0aGlzLnRhYmxlX2ZvbnRfc2l6ZSA9IGZvbnRTaXplOyAvLyBTZXQgaGVhZGVyIHZhbHVlc1xuXG4gICAgaWYgKGhlYWRlcnMgPT09IHVuZGVmaW5lZCB8fCBoZWFkZXJzID09PSBudWxsKSB7XG4gICAgICAvLyBObyBoZWFkZXJzIGRlZmluZWQgc28gd2UgZGVyaXZlIGZyb20gZGF0YVxuICAgICAgaGVhZGVyTmFtZXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdKTtcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnNbMF0gJiYgdHlwZW9mIGhlYWRlcnNbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHgycHQgPSAwLjI2NDU4MyAqIDcyIC8gMjUuNDsgLy8gU3BsaXQgaGVhZGVyIGNvbmZpZ3MgaW50byBuYW1lcyBhbmQgcHJvbXB0c1xuXG4gICAgICBmb3IgKGkgPSAwLCBsbiA9IGhlYWRlcnMubGVuZ3RoOyBpIDwgbG47IGkgKz0gMSkge1xuICAgICAgICBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICBoZWFkZXJOYW1lcy5wdXNoKGhlYWRlci5uYW1lKTtcbiAgICAgICAgaGVhZGVyUHJvbXB0cy5wdXNoKGhlYWRlci5wcm9tcHQpO1xuICAgICAgICBjb2x1bW5XaWR0aHNbaGVhZGVyLm5hbWVdID0gaGVhZGVyLndpZHRoICogcHgycHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlck5hbWVzID0gaGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAoYXV0b1NpemUpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG1hdHJpeCBvZiBjb2x1bW5zIGUuZy4sIHtjb2x1bW5fdGl0bGU6IFtyb3cxX1JlY29yZCwgcm93Ml9SZWNvcmRdfVxuICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMocmVjKSB7XG4gICAgICAgIHJldHVybiByZWNbaGVhZGVyXTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxuID0gaGVhZGVyTmFtZXMubGVuZ3RoOyBpIDwgbG47IGkgKz0gMSkge1xuICAgICAgICBoZWFkZXIgPSBoZWFkZXJOYW1lc1tpXTtcbiAgICAgICAgY29sdW1uTWF0cml4W2hlYWRlcl0gPSBkYXRhLm1hcChmdW5jKTsgLy8gZ2V0IGhlYWRlciB3aWR0aFxuXG4gICAgICAgIGNvbHVtbk1pbldpZHRocy5wdXNoKHRoaXMuZ2V0VGV4dERpbWVuc2lvbnMoaGVhZGVyUHJvbXB0c1tpXSB8fCBoZWFkZXIsIHtcbiAgICAgICAgICBzY2FsZUZhY3RvcjogMVxuICAgICAgICB9KS53KTtcbiAgICAgICAgY29sdW1uID0gY29sdW1uTWF0cml4W2hlYWRlcl07IC8vIGdldCBjZWxsIHdpZHRoc1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGNsbiA9IGNvbHVtbi5sZW5ndGg7IGogPCBjbG47IGogKz0gMSkge1xuICAgICAgICAgIGNvbHVtbkRhdGEgPSBjb2x1bW5bal07XG4gICAgICAgICAgY29sdW1uTWluV2lkdGhzLnB1c2godGhpcy5nZXRUZXh0RGltZW5zaW9ucyhjb2x1bW5EYXRhLCB7XG4gICAgICAgICAgICBzY2FsZUZhY3RvcjogMVxuICAgICAgICAgIH0pLncpO1xuICAgICAgICB9IC8vIGdldCBmaW5hbCBjb2x1bW4gd2lkdGhcblxuXG4gICAgICAgIGNvbHVtbldpZHRoc1toZWFkZXJdID0ganNQREZBUEkuYXJyYXlNYXgoY29sdW1uTWluV2lkdGhzKTsgLy9oYXZlIHRvIHJlc2V0XG5cbiAgICAgICAgY29sdW1uTWluV2lkdGhzID0gW107XG4gICAgICB9XG4gICAgfSAvLyAtLSBDb25zdHJ1Y3QgdGhlIHRhYmxlXG5cblxuICAgIGlmIChwcmludEhlYWRlcnMpIHtcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGVMaW5lSGVpZ2h0KGhlYWRlck5hbWVzLCBjb2x1bW5XaWR0aHMsIGhlYWRlclByb21wdHMubGVuZ3RoID8gaGVhZGVyUHJvbXB0cyA6IGhlYWRlck5hbWVzKTsgLy8gQ29uc3RydWN0IHRoZSBoZWFkZXIgcm93XG5cbiAgICAgIGZvciAoaSA9IDAsIGxuID0gaGVhZGVyTmFtZXMubGVuZ3RoOyBpIDwgbG47IGkgKz0gMSkge1xuICAgICAgICBoZWFkZXIgPSBoZWFkZXJOYW1lc1tpXTtcbiAgICAgICAgdGFibGVIZWFkZXJDb25maWdzLnB1c2goW3gsIHksIGNvbHVtbldpZHRoc1toZWFkZXJdLCBsaW5lSGVpZ2h0LCBTdHJpbmcoaGVhZGVyUHJvbXB0cy5sZW5ndGggPyBoZWFkZXJQcm9tcHRzW2ldIDogaGVhZGVyKV0pO1xuICAgICAgfSAvLyBTdG9yZSB0aGUgdGFibGUgaGVhZGVyIGNvbmZpZ1xuXG5cbiAgICAgIHRoaXMuc2V0VGFibGVIZWFkZXJSb3codGFibGVIZWFkZXJDb25maWdzKTsgLy8gUHJpbnQgdGhlIGhlYWRlciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZVxuXG4gICAgICB0aGlzLnByaW50SGVhZGVyUm93KDEsIGZhbHNlKTtcbiAgICB9IC8vIENvbnN0cnVjdCB0aGUgZGF0YSByb3dzXG5cblxuICAgIGZvciAoaSA9IDAsIGxuID0gZGF0YS5sZW5ndGg7IGkgPCBsbjsgaSArPSAxKSB7XG4gICAgICB2YXIgbGluZUhlaWdodDtcbiAgICAgIG1vZGVsID0gZGF0YVtpXTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZUxpbmVIZWlnaHQoaGVhZGVyTmFtZXMsIGNvbHVtbldpZHRocywgbW9kZWwpO1xuXG4gICAgICBmb3IgKGogPSAwLCBqbG4gPSBoZWFkZXJOYW1lcy5sZW5ndGg7IGogPCBqbG47IGogKz0gMSkge1xuICAgICAgICBoZWFkZXIgPSBoZWFkZXJOYW1lc1tqXTtcbiAgICAgICAgdGhpcy5jZWxsKHgsIHksIGNvbHVtbldpZHRoc1toZWFkZXJdLCBsaW5lSGVpZ2h0LCBtb2RlbFtoZWFkZXJdLCBpICsgMiwgaGVhZGVyLmFsaWduKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxhc3RDZWxsUG9zID0gbGFzdENlbGxQb3M7XG4gICAgdGhpcy50YWJsZV94ID0geDtcbiAgICB0aGlzLnRhYmxlX3kgPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBoZWlnaHQgZm9yIGNvbnRhaW5pbmcgdGhlIGhpZ2hlc3QgY29sdW1uXG4gICAqXG4gICAqIEBuYW1lIGNhbGN1bGF0ZUxpbmVIZWlnaHRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGhlYWRlck5hbWVzIGlzIHRoZSBoZWFkZXIsIHVzZWQgYXMga2V5cyB0byB0aGUgZGF0YVxuICAgKiBAcGFyYW0ge0ludGVnZXJbXX0gY29sdW1uV2lkdGhzIGlzIHNpemUgb2YgZWFjaCBjb2x1bW5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gbW9kZWwgaXMgdGhlIGxpbmUgb2YgZGF0YSB3ZSB3YW50IHRvIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IGxpbmVIZWlnaHRcbiAgICovXG5cblxuICBqc1BERkFQSS5jYWxjdWxhdGVMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKGhlYWRlck5hbWVzLCBjb2x1bW5XaWR0aHMsIG1vZGVsKSB7XG4gICAgdmFyIGhlYWRlcixcbiAgICAgICAgbGluZUhlaWdodCA9IDA7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhlYWRlck5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBoZWFkZXIgPSBoZWFkZXJOYW1lc1tqXTtcbiAgICAgIG1vZGVsW2hlYWRlcl0gPSB0aGlzLnNwbGl0VGV4dFRvU2l6ZShTdHJpbmcobW9kZWxbaGVhZGVyXSksIGNvbHVtbldpZHRoc1toZWFkZXJdIC0gcGFkZGluZyk7XG4gICAgICB2YXIgaCA9IHRoaXMuaW50ZXJuYWwuZ2V0TGluZUhlaWdodCgpICogbW9kZWxbaGVhZGVyXS5sZW5ndGggKyBwYWRkaW5nO1xuICAgICAgaWYgKGggPiBsaW5lSGVpZ2h0KSBsaW5lSGVpZ2h0ID0gaDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZUhlaWdodDtcbiAgfTtcbiAgLyoqXG4gICAqIFN0b3JlIHRoZSBjb25maWcgZm9yIG91dHB1dHRpbmcgYSB0YWJsZSBoZWFkZXJcbiAgICpcbiAgICogQG5hbWUgc2V0VGFibGVIZWFkZXJSb3dcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbmZpZ1xuICAgKiBBbiBhcnJheSBvZiBjZWxsIGNvbmZpZ3MgdGhhdCB3b3VsZCBkZWZpbmUgYSBoZWFkZXIgcm93OiBFYWNoIGNvbmZpZyBtYXRjaGVzIHRoZSBjb25maWcgdXNlZCBieSBqc1BERkFQSS5jZWxsXG4gICAqIGV4Y2VwdCB0aGUgbG4gcGFyYW1ldGVyIGlzIGV4Y2x1ZGVkXG4gICAqL1xuXG5cbiAganNQREZBUEkuc2V0VGFibGVIZWFkZXJSb3cgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgdGhpcy50YWJsZUhlYWRlclJvdyA9IGNvbmZpZztcbiAgfTtcbiAgLyoqXG4gICAqIE91dHB1dCB0aGUgc3RvcmUgaGVhZGVyIHJvd1xuICAgKiBcbiAgICogQG5hbWUgcHJpbnRIZWFkZXJSb3dcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lTnVtYmVyIFRoZSBsaW5lIG51bWJlciB0byBvdXRwdXQgdGhlIGhlYWRlciBhdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5ld19wYWdlIFxuICAgKi9cblxuXG4gIGpzUERGQVBJLnByaW50SGVhZGVyUm93ID0gZnVuY3Rpb24gKGxpbmVOdW1iZXIsIG5ld19wYWdlKSB7XG4gICAgaWYgKCF0aGlzLnRhYmxlSGVhZGVyUm93KSB7XG4gICAgICB0aHJvdyAnUHJvcGVydHkgdGFibGVIZWFkZXJSb3cgZG9lcyBub3QgZXhpc3QuJztcbiAgICB9XG5cbiAgICB2YXIgdGFibGVIZWFkZXJDZWxsLCB0bXBBcnJheSwgaSwgbG47XG4gICAgdGhpcy5wcmludGluZ0hlYWRlclJvdyA9IHRydWU7XG5cbiAgICBpZiAoaGVhZGVyRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gaGVhZGVyRnVuY3Rpb24odGhpcywgcGFnZXMpO1xuICAgICAgc2V0TGFzdENlbGxQb3NpdGlvbihwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIHBvc2l0aW9uWzJdLCBwb3NpdGlvblszXSwgLTEpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0Rm9udFN0eWxlKCdib2xkJyk7XG4gICAgdmFyIHRlbXBIZWFkZXJDb25mID0gW107XG5cbiAgICBmb3IgKGkgPSAwLCBsbiA9IHRoaXMudGFibGVIZWFkZXJSb3cubGVuZ3RoOyBpIDwgbG47IGkgKz0gMSkge1xuICAgICAgdGhpcy5zZXRGaWxsQ29sb3IoMjAwLCAyMDAsIDIwMCk7XG4gICAgICB0YWJsZUhlYWRlckNlbGwgPSB0aGlzLnRhYmxlSGVhZGVyUm93W2ldO1xuXG4gICAgICBpZiAobmV3X3BhZ2UpIHtcbiAgICAgICAgdGhpcy5tYXJnaW5zLnRvcCA9IG1hcmdpbjtcbiAgICAgICAgdGFibGVIZWFkZXJDZWxsWzFdID0gdGhpcy5tYXJnaW5zICYmIHRoaXMubWFyZ2lucy50b3AgfHwgMDtcbiAgICAgICAgdGVtcEhlYWRlckNvbmYucHVzaCh0YWJsZUhlYWRlckNlbGwpO1xuICAgICAgfVxuXG4gICAgICB0bXBBcnJheSA9IFtdLmNvbmNhdCh0YWJsZUhlYWRlckNlbGwpO1xuICAgICAgdGhpcy5jZWxsLmFwcGx5KHRoaXMsIHRtcEFycmF5LmNvbmNhdChsaW5lTnVtYmVyKSk7XG4gICAgfVxuXG4gICAgaWYgKHRlbXBIZWFkZXJDb25mLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2V0VGFibGVIZWFkZXJSb3codGVtcEhlYWRlckNvbmYpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0Rm9udFN0eWxlKCdub3JtYWwnKTtcbiAgICB0aGlzLnByaW50aW5nSGVhZGVyUm93ID0gZmFsc2U7XG4gIH07XG59KShqc1BERi5BUEkpO1xuXG4vKipcbiAqIGpzUERGIENvbnRleHQyRCBQbHVnSW4gQ29weXJpZ2h0IChjKSAyMDE0IFN0ZXZlbiBTcHVuZ2luIChUd2VsdmVUb25lIExMQykgc3RldmVuQHR3ZWx2ZXRvbmUudHZcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICovXG5cbi8qKlxuKiBUaGlzIHBsdWdpbiBtaW1pY3MgdGhlIEhUTUw1IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5cbipcbiogVGhlIGdvYWwgaXMgdG8gcHJvdmlkZSBhIHdheSBmb3IgY3VycmVudCBjYW52YXMgaW1wbGVtZW50YXRpb25zIHRvIHByaW50IGRpcmVjdGx5IHRvIGEgUERGLlxuKlxuKiBAbmFtZSBjb250ZXh0MmRcbiogQG1vZHVsZVxuKi9cbihmdW5jdGlvbiAoanNQREZBUEksIGdsb2JhbE9iaikge1xuXG4gIHZhciBDb250ZXh0TGF5ZXIgPSBmdW5jdGlvbiBDb250ZXh0TGF5ZXIoY3R4KSB7XG4gICAgY3R4ID0gY3R4IHx8IHt9O1xuICAgIHRoaXMuaXNTdHJva2VUcmFuc3BhcmVudCA9IGN0eC5pc1N0cm9rZVRyYW5zcGFyZW50IHx8IGZhbHNlO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IGN0eC5zdHJva2VPcGFjaXR5IHx8IDE7XG4gICAgdGhpcy5zdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZSB8fCAnIzAwMDAwMCc7XG4gICAgdGhpcy5maWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlIHx8ICcjMDAwMDAwJztcbiAgICB0aGlzLmlzRmlsbFRyYW5zcGFyZW50ID0gY3R4LmlzRmlsbFRyYW5zcGFyZW50IHx8IGZhbHNlO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSBjdHguZmlsbE9wYWNpdHkgfHwgMTtcbiAgICB0aGlzLmZvbnQgPSBjdHguZm9udCB8fCAnMTBweCBzYW5zLXNlcmlmJztcbiAgICB0aGlzLnRleHRCYXNlbGluZSA9IGN0eC50ZXh0QmFzZWxpbmUgfHwgJ2FscGhhYmV0aWMnO1xuICAgIHRoaXMudGV4dEFsaWduID0gY3R4LnRleHRBbGlnbiB8fCAnbGVmdCc7XG4gICAgdGhpcy5saW5lV2lkdGggPSBjdHgubGluZVdpZHRoIHx8IDE7XG4gICAgdGhpcy5saW5lSm9pbiA9IGN0eC5saW5lSm9pbiB8fCAnbWl0ZXInO1xuICAgIHRoaXMubGluZUNhcCA9IGN0eC5saW5lQ2FwIHx8ICdidXR0JztcbiAgICB0aGlzLnBhdGggPSBjdHgucGF0aCB8fCBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHR5cGVvZiBjdHgudHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJyA/IGN0eC50cmFuc2Zvcm0uY2xvbmUoKSA6IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gfHwgJ25vcm1hbCc7XG4gICAgdGhpcy5nbG9iYWxBbHBoYSA9IGN0eC5nbG9iYWxBbHBoYSB8fCAxLjA7XG4gICAgdGhpcy5jbGlwX3BhdGggPSBjdHguY2xpcF9wYXRoIHx8IFtdO1xuICAgIHRoaXMuY3VycmVudFBvaW50ID0gY3R4LmN1cnJlbnRQb2ludCB8fCBuZXcgUG9pbnQoKTtcbiAgICB0aGlzLm1pdGVyTGltaXQgPSBjdHgubWl0ZXJMaW1pdCB8fCAxMC4wO1xuICAgIHRoaXMubGFzdFBvaW50ID0gY3R4Lmxhc3RQb2ludCB8fCBuZXcgUG9pbnQoKTtcbiAgICB0aGlzLmlnbm9yZUNsZWFyUmVjdCA9IHR5cGVvZiBjdHguaWdub3JlQ2xlYXJSZWN0ID09PSBcImJvb2xlYW5cIiA/IGN0eC5pZ25vcmVDbGVhclJlY3QgOiB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvL3N0dWJcblxuXG4gIHZhciBmMiwgZjMsIGdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nLCBnZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcsIGdldEhvcml6b250YWxDb29yZGluYXRlLCBnZXRWZXJ0aWNhbENvb3JkaW5hdGU7XG4gIGpzUERGQVBJLmV2ZW50cy5wdXNoKFsnaW5pdGlhbGl6ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb250ZXh0MmQgPSBuZXcgQ29udGV4dDJEKHRoaXMpO1xuICAgIGYyID0gdGhpcy5pbnRlcm5hbC5mMjtcbiAgICBmMyA9IHRoaXMuaW50ZXJuYWwuZjM7XG4gICAgZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGVTdHJpbmcgPSB0aGlzLmludGVybmFsLmdldENvb3JkaW5hdGVTdHJpbmc7XG4gICAgZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nID0gdGhpcy5pbnRlcm5hbC5nZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmc7XG4gICAgZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUgPSB0aGlzLmludGVybmFsLmdldEhvcml6b250YWxDb29yZGluYXRlO1xuICAgIGdldFZlcnRpY2FsQ29vcmRpbmF0ZSA9IHRoaXMuaW50ZXJuYWwuZ2V0VmVydGljYWxDb29yZGluYXRlO1xuICB9XSk7XG5cbiAgdmFyIENvbnRleHQyRCA9IGZ1bmN0aW9uIENvbnRleHQyRChwZGYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbnZhcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhcmVudE5vZGU6IGZhbHNlLFxuICAgICAgICAgIHN0eWxlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGRmJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZGY7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9wYWdlV3JhcFhFbmFibGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgKiBAbmFtZSBwYWdlV3JhcFhFbmFibGVkXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGFnZVdyYXBYRW5hYmxlZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3BhZ2VXcmFwWEVuYWJsZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX3BhZ2VXcmFwWEVuYWJsZWQgPSBCb29sZWFuKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX3BhZ2VXcmFwWUVuYWJsZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAqIEBuYW1lIHBhZ2VXcmFwWUVuYWJsZWRcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BhZ2VXcmFwWUVuYWJsZWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9wYWdlV3JhcFlFbmFibGVkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9wYWdlV3JhcFlFbmFibGVkID0gQm9vbGVhbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9wb3NYID0gMDtcbiAgICAvKipcbiAgICAqIEBuYW1lIHBvc1hcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKiBAZGVmYXVsdCAwXG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncG9zWCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3Bvc1g7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICBfcG9zWCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9wb3NZID0gMDtcbiAgICAvKipcbiAgICAqIEBuYW1lIHBvc1lcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKiBAZGVmYXVsdCAwXG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncG9zWScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3Bvc1k7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICBfcG9zWSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9hdXRvUGFnaW5nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgKiBAbmFtZSBhdXRvUGFnaW5nXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdhdXRvUGFnaW5nJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfYXV0b1BhZ2luZztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfYXV0b1BhZ2luZyA9IEJvb2xlYW4odmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBsYXN0QnJlYWsgPSAwO1xuICAgIC8qKlxuICAgICogQG5hbWUgbGFzdEJyZWFrXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICogQGRlZmF1bHQgMFxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2xhc3RCcmVhaycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbGFzdEJyZWFrO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGxhc3RCcmVhayA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBwYWdlQnJlYWtzID0gW107XG4gICAgLyoqXG4gICAgKiBZIFBvc2l0aW9uIG9mIHBhZ2UgYnJlYWtzLlxuICAgICogQG5hbWUgcGFnZUJyZWFrc1xuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqIEBkZWZhdWx0IDBcbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYWdlQnJlYWtzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBwYWdlQnJlYWtzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHBhZ2VCcmVha3MgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBfY3R4ID0gbmV3IENvbnRleHRMYXllcigpO1xuICAgIC8qKlxuICAgICogQG5hbWUgY3R4XG4gICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICogQGRlZmF1bHQge31cbiAgICAqL1xuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2N0eCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2N0eDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb250ZXh0TGF5ZXIpIHtcbiAgICAgICAgICBfY3R4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIEBuYW1lIHBhdGhcbiAgICAqIEB0eXBlIHthcnJheX1cbiAgICAqIEBkZWZhdWx0IFtdXG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGF0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2N0eC5wYXRoO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9jdHgucGF0aCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogQG5hbWUgY3R4U3RhY2tcbiAgICAqIEB0eXBlIHthcnJheX1cbiAgICAqIEBkZWZhdWx0IFtdXG4gICAgKi9cblxuICAgIHZhciBfY3R4U3RhY2sgPSBbXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2N0eFN0YWNrJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfY3R4U3RhY2s7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX2N0eFN0YWNrID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBTZXRzIG9yIHJldHVybnMgdGhlIGNvbG9yLCBncmFkaWVudCwgb3IgcGF0dGVybiB1c2VkIHRvIGZpbGwgdGhlIGRyYXdpbmdcbiAgICAqXG4gICAgKiBAbmFtZSBmaWxsU3R5bGVcbiAgICAqIEBkZWZhdWx0ICMwMDAwMDBcbiAgICAqIEBwcm9wZXJ0eSB7KGNvbG9yfGdyYWRpZW50fHBhdHRlcm4pfSB2YWx1ZSBUaGUgY29sb3Igb2YgdGhlIGRyYXdpbmcuIERlZmF1bHQgdmFsdWUgaXMgIzAwMDAwMDxiciAvPlxuICAgICogQSBncmFkaWVudCBvYmplY3QgKGxpbmVhciBvciByYWRpYWwpIHVzZWQgdG8gZmlsbCB0aGUgZHJhd2luZyAobm90IHN1cHBvcnRlZCBieSBjb250ZXh0MmQpPGJyIC8+XG4gICAgKiBBIHBhdHRlcm4gb2JqZWN0IHRvIHVzZSB0byBmaWxsIHRoZSBkcmF3aW5nIChub3Qgc3VwcG9ydGVkIGJ5IGNvbnRleHQyZClcbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdmaWxsU3R5bGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3R4LmZpbGxTdHlsZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgcmdiYTtcbiAgICAgICAgcmdiYSA9IGdldFJHQkEodmFsdWUpO1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSByZ2JhLnN0eWxlO1xuICAgICAgICB0aGlzLmN0eC5pc0ZpbGxUcmFuc3BhcmVudCA9IHJnYmEuYSA9PT0gMDtcbiAgICAgICAgdGhpcy5jdHguZmlsbE9wYWNpdHkgPSByZ2JhLmE7XG4gICAgICAgIHRoaXMucGRmLnNldEZpbGxDb2xvcihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iLCB7XG4gICAgICAgICAgYTogcmdiYS5hXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBkZi5zZXRUZXh0Q29sb3IocmdiYS5yLCByZ2JhLmcsIHJnYmEuYiwge1xuICAgICAgICAgIGE6IHJnYmEuYVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIFNldHMgb3IgcmV0dXJucyB0aGUgY29sb3IsIGdyYWRpZW50LCBvciBwYXR0ZXJuIHVzZWQgZm9yIHN0cm9rZXNcbiAgICAqXG4gICAgKiBAbmFtZSBzdHJva2VTdHlsZVxuICAgICogQGRlZmF1bHQgIzAwMDAwMFxuICAgICogQHByb3BlcnR5IHtjb2xvcn0gY29sb3IgQSBDU1MgY29sb3IgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgZHJhd2luZy4gRGVmYXVsdCB2YWx1ZSBpcyAjMDAwMDAwIChub3Qgc3VwcG9ydGVkIGJ5IGNvbnRleHQyZClcbiAgICAqIEBwcm9wZXJ0eSB7Z3JhZGllbnR9IGdyYWRpZW50IEEgZ3JhZGllbnQgb2JqZWN0IChsaW5lYXIgb3IgcmFkaWFsKSB1c2VkIHRvIGNyZWF0ZSBhIGdyYWRpZW50IHN0cm9rZSAobm90IHN1cHBvcnRlZCBieSBjb250ZXh0MmQpXG4gICAgKiBAcHJvcGVydHkge3BhdHRlcm59IHBhdHRlcm4gQSBwYXR0ZXJuIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSBhIHBhdHRlcm4gc3Ryb2tlIChub3Qgc3VwcG9ydGVkIGJ5IGNvbnRleHQyZClcbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdHJva2VTdHlsZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdHguc3Ryb2tlU3R5bGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHJnYmEgPSBnZXRSR0JBKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSByZ2JhLnN0eWxlO1xuICAgICAgICB0aGlzLmN0eC5pc1N0cm9rZVRyYW5zcGFyZW50ID0gcmdiYS5hID09PSAwO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VPcGFjaXR5ID0gcmdiYS5hO1xuXG4gICAgICAgIGlmIChyZ2JhLmEgPT09IDApIHtcbiAgICAgICAgICB0aGlzLnBkZi5zZXREcmF3Q29sb3IoMjU1LCAyNTUsIDI1NSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmdiYS5hID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5wZGYuc2V0RHJhd0NvbG9yKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGRmLnNldERyYXdDb2xvcihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogU2V0cyBvciByZXR1cm5zIHRoZSBzdHlsZSBvZiB0aGUgZW5kIGNhcHMgZm9yIGEgbGluZVxuICAgICpcbiAgICAqIEBuYW1lIGxpbmVDYXBcbiAgICAqIEBkZWZhdWx0IGJ1dHRcbiAgICAqIEBwcm9wZXJ0eSB7KGJ1dHR8cm91bmR8c3F1YXJlKX0gbGluZUNhcCBidXR0IEEgZmxhdCBlZGdlIGlzIGFkZGVkIHRvIGVhY2ggZW5kIG9mIHRoZSBsaW5lIDxici8+XG4gICAgKiByb3VuZCBBIHJvdW5kZWQgZW5kIGNhcCBpcyBhZGRlZCB0byBlYWNoIGVuZCBvZiB0aGUgbGluZTxici8+XG4gICAgKiBzcXVhcmUgQSBzcXVhcmUgZW5kIGNhcCBpcyBhZGRlZCB0byBlYWNoIGVuZCBvZiB0aGUgbGluZTxici8+XG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbGluZUNhcCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdHgubGluZUNhcDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoWydidXR0JywgJ3JvdW5kJywgJ3NxdWFyZSddLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuY3R4LmxpbmVDYXAgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnBkZi5zZXRMaW5lQ2FwKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogU2V0cyBvciByZXR1cm5zIHRoZSBjdXJyZW50IGxpbmUgd2lkdGhcbiAgICAqXG4gICAgKiBAbmFtZSBsaW5lV2lkdGhcbiAgICAqIEBkZWZhdWx0IDFcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lV2lkdGggVGhlIGN1cnJlbnQgbGluZSB3aWR0aCwgaW4gcGl4ZWxzXG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbGluZVdpZHRoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN0eC5saW5lV2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnBkZi5zZXRMaW5lV2lkdGgodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBTZXRzIG9yIHJldHVybnMgdGhlIHR5cGUgb2YgY29ybmVyIGNyZWF0ZWQsIHdoZW4gdHdvIGxpbmVzIG1lZXRcbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsaW5lSm9pbicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdHgubGluZUpvaW47XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKFsnYmV2ZWwnLCAncm91bmQnLCAnbWl0ZXInXS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lSm9pbiA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMucGRmLnNldExpbmVKb2luKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogQSBudW1iZXIgc3BlY2lmeWluZyB0aGUgbWl0ZXIgbGltaXQgcmF0aW8gaW4gY29vcmRpbmF0ZSBzcGFjZSB1bml0cy4gWmVybywgbmVnYXRpdmUsIEluZmluaXR5LCBhbmQgTmFOIHZhbHVlcyBhcmUgaWdub3JlZC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMTAuMC5cbiAgICAqXG4gICAgKiBAbmFtZSBtaXRlckxpbWl0XG4gICAgKiBAZGVmYXVsdCAxMFxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21pdGVyTGltaXQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3R4Lm1pdGVyTGltaXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLmN0eC5taXRlckxpbWl0ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5wZGYuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RleHRCYXNlbGluZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdHgudGV4dEJhc2VsaW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3R4LnRleHRCYXNlbGluZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndGV4dEFsaWduJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN0eC50ZXh0QWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKFsncmlnaHQnLCAnZW5kJywgJ2NlbnRlcicsICdsZWZ0JywgJ3N0YXJ0J10uaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5jdHgudGV4dEFsaWduID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2ZvbnQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3R4LmZvbnQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jdHguZm9udCA9IHZhbHVlO1xuICAgICAgICB2YXIgcngsIG1hdGNoZXM7IC8vc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTAxMzYwNDFcblxuICAgICAgICByeCA9IC9eXFxzKig/PSg/Oig/OlstYS16XStcXHMqKXswLDJ9KGl0YWxpY3xvYmxpcXVlKSk/KSg/PSg/Oig/OlstYS16XStcXHMqKXswLDJ9KHNtYWxsLWNhcHMpKT8pKD89KD86KD86Wy1hLXpdK1xccyopezAsMn0oYm9sZCg/OmVyKT98bGlnaHRlcnxbMS05XTAwKSk/KSg/Oig/Om5vcm1hbHxcXDF8XFwyfFxcMylcXHMqKXswLDN9KCg/Onh4Py0pPyg/OnNtYWxsfGxhcmdlKXxtZWRpdW18c21hbGxlcnxsYXJnZXJ8Wy5cXGRdKyg/OlxcJXxpbnxbY2VtXW18ZXh8cFtjdHhdKSkoPzpcXHMqXFwvXFxzKihub3JtYWx8Wy5cXGRdKyg/OlxcJXxpbnxbY2VtXW18ZXh8cFtjdHhdKSkpP1xccyooWy1fLFxcXCJcXCdcXHNhLXpdKz8pXFxzKiQvaTtcbiAgICAgICAgbWF0Y2hlcyA9IHJ4LmV4ZWModmFsdWUpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZvbnRTdHlsZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgdmFyIGZvbnRWYXJpYW50ID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICB2YXIgZm9udFdlaWdodCA9IG1hdGNoZXNbM107XG4gICAgICAgICAgdmFyIGZvbnRTaXplID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICB2YXIgZm9udFNpemVVbml0ID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgICB2YXIgZm9udEZhbWlseSA9IG1hdGNoZXNbNl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdweCcgPT09IGZvbnRTaXplVW5pdCkge1xuICAgICAgICAgIGZvbnRTaXplID0gTWF0aC5mbG9vcihwYXJzZUZsb2F0KGZvbnRTaXplKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2VtJyA9PT0gZm9udFNpemVVbml0KSB7XG4gICAgICAgICAgZm9udFNpemUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQoZm9udFNpemUpICogdGhpcy5wZGYuZ2V0Rm9udFNpemUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9udFNpemUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQoZm9udFNpemUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGRmLnNldEZvbnRTaXplKGZvbnRTaXplKTtcbiAgICAgICAgdmFyIHN0eWxlID0gJyc7XG5cbiAgICAgICAgaWYgKGZvbnRXZWlnaHQgPT09ICdib2xkJyB8fCBwYXJzZUludChmb250V2VpZ2h0LCAxMCkgPj0gNzAwIHx8IGZvbnRTdHlsZSA9PT0gJ2JvbGQnKSB7XG4gICAgICAgICAgc3R5bGUgPSAnYm9sZCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgICAgICAgIHN0eWxlICs9ICdpdGFsaWMnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHN0eWxlID0gJ25vcm1hbCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIganNQZGZGb250TmFtZSA9ICcnO1xuICAgICAgICB2YXIgcGFydHMgPSBmb250RmFtaWx5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXCJ8Jy9nLCAnJykuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgICB2YXIgZmFsbGJhY2tGb250cyA9IHtcbiAgICAgICAgICBhcmlhbDogJ0hlbHZldGljYScsXG4gICAgICAgICAgdmVyZGFuYTogJ0hlbHZldGljYScsXG4gICAgICAgICAgaGVsdmV0aWNhOiAnSGVsdmV0aWNhJyxcbiAgICAgICAgICAnc2Fucy1zZXJpZic6ICdIZWx2ZXRpY2EnLFxuICAgICAgICAgIGZpeGVkOiAnQ291cmllcicsXG4gICAgICAgICAgbW9ub3NwYWNlOiAnQ291cmllcicsXG4gICAgICAgICAgdGVybWluYWw6ICdDb3VyaWVyJyxcbiAgICAgICAgICBjb3VyaWVyOiAnQ291cmllcicsXG4gICAgICAgICAgdGltZXM6ICdUaW1lcycsXG4gICAgICAgICAgY3Vyc2l2ZTogJ1RpbWVzJyxcbiAgICAgICAgICBmYW50YXN5OiAnVGltZXMnLFxuICAgICAgICAgIHNlcmlmOiAnVGltZXMnXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnBkZi5pbnRlcm5hbC5nZXRGb250KHBhcnRzW2ldLCBzdHlsZSwge1xuICAgICAgICAgICAgbm9GYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVXYXJuaW5nOiB0cnVlXG4gICAgICAgICAgfSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAganNQZGZGb250TmFtZSA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ2JvbGRpdGFsaWMnICYmIHRoaXMucGRmLmludGVybmFsLmdldEZvbnQocGFydHNbaV0sICdib2xkJywge1xuICAgICAgICAgICAgbm9GYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVXYXJuaW5nOiB0cnVlXG4gICAgICAgICAgfSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAganNQZGZGb250TmFtZSA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgc3R5bGUgPSAnYm9sZCc7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBkZi5pbnRlcm5hbC5nZXRGb250KHBhcnRzW2ldLCAnbm9ybWFsJywge1xuICAgICAgICAgICAgbm9GYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVXYXJuaW5nOiB0cnVlXG4gICAgICAgICAgfSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAganNQZGZGb250TmFtZSA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgc3R5bGUgPSAnbm9ybWFsJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqc1BkZkZvbnROYW1lID09PSAnJykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmYWxsYmFja0ZvbnRzW3BhcnRzW2ldXSkge1xuICAgICAgICAgICAgICBqc1BkZkZvbnROYW1lID0gZmFsbGJhY2tGb250c1twYXJ0c1tpXV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGpzUGRmRm9udE5hbWUgPSBqc1BkZkZvbnROYW1lID09PSAnJyA/ICdUaW1lcycgOiBqc1BkZkZvbnROYW1lO1xuICAgICAgICB0aGlzLnBkZi5zZXRGb250KGpzUGRmRm9udE5hbWUsIHN0eWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZ2xvYmFsQWxwaGEnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7IC8vIE5vdCBIVE1MIEFQSVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZ25vcmVDbGVhclJlY3QnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3R4Lmlnbm9yZUNsZWFyUmVjdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmN0eC5pZ25vcmVDbGVhclJlY3QgPSBCb29sZWFuKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBDb250ZXh0MkQucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGF0aFByZVByb2Nlc3MuY2FsbCh0aGlzLCAnZmlsbCcsIGZhbHNlKTtcbiAgfTtcbiAgLyoqXG4gICogQWN0dWFsbHkgZHJhd3MgdGhlIHBhdGggeW91IGhhdmUgZGVmaW5lZFxuICAqXG4gICogQG5hbWUgc3Ryb2tlXG4gICogQGZ1bmN0aW9uXG4gICogQGRlc2NyaXB0aW9uIFRoZSBzdHJva2UoKSBtZXRob2QgYWN0dWFsbHkgZHJhd3MgdGhlIHBhdGggeW91IGhhdmUgZGVmaW5lZCB3aXRoIGFsbCB0aG9zZSBtb3ZlVG8oKSBhbmQgbGluZVRvKCkgbWV0aG9kcy4gVGhlIGRlZmF1bHQgY29sb3IgaXMgYmxhY2suXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLnN0cm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYXRoUHJlUHJvY2Vzcy5jYWxsKHRoaXMsICdzdHJva2UnLCBmYWxzZSk7XG4gIH07XG4gIC8qKlxuICAqIEJlZ2lucyBhIHBhdGgsIG9yIHJlc2V0cyB0aGUgY3VycmVudCBcbiAgKlxuICAqIEBuYW1lIGJlZ2luUGF0aFxuICAqIEBmdW5jdGlvbiBcbiAgKiBAZGVzY3JpcHRpb24gVGhlIGJlZ2luUGF0aCgpIG1ldGhvZCBiZWdpbnMgYSBwYXRoLCBvciByZXNldHMgdGhlIGN1cnJlbnQgcGF0aC5cbiAgKi9cblxuXG4gIENvbnRleHQyRC5wcm90b3R5cGUuYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGF0aCA9IFt7XG4gICAgICB0eXBlOiAnYmVnaW4nXG4gICAgfV07XG4gIH07XG4gIC8qKlxuICAqIE1vdmVzIHRoZSBwYXRoIHRvIHRoZSBzcGVjaWZpZWQgcG9pbnQgaW4gdGhlIGNhbnZhcywgd2l0aG91dCBjcmVhdGluZyBhIGxpbmVcbiAgKiBcbiAgKiBAbmFtZSBtb3ZlVG9cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgeC1jb29yZGluYXRlIG9mIHdoZXJlIHRvIG1vdmUgdGhlIHBhdGggdG9cbiAgKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeS1jb29yZGluYXRlIG9mIHdoZXJlIHRvIG1vdmUgdGhlIHBhdGggdG9cbiAgKi9cblxuXG4gIENvbnRleHQyRC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGLmNvbnRleHQyZC5tb3ZlVG86IEludmFsaWQgYXJndW1lbnRzJywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5tb3ZlVG8nKTtcbiAgICB9XG5cbiAgICB2YXIgcHQgPSB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBQb2ludCh4LCB5KSk7XG4gICAgdGhpcy5wYXRoLnB1c2goe1xuICAgICAgdHlwZTogJ210JyxcbiAgICAgIHg6IHB0LngsXG4gICAgICB5OiBwdC55XG4gICAgfSk7XG4gICAgdGhpcy5jdHgubGFzdFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICB9O1xuICAvKipcbiAgKiBDcmVhdGVzIGEgcGF0aCBmcm9tIHRoZSBjdXJyZW50IHBvaW50IGJhY2sgdG8gdGhlIHN0YXJ0aW5nIHBvaW50XG4gICogXG4gICogQG5hbWUgY2xvc2VQYXRoXG4gICogQGZ1bmN0aW9uXG4gICogQGRlc2NyaXB0aW9uIFRoZSBjbG9zZVBhdGgoKSBtZXRob2QgY3JlYXRlcyBhIHBhdGggZnJvbSB0aGUgY3VycmVudCBwb2ludCBiYWNrIHRvIHRoZSBzdGFydGluZyBwb2ludC5cbiAgKi9cblxuXG4gIENvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXRoQmVnaW4gPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gdGhpcy5wYXRoLmxlbmd0aCAtIDE7IGkgIT09IC0xOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLnBhdGhbaV0udHlwZSA9PT0gJ2JlZ2luJykge1xuICAgICAgICBpZiAoX3R5cGVvZih0aGlzLnBhdGhbaSArIDFdKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoaXMucGF0aFtpICsgMV0ueCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBwYXRoQmVnaW4gPSBuZXcgUG9pbnQodGhpcy5wYXRoW2kgKyAxXS54LCB0aGlzLnBhdGhbaSArIDFdLnkpO1xuICAgICAgICAgIHRoaXMucGF0aC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdsdCcsXG4gICAgICAgICAgICB4OiBwYXRoQmVnaW4ueCxcbiAgICAgICAgICAgIHk6IHBhdGhCZWdpbi55XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZih0aGlzLnBhdGhbaSArIDJdKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoaXMucGF0aFtpICsgMl0ueCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGF0aC5wdXNoKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXRoW2kgKyAyXSkpKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhdGgucHVzaCh7XG4gICAgICB0eXBlOiAnY2xvc2UnXG4gICAgfSk7XG4gICAgdGhpcy5jdHgubGFzdFBvaW50ID0gbmV3IFBvaW50KHBhdGhCZWdpbi54LCBwYXRoQmVnaW4ueSk7XG4gIH07XG4gIC8qKlxuICAqIEFkZHMgYSBuZXcgcG9pbnQgYW5kIGNyZWF0ZXMgYSBsaW5lIHRvIHRoYXQgcG9pbnQgZnJvbSB0aGUgbGFzdCBzcGVjaWZpZWQgcG9pbnQgaW4gdGhlIGNhbnZhc1xuICAqIFxuICAqIEBuYW1lIGxpbmVUb1xuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB4IFRoZSB4LWNvb3JkaW5hdGUgb2Ygd2hlcmUgdG8gY3JlYXRlIHRoZSBsaW5lIHRvXG4gICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZSBvZiB3aGVyZSB0byBjcmVhdGUgdGhlIGxpbmUgdG9cbiAgKiBAZGVzY3JpcHRpb24gVGhlIGxpbmVUbygpIG1ldGhvZCBhZGRzIGEgbmV3IHBvaW50IGFuZCBjcmVhdGVzIGEgbGluZSBUTyB0aGF0IHBvaW50IEZST00gdGhlIGxhc3Qgc3BlY2lmaWVkIHBvaW50IGluIHRoZSBjYW52YXMgKHRoaXMgbWV0aG9kIGRvZXMgbm90IGRyYXcgdGhlIGxpbmUpLlxuICAqL1xuXG5cbiAgQ29udGV4dDJELnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkge1xuICAgICAgY29uc29sZS5lcnJvcignanNQREYuY29udGV4dDJkLmxpbmVUbzogSW52YWxpZCBhcmd1bWVudHMnLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLmxpbmVUbycpO1xuICAgIH1cblxuICAgIHZhciBwdCA9IHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IFBvaW50KHgsIHkpKTtcbiAgICB0aGlzLnBhdGgucHVzaCh7XG4gICAgICB0eXBlOiAnbHQnLFxuICAgICAgeDogcHQueCxcbiAgICAgIHk6IHB0LnlcbiAgICB9KTtcbiAgICB0aGlzLmN0eC5sYXN0UG9pbnQgPSBuZXcgUG9pbnQocHQueCwgcHQueSk7XG4gIH07XG4gIC8qKlxuICAqIENsaXBzIGEgcmVnaW9uIG9mIGFueSBzaGFwZSBhbmQgc2l6ZSBmcm9tIHRoZSBvcmlnaW5hbCBjYW52YXNcbiAgKiBcbiAgKiBAbmFtZSBjbGlwXG4gICogQGZ1bmN0aW9uXG4gICogQGRlc2NyaXB0aW9uIFRoZSBjbGlwKCkgbWV0aG9kIGNsaXBzIGEgcmVnaW9uIG9mIGFueSBzaGFwZSBhbmQgc2l6ZSBmcm9tIHRoZSBvcmlnaW5hbCBjYW52YXMuXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdHguY2xpcF9wYXRoID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBhdGgpKTtcbiAgICBwYXRoUHJlUHJvY2Vzcy5jYWxsKHRoaXMsIG51bGwsIHRydWUpO1xuICB9O1xuICAvKipcbiAgKiBDcmVhdGVzIGEgY3ViaWMgQsOpemllciBjdXJ2ZVxuICAqXG4gICogQG5hbWUgcXVhZHJhdGljQ3VydmVUb1xuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSBjcHgge051bWJlcn0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgQsOpemllciBjb250cm9sIHBvaW50XG4gICogQHBhcmFtIGNweSB7TnVtYmVyfSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBCw6l6aWVyIGNvbnRyb2wgcG9pbnRcbiAgKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnRcbiAgKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnRcbiAgKiBAZGVzY3JpcHRpb24gVGhlIHF1YWRyYXRpY0N1cnZlVG8oKSBtZXRob2QgYWRkcyBhIHBvaW50IHRvIHRoZSBjdXJyZW50IHBhdGggYnkgdXNpbmcgdGhlIHNwZWNpZmllZCBjb250cm9sIHBvaW50cyB0aGF0IHJlcHJlc2VudCBhIHF1YWRyYXRpYyBCw6l6aWVyIGN1cnZlLjxiciAvPjxiciAvPiBBIHF1YWRyYXRpYyBCw6l6aWVyIGN1cnZlIHJlcXVpcmVzIHR3byBwb2ludHMuIFRoZSBmaXJzdCBwb2ludCBpcyBhIGNvbnRyb2wgcG9pbnQgdGhhdCBpcyB1c2VkIGluIHRoZSBxdWFkcmF0aWMgQsOpemllciBjYWxjdWxhdGlvbiBhbmQgdGhlIHNlY29uZCBwb2ludCBpcyB0aGUgZW5kaW5nIHBvaW50IGZvciB0aGUgY3VydmUuIFRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIGN1cnZlIGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguIElmIGEgcGF0aCBkb2VzIG5vdCBleGlzdCwgdXNlIHRoZSBiZWdpblBhdGgoKSBhbmQgbW92ZVRvKCkgbWV0aG9kcyB0byBkZWZpbmUgYSBzdGFydGluZyBwb2ludC5cbiAgKi9cblxuXG4gIENvbnRleHQyRC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uIChjcHgsIGNweSwgeCwgeSkge1xuICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSB8fCBpc05hTihjcHgpIHx8IGlzTmFOKGNweSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGLmNvbnRleHQyZC5xdWFkcmF0aWNDdXJ2ZVRvOiBJbnZhbGlkIGFyZ3VtZW50cycsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQucXVhZHJhdGljQ3VydmVUbycpO1xuICAgIH1cblxuICAgIHZhciBwdDAgPSB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBQb2ludCh4LCB5KSk7XG4gICAgdmFyIHB0MSA9IHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IFBvaW50KGNweCwgY3B5KSk7XG4gICAgdGhpcy5wYXRoLnB1c2goe1xuICAgICAgdHlwZTogJ3FjdCcsXG4gICAgICB4MTogcHQxLngsXG4gICAgICB5MTogcHQxLnksXG4gICAgICB4OiBwdDAueCxcbiAgICAgIHk6IHB0MC55XG4gICAgfSk7XG4gICAgdGhpcy5jdHgubGFzdFBvaW50ID0gbmV3IFBvaW50KHB0MC54LCBwdDAueSk7XG4gIH07XG4gIC8qKlxuICAqIENyZWF0ZXMgYSBjdWJpYyBCw6l6aWVyIGN1cnZlXG4gICpcbiAgKiBAbmFtZSBiZXppZXJDdXJ2ZVRvXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIGNwMXgge051bWJlcn0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgQsOpemllciBjb250cm9sIHBvaW50XG4gICogQHBhcmFtIGNwMXkge051bWJlcn0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgQsOpemllciBjb250cm9sIHBvaW50XG4gICogQHBhcmFtIGNwMngge051bWJlcn0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIELDqXppZXIgY29udHJvbCBwb2ludFxuICAqIEBwYXJhbSBjcDJ5IHtOdW1iZXJ9IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBCw6l6aWVyIGNvbnRyb2wgcG9pbnRcbiAgKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnRcbiAgKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnRcbiAgKiBAZGVzY3JpcHRpb24gVGhlIGJlemllckN1cnZlVG8oKSBtZXRob2QgYWRkcyBhIHBvaW50IHRvIHRoZSBjdXJyZW50IHBhdGggYnkgdXNpbmcgdGhlIHNwZWNpZmllZCBjb250cm9sIHBvaW50cyB0aGF0IHJlcHJlc2VudCBhIGN1YmljIELDqXppZXIgY3VydmUuIDxiciAvPjxiciAvPkEgY3ViaWMgYmV6aWVyIGN1cnZlIHJlcXVpcmVzIHRocmVlIHBvaW50cy4gVGhlIGZpcnN0IHR3byBwb2ludHMgYXJlIGNvbnRyb2wgcG9pbnRzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIGN1YmljIELDqXppZXIgY2FsY3VsYXRpb24gYW5kIHRoZSBsYXN0IHBvaW50IGlzIHRoZSBlbmRpbmcgcG9pbnQgZm9yIHRoZSBjdXJ2ZS4gIFRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIGN1cnZlIGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguIElmIGEgcGF0aCBkb2VzIG5vdCBleGlzdCwgdXNlIHRoZSBiZWdpblBhdGgoKSBhbmQgbW92ZVRvKCkgbWV0aG9kcyB0byBkZWZpbmUgYSBzdGFydGluZyBwb2ludC5cbiAgKi9cblxuXG4gIENvbnRleHQyRC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpIHx8IGlzTmFOKGNwMXgpIHx8IGlzTmFOKGNwMXkpIHx8IGlzTmFOKGNwMngpIHx8IGlzTmFOKGNwMnkpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdqc1BERi5jb250ZXh0MmQuYmV6aWVyQ3VydmVUbzogSW52YWxpZCBhcmd1bWVudHMnLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLmJlemllckN1cnZlVG8nKTtcbiAgICB9XG5cbiAgICB2YXIgcHQwID0gdGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9Qb2ludChuZXcgUG9pbnQoeCwgeSkpO1xuICAgIHZhciBwdDEgPSB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBQb2ludChjcDF4LCBjcDF5KSk7XG4gICAgdmFyIHB0MiA9IHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IFBvaW50KGNwMngsIGNwMnkpKTtcbiAgICB0aGlzLnBhdGgucHVzaCh7XG4gICAgICB0eXBlOiAnYmN0JyxcbiAgICAgIHgxOiBwdDEueCxcbiAgICAgIHkxOiBwdDEueSxcbiAgICAgIHgyOiBwdDIueCxcbiAgICAgIHkyOiBwdDIueSxcbiAgICAgIHg6IHB0MC54LFxuICAgICAgeTogcHQwLnlcbiAgICB9KTtcbiAgICB0aGlzLmN0eC5sYXN0UG9pbnQgPSBuZXcgUG9pbnQocHQwLngsIHB0MC55KTtcbiAgfTtcbiAgLyoqXG4gICogQ3JlYXRlcyBhbiBhcmMvY3VydmUgKHVzZWQgdG8gY3JlYXRlIGNpcmNsZXMsIG9yIHBhcnRzIG9mIGNpcmNsZXMpXG4gICpcbiAgKiBAbmFtZSBhcmNcbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICogQHBhcmFtIHJhZGl1cyB7TnVtYmVyfSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgKiBAcGFyYW0gc3RhcnRBbmdsZSB7TnVtYmVyfSBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMgKDAgaXMgYXQgdGhlIDMgbydjbG9jayBwb3NpdGlvbiBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxuICAqIEBwYXJhbSBlbmRBbmdsZSB7TnVtYmVyfSBUaGUgZW5kaW5nIGFuZ2xlLCBpbiByYWRpYW5zXG4gICogQHBhcmFtIGNvdW50ZXJjbG9ja3dpc2Uge0Jvb2xlYW59IE9wdGlvbmFsLiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZHJhd2luZyBzaG91bGQgYmUgY291bnRlcmNsb2Nrd2lzZSBvciBjbG9ja3dpc2UuIEZhbHNlIGlzIGRlZmF1bHQsIGFuZCBpbmRpY2F0ZXMgY2xvY2t3aXNlLCB3aGlsZSB0cnVlIGluZGljYXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAgKiBAZGVzY3JpcHRpb24gVGhlIGFyYygpIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSAodXNlZCB0byBjcmVhdGUgY2lyY2xlcywgb3IgcGFydHMgb2YgY2lyY2xlcykuXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyY2xvY2t3aXNlKSB7XG4gICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpIHx8IGlzTmFOKHJhZGl1cykgfHwgaXNOYU4oc3RhcnRBbmdsZSkgfHwgaXNOYU4oZW5kQW5nbGUpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdqc1BERi5jb250ZXh0MmQuYXJjOiBJbnZhbGlkIGFyZ3VtZW50cycsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQuYXJjJyk7XG4gICAgfVxuXG4gICAgY291bnRlcmNsb2Nrd2lzZSA9IEJvb2xlYW4oY291bnRlcmNsb2Nrd2lzZSk7XG5cbiAgICBpZiAoIXRoaXMuY3R4LnRyYW5zZm9ybS5pc0lkZW50aXR5KSB7XG4gICAgICB2YXIgeHB0ID0gdGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9Qb2ludChuZXcgUG9pbnQoeCwgeSkpO1xuICAgICAgeCA9IHhwdC54O1xuICAgICAgeSA9IHhwdC55O1xuICAgICAgdmFyIHhfcmFkUHQgPSB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBQb2ludCgwLCByYWRpdXMpKTtcbiAgICAgIHZhciB4X3JhZFB0MCA9IHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IFBvaW50KDAsIDApKTtcbiAgICAgIHJhZGl1cyA9IE1hdGguc3FydChNYXRoLnBvdyh4X3JhZFB0LnggLSB4X3JhZFB0MC54LCAyKSArIE1hdGgucG93KHhfcmFkUHQueSAtIHhfcmFkUHQwLnksIDIpKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+PSAyICogTWF0aC5QSSkge1xuICAgICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgICBlbmRBbmdsZSA9IDIgKiBNYXRoLlBJO1xuICAgIH1cblxuICAgIHRoaXMucGF0aC5wdXNoKHtcbiAgICAgIHR5cGU6ICdhcmMnLFxuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICBjb3VudGVyY2xvY2t3aXNlOiBjb3VudGVyY2xvY2t3aXNlXG4gICAgfSk7IC8vIHRoaXMuY3R4Lmxhc3RQb2ludChuZXcgUG9pbnQocHQueCxwdC55KSk7XG4gIH07XG4gIC8qKlxuICAqIENyZWF0ZXMgYW4gYXJjL2N1cnZlIGJldHdlZW4gdHdvIHRhbmdlbnRzXG4gICogXG4gICogQG5hbWUgYXJjVG9cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0geDEge051bWJlcn0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgdGFuZ2VudFxuICAqIEBwYXJhbSB5MSB7TnVtYmVyfSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCB0YW5nZW50XG4gICogQHBhcmFtIHgyIHtOdW1iZXJ9IFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCB0YW5nZW50XG4gICogQHBhcmFtIHkyIHtOdW1iZXJ9IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCB0YW5nZW50XG4gICogQHBhcmFtIHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBhcmNcbiAgKiBAZGVzY3JpcHRpb24gVGhlIGFyY1RvKCkgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlIGJldHdlZW4gdHdvIHRhbmdlbnRzIG9uIHRoZSBjYW52YXMuXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLmFyY1RvID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyY1RvIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfTtcbiAgLyoqXG4gICogQ3JlYXRlcyBhIHJlY3RhbmdsZVxuICAqXG4gICogQG5hbWUgcmVjdFxuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICogQHBhcmFtIHcge051bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUsIGluIHBpeGVsc1xuICAqIEBwYXJhbSBoIHtOdW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSwgaW4gcGl4ZWxzXG4gICogQGRlc2NyaXB0aW9uIFRoZSByZWN0KCkgbWV0aG9kIGNyZWF0ZXMgYSByZWN0YW5nbGUuXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSB8fCBpc05hTih3KSB8fCBpc05hTihoKSkge1xuICAgICAgY29uc29sZS5lcnJvcignanNQREYuY29udGV4dDJkLnJlY3Q6IEludmFsaWQgYXJndW1lbnRzJywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5yZWN0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHcsIHkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3LCB5ICsgaCk7XG4gICAgdGhpcy5saW5lVG8oeCwgeSArIGgpO1xuICAgIHRoaXMubGluZVRvKHgsIHkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3LCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4LCB5KTtcbiAgfTtcbiAgLyoqXG4gICogRHJhd3MgYSBcImZpbGxlZFwiIHJlY3RhbmdsZVxuICAqXG4gICogQG5hbWUgZmlsbFJlY3RcbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICogQHBhcmFtIHkge051bWJlcn0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAqIEBwYXJhbSB3IHtOdW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLCBpbiBwaXhlbHNcbiAgKiBAcGFyYW0gaCB7TnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUsIGluIHBpeGVsc1xuICAqIEBkZXNjcmlwdGlvbiBUaGUgZmlsbFJlY3QoKSBtZXRob2QgZHJhd3MgYSBcImZpbGxlZFwiIHJlY3RhbmdsZS4gVGhlIGRlZmF1bHQgY29sb3Igb2YgdGhlIGZpbGwgaXMgYmxhY2suXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLmZpbGxSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkgfHwgaXNOYU4odykgfHwgaXNOYU4oaCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGLmNvbnRleHQyZC5maWxsUmVjdDogSW52YWxpZCBhcmd1bWVudHMnLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLmZpbGxSZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRmlsbFRyYW5zcGFyZW50LmNhbGwodGhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0ge307XG5cbiAgICBpZiAodGhpcy5saW5lQ2FwICE9PSAnYnV0dCcpIHtcbiAgICAgIHRtcC5saW5lQ2FwID0gdGhpcy5saW5lQ2FwO1xuICAgICAgdGhpcy5saW5lQ2FwID0gJ2J1dHQnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxpbmVKb2luICE9PSAnbWl0ZXInKSB7XG4gICAgICB0bXAubGluZUpvaW4gPSB0aGlzLmxpbmVKb2luO1xuICAgICAgdGhpcy5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgfVxuXG4gICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICB0aGlzLnJlY3QoeCwgeSwgdywgaCk7XG4gICAgdGhpcy5maWxsKCk7XG5cbiAgICBpZiAodG1wLmhhc093blByb3BlcnR5KCdsaW5lQ2FwJykpIHtcbiAgICAgIHRoaXMubGluZUNhcCA9IHRtcC5saW5lQ2FwO1xuICAgIH1cblxuICAgIGlmICh0bXAuaGFzT3duUHJvcGVydHkoJ2xpbmVKb2luJykpIHtcbiAgICAgIHRoaXMubGluZUpvaW4gPSB0bXAubGluZUpvaW47XG4gICAgfVxuICB9O1xuICAvKipcbiAgKiAgICAgRHJhd3MgYSByZWN0YW5nbGUgKG5vIGZpbGwpXG4gICpcbiAgKiBAbmFtZSBzdHJva2VSZWN0XG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHgge051bWJlcn0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgKiBAcGFyYW0gdyB7TnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSwgaW4gcGl4ZWxzXG4gICogQHBhcmFtIGgge051bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLCBpbiBwaXhlbHNcbiAgKiBAZGVzY3JpcHRpb24gVGhlIHN0cm9rZVJlY3QoKSBtZXRob2QgZHJhd3MgYSByZWN0YW5nbGUgKG5vIGZpbGwpLiBUaGUgZGVmYXVsdCBjb2xvciBvZiB0aGUgc3Ryb2tlIGlzIGJsYWNrLlxuICAqL1xuXG5cbiAgQ29udGV4dDJELnByb3RvdHlwZS5zdHJva2VSZWN0ID0gZnVuY3Rpb24gc3Ryb2tlUmVjdCh4LCB5LCB3LCBoKSB7XG4gICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpIHx8IGlzTmFOKHcpIHx8IGlzTmFOKGgpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdqc1BERi5jb250ZXh0MmQuc3Ryb2tlUmVjdDogSW52YWxpZCBhcmd1bWVudHMnLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLnN0cm9rZVJlY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJva2VUcmFuc3BhcmVudC5jYWxsKHRoaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICB0aGlzLnJlY3QoeCwgeSwgdywgaCk7XG4gICAgdGhpcy5zdHJva2UoKTtcbiAgfTtcbiAgLyoqXG4gICogQ2xlYXJzIHRoZSBzcGVjaWZpZWQgcGl4ZWxzIHdpdGhpbiBhIGdpdmVuIHJlY3RhbmdsZVxuICAqXG4gICogQG5hbWUgY2xlYXJSZWN0XG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHgge051bWJlcn0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgKiBAcGFyYW0gdyB7TnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB0byBjbGVhciwgaW4gcGl4ZWxzXG4gICogQHBhcmFtIGgge051bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNsZWFyLCBpbiBwaXhlbHNcbiAgKiBAZGVzY3JpcHRpb24gV2UgY2Fubm90IGNsZWFyIFBERiBjb21tYW5kcyB0aGF0IHdlcmUgYWxyZWFkeSB3cml0dGVuIHRvIFBERiwgc28gd2UgdXNlIHdoaXRlIGluc3RlYWQuIDxiciAvPlxuICAqIEFzIGEgc3BlY2lhbCBjYXNlLCByZWFkIGEgc3BlY2lhbCBmbGFnIChpZ25vcmVDbGVhclJlY3QpIGFuZCBkbyBub3RoaW5nIGlmIGl0IGlzIHNldC5cbiAgKiBUaGlzIHJlc3VsdHMgaW4gYWxsIGNhbGxzIHRvIGNsZWFyUmVjdCgpIHRvIGRvIG5vdGhpbmcsIGFuZCBrZWVwIHRoZSBjYW52YXMgdHJhbnNwYXJlbnQuXG4gICogVGhpcyBmbGFnIGlzIHN0b3JlZCBpbiB0aGUgc2F2ZS9yZXN0b3JlIGNvbnRleHQgYW5kIGlzIG1hbmFnZWQgdGhlIHNhbWUgd2F5IGFzIG90aGVyIGRyYXdpbmcgc3RhdGVzLlxuICAqXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLmNsZWFyUmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpIHx8IGlzTmFOKHcpIHx8IGlzTmFOKGgpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdqc1BERi5jb250ZXh0MmQuY2xlYXJSZWN0OiBJbnZhbGlkIGFyZ3VtZW50cycsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQuY2xlYXJSZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaWdub3JlQ2xlYXJSZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5maWxsU3R5bGUgPSAnI2ZmZmZmZic7XG4gICAgdGhpcy5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgfTtcbiAgLyoqXG4gICogU2F2ZXMgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgKiBcbiAgKiBAbmFtZSBzYXZlXG4gICogQGZ1bmN0aW9uXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoZG9TdGFja1B1c2gpIHtcbiAgICBkb1N0YWNrUHVzaCA9IHR5cGVvZiBkb1N0YWNrUHVzaCA9PT0gJ2Jvb2xlYW4nID8gZG9TdGFja1B1c2ggOiB0cnVlO1xuICAgIHZhciB0bXBQYWdlTnVtYmVyID0gdGhpcy5wZGYuaW50ZXJuYWwuZ2V0Q3VycmVudFBhZ2VJbmZvKCkucGFnZU51bWJlcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZGYuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpOyBpKyspIHtcbiAgICAgIHRoaXMucGRmLnNldFBhZ2UoaSArIDEpO1xuICAgICAgdGhpcy5wZGYuaW50ZXJuYWwub3V0KCdxJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wZGYuc2V0UGFnZSh0bXBQYWdlTnVtYmVyKTtcblxuICAgIGlmIChkb1N0YWNrUHVzaCkge1xuICAgICAgdGhpcy5jdHguZm9udFNpemUgPSB0aGlzLnBkZi5pbnRlcm5hbC5nZXRGb250U2l6ZSgpO1xuICAgICAgdmFyIGN0eCA9IG5ldyBDb250ZXh0TGF5ZXIodGhpcy5jdHgpO1xuICAgICAgdGhpcy5jdHhTdGFjay5wdXNoKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICogUmV0dXJucyBwcmV2aW91c2x5IHNhdmVkIHBhdGggc3RhdGUgYW5kIGF0dHJpYnV0ZXNcbiAgKiBcbiAgKiBAbmFtZSByZXN0b3JlXG4gICogQGZ1bmN0aW9uXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoZG9TdGFja1BvcCkge1xuICAgIGRvU3RhY2tQb3AgPSB0eXBlb2YgZG9TdGFja1BvcCA9PT0gJ2Jvb2xlYW4nID8gZG9TdGFja1BvcCA6IHRydWU7XG4gICAgdmFyIHRtcFBhZ2VOdW1iZXIgPSB0aGlzLnBkZi5pbnRlcm5hbC5nZXRDdXJyZW50UGFnZUluZm8oKS5wYWdlTnVtYmVyO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBkZi5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCk7IGkrKykge1xuICAgICAgdGhpcy5wZGYuc2V0UGFnZShpICsgMSk7XG4gICAgICB0aGlzLnBkZi5pbnRlcm5hbC5vdXQoJ1EnKTtcbiAgICB9XG5cbiAgICB0aGlzLnBkZi5zZXRQYWdlKHRtcFBhZ2VOdW1iZXIpO1xuXG4gICAgaWYgKGRvU3RhY2tQb3AgJiYgdGhpcy5jdHhTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5jdHhTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMuZmlsbFN0eWxlID0gdGhpcy5jdHguZmlsbFN0eWxlO1xuICAgICAgdGhpcy5zdHJva2VTdHlsZSA9IHRoaXMuY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgdGhpcy5mb250ID0gdGhpcy5jdHguZm9udDtcbiAgICAgIHRoaXMubGluZUNhcCA9IHRoaXMuY3R4LmxpbmVDYXA7XG4gICAgICB0aGlzLmxpbmVXaWR0aCA9IHRoaXMuY3R4LmxpbmVXaWR0aDtcbiAgICAgIHRoaXMubGluZUpvaW4gPSB0aGlzLmN0eC5saW5lSm9pbjtcbiAgICB9XG4gIH07XG4gIC8qKiBcbiAgKiBAbmFtZSB0b0RhdGFVUkxcbiAgKiBAZnVuY3Rpb25cbiAgKi9cblxuXG4gIENvbnRleHQyRC5wcm90b3R5cGUudG9EYXRhVVJMID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9EYXRhVXJsIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfTsgLy9oZWxwZXIgZnVuY3Rpb25zXG5cbiAgLyoqXG4gICogR2V0IHRoZSBkZWNpbWFsIHZhbHVlcyBvZiByLCBnLCBiIGFuZCBhXG4gICpcbiAgKiBAbmFtZSBnZXRSR0JBXG4gICogQGZ1bmN0aW9uXG4gICogQHByaXZhdGVcbiAgKiBAaWdub3JlXG4gICovXG5cblxuICB2YXIgZ2V0UkdCQSA9IGZ1bmN0aW9uIGdldFJHQkEoc3R5bGUpIHtcbiAgICB2YXIgcnhSZ2IgPSAvcmdiXFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqXFwpLztcbiAgICB2YXIgcnhSZ2JhID0gL3JnYmFcXHMqXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihbXFxkXFwuXSspXFxzKlxcKS87XG4gICAgdmFyIHJ4VHJhbnNwYXJlbnQgPSAvdHJhbnNwYXJlbnR8cmdiYVxccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqMCtcXHMqXFwpLztcbiAgICB2YXIgciwgZywgYiwgYTtcblxuICAgIGlmIChzdHlsZS5pc0NhbnZhc0dyYWRpZW50ID09PSB0cnVlKSB7XG4gICAgICBzdHlsZSA9IHN0eWxlLmdldENvbG9yKCk7XG4gICAgfVxuXG4gICAgaWYgKCFzdHlsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgZzogMCxcbiAgICAgICAgYjogMCxcbiAgICAgICAgYTogMCxcbiAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChyeFRyYW5zcGFyZW50LnRlc3Qoc3R5bGUpKSB7XG4gICAgICByID0gMDtcbiAgICAgIGcgPSAwO1xuICAgICAgYiA9IDA7XG4gICAgICBhID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hdGNoZXMgPSByeFJnYi5leGVjKHN0eWxlKTtcblxuICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgciA9IHBhcnNlSW50KG1hdGNoZXNbMV0pO1xuICAgICAgICBnID0gcGFyc2VJbnQobWF0Y2hlc1syXSk7XG4gICAgICAgIGIgPSBwYXJzZUludChtYXRjaGVzWzNdKTtcbiAgICAgICAgYSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVzID0gcnhSZ2JhLmV4ZWMoc3R5bGUpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgciA9IHBhcnNlSW50KG1hdGNoZXNbMV0pO1xuICAgICAgICAgIGcgPSBwYXJzZUludChtYXRjaGVzWzJdKTtcbiAgICAgICAgICBiID0gcGFyc2VJbnQobWF0Y2hlc1szXSk7XG4gICAgICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hlc1s0XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYSA9IDE7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiICYmIHN0eWxlLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgICAgICAgICB2YXIgcmdiQ29sb3IgPSBuZXcgUkdCQ29sb3Ioc3R5bGUpO1xuXG4gICAgICAgICAgICBpZiAocmdiQ29sb3Iub2spIHtcbiAgICAgICAgICAgICAgc3R5bGUgPSByZ2JDb2xvci50b0hleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0eWxlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgciA9IHN0eWxlLnN1YnN0cmluZygxLCAyKTtcbiAgICAgICAgICAgIHIgKz0gcjtcbiAgICAgICAgICAgIGcgPSBzdHlsZS5zdWJzdHJpbmcoMiwgMyk7XG4gICAgICAgICAgICBnICs9IGc7XG4gICAgICAgICAgICBiID0gc3R5bGUuc3Vic3RyaW5nKDMsIDQpO1xuICAgICAgICAgICAgYiArPSBiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByID0gc3R5bGUuc3Vic3RyaW5nKDEsIDMpO1xuICAgICAgICAgICAgZyA9IHN0eWxlLnN1YnN0cmluZygzLCA1KTtcbiAgICAgICAgICAgIGIgPSBzdHlsZS5zdWJzdHJpbmcoNSwgNyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgciA9IHBhcnNlSW50KHIsIDE2KTtcbiAgICAgICAgICBnID0gcGFyc2VJbnQoZywgMTYpO1xuICAgICAgICAgIGIgPSBwYXJzZUludChiLCAxNik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcjogcixcbiAgICAgIGc6IGcsXG4gICAgICBiOiBiLFxuICAgICAgYTogYSxcbiAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH07XG4gIH07XG4gIC8qKlxuICAqIEBuYW1lIGlzRmlsbFRyYW5zcGFyZW50XG4gICogQGZ1bmN0aW9uIFxuICAqIEBwcml2YXRlXG4gICogQGlnbm9yZVxuICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAqL1xuXG5cbiAgdmFyIGlzRmlsbFRyYW5zcGFyZW50ID0gZnVuY3Rpb24gaXNGaWxsVHJhbnNwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmlzRmlsbFRyYW5zcGFyZW50IHx8IHRoaXMuZ2xvYmFsQWxwaGEgPT0gMDtcbiAgfTtcbiAgLyoqXG4gICogQG5hbWUgaXNTdHJva2VUcmFuc3BhcmVudFxuICAqIEBmdW5jdGlvbiBcbiAgKiBAcHJpdmF0ZVxuICAqIEBpZ25vcmVcbiAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgKi9cblxuXG4gIHZhciBpc1N0cm9rZVRyYW5zcGFyZW50ID0gZnVuY3Rpb24gaXNTdHJva2VUcmFuc3BhcmVudCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmN0eC5pc1N0cm9rZVRyYW5zcGFyZW50IHx8IHRoaXMuZ2xvYmFsQWxwaGEgPT0gMCk7XG4gIH07XG4gIC8qKlxuICAqIERyYXdzIFwiZmlsbGVkXCIgdGV4dCBvbiB0aGUgY2FudmFzXG4gICogXG4gICogQG5hbWUgZmlsbFRleHRcbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0gdGV4dCB7U3RyaW5nfSBTcGVjaWZpZXMgdGhlIHRleHQgdGhhdCB3aWxsIGJlIHdyaXR0ZW4gb24gdGhlIGNhbnZhc1xuICAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSB4IGNvb3JkaW5hdGUgd2hlcmUgdG8gc3RhcnQgcGFpbnRpbmcgdGhlIHRleHQgKHJlbGF0aXZlIHRvIHRoZSBjYW52YXMpXG4gICogQHBhcmFtIHkge051bWJlcn0gVGhlIHkgY29vcmRpbmF0ZSB3aGVyZSB0byBzdGFydCBwYWludGluZyB0aGUgdGV4dCAocmVsYXRpdmUgdG8gdGhlIGNhbnZhcylcbiAgKiBAcGFyYW0gbWF4V2lkdGgge051bWJlcn0gT3B0aW9uYWwuIFRoZSBtYXhpbXVtIGFsbG93ZWQgd2lkdGggb2YgdGhlIHRleHQsIGluIHBpeGVsc1xuICAqIEBkZXNjcmlwdGlvbiBUaGUgZmlsbFRleHQoKSBtZXRob2QgZHJhd3MgZmlsbGVkIHRleHQgb24gdGhlIGNhbnZhcy4gVGhlIGRlZmF1bHQgY29sb3Igb2YgdGhlIHRleHQgaXMgYmxhY2suXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLmZpbGxUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIG1heFdpZHRoKSB7XG4gICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpIHx8IHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc29sZS5lcnJvcignanNQREYuY29udGV4dDJkLmZpbGxUZXh0OiBJbnZhbGlkIGFyZ3VtZW50cycsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQuZmlsbFRleHQnKTtcbiAgICB9XG5cbiAgICBtYXhXaWR0aCA9IGlzTmFOKG1heFdpZHRoKSA/IHVuZGVmaW5lZCA6IG1heFdpZHRoO1xuXG4gICAgaWYgKGlzRmlsbFRyYW5zcGFyZW50LmNhbGwodGhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB5ID0gZ2V0QmFzZWxpbmUuY2FsbCh0aGlzLCB5KTtcbiAgICB2YXIgZGVncyA9IHJhZDJkZWcodGhpcy5jdHgudHJhbnNmb3JtLnJvdGF0aW9uKTsgLy8gV2Ugb25seSB1c2UgWCBheGlzIGFzIHNjYWxlIGhpbnQgXG5cbiAgICB2YXIgc2NhbGUgPSB0aGlzLmN0eC50cmFuc2Zvcm0uc2NhbGVYO1xuICAgIHB1dFRleHQuY2FsbCh0aGlzLCB7XG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBhbmdsZTogZGVncyxcbiAgICAgIGFsaWduOiB0aGlzLnRleHRBbGlnbixcbiAgICAgIG1heFdpZHRoOiBtYXhXaWR0aFxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgKiBEcmF3cyB0ZXh0IG9uIHRoZSBjYW52YXMgKG5vIGZpbGwpXG4gICogXG4gICogQG5hbWUgc3Ryb2tlVGV4dFxuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB0ZXh0IHtTdHJpbmd9IFNwZWNpZmllcyB0aGUgdGV4dCB0aGF0IHdpbGwgYmUgd3JpdHRlbiBvbiB0aGUgY2FudmFzXG4gICogQHBhcmFtIHgge051bWJlcn0gVGhlIHggY29vcmRpbmF0ZSB3aGVyZSB0byBzdGFydCBwYWludGluZyB0aGUgdGV4dCAocmVsYXRpdmUgdG8gdGhlIGNhbnZhcylcbiAgKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeSBjb29yZGluYXRlIHdoZXJlIHRvIHN0YXJ0IHBhaW50aW5nIHRoZSB0ZXh0IChyZWxhdGl2ZSB0byB0aGUgY2FudmFzKVxuICAqIEBwYXJhbSBtYXhXaWR0aCB7TnVtYmVyfSBPcHRpb25hbC4gVGhlIG1heGltdW0gYWxsb3dlZCB3aWR0aCBvZiB0aGUgdGV4dCwgaW4gcGl4ZWxzXG4gICogQGRlc2NyaXB0aW9uIFRoZSBzdHJva2VUZXh0KCkgbWV0aG9kIGRyYXdzIHRleHQgKHdpdGggbm8gZmlsbCkgb24gdGhlIGNhbnZhcy4gVGhlIGRlZmF1bHQgY29sb3Igb2YgdGhlIHRleHQgaXMgYmxhY2suXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLnN0cm9rZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgeCwgeSwgbWF4V2lkdGgpIHtcbiAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkgfHwgdHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdqc1BERi5jb250ZXh0MmQuc3Ryb2tlVGV4dDogSW52YWxpZCBhcmd1bWVudHMnLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLnN0cm9rZVRleHQnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJva2VUcmFuc3BhcmVudC5jYWxsKHRoaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWF4V2lkdGggPSBpc05hTihtYXhXaWR0aCkgPyB1bmRlZmluZWQgOiBtYXhXaWR0aDtcbiAgICB5ID0gZ2V0QmFzZWxpbmUuY2FsbCh0aGlzLCB5KTtcbiAgICB2YXIgZGVncyA9IHJhZDJkZWcodGhpcy5jdHgudHJhbnNmb3JtLnJvdGF0aW9uKTtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmN0eC50cmFuc2Zvcm0uc2NhbGVYO1xuICAgIHB1dFRleHQuY2FsbCh0aGlzLCB7XG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICByZW5kZXJpbmdNb2RlOiAnc3Ryb2tlJyxcbiAgICAgIGFuZ2xlOiBkZWdzLFxuICAgICAgYWxpZ246IHRoaXMudGV4dEFsaWduLFxuICAgICAgbWF4V2lkdGg6IG1heFdpZHRoXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHdpZHRoIG9mIHRoZSBzcGVjaWZpZWQgdGV4dFxuICAqXG4gICogQG5hbWUgbWVhc3VyZVRleHRcbiAgKiBAZnVuY3Rpb24gXG4gICogQHBhcmFtIHRleHQge1N0cmluZ30gVGhlIHRleHQgdG8gYmUgbWVhc3VyZWRcbiAgKiBAZGVzY3JpcHRpb24gVGhlIG1lYXN1cmVUZXh0KCkgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHdpZHRoIG9mIHRoZSBzcGVjaWZpZWQgdGV4dCwgaW4gcGl4ZWxzLlxuICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdqc1BERi5jb250ZXh0MmQubWVhc3VyZVRleHQ6IEludmFsaWQgYXJndW1lbnRzJywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5tZWFzdXJlVGV4dCcpO1xuICAgIH1cblxuICAgIHZhciBwZGYgPSB0aGlzLnBkZjtcbiAgICB2YXIgayA9IHRoaXMucGRmLmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgIHZhciBmb250U2l6ZSA9IHBkZi5pbnRlcm5hbC5nZXRGb250U2l6ZSgpO1xuICAgIHZhciB0eHRXaWR0aCA9IHBkZi5nZXRTdHJpbmdVbml0V2lkdGgodGV4dCkgKiBmb250U2l6ZSAvIHBkZi5pbnRlcm5hbC5zY2FsZUZhY3RvcjtcbiAgICB0eHRXaWR0aCAqPSBNYXRoLnJvdW5kKGsgKiA5NiAvIDcyICogMTAwMDApIC8gMTAwMDA7XG5cbiAgICB2YXIgVGV4dE1ldHJpY3MgPSBmdW5jdGlvbiBUZXh0TWV0cmljcyhvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIF93aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMDtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd3aWR0aCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF93aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBUZXh0TWV0cmljcyh7XG4gICAgICB3aWR0aDogdHh0V2lkdGhcbiAgICB9KTtcbiAgfTsgLy9UcmFuc2Zvcm1hdGlvbnNcblxuICAvKipcbiAgKiBTY2FsZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBiaWdnZXIgb3Igc21hbGxlclxuICAqIFxuICAqIEBuYW1lIHNjYWxlIFxuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSBzY2FsZXdpZHRoIHtOdW1iZXJ9IFNjYWxlcyB0aGUgd2lkdGggb2YgdGhlIGN1cnJlbnQgZHJhd2luZyAoMT0xMDAlLCAwLjU9NTAlLCAyPTIwMCUsIGV0Yy4pXG4gICogQHBhcmFtIHNjYWxlaGVpZ2h0IHtOdW1iZXJ9IFNjYWxlcyB0aGUgaGVpZ2h0IG9mIHRoZSBjdXJyZW50IGRyYXdpbmcgKDE9MTAwJSwgMC41PTUwJSwgMj0yMDAlLCBldGMuKVxuICAqIEBkZXNjcmlwdGlvbiBUaGUgc2NhbGUoKSBtZXRob2Qgc2NhbGVzIHRoZSBjdXJyZW50IGRyYXdpbmcsIGJpZ2dlciBvciBzbWFsbGVyLlxuICAqL1xuXG5cbiAgQ29udGV4dDJELnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChzY2FsZXdpZHRoLCBzY2FsZWhlaWdodCkge1xuICAgIGlmIChpc05hTihzY2FsZXdpZHRoKSB8fCBpc05hTihzY2FsZWhlaWdodCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGLmNvbnRleHQyZC5zY2FsZTogSW52YWxpZCBhcmd1bWVudHMnLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLnNjYWxlJyk7XG4gICAgfVxuXG4gICAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoc2NhbGV3aWR0aCwgMC4wLCAwLjAsIHNjYWxlaGVpZ2h0LCAwLjAsIDAuMCk7XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtID0gdGhpcy5jdHgudHJhbnNmb3JtLm11bHRpcGx5KG1hdHJpeCk7XG4gIH07XG4gIC8qKlxuICAqIFJvdGF0ZXMgdGhlIGN1cnJlbnQgZHJhd2luZ1xuICAqIFxuICAqIEBuYW1lIHJvdGF0ZVxuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSBhbmdsZSB7TnVtYmVyfSBUaGUgcm90YXRpb24gYW5nbGUsIGluIHJhZGlhbnMuXG4gICogQGRlc2NyaXB0aW9uIFRvIGNhbGN1bGF0ZSBmcm9tIGRlZ3JlZXMgdG8gcmFkaWFuczogZGVncmVlcypNYXRoLlBJLzE4MC4gPGJyIC8+XG4gICogRXhhbXBsZTogdG8gcm90YXRlIDUgZGVncmVlcywgc3BlY2lmeSB0aGUgZm9sbG93aW5nOiA1Kk1hdGguUEkvMTgwXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgIGlmIChpc05hTihhbmdsZSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGLmNvbnRleHQyZC5yb3RhdGU6IEludmFsaWQgYXJndW1lbnRzJywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5yb3RhdGUnKTtcbiAgICB9XG5cbiAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeChNYXRoLmNvcyhhbmdsZSksIE1hdGguc2luKGFuZ2xlKSwgLU1hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpLCAwLjAsIDAuMCk7XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtID0gdGhpcy5jdHgudHJhbnNmb3JtLm11bHRpcGx5KG1hdHJpeCk7XG4gIH07XG4gIC8qKlxuICAqIFJlbWFwcyB0aGUgKDAsMCkgcG9zaXRpb24gb24gdGhlIGNhbnZhc1xuICAqIFxuICAqIEBuYW1lIHRyYW5zbGF0ZVxuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSB2YWx1ZSB0byBhZGQgdG8gaG9yaXpvbnRhbCAoeCkgY29vcmRpbmF0ZXNcbiAgKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgdmFsdWUgdG8gYWRkIHRvIHZlcnRpY2FsICh5KSBjb29yZGluYXRlc1xuICAqIEBkZXNjcmlwdGlvbiBUaGUgdHJhbnNsYXRlKCkgbWV0aG9kIHJlbWFwcyB0aGUgKDAsMCkgcG9zaXRpb24gb24gdGhlIGNhbnZhcy5cbiAgKi9cblxuXG4gIENvbnRleHQyRC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGLmNvbnRleHQyZC50cmFuc2xhdGU6IEludmFsaWQgYXJndW1lbnRzJywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC50cmFuc2xhdGUnKTtcbiAgICB9XG5cbiAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgxLjAsIDAuMCwgMC4wLCAxLjAsIHgsIHkpO1xuICAgIHRoaXMuY3R4LnRyYW5zZm9ybSA9IHRoaXMuY3R4LnRyYW5zZm9ybS5tdWx0aXBseShtYXRyaXgpO1xuICB9O1xuICAvKipcbiAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZm9yIHRoZSBkcmF3aW5nXG4gICogXG4gICogQG5hbWUgdHJhbnNmb3JtXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIGEge051bWJlcn0gSG9yaXpvbnRhbCBzY2FsaW5nXG4gICogQHBhcmFtIGIge051bWJlcn0gSG9yaXpvbnRhbCBza2V3aW5nXG4gICogQHBhcmFtIGMge051bWJlcn0gVmVydGljYWwgc2tld2luZ1xuICAqIEBwYXJhbSBkIHtOdW1iZXJ9IFZlcnRpY2FsIHNjYWxpbmdcbiAgKiBAcGFyYW0gZSB7TnVtYmVyfSBIb3Jpem9udGFsIG1vdmluZ1xuICAqIEBwYXJhbSBmIHtOdW1iZXJ9IFZlcnRpY2FsIG1vdmluZ1xuICAqIEBkZXNjcmlwdGlvbiBFYWNoIG9iamVjdCBvbiB0aGUgY2FudmFzIGhhcyBhIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4LjxiciAvPjxiciAvPlRoZSB0cmFuc2Zvcm0oKSBtZXRob2QgcmVwbGFjZXMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJdCBtdWx0aXBsaWVzIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB3aXRoIHRoZSBtYXRyaXggZGVzY3JpYmVkIGJ5OjxiciAvPjxiciAvPjxiciAvPjxiciAvPmEgICAgYyAgICBlPGJyIC8+PGJyIC8+YiAgICBkICAgIGY8YnIgLz48YnIgLz4wICAgIDAgICAgMTxiciAvPjxiciAvPkluIG90aGVyIHdvcmRzLCB0aGUgdHJhbnNmb3JtKCkgbWV0aG9kIGxldHMgeW91IHNjYWxlLCByb3RhdGUsIG1vdmUsIGFuZCBza2V3IHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICovXG5cblxuICBDb250ZXh0MkQucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaWYgKGlzTmFOKGEpIHx8IGlzTmFOKGIpIHx8IGlzTmFOKGMpIHx8IGlzTmFOKGQpIHx8IGlzTmFOKGUpIHx8IGlzTmFOKGYpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdqc1BERi5jb250ZXh0MmQudHJhbnNmb3JtOiBJbnZhbGlkIGFyZ3VtZW50cycsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQudHJhbnNmb3JtJyk7XG4gICAgfVxuXG4gICAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtID0gdGhpcy5jdHgudHJhbnNmb3JtLm11bHRpcGx5KG1hdHJpeCk7XG4gIH07XG4gIC8qKlxuICAqIFJlc2V0cyB0aGUgY3VycmVudCB0cmFuc2Zvcm0gdG8gdGhlIGlkZW50aXR5IG1hdHJpeC4gVGhlbiBydW5zIHRyYW5zZm9ybSgpXG4gICogXG4gICogQG5hbWUgc2V0VHJhbnNmb3JtXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIGEge051bWJlcn0gSG9yaXpvbnRhbCBzY2FsaW5nXG4gICogQHBhcmFtIGIge051bWJlcn0gSG9yaXpvbnRhbCBza2V3aW5nXG4gICogQHBhcmFtIGMge051bWJlcn0gVmVydGljYWwgc2tld2luZ1xuICAqIEBwYXJhbSBkIHtOdW1iZXJ9IFZlcnRpY2FsIHNjYWxpbmdcbiAgKiBAcGFyYW0gZSB7TnVtYmVyfSBIb3Jpem9udGFsIG1vdmluZ1xuICAqIEBwYXJhbSBmIHtOdW1iZXJ9IFZlcnRpY2FsIG1vdmluZ1xuICAqIEBkZXNjcmlwdGlvbiBFYWNoIG9iamVjdCBvbiB0aGUgY2FudmFzIGhhcyBhIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4LiA8YnIgLz48YnIgLz5UaGUgc2V0VHJhbnNmb3JtKCkgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudCB0cmFuc2Zvcm0gdG8gdGhlIGlkZW50aXR5IG1hdHJpeCwgYW5kIHRoZW4gcnVucyB0cmFuc2Zvcm0oKSB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cy48YnIgLz48YnIgLz5JbiBvdGhlciB3b3JkcywgdGhlIHNldFRyYW5zZm9ybSgpIG1ldGhvZCBsZXRzIHlvdSBzY2FsZSwgcm90YXRlLCBtb3ZlLCBhbmQgc2tldyB0aGUgY3VycmVudCBjb250ZXh0LlxuICAqL1xuXG5cbiAgQ29udGV4dDJELnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGEgPSBpc05hTihhKSA/IDEgOiBhO1xuICAgIGIgPSBpc05hTihiKSA/IDAgOiBiO1xuICAgIGMgPSBpc05hTihjKSA/IDAgOiBjO1xuICAgIGQgPSBpc05hTihkKSA/IDEgOiBkO1xuICAgIGUgPSBpc05hTihlKSA/IDAgOiBlO1xuICAgIGYgPSBpc05hTihmKSA/IDAgOiBmO1xuICAgIHRoaXMuY3R4LnRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIC8qKlxuICAqIERyYXdzIGFuIGltYWdlLCBjYW52YXMsIG9yIHZpZGVvIG9udG8gdGhlIGNhbnZhc1xuICAqIFxuICAqIEBmdW5jdGlvbiBcbiAgKiBAcGFyYW0gaW1nIHt9IFNwZWNpZmllcyB0aGUgaW1hZ2UsIGNhbnZhcywgb3IgdmlkZW8gZWxlbWVudCB0byB1c2VcbiAgKiBAcGFyYW0gc3gge051bWJlcn0gT3B0aW9uYWwuIFRoZSB4IGNvb3JkaW5hdGUgd2hlcmUgdG8gc3RhcnQgY2xpcHBpbmdcbiAgKiBAcGFyYW0gc3kge051bWJlcn0gT3B0aW9uYWwuIFRoZSB5IGNvb3JkaW5hdGUgd2hlcmUgdG8gc3RhcnQgY2xpcHBpbmdcbiAgKiBAcGFyYW0gc3dpZHRoIHtOdW1iZXJ9IE9wdGlvbmFsLiBUaGUgd2lkdGggb2YgdGhlIGNsaXBwZWQgaW1hZ2VcbiAgKiBAcGFyYW0gc2hlaWdodCB7TnVtYmVyfSBPcHRpb25hbC4gVGhlIGhlaWdodCBvZiB0aGUgY2xpcHBlZCBpbWFnZVxuICAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSB4IGNvb3JkaW5hdGUgd2hlcmUgdG8gcGxhY2UgdGhlIGltYWdlIG9uIHRoZSBjYW52YXNcbiAgKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeSBjb29yZGluYXRlIHdoZXJlIHRvIHBsYWNlIHRoZSBpbWFnZSBvbiB0aGUgY2FudmFzXG4gICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IE9wdGlvbmFsLiBUaGUgd2lkdGggb2YgdGhlIGltYWdlIHRvIHVzZSAoc3RyZXRjaCBvciByZWR1Y2UgdGhlIGltYWdlKVxuICAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gT3B0aW9uYWwuIFRoZSBoZWlnaHQgb2YgdGhlIGltYWdlIHRvIHVzZSAoc3RyZXRjaCBvciByZWR1Y2UgdGhlIGltYWdlKVxuICAqL1xuXG5cbiAgQ29udGV4dDJELnByb3RvdHlwZS5kcmF3SW1hZ2UgPSBmdW5jdGlvbiAoaW1nLCBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBpbWFnZVByb3BlcnRpZXMgPSB0aGlzLnBkZi5nZXRJbWFnZVByb3BlcnRpZXMoaW1nKTtcbiAgICB2YXIgZmFjdG9yWCA9IDE7XG4gICAgdmFyIGZhY3RvclkgPSAxO1xuICAgIHZhciBjbGlwRmFjdG9yWCA9IDE7XG4gICAgdmFyIGNsaXBGYWN0b3JZID0gMTtcbiAgICB2YXIgc2NhbGVGYWN0b3JYID0gMTtcblxuICAgIGlmICh0eXBlb2Ygc3dpZHRoICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjbGlwRmFjdG9yWCA9IHdpZHRoIC8gc3dpZHRoO1xuICAgICAgY2xpcEZhY3RvclkgPSBoZWlnaHQgLyBzaGVpZ2h0O1xuICAgICAgZmFjdG9yWCA9IGltYWdlUHJvcGVydGllcy53aWR0aCAvIHN3aWR0aCAqIHdpZHRoIC8gc3dpZHRoO1xuICAgICAgZmFjdG9yWSA9IGltYWdlUHJvcGVydGllcy5oZWlnaHQgLyBzaGVpZ2h0ICogaGVpZ2h0IC8gc2hlaWdodDtcbiAgICB9IC8vaXMgc3ggYW5kIHN5IGFyZSBzZXQgYW5kIHggYW5kIHkgbm90LCBzZXQgeCBhbmQgeSB3aXRoIHZhbHVlcyBvZiBzeCBhbmQgc3lcblxuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgeCA9IHN4O1xuICAgICAgeSA9IHN5O1xuICAgICAgc3ggPSAwO1xuICAgICAgc3kgPSAwO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3dpZHRoICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2lkdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aWR0aCA9IHN3aWR0aDtcbiAgICAgIGhlaWdodCA9IHNoZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzd2lkdGggPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpZHRoID0gaW1hZ2VQcm9wZXJ0aWVzLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gaW1hZ2VQcm9wZXJ0aWVzLmhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgZGVjb21wb3NlZFRyYW5zZm9ybWF0aW9uTWF0cml4ID0gdGhpcy5jdHgudHJhbnNmb3JtLmRlY29tcG9zZSgpO1xuICAgIHZhciBhbmdsZSA9IHJhZDJkZWcoZGVjb21wb3NlZFRyYW5zZm9ybWF0aW9uTWF0cml4LnJvdGF0ZS5zaHgpO1xuICAgIHNjYWxlRmFjdG9yWCA9IGRlY29tcG9zZWRUcmFuc2Zvcm1hdGlvbk1hdHJpeC5zY2FsZS5zeDtcbiAgICBzY2FsZUZhY3RvclggPSBkZWNvbXBvc2VkVHJhbnNmb3JtYXRpb25NYXRyaXguc2NhbGUuc3k7XG4gICAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICBtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkoZGVjb21wb3NlZFRyYW5zZm9ybWF0aW9uTWF0cml4LnRyYW5zbGF0ZSk7XG4gICAgbWF0cml4ID0gbWF0cml4Lm11bHRpcGx5KGRlY29tcG9zZWRUcmFuc2Zvcm1hdGlvbk1hdHJpeC5za2V3KTtcbiAgICBtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkoZGVjb21wb3NlZFRyYW5zZm9ybWF0aW9uTWF0cml4LnNjYWxlKTtcbiAgICB2YXIgbVAgPSBtYXRyaXguYXBwbHlUb1BvaW50KG5ldyBQb2ludCh3aWR0aCwgaGVpZ2h0KSk7XG4gICAgdmFyIHhSZWN0ID0gbWF0cml4LmFwcGx5VG9SZWN0YW5nbGUobmV3IFJlY3RhbmdsZSh4IC0gc3ggKiBjbGlwRmFjdG9yWCwgeSAtIHN5ICogY2xpcEZhY3RvclksIHN3aWR0aCAqIGZhY3RvclgsIHNoZWlnaHQgKiBmYWN0b3JZKSk7XG4gICAgdmFyIHBhZ2VBcnJheSA9IGdldFBhZ2VzQnlQYXRoLmNhbGwodGhpcywgeFJlY3QpO1xuICAgIHZhciBwYWdlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHBhZ2VBcnJheS5sZW5ndGg7IGlpICs9IDEpIHtcbiAgICAgIGlmIChwYWdlcy5pbmRleE9mKHBhZ2VBcnJheVtpaV0pID09PSAtMSkge1xuICAgICAgICBwYWdlcy5wdXNoKHBhZ2VBcnJheVtpaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhZ2VzLnNvcnQoKTtcbiAgICB2YXIgY2xpcFBhdGg7XG5cbiAgICBpZiAodGhpcy5hdXRvUGFnaW5nKSB7XG4gICAgICB2YXIgbWluID0gcGFnZXNbMF07XG4gICAgICB2YXIgbWF4ID0gcGFnZXNbcGFnZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGZvciAodmFyIGkgPSBtaW47IGkgPCBtYXggKyAxOyBpKyspIHtcbiAgICAgICAgdGhpcy5wZGYuc2V0UGFnZShpKTtcblxuICAgICAgICBpZiAodGhpcy5jdHguY2xpcF9wYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHZhciB0bXBQYXRocyA9IHRoaXMucGF0aDtcbiAgICAgICAgICBjbGlwUGF0aCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jdHguY2xpcF9wYXRoKSk7XG4gICAgICAgICAgdGhpcy5wYXRoID0gcGF0aFBvc2l0aW9uUmVkbyhjbGlwUGF0aCwgdGhpcy5wb3NYLCAtMSAqIHRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLmhlaWdodCAqIChpIC0gMSkgKyB0aGlzLnBvc1kpO1xuICAgICAgICAgIGRyYXdQYXRocy5jYWxsKHRoaXMsICdmaWxsJywgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5wYXRoID0gdG1wUGF0aHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wUmVjdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoeFJlY3QpKTtcbiAgICAgICAgdG1wUmVjdCA9IHBhdGhQb3NpdGlvblJlZG8oW3RtcFJlY3RdLCB0aGlzLnBvc1gsIC0xICogdGhpcy5wZGYuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0ICogKGkgLSAxKSArIHRoaXMucG9zWSlbMF07XG4gICAgICAgIHRoaXMucGRmLmFkZEltYWdlKGltZywgJ2pwZycsIHRtcFJlY3QueCwgdG1wUmVjdC55LCB0bXBSZWN0LncsIHRtcFJlY3QuaCwgbnVsbCwgbnVsbCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBkZi5hZGRJbWFnZShpbWcsICdqcGcnLCB4UmVjdC54LCB4UmVjdC55LCB4UmVjdC53LCB4UmVjdC5oLCBudWxsLCBudWxsLCBhbmdsZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRQYWdlc0J5UGF0aCA9IGZ1bmN0aW9uIGdldFBhZ2VzQnlQYXRoKHBhdGgsIHBhZ2VXcmFwWCwgcGFnZVdyYXBZKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHBhZ2VXcmFwWCA9IHBhZ2VXcmFwWCB8fCB0aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS53aWR0aDtcbiAgICBwYWdlV3JhcFkgPSBwYWdlV3JhcFkgfHwgdGhpcy5wZGYuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0O1xuXG4gICAgc3dpdGNoIChwYXRoLnR5cGUpIHtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlICdtdCc6XG4gICAgICBjYXNlICdsdCc6XG4gICAgICAgIHJlc3VsdC5wdXNoKE1hdGguZmxvb3IoKHBhdGgueSArIHRoaXMucG9zWSkgLyBwYWdlV3JhcFkpICsgMSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhcmMnOlxuICAgICAgICByZXN1bHQucHVzaChNYXRoLmZsb29yKChwYXRoLnkgKyB0aGlzLnBvc1kgLSBwYXRoLnJhZGl1cykgLyBwYWdlV3JhcFkpICsgMSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKE1hdGguZmxvb3IoKHBhdGgueSArIHRoaXMucG9zWSArIHBhdGgucmFkaXVzKSAvIHBhZ2VXcmFwWSkgKyAxKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3FjdCc6XG4gICAgICAgIHZhciByZWN0T2ZRdWFkcmF0aWNDdXJ2ZSA9IGdldFF1YWRyYXRpY0N1cnZlQm91bmRhcnkodGhpcy5jdHgubGFzdFBvaW50LngsIHRoaXMuY3R4Lmxhc3RQb2ludC55LCBwYXRoLngxLCBwYXRoLnkxLCBwYXRoLngsIHBhdGgueSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKE1hdGguZmxvb3IocmVjdE9mUXVhZHJhdGljQ3VydmUueSAvIHBhZ2VXcmFwWSkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnB1c2goTWF0aC5mbG9vcigocmVjdE9mUXVhZHJhdGljQ3VydmUueSArIHJlY3RPZlF1YWRyYXRpY0N1cnZlLmgpIC8gcGFnZVdyYXBZKSArIDEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmN0JzpcbiAgICAgICAgdmFyIHJlY3RPZkJlemllckN1cnZlID0gZ2V0QmV6aWVyQ3VydmVCb3VuZGFyeSh0aGlzLmN0eC5sYXN0UG9pbnQueCwgdGhpcy5jdHgubGFzdFBvaW50LnksIHBhdGgueDEsIHBhdGgueTEsIHBhdGgueDIsIHBhdGgueTIsIHBhdGgueCwgcGF0aC55KTtcbiAgICAgICAgcmVzdWx0LnB1c2goTWF0aC5mbG9vcihyZWN0T2ZCZXppZXJDdXJ2ZS55IC8gcGFnZVdyYXBZKSArIDEpO1xuICAgICAgICByZXN1bHQucHVzaChNYXRoLmZsb29yKChyZWN0T2ZCZXppZXJDdXJ2ZS55ICsgcmVjdE9mQmV6aWVyQ3VydmUuaCkgLyBwYWdlV3JhcFkpICsgMSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyZWN0JzpcbiAgICAgICAgcmVzdWx0LnB1c2goTWF0aC5mbG9vcigocGF0aC55ICsgdGhpcy5wb3NZKSAvIHBhZ2VXcmFwWSkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnB1c2goTWF0aC5mbG9vcigocGF0aC55ICsgcGF0aC5oICsgdGhpcy5wb3NZKSAvIHBhZ2VXcmFwWSkgKyAxKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgd2hpbGUgKHRoaXMucGRmLmludGVybmFsLmdldE51bWJlck9mUGFnZXMoKSA8IHJlc3VsdFtpXSkge1xuICAgICAgICBhZGRQYWdlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkUGFnZSA9IGZ1bmN0aW9uIGFkZFBhZ2UoKSB7XG4gICAgdmFyIGZpbGxTdHlsZSA9IHRoaXMuZmlsbFN0eWxlO1xuICAgIHZhciBzdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlU3R5bGU7XG4gICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgdmFyIGxpbmVDYXAgPSB0aGlzLmxpbmVDYXA7XG4gICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuICAgIHZhciBsaW5lSm9pbiA9IHRoaXMubGluZUpvaW47XG4gICAgdGhpcy5wZGYuYWRkUGFnZSgpO1xuICAgIHRoaXMuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgdGhpcy5saW5lSm9pbiA9IGxpbmVKb2luO1xuICB9O1xuXG4gIHZhciBwYXRoUG9zaXRpb25SZWRvID0gZnVuY3Rpb24gcGF0aFBvc2l0aW9uUmVkbyhwYXRocywgeCwgeSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN3aXRjaCAocGF0aHNbaV0udHlwZSkge1xuICAgICAgICBjYXNlICdiY3QnOlxuICAgICAgICAgIHBhdGhzW2ldLngyICs9IHg7XG4gICAgICAgICAgcGF0aHNbaV0ueTIgKz0geTtcblxuICAgICAgICBjYXNlICdxY3QnOlxuICAgICAgICAgIHBhdGhzW2ldLngxICs9IHg7XG4gICAgICAgICAgcGF0aHNbaV0ueTEgKz0geTtcblxuICAgICAgICBjYXNlICdtdCc6XG4gICAgICAgIGNhc2UgJ2x0JzpcbiAgICAgICAgY2FzZSAnYXJjJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwYXRoc1tpXS54ICs9IHg7XG4gICAgICAgICAgcGF0aHNbaV0ueSArPSB5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfTtcblxuICB2YXIgcGF0aFByZVByb2Nlc3MgPSBmdW5jdGlvbiBwYXRoUHJlUHJvY2VzcyhydWxlLCBpc0NsaXApIHtcbiAgICB2YXIgZmlsbFN0eWxlID0gdGhpcy5maWxsU3R5bGU7XG4gICAgdmFyIHN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2VTdHlsZTtcbiAgICB2YXIgZm9udCA9IHRoaXMuZm9udDtcbiAgICB2YXIgbGluZUNhcCA9IHRoaXMubGluZUNhcDtcbiAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XG4gICAgdmFyIGxpbmVKb2luID0gdGhpcy5saW5lSm9pbjtcbiAgICB2YXIgb3JpZ1BhdGggPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGF0aCkpO1xuICAgIHZhciB4UGF0aCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXRoKSk7XG4gICAgdmFyIGNsaXBQYXRoO1xuICAgIHZhciB0bXBQYXRoO1xuICAgIHZhciBwYWdlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiB4UGF0aFtpXS54ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBwYWdlID0gZ2V0UGFnZXNCeVBhdGguY2FsbCh0aGlzLCB4UGF0aFtpXSk7XG5cbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHBhZ2UubGVuZ3RoOyBpaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHBhZ2VzLmluZGV4T2YocGFnZVtpaV0pID09PSAtMSkge1xuICAgICAgICAgICAgcGFnZXMucHVzaChwYWdlW2lpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgd2hpbGUgKHRoaXMucGRmLmludGVybmFsLmdldE51bWJlck9mUGFnZXMoKSA8IHBhZ2VzW2ldKSB7XG4gICAgICAgIGFkZFBhZ2UuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYWdlcy5zb3J0KCk7XG5cbiAgICBpZiAodGhpcy5hdXRvUGFnaW5nKSB7XG4gICAgICB2YXIgbWluID0gcGFnZXNbMF07XG4gICAgICB2YXIgbWF4ID0gcGFnZXNbcGFnZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGZvciAodmFyIGkgPSBtaW47IGkgPCBtYXggKyAxOyBpKyspIHtcbiAgICAgICAgdGhpcy5wZGYuc2V0UGFnZShpKTtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgdGhpcy5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIHRoaXMubGluZUpvaW4gPSBsaW5lSm9pbjtcblxuICAgICAgICBpZiAodGhpcy5jdHguY2xpcF9wYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHZhciB0bXBQYXRocyA9IHRoaXMucGF0aDtcbiAgICAgICAgICBjbGlwUGF0aCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jdHguY2xpcF9wYXRoKSk7XG4gICAgICAgICAgdGhpcy5wYXRoID0gcGF0aFBvc2l0aW9uUmVkbyhjbGlwUGF0aCwgdGhpcy5wb3NYLCAtMSAqIHRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLmhlaWdodCAqIChpIC0gMSkgKyB0aGlzLnBvc1kpO1xuICAgICAgICAgIGRyYXdQYXRocy5jYWxsKHRoaXMsIHJ1bGUsIHRydWUpO1xuICAgICAgICAgIHRoaXMucGF0aCA9IHRtcFBhdGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wUGF0aCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3JpZ1BhdGgpKTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aFBvc2l0aW9uUmVkbyh0bXBQYXRoLCB0aGlzLnBvc1gsIC0xICogdGhpcy5wZGYuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0ICogKGkgLSAxKSArIHRoaXMucG9zWSk7XG5cbiAgICAgICAgaWYgKGlzQ2xpcCA9PT0gZmFsc2UgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIGRyYXdQYXRocy5jYWxsKHRoaXMsIHJ1bGUsIGlzQ2xpcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1BhdGhzLmNhbGwodGhpcywgcnVsZSwgaXNDbGlwKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhdGggPSBvcmlnUGF0aDtcbiAgfTtcbiAgLyoqXG4gICogUHJvY2Vzc2VzIHRoZSBwYXRoc1xuICAqXG4gICogQGZ1bmN0aW9uIFxuICAqIEBwYXJhbSBydWxlIHtTdHJpbmd9XG4gICogQHBhcmFtIGlzQ2xpcCB7Qm9vbGVhbn1cbiAgKiBAcHJpdmF0ZVxuICAqIEBpZ25vcmVcbiAgKi9cblxuXG4gIHZhciBkcmF3UGF0aHMgPSBmdW5jdGlvbiBkcmF3UGF0aHMocnVsZSwgaXNDbGlwKSB7XG4gICAgaWYgKHJ1bGUgPT09ICdzdHJva2UnICYmICFpc0NsaXAgJiYgaXNTdHJva2VUcmFuc3BhcmVudC5jYWxsKHRoaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJ1bGUgIT09ICdzdHJva2UnICYmICFpc0NsaXAgJiYgaXNGaWxsVHJhbnNwYXJlbnQuY2FsbCh0aGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtb3ZlcyA9IFtdO1xuICAgIHZhciBhbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xuXG4gICAgaWYgKHRoaXMuY3R4LmZpbGxPcGFjaXR5IDwgMSkge1xuICAgICAgYWxwaGEgPSB0aGlzLmN0eC5maWxsT3BhY2l0eTtcbiAgICB9XG5cbiAgICB2YXIgeFBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSB4UGF0aFtpXTtcblxuICAgICAgc3dpdGNoIChwdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2JlZ2luJzpcbiAgICAgICAgICBtb3Zlcy5wdXNoKHtcbiAgICAgICAgICAgIGJlZ2luOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgY2xvc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtdCc6XG4gICAgICAgICAgbW92ZXMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogcHQsXG4gICAgICAgICAgICBkZWx0YXM6IFtdLFxuICAgICAgICAgICAgYWJzOiBbXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2x0JzpcbiAgICAgICAgICB2YXIgaWlpID0gbW92ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKCFpc05hTih4UGF0aFtpIC0gMV0ueCkpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IFtwdC54IC0geFBhdGhbaSAtIDFdLngsIHB0LnkgLSB4UGF0aFtpIC0gMV0ueV07XG5cbiAgICAgICAgICAgIGlmIChpaWkgPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAoaWlpOyBpaWkgPj0gMDsgaWlpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZXNbaWlpIC0gMV0uY2xvc2UgIT09IHRydWUgJiYgbW92ZXNbaWlpIC0gMV0uYmVnaW4gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIG1vdmVzW2lpaSAtIDFdLmRlbHRhcy5wdXNoKGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgIG1vdmVzW2lpaSAtIDFdLmFicy5wdXNoKHB0KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JjdCc6XG4gICAgICAgICAgdmFyIGRlbHRhID0gW3B0LngxIC0geFBhdGhbaSAtIDFdLngsIHB0LnkxIC0geFBhdGhbaSAtIDFdLnksIHB0LngyIC0geFBhdGhbaSAtIDFdLngsIHB0LnkyIC0geFBhdGhbaSAtIDFdLnksIHB0LnggLSB4UGF0aFtpIC0gMV0ueCwgcHQueSAtIHhQYXRoW2kgLSAxXS55XTtcbiAgICAgICAgICBtb3Zlc1ttb3Zlcy5sZW5ndGggLSAxXS5kZWx0YXMucHVzaChkZWx0YSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncWN0JzpcbiAgICAgICAgICB2YXIgeDEgPSB4UGF0aFtpIC0gMV0ueCArIDIuMCAvIDMuMCAqIChwdC54MSAtIHhQYXRoW2kgLSAxXS54KTtcbiAgICAgICAgICB2YXIgeTEgPSB4UGF0aFtpIC0gMV0ueSArIDIuMCAvIDMuMCAqIChwdC55MSAtIHhQYXRoW2kgLSAxXS55KTtcbiAgICAgICAgICB2YXIgeDIgPSBwdC54ICsgMi4wIC8gMy4wICogKHB0LngxIC0gcHQueCk7XG4gICAgICAgICAgdmFyIHkyID0gcHQueSArIDIuMCAvIDMuMCAqIChwdC55MSAtIHB0LnkpO1xuICAgICAgICAgIHZhciB4MyA9IHB0Lng7XG4gICAgICAgICAgdmFyIHkzID0gcHQueTtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBbeDEgLSB4UGF0aFtpIC0gMV0ueCwgeTEgLSB4UGF0aFtpIC0gMV0ueSwgeDIgLSB4UGF0aFtpIC0gMV0ueCwgeTIgLSB4UGF0aFtpIC0gMV0ueSwgeDMgLSB4UGF0aFtpIC0gMV0ueCwgeTMgLSB4UGF0aFtpIC0gMV0ueV07XG4gICAgICAgICAgbW92ZXNbbW92ZXMubGVuZ3RoIC0gMV0uZGVsdGFzLnB1c2goZGVsdGEpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FyYyc6XG4gICAgICAgICAgbW92ZXMucHVzaCh7XG4gICAgICAgICAgICBkZWx0YXM6IFtdLFxuICAgICAgICAgICAgYWJzOiBbXSxcbiAgICAgICAgICAgIGFyYzogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW92ZXNbbW92ZXMubGVuZ3RoIC0gMV0uYWJzKSkge1xuICAgICAgICAgICAgbW92ZXNbbW92ZXMubGVuZ3RoIC0gMV0uYWJzLnB1c2gocHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdHlsZTtcblxuICAgIGlmICghaXNDbGlwKSB7XG4gICAgICBpZiAocnVsZSA9PT0gJ3N0cm9rZScpIHtcbiAgICAgICAgc3R5bGUgPSAnc3Ryb2tlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlID0gJ2ZpbGwnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG1vdmVzW2ldLmFyYykge1xuICAgICAgICB2YXIgYXJjcyA9IG1vdmVzW2ldLmFicztcblxuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYXJjcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICB2YXIgYXJjID0gYXJjc1tpaV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGFyYy5zdGFydEFuZ2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcmFkMmRlZyhhcmMuc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB2YXIgZW5kID0gcmFkMmRlZyhhcmMuZW5kQW5nbGUpO1xuICAgICAgICAgICAgdmFyIHggPSBhcmMueDtcbiAgICAgICAgICAgIHZhciB5ID0gYXJjLnk7XG4gICAgICAgICAgICBkcmF3QXJjLmNhbGwodGhpcywgeCwgeSwgYXJjLnJhZGl1cywgc3RhcnQsIGVuZCwgYXJjLmNvdW50ZXJjbG9ja3dpc2UsIHN0eWxlLCBpc0NsaXApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmF3TGluZS5jYWxsKHRoaXMsIGFyYy54LCBhcmMueSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbW92ZXNbaV0uYXJjKSB7XG4gICAgICAgIGlmIChtb3Zlc1tpXS5jbG9zZSAhPT0gdHJ1ZSAmJiBtb3Zlc1tpXS5iZWdpbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciB4ID0gbW92ZXNbaV0uc3RhcnQueDtcbiAgICAgICAgICB2YXIgeSA9IG1vdmVzW2ldLnN0YXJ0Lnk7XG4gICAgICAgICAgZHJhd0xpbmVzLmNhbGwodGhpcywgbW92ZXNbaV0uZGVsdGFzLCB4LCB5LCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgcHV0U3R5bGUuY2FsbCh0aGlzLCBzdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ2xpcCkge1xuICAgICAgZG9DbGlwLmNhbGwodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRCYXNlbGluZSA9IGZ1bmN0aW9uIGdldEJhc2VsaW5lKHkpIHtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5wZGYuaW50ZXJuYWwuZ2V0Rm9udFNpemUoKSAvIHRoaXMucGRmLmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgIHZhciBkZXNjZW50ID0gaGVpZ2h0ICogKHRoaXMucGRmLmludGVybmFsLmdldExpbmVIZWlnaHRGYWN0b3IoKSAtIDEpO1xuXG4gICAgc3dpdGNoICh0aGlzLmN0eC50ZXh0QmFzZWxpbmUpIHtcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHJldHVybiB5IC0gZGVzY2VudDtcblxuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgcmV0dXJuIHkgKyBoZWlnaHQgLSBkZXNjZW50O1xuXG4gICAgICBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgcmV0dXJuIHkgKyBoZWlnaHQgLSAyICogZGVzY2VudDtcblxuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgcmV0dXJuIHkgKyBoZWlnaHQgLyAyIC0gZGVzY2VudDtcblxuICAgICAgY2FzZSAnaWRlb2dyYXBoaWMnOlxuICAgICAgICAvLyBUT0RPIG5vdCBpbXBsZW1lbnRlZFxuICAgICAgICByZXR1cm4geTtcblxuICAgICAgY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geTtcbiAgICB9XG4gIH07XG5cbiAgQ29udGV4dDJELnByb3RvdHlwZS5jcmVhdGVMaW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUxpbmVhckdyYWRpZW50KCkge1xuICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGZ1bmN0aW9uIGNhbnZhc0dyYWRpZW50KCkge307XG5cbiAgICBjYW52YXNHcmFkaWVudC5jb2xvclN0b3BzID0gW107XG5cbiAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AgPSBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goW29mZnNldCwgY29sb3JdKTtcbiAgICB9O1xuXG4gICAgY2FudmFzR3JhZGllbnQuZ2V0Q29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5jb2xvclN0b3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyMwMDAwMDAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb2xvclN0b3BzWzBdWzFdO1xuICAgIH07XG5cbiAgICBjYW52YXNHcmFkaWVudC5pc0NhbnZhc0dyYWRpZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gIH07XG5cbiAgQ29udGV4dDJELnByb3RvdHlwZS5jcmVhdGVQYXR0ZXJuID0gZnVuY3Rpb24gY3JlYXRlUGF0dGVybigpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJHcmFkaWVudCgpO1xuICB9O1xuXG4gIENvbnRleHQyRC5wcm90b3R5cGUuY3JlYXRlUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiBjcmVhdGVSYWRpYWxHcmFkaWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJHcmFkaWVudCgpO1xuICB9O1xuICAvKipcbiAgKlxuICAqIEBwYXJhbSB4IEVkZ2UgcG9pbnQgWFxuICAqIEBwYXJhbSB5IEVkZ2UgcG9pbnQgWVxuICAqIEBwYXJhbSByIFJhZGl1c1xuICAqIEBwYXJhbSBhMSBzdGFydCBhbmdsZVxuICAqIEBwYXJhbSBhMiBlbmQgYW5nbGVcbiAgKiBAcGFyYW0gY291bnRlcmNsb2Nrd2lzZVxuICAqIEBwYXJhbSBzdHlsZVxuICAqIEBwYXJhbSBpc0NsaXBcbiAgKi9cblxuXG4gIHZhciBkcmF3QXJjID0gZnVuY3Rpb24gZHJhd0FyYyh4LCB5LCByLCBhMSwgYTIsIGNvdW50ZXJjbG9ja3dpc2UsIHN0eWxlLCBpc0NsaXApIHtcbiAgICB2YXIgayA9IHRoaXMucGRmLmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgIHZhciBhMXIgPSBkZWcycmFkKGExKTtcbiAgICB2YXIgYTJyID0gZGVnMnJhZChhMik7XG4gICAgdmFyIGN1cnZlcyA9IGNyZWF0ZUFyYy5jYWxsKHRoaXMsIHIsIGExciwgYTJyLCBjb3VudGVyY2xvY2t3aXNlKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGRvTW92ZS5jYWxsKHRoaXMsIGN1cnZlLngxICsgeCwgY3VydmUueTEgKyB5KTtcbiAgICAgIH1cbiAgICAgIGRyYXdDdXJ2ZS5jYWxsKHRoaXMsIHgsIHksIGN1cnZlLngyLCBjdXJ2ZS55MiwgY3VydmUueDMsIGN1cnZlLnkzLCBjdXJ2ZS54NCwgY3VydmUueTQpO1xuICAgIH1cblxuICAgIGlmICghaXNDbGlwKSB7XG4gICAgICBwdXRTdHlsZS5jYWxsKHRoaXMsIHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9DbGlwLmNhbGwodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwdXRTdHlsZSA9IGZ1bmN0aW9uIHB1dFN0eWxlKHN0eWxlKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnc3Ryb2tlJzpcbiAgICAgICAgdGhpcy5wZGYuaW50ZXJuYWwub3V0KCdTJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdmaWxsJzpcbiAgICAgICAgdGhpcy5wZGYuaW50ZXJuYWwub3V0KCdmJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZG9DbGlwID0gZnVuY3Rpb24gZG9DbGlwKCkge1xuICAgIHRoaXMucGRmLmNsaXAoKTtcbiAgfTtcblxuICB2YXIgZG9Nb3ZlID0gZnVuY3Rpb24gZG9Nb3ZlKHgsIHkpIHtcbiAgICB0aGlzLnBkZi5pbnRlcm5hbC5vdXQoZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGVTdHJpbmcoeCkgKyAnICcgKyBnZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcoeSkgKyAnIG0nKTtcbiAgfTtcblxuICB2YXIgcHV0VGV4dCA9IGZ1bmN0aW9uIHB1dFRleHQob3B0aW9ucykge1xuICAgIHZhciB0ZXh0QWxpZ247XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMuYWxpZ24pIHtcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcHQgPSB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBQb2ludChvcHRpb25zLngsIG9wdGlvbnMueSkpO1xuICAgIHZhciBkZWNvbXBvc2VkVHJhbnNmb3JtYXRpb25NYXRyaXggPSB0aGlzLmN0eC50cmFuc2Zvcm0uZGVjb21wb3NlKCk7XG4gICAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICBtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkoZGVjb21wb3NlZFRyYW5zZm9ybWF0aW9uTWF0cml4LnRyYW5zbGF0ZSk7XG4gICAgbWF0cml4ID0gbWF0cml4Lm11bHRpcGx5KGRlY29tcG9zZWRUcmFuc2Zvcm1hdGlvbk1hdHJpeC5za2V3KTtcbiAgICBtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkoZGVjb21wb3NlZFRyYW5zZm9ybWF0aW9uTWF0cml4LnNjYWxlKTtcbiAgICB2YXIgdGV4dERpbWVuc2lvbnMgPSB0aGlzLnBkZi5nZXRUZXh0RGltZW5zaW9ucyhvcHRpb25zLnRleHQpO1xuICAgIHZhciB0ZXh0UmVjdCA9IHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUmVjdGFuZ2xlKG5ldyBSZWN0YW5nbGUob3B0aW9ucy54LCBvcHRpb25zLnksIHRleHREaW1lbnNpb25zLncsIHRleHREaW1lbnNpb25zLmgpKTtcbiAgICB2YXIgdGV4dFhSZWN0ID0gbWF0cml4LmFwcGx5VG9SZWN0YW5nbGUobmV3IFJlY3RhbmdsZShvcHRpb25zLngsIG9wdGlvbnMueSAtIHRleHREaW1lbnNpb25zLmgsIHRleHREaW1lbnNpb25zLncsIHRleHREaW1lbnNpb25zLmgpKTtcbiAgICB2YXIgcGFnZUFycmF5ID0gZ2V0UGFnZXNCeVBhdGguY2FsbCh0aGlzLCB0ZXh0WFJlY3QpO1xuICAgIHZhciBwYWdlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHBhZ2VBcnJheS5sZW5ndGg7IGlpICs9IDEpIHtcbiAgICAgIGlmIChwYWdlcy5pbmRleE9mKHBhZ2VBcnJheVtpaV0pID09PSAtMSkge1xuICAgICAgICBwYWdlcy5wdXNoKHBhZ2VBcnJheVtpaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhZ2VzLnNvcnQoKTtcbiAgICB2YXIgY2xpcFBhdGg7XG5cbiAgICBpZiAodGhpcy5hdXRvUGFnaW5nID09PSB0cnVlKSB7XG4gICAgICB2YXIgbWluID0gcGFnZXNbMF07XG4gICAgICB2YXIgbWF4ID0gcGFnZXNbcGFnZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGZvciAodmFyIGkgPSBtaW47IGkgPCBtYXggKyAxOyBpKyspIHtcbiAgICAgICAgdGhpcy5wZGYuc2V0UGFnZShpKTtcblxuICAgICAgICBpZiAodGhpcy5jdHguY2xpcF9wYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHZhciB0bXBQYXRocyA9IHRoaXMucGF0aDtcbiAgICAgICAgICBjbGlwUGF0aCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jdHguY2xpcF9wYXRoKSk7XG4gICAgICAgICAgdGhpcy5wYXRoID0gcGF0aFBvc2l0aW9uUmVkbyhjbGlwUGF0aCwgdGhpcy5wb3NYLCAtMSAqIHRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLmhlaWdodCAqIChpIC0gMSkgKyB0aGlzLnBvc1kpO1xuICAgICAgICAgIGRyYXdQYXRocy5jYWxsKHRoaXMsICdmaWxsJywgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5wYXRoID0gdG1wUGF0aHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wUmVjdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGV4dFJlY3QpKTtcbiAgICAgICAgdG1wUmVjdCA9IHBhdGhQb3NpdGlvblJlZG8oW3RtcFJlY3RdLCB0aGlzLnBvc1gsIC0xICogdGhpcy5wZGYuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0ICogKGkgLSAxKSArIHRoaXMucG9zWSlbMF07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGUgPj0gMC4wMSkge1xuICAgICAgICAgIHZhciBvbGRTaXplID0gdGhpcy5wZGYuaW50ZXJuYWwuZ2V0Rm9udFNpemUoKTtcbiAgICAgICAgICB0aGlzLnBkZi5zZXRGb250U2l6ZShvbGRTaXplICogb3B0aW9ucy5zY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBkZi50ZXh0KG9wdGlvbnMudGV4dCwgdG1wUmVjdC54LCB0bXBSZWN0LnksIHtcbiAgICAgICAgICBhbmdsZTogb3B0aW9ucy5hbmdsZSxcbiAgICAgICAgICBhbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgIHJlbmRlcmluZ01vZGU6IG9wdGlvbnMucmVuZGVyaW5nTW9kZSxcbiAgICAgICAgICBtYXhXaWR0aDogb3B0aW9ucy5tYXhXaWR0aFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zY2FsZSA+PSAwLjAxKSB7XG4gICAgICAgICAgdGhpcy5wZGYuc2V0Rm9udFNpemUob2xkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuc2NhbGUgPj0gMC4wMSkge1xuICAgICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMucGRmLmludGVybmFsLmdldEZvbnRTaXplKCk7XG4gICAgICAgIHRoaXMucGRmLnNldEZvbnRTaXplKG9sZFNpemUgKiBvcHRpb25zLnNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZGYudGV4dChvcHRpb25zLnRleHQsIHB0LnggKyB0aGlzLnBvc1gsIHB0LnkgKyB0aGlzLnBvc1ksIHtcbiAgICAgICAgYW5nbGU6IG9wdGlvbnMuYW5nbGUsXG4gICAgICAgIGFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHJlbmRlcmluZ01vZGU6IG9wdGlvbnMucmVuZGVyaW5nTW9kZSxcbiAgICAgICAgbWF4V2lkdGg6IG9wdGlvbnMubWF4V2lkdGhcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5zY2FsZSA+PSAwLjAxKSB7XG4gICAgICAgIHRoaXMucGRmLnNldEZvbnRTaXplKG9sZFNpemUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZHJhd0xpbmUgPSBmdW5jdGlvbiBkcmF3TGluZSh4LCB5LCBwcmV2WCwgcHJldlkpIHtcbiAgICBwcmV2WCA9IHByZXZYIHx8IDA7XG4gICAgcHJldlkgPSBwcmV2WSB8fCAwO1xuICAgIHRoaXMucGRmLmludGVybmFsLm91dChnZXRIb3Jpem9udGFsQ29vcmRpbmF0ZVN0cmluZyh4ICsgcHJldlgpICsgJyAnICsgZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nKHkgKyBwcmV2WSkgKyAnIGwnKTtcbiAgfTtcblxuICB2YXIgZHJhd0xpbmVzID0gZnVuY3Rpb24gZHJhd0xpbmVzKGxpbmVzLCB4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMucGRmLmxpbmVzKGxpbmVzLCB4LCB5LCBudWxsLCBudWxsKTtcbiAgfTtcblxuICB2YXIgZHJhd0N1cnZlID0gZnVuY3Rpb24gZHJhd0N1cnZlKHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB0aGlzLnBkZi5pbnRlcm5hbC5vdXQoW2YyKGdldEhvcml6b250YWxDb29yZGluYXRlKHgxICsgeCkpLCBmMihnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeTEgKyB5KSksIGYyKGdldEhvcml6b250YWxDb29yZGluYXRlKHgyICsgeCkpLCBmMihnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeTIgKyB5KSksIGYyKGdldEhvcml6b250YWxDb29yZGluYXRlKHgzICsgeCkpLCBmMihnZXRWZXJ0aWNhbENvb3JkaW5hdGUoeTMgKyB5KSksICdjJ10uam9pbignICcpKTtcbiAgfTtcbiAgLyoqXG4gICogUmV0dXJuIGEgYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IHJlcHJlc2VudCBiZXppZXIgY3VydmVzIHdoaWNoIGFwcHJveGltYXRlIHRoZSBjaXJjdWxhciBhcmMgY2VudGVyZWQgYXQgdGhlIG9yaWdpbiwgZnJvbSBzdGFydEFuZ2xlIHRvIGVuZEFuZ2xlIChyYWRpYW5zKSB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzLlxuICAqXG4gICogRWFjaCBiZXppZXIgY3VydmUgaXMgYW4gb2JqZWN0IHdpdGggZm91ciBwb2ludHMsIHdoZXJlIHgxLHkxIGFuZCB4NCx5NCBhcmUgdGhlIGFyYydzIGVuZCBwb2ludHMgYW5kIHgyLHkyIGFuZCB4Myx5MyBhcmUgdGhlIGN1YmljIGJlemllcidzIGNvbnRyb2wgcG9pbnRzLlxuICAqIEBmdW5jdGlvbiBjcmVhdGVBcmNcbiAgKi9cblxuXG4gIHZhciBjcmVhdGVBcmMgPSBmdW5jdGlvbiBjcmVhdGVBcmMocmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMTsgLy8gUm91Z2hseSAxLzEwMDB0aCBvZiBhIGRlZ3JlZSwgc2VlIGJlbG93ICAgICAgICAvLyBub3JtYWxpemUgc3RhcnRBbmdsZSwgZW5kQW5nbGUgdG8gWy0yUEksIDJQSV1cblxuICAgIHZhciB0d29QSSA9IE1hdGguUEkgKiAyO1xuICAgIHZhciBzdGFydEFuZ2xlTiA9IHN0YXJ0QW5nbGU7XG5cbiAgICBpZiAoc3RhcnRBbmdsZU4gPCB0d29QSSB8fCBzdGFydEFuZ2xlTiA+IHR3b1BJKSB7XG4gICAgICBzdGFydEFuZ2xlTiA9IHN0YXJ0QW5nbGVOICUgdHdvUEk7XG4gICAgfVxuXG4gICAgdmFyIGVuZEFuZ2xlTiA9IGVuZEFuZ2xlO1xuXG4gICAgaWYgKGVuZEFuZ2xlTiA8IHR3b1BJIHx8IGVuZEFuZ2xlTiA+IHR3b1BJKSB7XG4gICAgICBlbmRBbmdsZU4gPSBlbmRBbmdsZU4gJSB0d29QSTtcbiAgICB9IC8vIENvbXB1dGUgdGhlIHNlcXVlbmNlIG9mIGFyYyBjdXJ2ZXMsIHVwIHRvIFBJLzIgYXQgYSB0aW1lLiAgICAgICAgLy8gVG90YWwgYXJjIGFuZ2xlIGlzIGxlc3MgdGhhbiAyUEkuXG5cblxuICAgIHZhciBjdXJ2ZXMgPSBbXTtcbiAgICB2YXIgcGlPdmVyVHdvID0gTWF0aC5QSSAvIDIuMDsgLy92YXIgc2duID0gKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSkgPyArMSA6IC0xOyAvLyBjbG9ja3dpc2Ugb3IgY291bnRlcmNsb2Nrd2lzZVxuXG4gICAgdmFyIHNnbiA9IGFudGljbG9ja3dpc2UgPyAtMSA6ICsxO1xuICAgIHZhciBhMSA9IHN0YXJ0QW5nbGU7XG5cbiAgICBmb3IgKHZhciB0b3RhbEFuZ2xlID0gTWF0aC5taW4odHdvUEksIE1hdGguYWJzKGVuZEFuZ2xlTiAtIHN0YXJ0QW5nbGVOKSk7IHRvdGFsQW5nbGUgPiBFUFNJTE9OOykge1xuICAgICAgdmFyIGEyID0gYTEgKyBzZ24gKiBNYXRoLm1pbih0b3RhbEFuZ2xlLCBwaU92ZXJUd28pO1xuICAgICAgY3VydmVzLnB1c2goY3JlYXRlU21hbGxBcmMuY2FsbCh0aGlzLCByYWRpdXMsIGExLCBhMikpO1xuICAgICAgdG90YWxBbmdsZSAtPSBNYXRoLmFicyhhMiAtIGExKTtcbiAgICAgIGExID0gYTI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnZlcztcbiAgfTtcbiAgLyoqXG4gICogQ3ViaWMgYmV6aWVyIGFwcHJveGltYXRpb24gb2YgYSBjaXJjdWxhciBhcmMgY2VudGVyZWQgYXQgdGhlIG9yaWdpbiwgZnJvbSAocmFkaWFucykgYTEgdG8gYTIsIHdoZXJlIGEyLWExIDwgcGkvMi4gVGhlIGFyYydzIHJhZGl1cyBpcyByLlxuICAqXG4gICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBmb3VyIHBvaW50cywgd2hlcmUgeDEseTEgYW5kIHg0LHk0IGFyZSB0aGUgYXJjJ3MgZW5kIHBvaW50cyBhbmQgeDIseTIgYW5kIHgzLHkzIGFyZSB0aGUgY3ViaWMgYmV6aWVyJ3MgY29udHJvbCBwb2ludHMuXG4gICpcbiAgKiBUaGlzIGFsZ29yaXRobSBpcyBiYXNlZCBvbiB0aGUgYXBwcm9hY2ggZGVzY3JpYmVkIGluOiBBLiBSacWha3VzLCBcIkFwcHJveGltYXRpb24gb2YgYSBDdWJpYyBCZXppZXIgQ3VydmUgYnkgQ2lyY3VsYXIgQXJjcyBhbmQgVmljZSBWZXJzYSxcIiBJbmZvcm1hdGlvbiBUZWNobm9sb2d5IGFuZCBDb250cm9sLCAzNSg0KSwgMjAwNiBwcC4gMzcxLTM3OC5cbiAgKi9cblxuXG4gIHZhciBjcmVhdGVTbWFsbEFyYyA9IGZ1bmN0aW9uIGNyZWF0ZVNtYWxsQXJjKHIsIGExLCBhMikge1xuICAgIHZhciBhID0gKGEyIC0gYTEpIC8gMi4wO1xuICAgIHZhciB4NCA9IHIgKiBNYXRoLmNvcyhhKTtcbiAgICB2YXIgeTQgPSByICogTWF0aC5zaW4oYSk7XG4gICAgdmFyIHgxID0geDQ7XG4gICAgdmFyIHkxID0gLXk0O1xuICAgIHZhciBxMSA9IHgxICogeDEgKyB5MSAqIHkxO1xuICAgIHZhciBxMiA9IHExICsgeDEgKiB4NCArIHkxICogeTQ7XG4gICAgdmFyIGsyID0gNCAvIDMgKiAoTWF0aC5zcXJ0KDIgKiBxMSAqIHEyKSAtIHEyKSAvICh4MSAqIHk0IC0geTEgKiB4NCk7XG4gICAgdmFyIHgyID0geDEgLSBrMiAqIHkxO1xuICAgIHZhciB5MiA9IHkxICsgazIgKiB4MTtcbiAgICB2YXIgeDMgPSB4MjtcbiAgICB2YXIgeTMgPSAteTI7XG4gICAgdmFyIGFyID0gYSArIGExO1xuICAgIHZhciBjb3NfYXIgPSBNYXRoLmNvcyhhcik7XG4gICAgdmFyIHNpbl9hciA9IE1hdGguc2luKGFyKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHIgKiBNYXRoLmNvcyhhMSksXG4gICAgICB5MTogciAqIE1hdGguc2luKGExKSxcbiAgICAgIHgyOiB4MiAqIGNvc19hciAtIHkyICogc2luX2FyLFxuICAgICAgeTI6IHgyICogc2luX2FyICsgeTIgKiBjb3NfYXIsXG4gICAgICB4MzogeDMgKiBjb3NfYXIgLSB5MyAqIHNpbl9hcixcbiAgICAgIHkzOiB4MyAqIHNpbl9hciArIHkzICogY29zX2FyLFxuICAgICAgeDQ6IHIgKiBNYXRoLmNvcyhhMiksXG4gICAgICB5NDogciAqIE1hdGguc2luKGEyKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIHJhZDJkZWcgPSBmdW5jdGlvbiByYWQyZGVnKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICogMTgwIC8gTWF0aC5QSTtcbiAgfTtcblxuICB2YXIgZGVnMnJhZCA9IGZ1bmN0aW9uIGRlZzJyYWQoZGVnKSB7XG4gICAgcmV0dXJuIGRlZyAqIE1hdGguUEkgLyAxODA7XG4gIH07XG5cbiAgdmFyIGdldFF1YWRyYXRpY0N1cnZlQm91bmRhcnkgPSBmdW5jdGlvbiBnZXRRdWFkcmF0aWNDdXJ2ZUJvdW5kYXJ5KHN4LCBzeSwgY3B4LCBjcHksIGV4LCBleSkge1xuICAgIHZhciBtaWRYMSA9IHN4ICsgKGNweCAtIHN4KSAqIDAuNTA7XG4gICAgdmFyIG1pZFkxID0gc3kgKyAoY3B5IC0gc3kpICogMC41MDtcbiAgICB2YXIgbWlkWDIgPSBleCArIChjcHggLSBleCkgKiAwLjUwO1xuICAgIHZhciBtaWRZMiA9IGV5ICsgKGNweSAtIGV5KSAqIDAuNTA7XG4gICAgdmFyIHJlc3VsdFgxID0gTWF0aC5taW4oc3gsIGV4LCBtaWRYMSwgbWlkWDIpO1xuICAgIHZhciByZXN1bHRYMiA9IE1hdGgubWF4KHN4LCBleCwgbWlkWDEsIG1pZFgyKTtcbiAgICB2YXIgcmVzdWx0WTEgPSBNYXRoLm1pbihzeSwgZXksIG1pZFkxLCBtaWRZMik7XG4gICAgdmFyIHJlc3VsdFkyID0gTWF0aC5tYXgoc3ksIGV5LCBtaWRZMSwgbWlkWTIpO1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHJlc3VsdFgxLCByZXN1bHRZMSwgcmVzdWx0WDIgLSByZXN1bHRYMSwgcmVzdWx0WTIgLSByZXN1bHRZMSk7XG4gIH07IC8vRGUgQ2FzdGVsamF1IGFsZ29yaXRobVxuXG5cbiAgdmFyIGdldEJlemllckN1cnZlQm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCZXppZXJDdXJ2ZUJvdW5kYXJ5KGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIGR4LCBkeSkge1xuICAgIHZhciB0b2J4ID0gYnggLSBheDtcbiAgICB2YXIgdG9ieSA9IGJ5IC0gYXk7XG4gICAgdmFyIHRvY3ggPSBjeCAtIGJ4O1xuICAgIHZhciB0b2N5ID0gY3kgLSBieTtcbiAgICB2YXIgdG9keCA9IGR4IC0gY3g7XG4gICAgdmFyIHRvZHkgPSBkeSAtIGN5O1xuICAgIHZhciBwcmVjaXNpb24gPSA0MDtcbiAgICB2YXIgZCwgcHgsIHB5LCBxeCwgcXksIHJ4LCByeSwgdHgsIHR5LCBzeCwgc3ksIHgsIHksIGksIG1pbngsIG1pbnksIG1heHgsIG1heHksIHRvcXgsIHRvcXksIHRvcngsIHRvcnksIHRvdHgsIHRvdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWNpc2lvbiArIDE7IGkrKykge1xuICAgICAgZCA9IGkgLyBwcmVjaXNpb247XG4gICAgICBweCA9IGF4ICsgZCAqIHRvYng7XG4gICAgICBweSA9IGF5ICsgZCAqIHRvYnk7XG4gICAgICBxeCA9IGJ4ICsgZCAqIHRvY3g7XG4gICAgICBxeSA9IGJ5ICsgZCAqIHRvY3k7XG4gICAgICByeCA9IGN4ICsgZCAqIHRvZHg7XG4gICAgICByeSA9IGN5ICsgZCAqIHRvZHk7XG4gICAgICB0b3F4ID0gcXggLSBweDtcbiAgICAgIHRvcXkgPSBxeSAtIHB5O1xuICAgICAgdG9yeCA9IHJ4IC0gcXg7XG4gICAgICB0b3J5ID0gcnkgLSBxeTtcbiAgICAgIHN4ID0gcHggKyBkICogdG9xeDtcbiAgICAgIHN5ID0gcHkgKyBkICogdG9xeTtcbiAgICAgIHR4ID0gcXggKyBkICogdG9yeDtcbiAgICAgIHR5ID0gcXkgKyBkICogdG9yeTtcbiAgICAgIHRvdHggPSB0eCAtIHN4O1xuICAgICAgdG90eSA9IHR5IC0gc3k7XG4gICAgICB4ID0gc3ggKyBkICogdG90eDtcbiAgICAgIHkgPSBzeSArIGQgKiB0b3R5O1xuXG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIG1pbnggPSB4O1xuICAgICAgICBtaW55ID0geTtcbiAgICAgICAgbWF4eCA9IHg7XG4gICAgICAgIG1heHkgPSB5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlueCA9IE1hdGgubWluKG1pbngsIHgpO1xuICAgICAgICBtaW55ID0gTWF0aC5taW4obWlueSwgeSk7XG4gICAgICAgIG1heHggPSBNYXRoLm1heChtYXh4LCB4KTtcbiAgICAgICAgbWF4eSA9IE1hdGgubWF4KG1heHksIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKE1hdGgucm91bmQobWlueCksIE1hdGgucm91bmQobWlueSksIE1hdGgucm91bmQobWF4eCAtIG1pbngpLCBNYXRoLnJvdW5kKG1heHkgLSBtaW55KSk7XG4gIH07XG5cbiAgdmFyIFBvaW50ID0gZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgIHZhciBfeCA9IHggfHwgMDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAneCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF94O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgX3ggPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIF95ID0geSB8fCAwO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd5Jywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3k7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICBfeSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF90eXBlID0gJ3B0JztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfdHlwZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfdHlwZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIFJlY3RhbmdsZSA9IGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3LCBoKSB7XG4gICAgUG9pbnQuY2FsbCh0aGlzLCB4LCB5KTtcbiAgICB0aGlzLnR5cGUgPSAncmVjdCc7XG5cbiAgICB2YXIgX3cgPSB3IHx8IDA7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3cnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfdztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgIF93ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBfaCA9IGggfHwgMDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9oO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgX2ggPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBNYXRyaXggPSBmdW5jdGlvbiBNYXRyaXgoc3gsIHNoeSwgc2h4LCBzeSwgdHgsIHR5KSB7XG4gICAgdmFyIF9tYXRyaXggPSBbXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N4Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfbWF0cml4WzBdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9tYXRyaXhbMF0gPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NoeScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX21hdHJpeFsxXTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfbWF0cml4WzFdID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMCkgLyAxMDAwMDA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzaHgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9tYXRyaXhbMl07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX21hdHJpeFsyXSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3knLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9tYXRyaXhbM107XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX21hdHJpeFszXSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9tYXRyaXhbNF07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX21hdHJpeFs0XSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHknLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9tYXRyaXhbNV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX21hdHJpeFs1XSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncm90YXRpb24nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5zaHgsIHRoaXMuc3gpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NhbGVYJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29tcG9zZSgpLnNjYWxlLnN4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NhbGVZJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29tcG9zZSgpLnNjYWxlLnN5O1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNJZGVudGl0eScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5zeCAhPT0gMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNoeSAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNoeCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN5ICE9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHggIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50eSAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3ggPSAhaXNOYU4oc3gpID8gc3ggOiAxO1xuICAgIHRoaXMuc2h5ID0gIWlzTmFOKHNoeSkgPyBzaHkgOiAwO1xuICAgIHRoaXMuc2h4ID0gIWlzTmFOKHNoeCkgPyBzaHggOiAwO1xuICAgIHRoaXMuc3kgPSAhaXNOYU4oc3kpID8gc3kgOiAxO1xuICAgIHRoaXMudHggPSAhaXNOYU4odHgpID8gdHggOiAwO1xuICAgIHRoaXMudHkgPSAhaXNOYU4odHkpID8gdHkgOiAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgKiBNdWx0aXBseSB0aGUgbWF0cml4IHdpdGggZ2l2ZW4gTWF0cml4XG4gICogXG4gICogQGZ1bmN0aW9uIG11bHRpcGx5XG4gICogQHBhcmFtIG1hdHJpeFxuICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICogQHByaXZhdGVcbiAgKiBAaWdub3JlXG4gICovXG5cblxuICBNYXRyaXgucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgIHZhciBzeCA9IG1hdHJpeC5zeCAqIHRoaXMuc3ggKyBtYXRyaXguc2h5ICogdGhpcy5zaHg7XG4gICAgdmFyIHNoeSA9IG1hdHJpeC5zeCAqIHRoaXMuc2h5ICsgbWF0cml4LnNoeSAqIHRoaXMuc3k7XG4gICAgdmFyIHNoeCA9IG1hdHJpeC5zaHggKiB0aGlzLnN4ICsgbWF0cml4LnN5ICogdGhpcy5zaHg7XG4gICAgdmFyIHN5ID0gbWF0cml4LnNoeCAqIHRoaXMuc2h5ICsgbWF0cml4LnN5ICogdGhpcy5zeTtcbiAgICB2YXIgdHggPSBtYXRyaXgudHggKiB0aGlzLnN4ICsgbWF0cml4LnR5ICogdGhpcy5zaHggKyB0aGlzLnR4O1xuICAgIHZhciB0eSA9IG1hdHJpeC50eCAqIHRoaXMuc2h5ICsgbWF0cml4LnR5ICogdGhpcy5zeSArIHRoaXMudHk7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgoc3gsIHNoeSwgc2h4LCBzeSwgdHgsIHR5KTtcbiAgfTtcbiAgLyoqXG4gICogQGZ1bmN0aW9uIGRlY29tcG9zZVxuICAqIEBwcml2YXRlXG4gICogQGlnbm9yZVxuICAqL1xuXG5cbiAgTWF0cml4LnByb3RvdHlwZS5kZWNvbXBvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSB0aGlzLnN4O1xuICAgIHZhciBiID0gdGhpcy5zaHk7XG4gICAgdmFyIGMgPSB0aGlzLnNoeDtcbiAgICB2YXIgZCA9IHRoaXMuc3k7XG4gICAgdmFyIGUgPSB0aGlzLnR4O1xuICAgIHZhciBmID0gdGhpcy50eTtcbiAgICB2YXIgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgIGEgLz0gc2NhbGVYO1xuICAgIGIgLz0gc2NhbGVYO1xuICAgIHZhciBzaGVhciA9IGEgKiBjICsgYiAqIGQ7XG4gICAgYyAtPSBhICogc2hlYXI7XG4gICAgZCAtPSBiICogc2hlYXI7XG4gICAgdmFyIHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKTtcbiAgICBjIC89IHNjYWxlWTtcbiAgICBkIC89IHNjYWxlWTtcbiAgICBzaGVhciAvPSBzY2FsZVk7XG5cbiAgICBpZiAoYSAqIGQgPCBiICogYykge1xuICAgICAgYSA9IC1hO1xuICAgICAgYiA9IC1iO1xuICAgICAgc2hlYXIgPSAtc2hlYXI7XG4gICAgICBzY2FsZVggPSAtc2NhbGVYO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZTogbmV3IE1hdHJpeChzY2FsZVgsIDAsIDAsIHNjYWxlWSwgMCwgMCksXG4gICAgICB0cmFuc2xhdGU6IG5ldyBNYXRyaXgoMSwgMCwgMCwgMSwgZSwgZiksXG4gICAgICByb3RhdGU6IG5ldyBNYXRyaXgoYSwgYiwgLWIsIGEsIDAsIDApLFxuICAgICAgc2tldzogbmV3IE1hdHJpeCgxLCAwLCBzaGVhciwgMSwgMCwgMClcbiAgICB9O1xuICB9O1xuICAvKipcbiAgKiBAZnVuY3Rpb24gYXBwbHlUb1BvaW50XG4gICogQHByaXZhdGVcbiAgKiBAaWdub3JlXG4gICovXG5cblxuICBNYXRyaXgucHJvdG90eXBlLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uIChwdCkge1xuICAgIHZhciB4ID0gcHQueCAqIHRoaXMuc3ggKyBwdC55ICogdGhpcy5zaHggKyB0aGlzLnR4O1xuICAgIHZhciB5ID0gcHQueCAqIHRoaXMuc2h5ICsgcHQueSAqIHRoaXMuc3kgKyB0aGlzLnR5O1xuICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gIH07XG4gIC8qKlxuICAqIEBmdW5jdGlvbiBhcHBseVRvUmVjdGFuZ2xlXG4gICogQHByaXZhdGVcbiAgKiBAaWdub3JlXG4gICovXG5cblxuICBNYXRyaXgucHJvdG90eXBlLmFwcGx5VG9SZWN0YW5nbGUgPSBmdW5jdGlvbiAocmVjdCkge1xuICAgIHZhciBwdDEgPSB0aGlzLmFwcGx5VG9Qb2ludChyZWN0KTtcbiAgICB2YXIgcHQyID0gdGhpcy5hcHBseVRvUG9pbnQobmV3IFBvaW50KHJlY3QueCArIHJlY3QudywgcmVjdC55ICsgcmVjdC5oKSk7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUocHQxLngsIHB0MS55LCBwdDIueCAtIHB0MS54LCBwdDIueSAtIHB0MS55KTtcbiAgfTtcbiAgLyoqXG4gICogQGZ1bmN0aW9uIGNsb25lXG4gICogQHByaXZhdGVcbiAgKiBAaWdub3JlXG4gICovXG5cblxuICBNYXRyaXgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzeCA9IHRoaXMuc3g7XG4gICAgdmFyIHNoeSA9IHRoaXMuc2h5O1xuICAgIHZhciBzaHggPSB0aGlzLnNoeDtcbiAgICB2YXIgc3kgPSB0aGlzLnN5O1xuICAgIHZhciB0eCA9IHRoaXMudHg7XG4gICAgdmFyIHR5ID0gdGhpcy50eTtcbiAgICByZXR1cm4gbmV3IE1hdHJpeChzeCwgc2h5LCBzaHgsIHN5LCB0eCwgdHkpO1xuICB9O1xufSkoanNQREYuQVBJLCB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgfHwgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgJiYgdGhpcy5jb250ZW50JykoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpKTtcblxuLyoqXG4gKiBqc1BERiBmaWx0ZXJzIFBsdWdJblxuICogQ29weXJpZ2h0IChjKSAyMDE0IEFyYXMgQWJiYXNpIFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGpzUERGQVBJKSB7XG5cbiAgdmFyIEFTQ0lJODVFbmNvZGUgPSBmdW5jdGlvbiBBU0NJSTg1RW5jb2RlKGEpIHtcbiAgICB2YXIgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaztcblxuICAgIGZvciAoIS9bXlxceDAwLVxceEZGXS8udGVzdChhKSwgYiA9IFwiXFx4MDBcXHgwMFxceDAwXFx4MDBcIi5zbGljZShhLmxlbmd0aCAlIDQgfHwgNCksIGEgKz0gYiwgYyA9IFtdLCBkID0gMCwgZSA9IGEubGVuZ3RoOyBlID4gZDsgZCArPSA0KSB7XG4gICAgICBmID0gKGEuY2hhckNvZGVBdChkKSA8PCAyNCkgKyAoYS5jaGFyQ29kZUF0KGQgKyAxKSA8PCAxNikgKyAoYS5jaGFyQ29kZUF0KGQgKyAyKSA8PCA4KSArIGEuY2hhckNvZGVBdChkICsgMyksIDAgIT09IGYgPyAoayA9IGYgJSA4NSwgZiA9IChmIC0gaykgLyA4NSwgaiA9IGYgJSA4NSwgZiA9IChmIC0gaikgLyA4NSwgaSA9IGYgJSA4NSwgZiA9IChmIC0gaSkgLyA4NSwgaCA9IGYgJSA4NSwgZiA9IChmIC0gaCkgLyA4NSwgZyA9IGYgJSA4NSwgYy5wdXNoKGcgKyAzMywgaCArIDMzLCBpICsgMzMsIGogKyAzMywgayArIDMzKSkgOiBjLnB1c2goMTIyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGZvciAodmFyIGMgPSBiOyBjID4gMDsgYy0tKSB7XG4gICAgICAgIGEucG9wKCk7XG4gICAgICB9XG4gICAgfShjLCBiLmxlbmd0aCksIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjKSArIFwifj5cIjtcbiAgfTtcblxuICB2YXIgQVNDSUk4NURlY29kZSA9IGZ1bmN0aW9uIEFTQ0lJODVEZWNvZGUoYSkge1xuICAgIHZhciBjLFxuICAgICAgICBkLFxuICAgICAgICBlLFxuICAgICAgICBmLFxuICAgICAgICBnLFxuICAgICAgICBoID0gU3RyaW5nLFxuICAgICAgICBsID0gXCJsZW5ndGhcIixcbiAgICAgICAgdyA9IDI1NSxcbiAgICAgICAgeCA9IFwiY2hhckNvZGVBdFwiLFxuICAgICAgICB5ID0gXCJzbGljZVwiLFxuICAgICAgICB6ID0gXCJyZXBsYWNlXCI7XG5cbiAgICBmb3IgKFwifj5cIiA9PT0gYVt5XSgtMiksIGEgPSBhW3ldKDAsIC0yKVt6XSgvXFxzL2csIFwiXCIpW3pdKFwielwiLCBcIiEhISEhXCIpLCBjID0gXCJ1dXV1dVwiW3ldKGFbbF0gJSA1IHx8IDUpLCBhICs9IGMsIGUgPSBbXSwgZiA9IDAsIGcgPSBhW2xdOyBnID4gZjsgZiArPSA1KSB7XG4gICAgICBkID0gNTIyMDA2MjUgKiAoYVt4XShmKSAtIDMzKSArIDYxNDEyNSAqIChhW3hdKGYgKyAxKSAtIDMzKSArIDcyMjUgKiAoYVt4XShmICsgMikgLSAzMykgKyA4NSAqIChhW3hdKGYgKyAzKSAtIDMzKSArIChhW3hdKGYgKyA0KSAtIDMzKSwgZS5wdXNoKHcgJiBkID4+IDI0LCB3ICYgZCA+PiAxNiwgdyAmIGQgPj4gOCwgdyAmIGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgZm9yICh2YXIgYyA9IGI7IGMgPiAwOyBjLS0pIHtcbiAgICAgICAgYS5wb3AoKTtcbiAgICAgIH1cbiAgICB9KGUsIGNbbF0pLCBoLmZyb21DaGFyQ29kZS5hcHBseShoLCBlKTtcbiAgfTtcbiAgLyoqXG4gICogVE9ETzogTm90IFRlc3RlZDpcbiAgLy9odHRwczovL2dpc3QuZ2l0aHViLmNvbS9yZXZvbHVuZXQvODQzODg5XG4gIC8vIExaVy1jb21wcmVzcyBhIHN0cmluZ1xuICB2YXIgTFpXRW5jb2RlID0gZnVuY3Rpb24ocywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHByZWRpY3RvcjogMSxcbiAgICAgIGNvbG9yczogMSxcbiAgICAgIGJpdHNQZXJDb21wb25lbnQ6IDgsXG4gICAgICBjb2x1bW5zOiAxLFxuICAgICAgZWFybHlDaGFuZ2U6IDFcbiAgICB9LCBvcHRpb25zKTtcbiAgICAgdmFyIGRpY3QgPSB7fTtcbiAgICB2YXIgZGF0YSA9IChzICsgXCJcIikuc3BsaXQoXCJcIik7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBjdXJyQ2hhcjtcbiAgICB2YXIgcGhyYXNlID0gZGF0YVswXTtcbiAgICB2YXIgY29kZSA9IDI1NjsgLy8weGUwMDBcbiAgICBmb3IgKHZhciBpPTE7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY3VyckNoYXI9ZGF0YVtpXTtcbiAgICAgIGlmIChkaWN0WydfJyArIHBocmFzZSArIGN1cnJDaGFyXSAhPSBudWxsKSB7XG4gICAgICAgIHBocmFzZSArPSBjdXJyQ2hhcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvdXQucHVzaChwaHJhc2UubGVuZ3RoID4gMSA/IGRpY3RbJ18nK3BocmFzZV0gOiBwaHJhc2UuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIGRpY3RbJ18nICsgcGhyYXNlICsgY3VyckNoYXJdID0gY29kZTtcbiAgICAgICAgY29kZSsrO1xuICAgICAgICBwaHJhc2U9Y3VyckNoYXI7XG4gICAgICB9XG4gICAgfVxuICAgIG91dC5wdXNoKHBocmFzZS5sZW5ndGggPiAxID8gZGljdFsnXycrcGhyYXNlXSA6IHBocmFzZS5jaGFyQ29kZUF0KDApKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8b3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG91dFtpXSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQuam9pbihcIlwiKTtcbiAgfVxuICAgLy8gRGVjb21wcmVzcyBhbiBMWlctZW5jb2RlZCBzdHJpbmdcbiAgdmFyIExaV0RlY29kZSA9IGZ1bmN0aW9uKHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBwcmVkaWN0b3I6IDEsXG4gICAgICBjb2xvcnM6IDEsXG4gICAgICBiaXRzUGVyQ29tcG9uZW50OiA4LFxuICAgICAgY29sdW1uczogMSxcbiAgICAgIGVhcmx5Q2hhbmdlOiAxXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgIHZhciBkaWN0ID0ge307XG4gICAgdmFyIGRhdGEgPSAocyArIFwiXCIpLnNwbGl0KFwiXCIpO1xuICAgIHZhciBjdXJyQ2hhciA9IGRhdGFbMF07XG4gICAgdmFyIG9sZFBocmFzZSA9IGN1cnJDaGFyO1xuICAgIHZhciBvdXQgPSBbY3VyckNoYXJdO1xuICAgIHZhciBjb2RlID0gMjU2O1xuICAgIHZhciBwaHJhc2U7XG4gICAgZm9yICh2YXIgaT0xOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyQ29kZSA9IGRhdGFbaV0uY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjdXJyQ29kZSA8IDI1Nikge1xuICAgICAgICBwaHJhc2UgPSBkYXRhW2ldO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBwaHJhc2UgPSBkaWN0WydfJytjdXJyQ29kZV0gPyBkaWN0WydfJytjdXJyQ29kZV0gOiAob2xkUGhyYXNlICsgY3VyckNoYXIpO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2gocGhyYXNlKTtcbiAgICAgIGN1cnJDaGFyID0gcGhyYXNlLmNoYXJBdCgwKTtcbiAgICAgIGRpY3RbJ18nK2NvZGVdID0gb2xkUGhyYXNlICsgY3VyckNoYXI7XG4gICAgICBjb2RlKys7XG4gICAgICBvbGRQaHJhc2UgPSBwaHJhc2U7XG4gICAgfVxuICAgIHJldHVybiBvdXQuam9pbihcIlwiKTtcbiAgfVxuICAqL1xuXG5cbiAgdmFyIEFTQ0lJSGV4RW5jb2RlID0gZnVuY3Rpb24gQVNDSUlIZXhFbmNvZGUodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICByZXN1bHQgKz0gKFwiMFwiICsgdmFsdWUuY2hhckNvZGVBdChpKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gJz4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIEFTQ0lJSGV4RGVjb2RlID0gZnVuY3Rpb24gQVNDSUlIZXhEZWNvZGUodmFsdWUpIHtcbiAgICB2YXIgcmVnZXhDaGVja0lmSGV4ID0gbmV3IFJlZ0V4cCgvXihbMC05QS1GYS1mXXsyfSkrJC8pO1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiPlwiKSAhPT0gLTEpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIHZhbHVlLmluZGV4T2YoXCI+XCIpKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgdmFsdWUgKz0gXCIwXCI7XG4gICAgfVxuXG4gICAgaWYgKHJlZ2V4Q2hlY2tJZkhleC50ZXN0KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFwiMHhcIiArICh2YWx1ZVtpXSArIHZhbHVlW2kgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIEZsYXRlRW5jb2RlID0gZnVuY3Rpb24gRmxhdGVFbmNvZGUoZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHByZWRpY3RvcjogMSxcbiAgICAgIGNvbG9yczogMSxcbiAgICAgIGJpdHNQZXJDb21wb25lbnQ6IDgsXG4gICAgICBjb2x1bW5zOiAxXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHZhciBpID0gZGF0YS5sZW5ndGg7XG4gICAgdmFyIGFkbGVyMzI7XG4gICAgdmFyIGRlZmxhdGVyO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJyW2ldID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIGFkbGVyMzIgPSBqc1BERkFQSS5hZGxlcjMyY3MuZnJvbShkYXRhKTtcbiAgICBkZWZsYXRlciA9IG5ldyBEZWZsYXRlcig2KTtcbiAgICBkZWZsYXRlci5hcHBlbmQobmV3IFVpbnQ4QXJyYXkoYXJyKSk7XG4gICAgZGF0YSA9IGRlZmxhdGVyLmZsdXNoKCk7XG4gICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyA2KTtcbiAgICBhcnIuc2V0KG5ldyBVaW50OEFycmF5KFsxMjAsIDE1Nl0pKSwgYXJyLnNldChkYXRhLCAyKTtcbiAgICBhcnIuc2V0KG5ldyBVaW50OEFycmF5KFthZGxlcjMyICYgMHhGRiwgYWRsZXIzMiA+PiA4ICYgMHhGRiwgYWRsZXIzMiA+PiAxNiAmIDB4RkYsIGFkbGVyMzIgPj4gMjQgJiAweEZGXSksIGRhdGEubGVuZ3RoICsgMik7XG4gICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBqc1BERkFQSS5wcm9jZXNzRGF0YUJ5RmlsdGVycyA9IGZ1bmN0aW9uIChvcmlnRGF0YSwgZmlsdGVyQ2hhaW4pIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZGF0YSA9IG9yaWdEYXRhIHx8ICcnO1xuICAgIHZhciByZXZlcnNlQ2hhaW4gPSBbXTtcbiAgICBmaWx0ZXJDaGFpbiA9IGZpbHRlckNoYWluIHx8IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJDaGFpbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZmlsdGVyQ2hhaW4gPSBbZmlsdGVyQ2hhaW5dO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJDaGFpbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgc3dpdGNoIChmaWx0ZXJDaGFpbltpXSkge1xuICAgICAgICBjYXNlIFwiQVNDSUk4NURlY29kZVwiOlxuICAgICAgICBjYXNlIFwiL0FTQ0lJODVEZWNvZGVcIjpcbiAgICAgICAgICBkYXRhID0gQVNDSUk4NURlY29kZShkYXRhKTtcbiAgICAgICAgICByZXZlcnNlQ2hhaW4ucHVzaChcIi9BU0NJSTg1RW5jb2RlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJBU0NJSTg1RW5jb2RlXCI6XG4gICAgICAgIGNhc2UgXCIvQVNDSUk4NUVuY29kZVwiOlxuICAgICAgICAgIGRhdGEgPSBBU0NJSTg1RW5jb2RlKGRhdGEpO1xuICAgICAgICAgIHJldmVyc2VDaGFpbi5wdXNoKFwiL0FTQ0lJODVEZWNvZGVcIik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkFTQ0lJSGV4RGVjb2RlXCI6XG4gICAgICAgIGNhc2UgXCIvQVNDSUlIZXhEZWNvZGVcIjpcbiAgICAgICAgICBkYXRhID0gQVNDSUlIZXhEZWNvZGUoZGF0YSk7XG4gICAgICAgICAgcmV2ZXJzZUNoYWluLnB1c2goXCIvQVNDSUlIZXhFbmNvZGVcIik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkFTQ0lJSGV4RW5jb2RlXCI6XG4gICAgICAgIGNhc2UgXCIvQVNDSUlIZXhFbmNvZGVcIjpcbiAgICAgICAgICBkYXRhID0gQVNDSUlIZXhFbmNvZGUoZGF0YSk7XG4gICAgICAgICAgcmV2ZXJzZUNoYWluLnB1c2goXCIvQVNDSUlIZXhEZWNvZGVcIik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkZsYXRlRW5jb2RlXCI6XG4gICAgICAgIGNhc2UgXCIvRmxhdGVFbmNvZGVcIjpcbiAgICAgICAgICBkYXRhID0gRmxhdGVFbmNvZGUoZGF0YSk7XG4gICAgICAgICAgcmV2ZXJzZUNoYWluLnB1c2goXCIvRmxhdGVEZWNvZGVcIik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyoqXG4gICAgICAgIGNhc2UgXCJMWldEZWNvZGVcIjpcbiAgICAgICAgY2FzZSBcIi9MWldEZWNvZGVcIjpcbiAgICAgICAgICBkYXRhID0gTFpXRGVjb2RlKGRhdGEpO1xuICAgICAgICAgIHJldmVyc2VDaGFpbi5wdXNoKFwiL0xaV0VuY29kZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxaV0VuY29kZVwiOlxuICAgICAgICBjYXNlIFwiL0xaV0VuY29kZVwiOlxuICAgICAgICAgIGRhdGEgPSBMWldFbmNvZGUoZGF0YSk7XG4gICAgICAgICAgcmV2ZXJzZUNoYWluLnB1c2goXCIvTFpXRGVjb2RlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAqL1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgXCJUaGUgZmlsdGVyOiBcXFwiXCIgKyBmaWx0ZXJDaGFpbltpXSArIFwiXFxcIiBpcyBub3QgaW1wbGVtZW50ZWRcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHJldmVyc2VDaGFpbjogcmV2ZXJzZUNoYWluLnJldmVyc2UoKS5qb2luKFwiIFwiKVxuICAgIH07XG4gIH07XG59KShqc1BERi5BUEkpO1xuXG4vKipcbiAqIGpzUERGIGZpbGVsb2FkaW5nIFBsdWdJblxuICogQ29weXJpZ2h0IChjKSAyMDE4IEFyYXMgQWJiYXNpIChhcmFzLmFiYmFzaUBnbWFpbC5jb20pXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlXG4gKi9cblxuLyoqXG4qIEBuYW1lIGZpbGVsb2FkaW5nXG4qIEBtb2R1bGVcbiovXG4oZnVuY3Rpb24gKGpzUERGQVBJKSB7XG4gIC8qKlxuICAqIEBuYW1lIGxvYWRGaWxlXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1xuICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IHJlc3VsdFxuICAqL1xuXG4gIGpzUERGQVBJLmxvYWRGaWxlID0gZnVuY3Rpb24gKHVybCwgc3luYywgY2FsbGJhY2spIHtcbiAgICBzeW5jID0gc3luYyB8fCB0cnVlO1xuXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciByZXN1bHQ7XG5cbiAgICB2YXIgeGhyID0gZnVuY3Rpb24geGhyKHVybCwgc3luYywgY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdmFyIHNhbml0aXplVW5pY29kZSA9IGZ1bmN0aW9uIHNhbml0aXplVW5pY29kZShkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBTdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlOyAvL1RyYW5zZm9ybSBVbmljb2RlIHRvIEFTQ0lJXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKFN0cmluZ0Zyb21DaGFyQ29kZShkYXRhLmNoYXJDb2RlQXQoaSkgJiAweGZmKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnl0ZUFycmF5LmpvaW4oXCJcIik7XG4gICAgICB9O1xuXG4gICAgICByZXEub3BlbignR0VUJywgdXJsLCAhc3luYyk7IC8vIFhIUiBiaW5hcnkgY2hhcnNldCBvcHQgYnkgTWFyY3VzIEdyYW5hZG8gMjAwNiBbaHR0cDovL21ncmFuLmJsb2dzcG90LmNvbV1cblxuICAgICAgcmVxLm92ZXJyaWRlTWltZVR5cGUoJ3RleHRcXC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xuXG4gICAgICBpZiAoc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc2FuaXRpemVVbmljb2RlKHRoaXMucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmVxLnNlbmQobnVsbCk7XG5cbiAgICAgIGlmIChyZXEuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gbG9hZCBmaWxlIFwiJyArIHVybCArICdcIicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIHJldHVybiBzYW5pdGl6ZVVuaWNvZGUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB4aHIodXJsLCBzeW5jLCBjYWxsYmFjayk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8qKlxuICAqIEBuYW1lIGxvYWRJbWFnZUZpbGVcbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1xuICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICovXG5cblxuICBqc1BERkFQSS5sb2FkSW1hZ2VGaWxlID0ganNQREZBUEkubG9hZEZpbGU7XG59KShqc1BERi5BUEkpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxOCBFcmlrIEtvb3BtYW5zXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBqc1BERiBodG1sIFBsdWdJblxuICpcbiAqIEBuYW1lIGh0bWxcbiAqIEBtb2R1bGVcbiAqL1xuKGZ1bmN0aW9uIChqc1BERkFQSSwgZ2xvYmFsKSB7XG4gIC8qKlxuICAqIERldGVybWluZSB0aGUgdHlwZSBvZiBhIHZhcmlhYmxlL29iamVjdC5cbiAgKiBcbiAgKiBAcHJpdmF0ZVxuICAqIEBpZ25vcmVcbiAgKi9cblxuICB2YXIgb2JqVHlwZSA9IGZ1bmN0aW9uIG9ialR5cGUob2JqKSB7XG4gICAgdmFyIHR5cGUgPSBfdHlwZW9mKG9iaik7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAndW5kZWZpbmVkJztlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiAnc3RyaW5nJztlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAnbnVtYmVyJztlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nIHx8IG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSByZXR1cm4gJ2Z1bmN0aW9uJztlbHNlIGlmICghIW9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5KSByZXR1cm4gJ2FycmF5JztlbHNlIGlmIChvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKSByZXR1cm4gJ2VsZW1lbnQnO2Vsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSByZXR1cm4gJ29iamVjdCc7ZWxzZSByZXR1cm4gJ3Vua25vd24nO1xuICB9O1xuICAvKipcbiAgKiBDcmVhdGUgYW4gSFRNTCBlbGVtZW50IHdpdGggb3B0aW9uYWwgY2xhc3NOYW1lLCBpbm5lckhUTUwsIGFuZCBzdHlsZS5cbiAgKiBcbiAgKiBAcHJpdmF0ZVxuICAqIEBpZ25vcmVcbiAgKi9cblxuXG4gIHZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBvcHQpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGlmIChvcHQuY2xhc3NOYW1lKSBlbC5jbGFzc05hbWUgPSBvcHQuY2xhc3NOYW1lO1xuXG4gICAgaWYgKG9wdC5pbm5lckhUTUwpIHtcbiAgICAgIGVsLmlubmVySFRNTCA9IG9wdC5pbm5lckhUTUw7XG4gICAgICB2YXIgc2NyaXB0cyA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IHNjcmlwdHMubGVuZ3RoOyBpLS0gPiAwOyBudWxsKSB7XG4gICAgICAgIHNjcmlwdHNbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0LnN0eWxlKSB7XG4gICAgICBlbC5zdHlsZVtrZXldID0gb3B0LnN0eWxlW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuICAvKipcbiAgKiBEZWVwLWNsb25lIGEgbm9kZSBhbmQgcHJlc2VydmUgY29udGVudHMvcHJvcGVydGllcy5cbiAgKiBcbiAgKiBAcHJpdmF0ZVxuICAqIEBpZ25vcmVcbiAgKi9cblxuXG4gIHZhciBjbG9uZU5vZGUgPSBmdW5jdGlvbiBjbG9uZU5vZGUobm9kZSwgamF2YXNjcmlwdEVuYWJsZWQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjbG9uZSB0aGUgbm9kZS5cbiAgICB2YXIgY2xvbmUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS5ub2RlVmFsdWUpIDogbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuXG4gICAgZm9yICh2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAoamF2YXNjcmlwdEVuYWJsZWQgPT09IHRydWUgfHwgY2hpbGQubm9kZVR5cGUgIT09IDEgfHwgY2hpbGQubm9kZU5hbWUgIT09ICdTQ1JJUFQnKSB7XG4gICAgICAgIGNsb25lLmFwcGVuZENoaWxkKGNsb25lTm9kZShjaGlsZCwgamF2YXNjcmlwdEVuYWJsZWQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgLy8gUHJlc2VydmUgY29udGVudHMvcHJvcGVydGllcyBvZiBzcGVjaWFsIG5vZGVzLlxuICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdDQU5WQVMnKSB7XG4gICAgICAgIGNsb25lLndpZHRoID0gbm9kZS53aWR0aDtcbiAgICAgICAgY2xvbmUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XG4gICAgICAgIGNsb25lLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKG5vZGUsIDAsIDApO1xuICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09PSAnVEVYVEFSRUEnIHx8IG5vZGUubm9kZU5hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgIGNsb25lLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgIH0gLy8gUHJlc2VydmUgdGhlIG5vZGUncyBzY3JvbGwgcG9zaXRpb24gd2hlbiBpdCBsb2Fkcy5cblxuXG4gICAgICBjbG9uZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjbG9uZS5zY3JvbGxUb3AgPSBub2RlLnNjcm9sbFRvcDtcbiAgICAgICAgY2xvbmUuc2Nyb2xsTGVmdCA9IG5vZGUuc2Nyb2xsTGVmdDtcbiAgICAgIH0sIHRydWUpO1xuICAgIH0gLy8gUmV0dXJuIHRoZSBjbG9uZWQgbm9kZS5cblxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9O1xuICAvKiAtLS0tLSBDT05TVFJVQ1RPUiAtLS0tLSAqL1xuXG5cbiAgdmFyIFdvcmtlciA9IGZ1bmN0aW9uIFdvcmtlcihvcHQpIHtcbiAgICAvLyBDcmVhdGUgdGhlIHJvb3QgcGFyZW50IGZvciB0aGUgcHJvdG8gY2hhaW4sIGFuZCB0aGUgc3RhcnRpbmcgV29ya2VyLlxuICAgIHZhciByb290ID0gT2JqZWN0LmFzc2lnbihXb3JrZXIuY29udmVydChQcm9taXNlLnJlc29sdmUoKSksIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoV29ya2VyLnRlbXBsYXRlKSkpO1xuICAgIHZhciBzZWxmID0gV29ya2VyLmNvbnZlcnQoUHJvbWlzZS5yZXNvbHZlKCksIHJvb3QpOyAvLyBTZXQgcHJvZ3Jlc3MsIG9wdGlvbmFsIHNldHRpbmdzLCBhbmQgcmV0dXJuLlxuXG4gICAgc2VsZiA9IHNlbGYuc2V0UHJvZ3Jlc3MoMSwgV29ya2VyLCAxLCBbV29ya2VyXSk7XG4gICAgc2VsZiA9IHNlbGYuc2V0KG9wdCk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07IC8vIEJvaWxlcnBsYXRlIGZvciBzdWJjbGFzc2luZyBQcm9taXNlLlxuXG5cbiAgV29ya2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuICBXb3JrZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV29ya2VyOyAvLyBDb252ZXJ0cy9jYXN0cyBwcm9taXNlcyBpbnRvIFdvcmtlcnMuXG5cbiAgV29ya2VyLmNvbnZlcnQgPSBmdW5jdGlvbiBjb252ZXJ0KHByb21pc2UsIGluaGVyaXQpIHtcbiAgICAvLyBVc2VzIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgdG8gcmVjZWl2ZSBjaGFuZ2VzIG1hZGUgdG8gYW5jZXN0b3JzJyBwcm9wZXJ0aWVzLlxuICAgIHByb21pc2UuX19wcm90b19fID0gaW5oZXJpdCB8fCBXb3JrZXIucHJvdG90eXBlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIFdvcmtlci50ZW1wbGF0ZSA9IHtcbiAgICBwcm9wOiB7XG4gICAgICBzcmM6IG51bGwsXG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgY2FudmFzOiBudWxsLFxuICAgICAgaW1nOiBudWxsLFxuICAgICAgcGRmOiBudWxsLFxuICAgICAgcGFnZVNpemU6IG51bGwsXG4gICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soKSB7fVxuICAgIH0sXG4gICAgcHJvZ3Jlc3M6IHtcbiAgICAgIHZhbDogMCxcbiAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgbjogMCxcbiAgICAgIHN0YWNrOiBbXVxuICAgIH0sXG4gICAgb3B0OiB7XG4gICAgICBmaWxlbmFtZTogJ2ZpbGUucGRmJyxcbiAgICAgIG1hcmdpbjogWzAsIDAsIDAsIDBdLFxuICAgICAgZW5hYmxlTGlua3M6IHRydWUsXG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGh0bWwyY2FudmFzOiB7fSxcbiAgICAgIGpzUERGOiB7fVxuICAgIH1cbiAgfTtcbiAgLyogLS0tLS0gRlJPTSAvIFRPIC0tLS0tICovXG5cbiAgV29ya2VyLnByb3RvdHlwZS5mcm9tID0gZnVuY3Rpb24gZnJvbShzcmMsIHR5cGUpIHtcbiAgICBmdW5jdGlvbiBnZXRUeXBlKHNyYykge1xuICAgICAgc3dpdGNoIChvYmpUeXBlKHNyYykpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG5cbiAgICAgICAgY2FzZSAnZWxlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHNyYy5ub2RlTmFtZS50b0xvd2VyQ2FzZSA9PT0gJ2NhbnZhcycgPyAnY2FudmFzJyA6ICdlbGVtZW50JztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiBmcm9tX21haW4oKSB7XG4gICAgICB0eXBlID0gdHlwZSB8fCBnZXRUeXBlKHNyYyk7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgICBzcmM6IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgaW5uZXJIVE1MOiBzcmNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnZWxlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnY2FudmFzJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoe1xuICAgICAgICAgICAgY2FudmFzOiBzcmNcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgICBpbWc6IHNyY1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1Vua25vd24gc291cmNlIHR5cGUuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgV29ya2VyLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIHRvKHRhcmdldCkge1xuICAgIC8vIFJvdXRlIHRoZSAndG8nIHJlcXVlc3QgdG8gdGhlIGFwcHJvcHJpYXRlIG1ldGhvZC5cbiAgICBzd2l0Y2ggKHRhcmdldCkge1xuICAgICAgY2FzZSAnY29udGFpbmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db250YWluZXIoKTtcblxuICAgICAgY2FzZSAnY2FudmFzJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9DYW52YXMoKTtcblxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9JbWcoKTtcblxuICAgICAgY2FzZSAncGRmJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9QZGYoKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgdGFyZ2V0LicpO1xuICAgIH1cbiAgfTtcblxuICBXb3JrZXIucHJvdG90eXBlLnRvQ29udGFpbmVyID0gZnVuY3Rpb24gdG9Db250YWluZXIoKSB7XG4gICAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gICAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tTcmMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wLnNyYyB8fCB0aGlzLmVycm9yKCdDYW5ub3QgZHVwbGljYXRlIC0gbm8gc291cmNlIEhUTUwuJyk7XG4gICAgfSwgZnVuY3Rpb24gY2hlY2tQYWdlU2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3AucGFnZVNpemUgfHwgdGhpcy5zZXRQYWdlU2l6ZSgpO1xuICAgIH1dO1xuICAgIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gdG9Db250YWluZXJfbWFpbigpIHtcbiAgICAgIC8vIERlZmluZSB0aGUgQ1NTIHN0eWxlcyBmb3IgdGhlIGNvbnRhaW5lciBhbmQgaXRzIG92ZXJsYXkgcGFyZW50LlxuICAgICAgdmFyIG92ZXJsYXlDU1MgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHpJbmRleDogMTAwMCxcbiAgICAgICAgbGVmdDogJy0xMDAwMDBweCcsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIHRvcDogMFxuICAgICAgfTtcbiAgICAgIHZhciBjb250YWluZXJDU1MgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KHRoaXMucHJvcC5zcmMuY2xpZW50V2lkdGgsIHRoaXMucHJvcC5zcmMuc2Nyb2xsV2lkdGgsIHRoaXMucHJvcC5zcmMub2Zmc2V0V2lkdGgpICsgJ3B4JyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbWFyZ2luOiAnYXV0bycsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJ1xuICAgICAgfTsgLy8gU2V0IHRoZSBvdmVybGF5IHRvIGhpZGRlbiAoY291bGQgYmUgY2hhbmdlZCBpbiB0aGUgZnV0dXJlIHRvIHByb3ZpZGUgYSBwcmludCBwcmV2aWV3KS5cblxuICAgICAgdmFyIHNvdXJjZSA9IGNsb25lTm9kZSh0aGlzLnByb3Auc3JjLCB0aGlzLm9wdC5odG1sMmNhbnZhcy5qYXZhc2NyaXB0RW5hYmxlZCk7XG5cbiAgICAgIGlmIChzb3VyY2UudGFnTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGNvbnRhaW5lckNTUy5oZWlnaHQgPSBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQpICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wLm92ZXJsYXkgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2h0bWwycGRmX19vdmVybGF5JyxcbiAgICAgICAgc3R5bGU6IG92ZXJsYXlDU1NcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wLmNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnaHRtbDJwZGZfX2NvbnRhaW5lcicsXG4gICAgICAgIHN0eWxlOiBjb250YWluZXJDU1NcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wLmNvbnRhaW5lci5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICAgICAgdGhpcy5wcm9wLmNvbnRhaW5lci5maXJzdENoaWxkLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBjbGVhcjogJ2JvdGgnLFxuICAgICAgICAgIGJvcmRlcjogJzAgbm9uZSB0cmFuc3BhcmVudCcsXG4gICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHRoaXMucHJvcC5jb250YWluZXIuc3R5bGUuZmxvYXQgPSAnbm9uZSc7XG4gICAgICB0aGlzLnByb3Aub3ZlcmxheS5hcHBlbmRDaGlsZCh0aGlzLnByb3AuY29udGFpbmVyKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wcm9wLm92ZXJsYXkpO1xuICAgICAgdGhpcy5wcm9wLmNvbnRhaW5lci5maXJzdENoaWxkLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIHRoaXMucHJvcC5jb250YWluZXIuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5wcm9wLmNvbnRhaW5lci5maXJzdENoaWxkLmNsaWVudEhlaWdodCwgdGhpcy5wcm9wLmNvbnRhaW5lci5maXJzdENoaWxkLnNjcm9sbEhlaWdodCwgdGhpcy5wcm9wLmNvbnRhaW5lci5maXJzdENoaWxkLm9mZnNldEhlaWdodCkgKyAncHgnO1xuICAgIH0pO1xuICB9O1xuXG4gIFdvcmtlci5wcm90b3R5cGUudG9DYW52YXMgPSBmdW5jdGlvbiB0b0NhbnZhcygpIHtcbiAgICAvLyBTZXQgdXAgZnVuY3Rpb24gcHJlcmVxdWlzaXRlcy5cbiAgICB2YXIgcHJlcmVxcyA9IFtmdW5jdGlvbiBjaGVja0NvbnRhaW5lcigpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMucHJvcC5jb250YWluZXIpIHx8IHRoaXMudG9Db250YWluZXIoKTtcbiAgICB9XTsgLy8gRnVsZmlsbCBwcmVyZXFzIHRoZW4gY3JlYXRlIHRoZSBjYW52YXMuXG5cbiAgICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS50aGVuKGZ1bmN0aW9uIHRvQ2FudmFzX21haW4oKSB7XG4gICAgICAvLyBIYW5kbGUgb2xkLWZhc2hpb25lZCAnb25yZW5kZXJlZCcgYXJndW1lbnQuXG4gICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0Lmh0bWwyY2FudmFzKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9ucmVuZGVyZWQ7XG5cbiAgICAgIGlmICghdGhpcy5pc0h0bWwyQ2FudmFzTG9hZGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaHRtbDJjYW52YXModGhpcy5wcm9wLmNvbnRhaW5lciwgb3B0aW9ucyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiB0b0NhbnZhc19wb3N0KGNhbnZhcykge1xuICAgICAgLy8gSGFuZGxlIG9sZC1mYXNoaW9uZWQgJ29ucmVuZGVyZWQnIGFyZ3VtZW50LlxuICAgICAgdmFyIG9uUmVuZGVyZWQgPSB0aGlzLm9wdC5odG1sMmNhbnZhcy5vbnJlbmRlcmVkIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICBvblJlbmRlcmVkKGNhbnZhcyk7XG4gICAgICB0aGlzLnByb3AuY2FudmFzID0gY2FudmFzO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLnByb3Aub3ZlcmxheSk7XG4gICAgfSk7XG4gIH07XG5cbiAgV29ya2VyLnByb3RvdHlwZS50b0NvbnRleHQyZCA9IGZ1bmN0aW9uIHRvQ29udGV4dDJkKCkge1xuICAgIC8vIFNldCB1cCBmdW5jdGlvbiBwcmVyZXF1aXNpdGVzLlxuICAgIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrQ29udGFpbmVyKCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5wcm9wLmNvbnRhaW5lcikgfHwgdGhpcy50b0NvbnRhaW5lcigpO1xuICAgIH1dOyAvLyBGdWxmaWxsIHByZXJlcXMgdGhlbiBjcmVhdGUgdGhlIGNhbnZhcy5cblxuICAgIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gdG9Db250ZXh0MmRfbWFpbigpIHtcbiAgICAgIC8vIEhhbmRsZSBvbGQtZmFzaGlvbmVkICdvbnJlbmRlcmVkJyBhcmd1bWVudC5cbiAgICAgIHZhciBwZGYgPSB0aGlzLm9wdC5qc1BERjtcbiAgICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICBhbGxvd1RhaW50OiB0cnVlLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgaW1hZ2VUaW1lb3V0OiAxNTAwMCxcbiAgICAgICAgbG9nZ2luZzogdHJ1ZSxcbiAgICAgICAgcHJveHk6IG51bGwsXG4gICAgICAgIHJlbW92ZUNvbnRhaW5lcjogdHJ1ZSxcbiAgICAgICAgZm9yZWlnbk9iamVjdFJlbmRlcmluZzogZmFsc2UsXG4gICAgICAgIHVzZUNPUlM6IGZhbHNlXG4gICAgICB9LCB0aGlzLm9wdC5odG1sMmNhbnZhcyk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5vbnJlbmRlcmVkO1xuICAgICAgcGRmLmNvbnRleHQyZC5hdXRvUGFnaW5nID0gdHJ1ZTtcbiAgICAgIHBkZi5jb250ZXh0MmQucG9zWCA9IHRoaXMub3B0Lng7XG4gICAgICBwZGYuY29udGV4dDJkLnBvc1kgPSB0aGlzLm9wdC55O1xuICAgICAgb3B0aW9ucy53aW5kb3dIZWlnaHQgPSBvcHRpb25zLndpbmRvd0hlaWdodCB8fCAwO1xuICAgICAgb3B0aW9ucy53aW5kb3dIZWlnaHQgPSBvcHRpb25zLndpbmRvd0hlaWdodCA9PSAwID8gTWF0aC5tYXgodGhpcy5wcm9wLmNvbnRhaW5lci5jbGllbnRIZWlnaHQsIHRoaXMucHJvcC5jb250YWluZXIuc2Nyb2xsSGVpZ2h0LCB0aGlzLnByb3AuY29udGFpbmVyLm9mZnNldEhlaWdodCkgOiBvcHRpb25zLndpbmRvd0hlaWdodDtcblxuICAgICAgaWYgKCF0aGlzLmlzSHRtbDJDYW52YXNMb2FkZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBodG1sMmNhbnZhcyh0aGlzLnByb3AuY29udGFpbmVyLCBvcHRpb25zKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIHRvQ29udGV4dDJkX3Bvc3QoY2FudmFzKSB7XG4gICAgICAvLyBIYW5kbGUgb2xkLWZhc2hpb25lZCAnb25yZW5kZXJlZCcgYXJndW1lbnQuXG4gICAgICB2YXIgb25SZW5kZXJlZCA9IHRoaXMub3B0Lmh0bWwyY2FudmFzLm9ucmVuZGVyZWQgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAgIG9uUmVuZGVyZWQoY2FudmFzKTtcbiAgICAgIHRoaXMucHJvcC5jYW52YXMgPSBjYW52YXM7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMucHJvcC5vdmVybGF5KTtcbiAgICB9KTtcbiAgfTtcblxuICBXb3JrZXIucHJvdG90eXBlLnRvSW1nID0gZnVuY3Rpb24gdG9JbWcoKSB7XG4gICAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gICAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tDYW52YXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wLmNhbnZhcyB8fCB0aGlzLnRvQ2FudmFzKCk7XG4gICAgfV07IC8vIEZ1bGZpbGwgcHJlcmVxcyB0aGVuIGNyZWF0ZSB0aGUgaW1hZ2UuXG5cbiAgICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS50aGVuKGZ1bmN0aW9uIHRvSW1nX21haW4oKSB7XG4gICAgICB2YXIgaW1nRGF0YSA9IHRoaXMucHJvcC5jYW52YXMudG9EYXRhVVJMKCdpbWFnZS8nICsgdGhpcy5vcHQuaW1hZ2UudHlwZSwgdGhpcy5vcHQuaW1hZ2UucXVhbGl0eSk7XG4gICAgICB0aGlzLnByb3AuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICB0aGlzLnByb3AuaW1nLnNyYyA9IGltZ0RhdGE7XG4gICAgfSk7XG4gIH07XG5cbiAgV29ya2VyLnByb3RvdHlwZS50b1BkZiA9IGZ1bmN0aW9uIHRvUGRmKCkge1xuICAgIC8vIFNldCB1cCBmdW5jdGlvbiBwcmVyZXF1aXNpdGVzLlxuICAgIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrQ29udGV4dDJkKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Db250ZXh0MmQoKTtcbiAgICB9IC8vZnVuY3Rpb24gY2hlY2tDYW52YXMoKSB7IHJldHVybiB0aGlzLnByb3AuY2FudmFzIHx8IHRoaXMudG9DYW52YXMoKTsgfVxuICAgIF07IC8vIEZ1bGZpbGwgcHJlcmVxcyB0aGVuIGNyZWF0ZSB0aGUgaW1hZ2UuXG5cbiAgICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS50aGVuKGZ1bmN0aW9uIHRvUGRmX21haW4oKSB7XG4gICAgICAvLyBDcmVhdGUgbG9jYWwgY29waWVzIG9mIGZyZXF1ZW50bHkgdXNlZCBwcm9wZXJ0aWVzLlxuICAgICAgdGhpcy5wcm9wLnBkZiA9IHRoaXMucHJvcC5wZGYgfHwgdGhpcy5vcHQuanNQREY7XG4gICAgfSk7XG4gIH07XG4gIC8qIC0tLS0tIE9VVFBVVCAvIFNBVkUgLS0tLS0gKi9cblxuXG4gIFdvcmtlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gb3V0cHV0KHR5cGUsIG9wdGlvbnMsIHNyYykge1xuICAgIC8vIFJlZGlyZWN0IHJlcXVlc3RzIHRvIHRoZSBjb3JyZWN0IGZ1bmN0aW9uIChvdXRwdXRQZGYgLyBvdXRwdXRJbWcpLlxuICAgIHNyYyA9IHNyYyB8fCAncGRmJztcblxuICAgIGlmIChzcmMudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycgfHwgc3JjLnRvTG93ZXJDYXNlKCkgPT09ICdpbWFnZScpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dEltZyh0eXBlLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0UGRmKHR5cGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICBXb3JrZXIucHJvdG90eXBlLm91dHB1dFBkZiA9IGZ1bmN0aW9uIG91dHB1dFBkZih0eXBlLCBvcHRpb25zKSB7XG4gICAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gICAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tQZGYoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wLnBkZiB8fCB0aGlzLnRvUGRmKCk7XG4gICAgfV07IC8vIEZ1bGZpbGwgcHJlcmVxcyB0aGVuIHBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIG91dHB1dC5cblxuICAgIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gb3V0cHV0UGRmX21haW4oKSB7XG4gICAgICAvKiBDdXJyZW50bHkgaW1wbGVtZW50ZWQgb3V0cHV0IHR5cGVzOlxuICAgICAgICogICAgaHR0cHM6Ly9yYXdnaXQuY29tL01yUmlvL2pzUERGL21hc3Rlci9kb2NzL2pzcGRmLmpzLmh0bWwjbGluZTk5MlxuICAgICAgICogIHNhdmUob3B0aW9ucyksIGFycmF5YnVmZmVyLCBibG9iLCBibG9idXJpL2Jsb2J1cmwsXG4gICAgICAgKiAgZGF0YXVyaXN0cmluZy9kYXRhdXJsc3RyaW5nLCBkYXRhdXJsbmV3d2luZG93LCBkYXRhdXJpL2RhdGF1cmxcbiAgICAgICAqL1xuICAgICAgcmV0dXJuIHRoaXMucHJvcC5wZGYub3V0cHV0KHR5cGUsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFdvcmtlci5wcm90b3R5cGUub3V0cHV0SW1nID0gZnVuY3Rpb24gb3V0cHV0SW1nKHR5cGUsIG9wdGlvbnMpIHtcbiAgICAvLyBTZXQgdXAgZnVuY3Rpb24gcHJlcmVxdWlzaXRlcy5cbiAgICB2YXIgcHJlcmVxcyA9IFtmdW5jdGlvbiBjaGVja0ltZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3AuaW1nIHx8IHRoaXMudG9JbWcoKTtcbiAgICB9XTsgLy8gRnVsZmlsbCBwcmVyZXFzIHRoZW4gcGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgb3V0cHV0LlxuXG4gICAgcmV0dXJuIHRoaXMudGhlbkxpc3QocHJlcmVxcykudGhlbihmdW5jdGlvbiBvdXRwdXRJbWdfbWFpbigpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wLmltZztcblxuICAgICAgICBjYXNlICdkYXRhdXJpc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnZGF0YXVybHN0cmluZyc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5pbWcuc3JjO1xuXG4gICAgICAgIGNhc2UgJ2RhdGF1cmknOlxuICAgICAgICBjYXNlICdkYXRhdXJsJzpcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9IHRoaXMucHJvcC5pbWcuc3JjO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgJ0ltYWdlIG91dHB1dCB0eXBlIFwiJyArIHR5cGUgKyAnXCIgaXMgbm90IHN1cHBvcnRlZC4nO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFdvcmtlci5wcm90b3R5cGUuaXNIdG1sMkNhbnZhc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIGdsb2JhbC5odG1sMmNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiaHRtbDJjYW52YXMgbm90IGxvYWRlZC5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBXb3JrZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKGZpbGVuYW1lKSB7XG4gICAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gICAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tQZGYoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wLnBkZiB8fCB0aGlzLnRvUGRmKCk7XG4gICAgfV07XG5cbiAgICBpZiAoIXRoaXMuaXNIdG1sMkNhbnZhc0xvYWRlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGdWxmaWxsIHByZXJlcXMsIHVwZGF0ZSB0aGUgZmlsZW5hbWUgKGlmIHByb3ZpZGVkKSwgYW5kIHNhdmUgdGhlIFBERi5cblxuXG4gICAgcmV0dXJuIHRoaXMudGhlbkxpc3QocHJlcmVxcykuc2V0KGZpbGVuYW1lID8ge1xuICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lXG4gICAgfSA6IG51bGwpLnRoZW4oZnVuY3Rpb24gc2F2ZV9tYWluKCkge1xuICAgICAgdGhpcy5wcm9wLnBkZi5zYXZlKHRoaXMub3B0LmZpbGVuYW1lKTtcbiAgICB9KTtcbiAgfTtcblxuICBXb3JrZXIucHJvdG90eXBlLmRvQ2FsbGJhY2sgPSBmdW5jdGlvbiBkb0NhbGxiYWNrKGZpbGVuYW1lKSB7XG4gICAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gICAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tQZGYoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wLnBkZiB8fCB0aGlzLnRvUGRmKCk7XG4gICAgfV07XG5cbiAgICBpZiAoIXRoaXMuaXNIdG1sMkNhbnZhc0xvYWRlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGdWxmaWxsIHByZXJlcXMsIHVwZGF0ZSB0aGUgZmlsZW5hbWUgKGlmIHByb3ZpZGVkKSwgYW5kIHNhdmUgdGhlIFBERi5cblxuXG4gICAgcmV0dXJuIHRoaXMudGhlbkxpc3QocHJlcmVxcykudGhlbihmdW5jdGlvbiBkb0NhbGxiYWNrX21haW4oKSB7XG4gICAgICB0aGlzLnByb3AuY2FsbGJhY2sodGhpcy5wcm9wLnBkZik7XG4gICAgfSk7XG4gIH07XG4gIC8qIC0tLS0tIFNFVCAvIEdFVCAtLS0tLSAqL1xuXG5cbiAgV29ya2VyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQob3B0KSB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50IG9yZGVyZWQgcGFpcnM/XG4gICAgLy8gU2lsZW50bHkgaWdub3JlIGludmFsaWQgb3IgZW1wdHkgaW5wdXQuXG4gICAgaWYgKG9ialR5cGUob3B0KSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gQnVpbGQgYW4gYXJyYXkgb2Ygc2V0dGVyIGZ1bmN0aW9ucyB0byBxdWV1ZS5cblxuXG4gICAgdmFyIGZucyA9IE9iamVjdC5rZXlzKG9wdCB8fCB7fSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gV29ya2VyLnRlbXBsYXRlLnByb3ApIHtcbiAgICAgICAgLy8gU2V0IHByZS1kZWZpbmVkIHByb3BlcnRpZXMuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRfcHJvcCgpIHtcbiAgICAgICAgICB0aGlzLnByb3Bba2V5XSA9IG9wdFtrZXldO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdtYXJnaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWFyZ2luLmJpbmQodGhpcywgb3B0Lm1hcmdpbik7XG5cbiAgICAgICAgICBjYXNlICdqc1BERic6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2V0X2pzUERGKCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdC5qc1BERiA9IG9wdC5qc1BERjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0UGFnZVNpemUoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlICdwYWdlU2l6ZSc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQYWdlU2l6ZS5iaW5kKHRoaXMsIG9wdC5wYWdlU2l6ZSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gU2V0IGFueSBvdGhlciBwcm9wZXJ0aWVzIGluIG9wdC5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRfb3B0KCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdFtrZXldID0gb3B0W2tleV07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcyk7IC8vIFNldCBwcm9wZXJ0aWVzIHdpdGhpbiB0aGUgcHJvbWlzZSBjaGFpbi5cblxuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gc2V0X21haW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuTGlzdChmbnMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFdvcmtlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSwgY2JrKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiBnZXRfbWFpbigpIHtcbiAgICAgIC8vIEZldGNoIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHksIGVpdGhlciBhcyBhIHByZWRlZmluZWQgcHJvcCBvciBpbiBvcHQuXG4gICAgICB2YXIgdmFsID0ga2V5IGluIFdvcmtlci50ZW1wbGF0ZS5wcm9wID8gdGhpcy5wcm9wW2tleV0gOiB0aGlzLm9wdFtrZXldO1xuICAgICAgcmV0dXJuIGNiayA/IGNiayh2YWwpIDogdmFsO1xuICAgIH0pO1xuICB9O1xuXG4gIFdvcmtlci5wcm90b3R5cGUuc2V0TWFyZ2luID0gZnVuY3Rpb24gc2V0TWFyZ2luKG1hcmdpbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gc2V0TWFyZ2luX21haW4oKSB7XG4gICAgICAvLyBQYXJzZSB0aGUgbWFyZ2luIHByb3BlcnR5LlxuICAgICAgc3dpdGNoIChvYmpUeXBlKG1hcmdpbikpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBtYXJnaW4gPSBbbWFyZ2luLCBtYXJnaW4sIG1hcmdpbiwgbWFyZ2luXTtcblxuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgaWYgKG1hcmdpbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIG1hcmdpbiA9IFttYXJnaW5bMF0sIG1hcmdpblsxXSwgbWFyZ2luWzBdLCBtYXJnaW5bMV1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXJnaW4ubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignSW52YWxpZCBtYXJnaW4gYXJyYXkuJyk7XG4gICAgICB9IC8vIFNldCB0aGUgbWFyZ2luIHByb3BlcnR5LCB0aGVuIHVwZGF0ZSBwYWdlU2l6ZS5cblxuXG4gICAgICB0aGlzLm9wdC5tYXJnaW4gPSBtYXJnaW47XG4gICAgfSkudGhlbih0aGlzLnNldFBhZ2VTaXplKTtcbiAgfTtcblxuICBXb3JrZXIucHJvdG90eXBlLnNldFBhZ2VTaXplID0gZnVuY3Rpb24gc2V0UGFnZVNpemUocGFnZVNpemUpIHtcbiAgICBmdW5jdGlvbiB0b1B4KHZhbCwgaykge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsICogayAvIDcyICogOTYpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gc2V0UGFnZVNpemVfbWFpbigpIHtcbiAgICAgIC8vIFJldHJpZXZlIHBhZ2Utc2l6ZSBiYXNlZCBvbiBqc1BERiBzZXR0aW5ncywgaWYgbm90IGV4cGxpY2l0bHkgcHJvdmlkZWQuXG4gICAgICBwYWdlU2l6ZSA9IHBhZ2VTaXplIHx8IGpzUERGLmdldFBhZ2VTaXplKHRoaXMub3B0LmpzUERGKTsgLy8gQWRkICdpbm5lcicgZmllbGQgaWYgbm90IHByZXNlbnQuXG5cbiAgICAgIGlmICghcGFnZVNpemUuaGFzT3duUHJvcGVydHkoJ2lubmVyJykpIHtcbiAgICAgICAgcGFnZVNpemUuaW5uZXIgPSB7XG4gICAgICAgICAgd2lkdGg6IHBhZ2VTaXplLndpZHRoIC0gdGhpcy5vcHQubWFyZ2luWzFdIC0gdGhpcy5vcHQubWFyZ2luWzNdLFxuICAgICAgICAgIGhlaWdodDogcGFnZVNpemUuaGVpZ2h0IC0gdGhpcy5vcHQubWFyZ2luWzBdIC0gdGhpcy5vcHQubWFyZ2luWzJdXG4gICAgICAgIH07XG4gICAgICAgIHBhZ2VTaXplLmlubmVyLnB4ID0ge1xuICAgICAgICAgIHdpZHRoOiB0b1B4KHBhZ2VTaXplLmlubmVyLndpZHRoLCBwYWdlU2l6ZS5rKSxcbiAgICAgICAgICBoZWlnaHQ6IHRvUHgocGFnZVNpemUuaW5uZXIuaGVpZ2h0LCBwYWdlU2l6ZS5rKVxuICAgICAgICB9O1xuICAgICAgICBwYWdlU2l6ZS5pbm5lci5yYXRpbyA9IHBhZ2VTaXplLmlubmVyLmhlaWdodCAvIHBhZ2VTaXplLmlubmVyLndpZHRoO1xuICAgICAgfSAvLyBBdHRhY2ggcGFnZVNpemUgdG8gdGhpcy5cblxuXG4gICAgICB0aGlzLnByb3AucGFnZVNpemUgPSBwYWdlU2l6ZTtcbiAgICB9KTtcbiAgfTtcblxuICBXb3JrZXIucHJvdG90eXBlLnNldFByb2dyZXNzID0gZnVuY3Rpb24gc2V0UHJvZ3Jlc3ModmFsLCBzdGF0ZSwgbiwgc3RhY2spIHtcbiAgICAvLyBJbW1lZGlhdGVseSB1cGRhdGUgYWxsIHByb2dyZXNzIHZhbHVlcy5cbiAgICBpZiAodmFsICE9IG51bGwpIHRoaXMucHJvZ3Jlc3MudmFsID0gdmFsO1xuICAgIGlmIChzdGF0ZSAhPSBudWxsKSB0aGlzLnByb2dyZXNzLnN0YXRlID0gc3RhdGU7XG4gICAgaWYgKG4gIT0gbnVsbCkgdGhpcy5wcm9ncmVzcy5uID0gbjtcbiAgICBpZiAoc3RhY2sgIT0gbnVsbCkgdGhpcy5wcm9ncmVzcy5zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMucHJvZ3Jlc3MucmF0aW8gPSB0aGlzLnByb2dyZXNzLnZhbCAvIHRoaXMucHJvZ3Jlc3Muc3RhdGU7IC8vIFJldHVybiB0aGlzIGZvciBjb21tYW5kIGNoYWluaW5nLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgV29ya2VyLnByb3RvdHlwZS51cGRhdGVQcm9ncmVzcyA9IGZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzKHZhbCwgc3RhdGUsIG4sIHN0YWNrKSB7XG4gICAgLy8gSW1tZWRpYXRlbHkgdXBkYXRlIGFsbCBwcm9ncmVzcyB2YWx1ZXMsIHVzaW5nIHNldFByb2dyZXNzLlxuICAgIHJldHVybiB0aGlzLnNldFByb2dyZXNzKHZhbCA/IHRoaXMucHJvZ3Jlc3MudmFsICsgdmFsIDogbnVsbCwgc3RhdGUgPyBzdGF0ZSA6IG51bGwsIG4gPyB0aGlzLnByb2dyZXNzLm4gKyBuIDogbnVsbCwgc3RhY2sgPyB0aGlzLnByb2dyZXNzLnN0YWNrLmNvbmNhdChzdGFjaykgOiBudWxsKTtcbiAgfTtcbiAgLyogLS0tLS0gUFJPTUlTRSBNQVBQSU5HIC0tLS0tICovXG5cblxuICBXb3JrZXIucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgLy8gV3JhcCBgdGhpc2AgZm9yIGVuY2Fwc3VsYXRpb24uXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLnRoZW5Db3JlKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBmdW5jdGlvbiB0aGVuX21haW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyB3aGlsZSBxdWV1aW5nLCBjYWxsaW5nLCBhbmQgcmVzb2x2aW5nIGB0aGVuYC5cbiAgICAgIHNlbGYudXBkYXRlUHJvZ3Jlc3MobnVsbCwgbnVsbCwgMSwgW29uRnVsZmlsbGVkXSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsIGZ1bmN0aW9uIHRoZW5fcHJlKHZhbCkge1xuICAgICAgICBzZWxmLnVwZGF0ZVByb2dyZXNzKG51bGwsIG9uRnVsZmlsbGVkKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpLnRoZW4oZnVuY3Rpb24gdGhlbl9wb3N0KHZhbCkge1xuICAgICAgICBzZWxmLnVwZGF0ZVByb2dyZXNzKDEpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgV29ya2VyLnByb3RvdHlwZS50aGVuQ29yZSA9IGZ1bmN0aW9uIHRoZW5Db3JlKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCB0aGVuQmFzZSkge1xuICAgIC8vIEhhbmRsZSBvcHRpb25hbCB0aGVuQmFzZSBwYXJhbWV0ZXIuXG4gICAgdGhlbkJhc2UgPSB0aGVuQmFzZSB8fCBQcm9taXNlLnByb3RvdHlwZS50aGVuOyAvLyBXcmFwIGB0aGlzYCBmb3IgZW5jYXBzdWxhdGlvbiBhbmQgYmluZCBpdCB0byB0aGUgcHJvbWlzZSBoYW5kbGVycy5cblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChvbkZ1bGZpbGxlZCkge1xuICAgICAgb25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZC5iaW5kKHNlbGYpO1xuICAgIH1cblxuICAgIGlmIChvblJlamVjdGVkKSB7XG4gICAgICBvblJlamVjdGVkID0gb25SZWplY3RlZC5iaW5kKHNlbGYpO1xuICAgIH0gLy8gQ2FzdCBzZWxmIGludG8gYSBQcm9taXNlIHRvIGF2b2lkIHBvbHlmaWxscyByZWN1cnNpdmVseSBkZWZpbmluZyBgdGhlbmAuXG5cblxuICAgIHZhciBpc05hdGl2ZSA9IFByb21pc2UudG9TdHJpbmcoKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgIT09IC0xICYmIFByb21pc2UubmFtZSA9PT0gJ1Byb21pc2UnO1xuICAgIHZhciBzZWxmUHJvbWlzZSA9IGlzTmF0aXZlID8gc2VsZiA6IFdvcmtlci5jb252ZXJ0KE9iamVjdC5hc3NpZ24oe30sIHNlbGYpLCBQcm9taXNlLnByb3RvdHlwZSk7IC8vIFJldHVybiB0aGUgcHJvbWlzZSwgYWZ0ZXIgY2FzdGluZyBpdCBpbnRvIGEgV29ya2VyIGFuZCBwcmVzZXJ2aW5nIHByb3BzLlxuXG4gICAgdmFyIHJldHVyblZhbCA9IHRoZW5CYXNlLmNhbGwoc2VsZlByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICByZXR1cm4gV29ya2VyLmNvbnZlcnQocmV0dXJuVmFsLCBzZWxmLl9fcHJvdG9fXyk7XG4gIH07XG5cbiAgV29ya2VyLnByb3RvdHlwZS50aGVuRXh0ZXJuYWwgPSBmdW5jdGlvbiB0aGVuRXh0ZXJuYWwob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAvLyBDYWxsIGB0aGVuYCBhbmQgcmV0dXJuIGEgc3RhbmRhcmQgcHJvbWlzZSAoZXhpdHMgdGhlIFdvcmtlciBjaGFpbikuXG4gICAgcmV0dXJuIFByb21pc2UucHJvdG90eXBlLnRoZW4uY2FsbCh0aGlzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH07XG5cbiAgV29ya2VyLnByb3RvdHlwZS50aGVuTGlzdCA9IGZ1bmN0aW9uIHRoZW5MaXN0KGZucykge1xuICAgIC8vIFF1ZXVlIGEgc2VyaWVzIG9mIHByb21pc2UgJ2ZhY3RvcmllcycgaW50byB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZm5zLmZvckVhY2goZnVuY3Rpb24gdGhlbkxpc3RfZm9yRWFjaChmbikge1xuICAgICAgc2VsZiA9IHNlbGYudGhlbkNvcmUoZm4pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIFdvcmtlci5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIC8vIEJpbmQgYHRoaXNgIHRvIHRoZSBwcm9taXNlIGhhbmRsZXIsIGNhbGwgYGNhdGNoYCwgYW5kIHJldHVybiBhIFdvcmtlci5cbiAgICBpZiAob25SZWplY3RlZCkge1xuICAgICAgb25SZWplY3RlZCA9IG9uUmVqZWN0ZWQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0dXJuVmFsID0gUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10uY2FsbCh0aGlzLCBvblJlamVjdGVkKTtcbiAgICByZXR1cm4gV29ya2VyLmNvbnZlcnQocmV0dXJuVmFsLCB0aGlzKTtcbiAgfTtcblxuICBXb3JrZXIucHJvdG90eXBlLmNhdGNoRXh0ZXJuYWwgPSBmdW5jdGlvbiBjYXRjaEV4dGVybmFsKG9uUmVqZWN0ZWQpIHtcbiAgICAvLyBDYWxsIGBjYXRjaGAgYW5kIHJldHVybiBhIHN0YW5kYXJkIHByb21pc2UgKGV4aXRzIHRoZSBXb3JrZXIgY2hhaW4pLlxuICAgIHJldHVybiBQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXS5jYWxsKHRoaXMsIG9uUmVqZWN0ZWQpO1xuICB9O1xuXG4gIFdvcmtlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgICAvLyBUaHJvdyB0aGUgZXJyb3IgaW4gdGhlIFByb21pc2UgY2hhaW4uXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiBlcnJvcl9tYWluKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfSk7XG4gIH07XG4gIC8qIC0tLS0tIEFMSUFTRVMgLS0tLS0gKi9cblxuXG4gIFdvcmtlci5wcm90b3R5cGUudXNpbmcgPSBXb3JrZXIucHJvdG90eXBlLnNldDtcbiAgV29ya2VyLnByb3RvdHlwZS5zYXZlQXMgPSBXb3JrZXIucHJvdG90eXBlLnNhdmU7XG4gIFdvcmtlci5wcm90b3R5cGUuZXhwb3J0ID0gV29ya2VyLnByb3RvdHlwZS5vdXRwdXQ7XG4gIFdvcmtlci5wcm90b3R5cGUucnVuID0gV29ya2VyLnByb3RvdHlwZS50aGVuOyAvLyBHZXQgZGltZW5zaW9ucyBvZiBhIFBERiBwYWdlLCBhcyBkZXRlcm1pbmVkIGJ5IGpzUERGLlxuXG4gIGpzUERGLmdldFBhZ2VTaXplID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uLCB1bml0LCBmb3JtYXQpIHtcbiAgICAvLyBEZWNvZGUgb3B0aW9ucyBvYmplY3RcbiAgICBpZiAoX3R5cGVvZihvcmllbnRhdGlvbikgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IG9yaWVudGF0aW9uO1xuICAgICAgb3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uO1xuICAgICAgdW5pdCA9IG9wdGlvbnMudW5pdCB8fCB1bml0O1xuICAgICAgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0O1xuICAgIH0gLy8gRGVmYXVsdCBvcHRpb25zXG5cblxuICAgIHVuaXQgPSB1bml0IHx8ICdtbSc7XG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICdhNCc7XG4gICAgb3JpZW50YXRpb24gPSAoJycgKyAob3JpZW50YXRpb24gfHwgJ1AnKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgZm9ybWF0X2FzX3N0cmluZyA9ICgnJyArIGZvcm1hdCkudG9Mb3dlckNhc2UoKTsgLy8gU2l6ZSBpbiBwdCBvZiB2YXJpb3VzIHBhcGVyIGZvcm1hdHNcblxuICAgIHZhciBwYWdlRm9ybWF0cyA9IHtcbiAgICAgICdhMCc6IFsyMzgzLjk0LCAzMzcwLjM5XSxcbiAgICAgICdhMSc6IFsxNjgzLjc4LCAyMzgzLjk0XSxcbiAgICAgICdhMic6IFsxMTkwLjU1LCAxNjgzLjc4XSxcbiAgICAgICdhMyc6IFs4NDEuODksIDExOTAuNTVdLFxuICAgICAgJ2E0JzogWzU5NS4yOCwgODQxLjg5XSxcbiAgICAgICdhNSc6IFs0MTkuNTMsIDU5NS4yOF0sXG4gICAgICAnYTYnOiBbMjk3LjY0LCA0MTkuNTNdLFxuICAgICAgJ2E3JzogWzIwOS43NiwgMjk3LjY0XSxcbiAgICAgICdhOCc6IFsxNDcuNDAsIDIwOS43Nl0sXG4gICAgICAnYTknOiBbMTA0Ljg4LCAxNDcuNDBdLFxuICAgICAgJ2ExMCc6IFs3My43MCwgMTA0Ljg4XSxcbiAgICAgICdiMCc6IFsyODM0LjY1LCA0MDA4LjE5XSxcbiAgICAgICdiMSc6IFsyMDA0LjA5LCAyODM0LjY1XSxcbiAgICAgICdiMic6IFsxNDE3LjMyLCAyMDA0LjA5XSxcbiAgICAgICdiMyc6IFsxMDAwLjYzLCAxNDE3LjMyXSxcbiAgICAgICdiNCc6IFs3MDguNjYsIDEwMDAuNjNdLFxuICAgICAgJ2I1JzogWzQ5OC45MCwgNzA4LjY2XSxcbiAgICAgICdiNic6IFszNTQuMzMsIDQ5OC45MF0sXG4gICAgICAnYjcnOiBbMjQ5LjQ1LCAzNTQuMzNdLFxuICAgICAgJ2I4JzogWzE3NS43NSwgMjQ5LjQ1XSxcbiAgICAgICdiOSc6IFsxMjQuNzIsIDE3NS43NV0sXG4gICAgICAnYjEwJzogWzg3Ljg3LCAxMjQuNzJdLFxuICAgICAgJ2MwJzogWzI1OTkuMzcsIDM2NzYuNTRdLFxuICAgICAgJ2MxJzogWzE4MzYuODUsIDI1OTkuMzddLFxuICAgICAgJ2MyJzogWzEyOTguMjcsIDE4MzYuODVdLFxuICAgICAgJ2MzJzogWzkxOC40MywgMTI5OC4yN10sXG4gICAgICAnYzQnOiBbNjQ5LjEzLCA5MTguNDNdLFxuICAgICAgJ2M1JzogWzQ1OS4yMSwgNjQ5LjEzXSxcbiAgICAgICdjNic6IFszMjMuMTUsIDQ1OS4yMV0sXG4gICAgICAnYzcnOiBbMjI5LjYxLCAzMjMuMTVdLFxuICAgICAgJ2M4JzogWzE2MS41NywgMjI5LjYxXSxcbiAgICAgICdjOSc6IFsxMTMuMzksIDE2MS41N10sXG4gICAgICAnYzEwJzogWzc5LjM3LCAxMTMuMzldLFxuICAgICAgJ2RsJzogWzMxMS44MSwgNjIzLjYyXSxcbiAgICAgICdsZXR0ZXInOiBbNjEyLCA3OTJdLFxuICAgICAgJ2dvdmVybm1lbnQtbGV0dGVyJzogWzU3NiwgNzU2XSxcbiAgICAgICdsZWdhbCc6IFs2MTIsIDEwMDhdLFxuICAgICAgJ2p1bmlvci1sZWdhbCc6IFs1NzYsIDM2MF0sXG4gICAgICAnbGVkZ2VyJzogWzEyMjQsIDc5Ml0sXG4gICAgICAndGFibG9pZCc6IFs3OTIsIDEyMjRdLFxuICAgICAgJ2NyZWRpdC1jYXJkJzogWzE1MywgMjQzXVxuICAgIH07IC8vIFVuaXQgY29udmVyc2lvblxuXG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICdwdCc6XG4gICAgICAgIHZhciBrID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgdmFyIGsgPSA3MiAvIDI1LjQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjbSc6XG4gICAgICAgIHZhciBrID0gNzIgLyAyLjU0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW4nOlxuICAgICAgICB2YXIgayA9IDcyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncHgnOlxuICAgICAgICB2YXIgayA9IDcyIC8gOTY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwYyc6XG4gICAgICAgIHZhciBrID0gMTI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlbSc6XG4gICAgICAgIHZhciBrID0gMTI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdleCc6XG4gICAgICAgIHZhciBrID0gNjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93ICdJbnZhbGlkIHVuaXQ6ICcgKyB1bml0O1xuICAgIH0gLy8gRGltZW5zaW9ucyBhcmUgc3RvcmVkIGFzIHVzZXIgdW5pdHMgYW5kIGNvbnZlcnRlZCB0byBwb2ludHMgb24gb3V0cHV0XG5cblxuICAgIGlmIChwYWdlRm9ybWF0cy5oYXNPd25Qcm9wZXJ0eShmb3JtYXRfYXNfc3RyaW5nKSkge1xuICAgICAgdmFyIHBhZ2VIZWlnaHQgPSBwYWdlRm9ybWF0c1tmb3JtYXRfYXNfc3RyaW5nXVsxXSAvIGs7XG4gICAgICB2YXIgcGFnZVdpZHRoID0gcGFnZUZvcm1hdHNbZm9ybWF0X2FzX3N0cmluZ11bMF0gLyBrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcGFnZUhlaWdodCA9IGZvcm1hdFsxXTtcbiAgICAgICAgdmFyIHBhZ2VXaWR0aCA9IGZvcm1hdFswXTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZm9ybWF0OiAnICsgZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9IC8vIEhhbmRsZSBwYWdlIG9yaWVudGF0aW9uXG5cblxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ3AnIHx8IG9yaWVudGF0aW9uID09PSAncG9ydHJhaXQnKSB7XG4gICAgICBvcmllbnRhdGlvbiA9ICdwJztcblxuICAgICAgaWYgKHBhZ2VXaWR0aCA+IHBhZ2VIZWlnaHQpIHtcbiAgICAgICAgdmFyIHRtcCA9IHBhZ2VXaWR0aDtcbiAgICAgICAgcGFnZVdpZHRoID0gcGFnZUhlaWdodDtcbiAgICAgICAgcGFnZUhlaWdodCA9IHRtcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSAnbCcgfHwgb3JpZW50YXRpb24gPT09ICdsYW5kc2NhcGUnKSB7XG4gICAgICBvcmllbnRhdGlvbiA9ICdsJztcblxuICAgICAgaWYgKHBhZ2VIZWlnaHQgPiBwYWdlV2lkdGgpIHtcbiAgICAgICAgdmFyIHRtcCA9IHBhZ2VXaWR0aDtcbiAgICAgICAgcGFnZVdpZHRoID0gcGFnZUhlaWdodDtcbiAgICAgICAgcGFnZUhlaWdodCA9IHRtcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ0ludmFsaWQgb3JpZW50YXRpb246ICcgKyBvcmllbnRhdGlvbjtcbiAgICB9IC8vIFJldHVybiBpbmZvcm1hdGlvbiAoayBpcyB0aGUgdW5pdCBjb252ZXJzaW9uIHJhdGlvIGZyb20gcHRzKVxuXG5cbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgICd3aWR0aCc6IHBhZ2VXaWR0aCxcbiAgICAgICdoZWlnaHQnOiBwYWdlSGVpZ2h0LFxuICAgICAgJ3VuaXQnOiB1bml0LFxuICAgICAgJ2snOiBrXG4gICAgfTtcbiAgICByZXR1cm4gaW5mbztcbiAgfTtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgUERGIGZyb20gYW4gSFRNTCBlbGVtZW50IG9yIHN0cmluZyB1c2luZy5cbiAgICpcbiAgICogQG5hbWUgaHRtbFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgZWxlbWVudCBvciBIVE1MIHN0cmluZy5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIEFuIG9iamVjdCBvZiBvcHRpb25hbCBzZXR0aW5ncy5cbiAgICogQGRlc2NyaXB0aW9uIFRoZSBQbHVnaW4gbmVlZHMgaHRtbDJjYW52YXMgZnJvbSBuaWtsYXN2aFxuICAgKi9cblxuXG4gIGpzUERGQVBJLmh0bWwgPSBmdW5jdGlvbiAoc3JjLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgb3B0aW9ucy5odG1sMmNhbnZhcyA9IG9wdGlvbnMuaHRtbDJjYW52YXMgfHwge307XG4gICAgb3B0aW9ucy5odG1sMmNhbnZhcy5jYW52YXMgPSBvcHRpb25zLmh0bWwyY2FudmFzLmNhbnZhcyB8fCB0aGlzLmNhbnZhcztcbiAgICBvcHRpb25zLmpzUERGID0gb3B0aW9ucy5qc1BERiB8fCB0aGlzOyAvLyBDcmVhdGUgYSBuZXcgd29ya2VyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5cbiAgICB2YXIgcGRmID0gb3B0aW9ucy5qc1BERjtcbiAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihvcHRpb25zKTtcblxuICAgIGlmICghb3B0aW9ucy53b3JrZXIpIHtcbiAgICAgIC8vIElmIHdvcmtlciBpcyBub3Qgc2V0IHRvIHRydWUsIHBlcmZvcm0gdGhlIHRyYWRpdGlvbmFsICdzaW1wbGUnIG9wZXJhdGlvbi5cbiAgICAgIHJldHVybiB3b3JrZXIuZnJvbShzcmMpLmRvQ2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIHdvcmtlciBmb3IgbmV3IFByb21pc2UtYmFzZWQgb3BlcmF0aW9uLlxuICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKGpzUERGLkFQSSwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBcbiAqIENvcHlyaWdodCAoYykgMjAxMyBZb3Vzc2VmIEJlZGRhZCwgeW91c3NlZi5iZWRkYWRAZ21haWwuY29tXG4gKiBcbiAqIFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKmdsb2JhbCBqc1BERiAqL1xuXG4vKipcbiAqIGpzUERGIEphdmFTY3JpcHQgcGx1Z2luXG4gKlxuICogQG5hbWUgamF2YXNjcmlwdFxuICogQG1vZHVsZVxuKi9cbihmdW5jdGlvbiAoanNQREZBUEkpIHtcblxuICB2YXIganNOYW1lc09iaiwganNKc09iaiwgdGV4dDtcbiAgLyoqXG4gICogQG5hbWUgYWRkSlNcbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0ge3N0cmluZ30gamF2YXNjcmlwdCBUaGUgamF2YXNjcmlwdCB0byBiZSBlbWJlZGRlZCBpbnRvIHRoZSBQREYtZmlsZS5cbiAgKiBAcmV0dXJucyB7anNQREZ9XG4gICovXG5cbiAganNQREZBUEkuYWRkSlMgPSBmdW5jdGlvbiAoamF2YXNjcmlwdCkge1xuICAgIHRleHQgPSBqYXZhc2NyaXB0O1xuICAgIHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgncG9zdFB1dFJlc291cmNlcycsIGZ1bmN0aW9uIChqYXZhc2NyaXB0KSB7XG4gICAgICBqc05hbWVzT2JqID0gdGhpcy5pbnRlcm5hbC5uZXdPYmplY3QoKTtcbiAgICAgIHRoaXMuaW50ZXJuYWwub3V0KCc8PCcpO1xuICAgICAgdGhpcy5pbnRlcm5hbC5vdXQoJy9OYW1lcyBbKEVtYmVkZGVkSlMpICcgKyAoanNOYW1lc09iaiArIDEpICsgJyAwIFJdJyk7XG4gICAgICB0aGlzLmludGVybmFsLm91dCgnPj4nKTtcbiAgICAgIHRoaXMuaW50ZXJuYWwub3V0KCdlbmRvYmonKTtcbiAgICAgIGpzSnNPYmogPSB0aGlzLmludGVybmFsLm5ld09iamVjdCgpO1xuICAgICAgdGhpcy5pbnRlcm5hbC5vdXQoJzw8Jyk7XG4gICAgICB0aGlzLmludGVybmFsLm91dCgnL1MgL0phdmFTY3JpcHQnKTtcbiAgICAgIHRoaXMuaW50ZXJuYWwub3V0KCcvSlMgKCcgKyB0ZXh0ICsgJyknKTtcbiAgICAgIHRoaXMuaW50ZXJuYWwub3V0KCc+PicpO1xuICAgICAgdGhpcy5pbnRlcm5hbC5vdXQoJ2VuZG9iaicpO1xuICAgIH0pO1xuICAgIHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgncHV0Q2F0YWxvZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChqc05hbWVzT2JqICE9PSB1bmRlZmluZWQgJiYganNKc09iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWwub3V0KCcvTmFtZXMgPDwvSmF2YVNjcmlwdCAnICsganNOYW1lc09iaiArICcgMCBSPj4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKGpzUERGLkFQSSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNCBTdGV2ZW4gU3B1bmdpbiAoVHdlbHZlVG9uZSBMTEMpICBzdGV2ZW5AdHdlbHZldG9uZS50dlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICovXG5cbihmdW5jdGlvbiAoanNQREZBUEkpIHtcblxuICBqc1BERkFQSS5ldmVudHMucHVzaChbJ3Bvc3RQdXRSZXNvdXJjZXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBkZiA9IHRoaXM7XG4gICAgdmFyIHJ4ID0gL14oXFxkKykgMCBvYmokLzsgLy8gV3JpdGUgYWN0aW9uIGdvdG8gb2JqZWN0cyBmb3IgZWFjaCBwYWdlXG4gICAgLy8gdGhpcy5vdXRsaW5lLmRlc3RzR290byA9IFtdO1xuICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxQYWdlczsgaSsrKSB7XG4gICAgLy8gdmFyIGlkID0gcGRmLmludGVybmFsLm5ld09iamVjdCgpO1xuICAgIC8vIHRoaXMub3V0bGluZS5kZXN0c0dvdG8ucHVzaChpZCk7XG4gICAgLy8gcGRmLmludGVybmFsLndyaXRlKFwiPDwvRFtcIiArIChpICogMiArIDMpICsgXCIgMCBSIC9YWVogbnVsbFxuICAgIC8vIG51bGwgbnVsbF0vUy9Hb1RvPj4gZW5kb2JqXCIpO1xuICAgIC8vIH1cbiAgICAvL1xuICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBwZGYuaW50ZXJuYWwud3JpdGUoXCIocGFnZV9cIiArIChpICsgMSkgKyBcIilcIiArIGRlc3RzW2ldICsgXCIgMFxuICAgIC8vIFJcIik7XG4gICAgLy8gfVxuICAgIC8vXHRcdFx0XHRcblxuICAgIGlmICh0aGlzLm91dGxpbmUucm9vdC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbGluZXMgPSBwZGYub3V0bGluZS5yZW5kZXIoKS5zcGxpdCgvXFxyXFxuLyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgdmFyIG0gPSByeC5leGVjKGxpbmUpO1xuXG4gICAgICAgIGlmIChtICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb2lkID0gbVsxXTtcbiAgICAgICAgICBwZGYuaW50ZXJuYWwubmV3T2JqZWN0RGVmZXJyZWRCZWdpbihvaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBkZi5pbnRlcm5hbC53cml0ZShsaW5lKTtcbiAgICAgIH1cbiAgICB9IC8vIFRoaXMgY29kZSB3aWxsIHdyaXRlIG5hbWVkIGRlc3RpbmF0aW9uIGZvciBlYWNoIHBhZ2UgcmVmZXJlbmNlXG4gICAgLy8gKHBhZ2VfMSwgZXRjKVxuXG5cbiAgICBpZiAodGhpcy5vdXRsaW5lLmNyZWF0ZU5hbWVkRGVzdGluYXRpb25zKSB7XG4gICAgICB2YXIgdG90YWxQYWdlcyA9IHRoaXMuaW50ZXJuYWwucGFnZXMubGVuZ3RoOyAvLyBXQVJOSU5HOiB0aGlzIGFzc3VtZXMganNQREYgc3RhcnRzIG9uIHBhZ2UgMyBhbmQgcGFnZUlEc1xuICAgICAgLy8gZm9sbG93IDUsIDcsIDksIGV0Y1xuICAgICAgLy8gV3JpdGUgZGVzdGluYXRpb24gb2JqZWN0cyBmb3IgZWFjaCBwYWdlXG5cbiAgICAgIHZhciBkZXN0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsUGFnZXM7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBwZGYuaW50ZXJuYWwubmV3T2JqZWN0KCk7XG4gICAgICAgIGRlc3RzLnB1c2goaWQpO1xuICAgICAgICB2YXIgaW5mbyA9IHBkZi5pbnRlcm5hbC5nZXRQYWdlSW5mbyhpICsgMSk7XG4gICAgICAgIHBkZi5pbnRlcm5hbC53cml0ZShcIjw8IC9EW1wiICsgaW5mby5vYmpJZCArIFwiIDAgUiAvWFlaIG51bGwgbnVsbCBudWxsXT4+IGVuZG9ialwiKTtcbiAgICAgIH0gLy8gYXNzaWduIGEgbmFtZSBmb3IgZWFjaCBkZXN0aW5hdGlvblxuXG5cbiAgICAgIHZhciBuYW1lczJPaWQgPSBwZGYuaW50ZXJuYWwubmV3T2JqZWN0KCk7XG4gICAgICBwZGYuaW50ZXJuYWwud3JpdGUoJzw8IC9OYW1lcyBbICcpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBkZi5pbnRlcm5hbC53cml0ZShcIihwYWdlX1wiICsgKGkgKyAxKSArIFwiKVwiICsgZGVzdHNbaV0gKyBcIiAwIFJcIik7XG4gICAgICB9XG5cbiAgICAgIHBkZi5pbnRlcm5hbC53cml0ZSgnIF0gPj4nLCAnZW5kb2JqJyk7IC8vIHZhciBraWRzID0gcGRmLmludGVybmFsLm5ld09iamVjdCgpO1xuICAgICAgLy8gcGRmLmludGVybmFsLndyaXRlKCc8PCAvS2lkcyBbICcgKyBuYW1lczJPaWQgKyAnIDAgUicpO1xuICAgICAgLy8gcGRmLmludGVybmFsLndyaXRlKCcgXSA+PicsICdlbmRvYmonKTtcblxuICAgICAgdmFyIG5hbWVzT2lkID0gcGRmLmludGVybmFsLm5ld09iamVjdCgpO1xuICAgICAgcGRmLmludGVybmFsLndyaXRlKCc8PCAvRGVzdHMgJyArIG5hbWVzMk9pZCArIFwiIDAgUlwiKTtcbiAgICAgIHBkZi5pbnRlcm5hbC53cml0ZSgnPj4nLCAnZW5kb2JqJyk7XG4gICAgfVxuICB9XSk7XG4gIGpzUERGQVBJLmV2ZW50cy5wdXNoKFsncHV0Q2F0YWxvZycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGRmID0gdGhpcztcblxuICAgIGlmIChwZGYub3V0bGluZS5yb290LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHBkZi5pbnRlcm5hbC53cml0ZShcIi9PdXRsaW5lc1wiLCB0aGlzLm91dGxpbmUubWFrZVJlZih0aGlzLm91dGxpbmUucm9vdCkpO1xuXG4gICAgICBpZiAodGhpcy5vdXRsaW5lLmNyZWF0ZU5hbWVkRGVzdGluYXRpb25zKSB7XG4gICAgICAgIHBkZi5pbnRlcm5hbC53cml0ZShcIi9OYW1lcyBcIiArIG5hbWVzT2lkICsgXCIgMCBSXCIpO1xuICAgICAgfSAvLyBPcGVuIHdpdGggQm9va21hcmtzIHNob3dpbmdcbiAgICAgIC8vIHBkZi5pbnRlcm5hbC53cml0ZShcIi9QYWdlTW9kZSAvVXNlT3V0bGluZXNcIik7XG5cbiAgICB9XG4gIH1dKTtcbiAganNQREZBUEkuZXZlbnRzLnB1c2goWydpbml0aWFsaXplZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGRmID0gdGhpcztcbiAgICBwZGYub3V0bGluZSA9IHtcbiAgICAgIGNyZWF0ZU5hbWVkRGVzdGluYXRpb25zOiBmYWxzZSxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPcHRpb25zOiBwYWdlTnVtYmVyXG4gICAgICovXG5cbiAgICBwZGYub3V0bGluZS5hZGQgPSBmdW5jdGlvbiAocGFyZW50LCB0aXRsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9O1xuXG4gICAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5yb290O1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG5cbiAgICBwZGYub3V0bGluZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmN0eCA9IHt9O1xuICAgICAgdGhpcy5jdHgudmFsID0gJyc7XG4gICAgICB0aGlzLmN0eC5wZGYgPSBwZGY7XG4gICAgICB0aGlzLmdlbklkc19yKHRoaXMucm9vdCk7XG4gICAgICB0aGlzLnJlbmRlclJvb3QodGhpcy5yb290KTtcbiAgICAgIHRoaXMucmVuZGVySXRlbXModGhpcy5yb290KTtcbiAgICAgIHJldHVybiB0aGlzLmN0eC52YWw7XG4gICAgfTtcblxuICAgIHBkZi5vdXRsaW5lLmdlbklkc19yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5vZGUuaWQgPSBwZGYuaW50ZXJuYWwubmV3T2JqZWN0RGVmZXJyZWQoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2VuSWRzX3Iobm9kZS5jaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHBkZi5vdXRsaW5lLnJlbmRlclJvb3QgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdGhpcy5vYmpTdGFydChub2RlKTtcbiAgICAgIHRoaXMubGluZSgnL1R5cGUgL091dGxpbmVzJyk7XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5saW5lKCcvRmlyc3QgJyArIHRoaXMubWFrZVJlZihub2RlLmNoaWxkcmVuWzBdKSk7XG4gICAgICAgIHRoaXMubGluZSgnL0xhc3QgJyArIHRoaXMubWFrZVJlZihub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5saW5lKCcvQ291bnQgJyArIHRoaXMuY291bnRfcih7XG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9LCBub2RlKSk7XG4gICAgICB0aGlzLm9iakVuZCgpO1xuICAgIH07XG5cbiAgICBwZGYub3V0bGluZS5yZW5kZXJJdGVtcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGVTdHJpbmcgPSB0aGlzLmN0eC5wZGYuaW50ZXJuYWwuZ2V0Q29vcmRpbmF0ZVN0cmluZztcbiAgICAgIHZhciBnZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcgPSB0aGlzLmN0eC5wZGYuaW50ZXJuYWwuZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICB0aGlzLm9ialN0YXJ0KGl0ZW0pO1xuICAgICAgICB0aGlzLmxpbmUoJy9UaXRsZSAnICsgdGhpcy5tYWtlU3RyaW5nKGl0ZW0udGl0bGUpKTtcbiAgICAgICAgdGhpcy5saW5lKCcvUGFyZW50ICcgKyB0aGlzLm1ha2VSZWYobm9kZSkpO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHRoaXMubGluZSgnL1ByZXYgJyArIHRoaXMubWFrZVJlZihub2RlLmNoaWxkcmVuW2kgLSAxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB0aGlzLmxpbmUoJy9OZXh0ICcgKyB0aGlzLm1ha2VSZWYobm9kZS5jaGlsZHJlbltpICsgMV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmxpbmUoJy9GaXJzdCAnICsgdGhpcy5tYWtlUmVmKGl0ZW0uY2hpbGRyZW5bMF0pKTtcbiAgICAgICAgICB0aGlzLmxpbmUoJy9MYXN0ICcgKyB0aGlzLm1ha2VSZWYoaXRlbS5jaGlsZHJlbltpdGVtLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50ID0gdGhpcy5jb3VudF9yKHtcbiAgICAgICAgICBjb3VudDogMFxuICAgICAgICB9LCBpdGVtKTtcblxuICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5saW5lKCcvQ291bnQgJyArIGNvdW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLm9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoaXRlbS5vcHRpb25zLnBhZ2VOdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0IERlc3RpbmF0aW9uXG4gICAgICAgICAgICAvL1dBUk5JTkcgdGhpcyBhc3N1bWVzIHBhZ2UgaWRzIGFyZSAzLDUsNywgZXRjLlxuICAgICAgICAgICAgdmFyIGluZm8gPSBwZGYuaW50ZXJuYWwuZ2V0UGFnZUluZm8oaXRlbS5vcHRpb25zLnBhZ2VOdW1iZXIpO1xuICAgICAgICAgICAgdGhpcy5saW5lKCcvRGVzdCAnICsgJ1snICsgaW5mby5vYmpJZCArICcgMCBSIC9YWVogMCAnICsgZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nKDApICsgJyAwXScpOyAvLyB0aGlzIGxpbmUgZG9lcyBub3Qgd29yayBvbiBhbGwgY2xpZW50cyAocGFnZU51bWJlciBpbnN0ZWFkIG9mIHBhZ2UgcmVmKVxuICAgICAgICAgICAgLy90aGlzLmxpbmUoJy9EZXN0ICcgKyAnWycgKyAoaXRlbS5vcHRpb25zLnBhZ2VOdW1iZXIgLSAxKSArICcgL1hZWiAwICcgKyB0aGlzLmN0eC5wZGYuaW50ZXJuYWwucGFnZVNpemUuZ2V0SGVpZ2h0KCkgKyAnIDBdJyk7XG4gICAgICAgICAgICAvLyBOYW1lZCBEZXN0aW5hdGlvblxuICAgICAgICAgICAgLy8gdGhpcy5saW5lKCcvRGVzdCAocGFnZV8nICsgKGl0ZW0ub3B0aW9ucy5wYWdlTnVtYmVyKSArICcpJyk7XG4gICAgICAgICAgICAvLyBBY3Rpb24gRGVzdGluYXRpb25cbiAgICAgICAgICAgIC8vIHZhciBpZCA9IHBkZi5pbnRlcm5hbC5uZXdPYmplY3QoKTtcbiAgICAgICAgICAgIC8vIHBkZi5pbnRlcm5hbC53cml0ZSgnPDwvRFsnICsgKGl0ZW0ub3B0aW9ucy5wYWdlTnVtYmVyIC0gMSkgKyAnIC9YWVogbnVsbCBudWxsIG51bGxdL1MvR29Ubz4+IGVuZG9iaicpO1xuICAgICAgICAgICAgLy8gdGhpcy5saW5lKCcvQSAnICsgaWQgKyAnIDAgUicgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9iakVuZCgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICB0aGlzLnJlbmRlckl0ZW1zKGl0ZW0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwZGYub3V0bGluZS5saW5lID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIHRoaXMuY3R4LnZhbCArPSB0ZXh0ICsgJ1xcclxcbic7XG4gICAgfTtcblxuICAgIHBkZi5vdXRsaW5lLm1ha2VSZWYgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuaWQgKyAnIDAgUic7XG4gICAgfTtcblxuICAgIHBkZi5vdXRsaW5lLm1ha2VTdHJpbmcgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gJygnICsgcGRmLmludGVybmFsLnBkZkVzY2FwZSh2YWwpICsgJyknO1xuICAgIH07XG5cbiAgICBwZGYub3V0bGluZS5vYmpTdGFydCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB0aGlzLmN0eC52YWwgKz0gJ1xcclxcbicgKyBub2RlLmlkICsgJyAwIG9iaicgKyAnXFxyXFxuPDxcXHJcXG4nO1xuICAgIH07XG5cbiAgICBwZGYub3V0bGluZS5vYmpFbmQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdGhpcy5jdHgudmFsICs9ICc+PiBcXHJcXG4nICsgJ2VuZG9iaicgKyAnXFxyXFxuJztcbiAgICB9O1xuXG4gICAgcGRmLm91dGxpbmUuY291bnRfciA9IGZ1bmN0aW9uIChjdHgsIG5vZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdHguY291bnQrKztcbiAgICAgICAgdGhpcy5jb3VudF9yKGN0eCwgbm9kZS5jaGlsZHJlbltpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdHguY291bnQ7XG4gICAgfTtcbiAgfV0pO1xuICByZXR1cm4gdGhpcztcbn0pKGpzUERGLkFQSSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE0IEphbWVzIFJvYmIsIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW1lc2Jyb2JiXG4gKlxuICogXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuKiBqc1BERiBQTkcgUGx1Z0luXG4qIEBuYW1lIHBuZ19zdXBwb3J0XG4qIEBtb2R1bGVcbiovXG4oZnVuY3Rpb24gKGpzUERGQVBJKSB7XG4gIC8qXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvUE5HLUNodW5rcy5odG1sXG4gICAqXG4gICBDb2xvciAgICBBbGxvd2VkICAgICAgSW50ZXJwcmV0YXRpb25cbiAgIFR5cGUgICAgIEJpdCBEZXB0aHNcbiAgXHQgICAwICAgICAgIDEsMiw0LDgsMTYgIEVhY2ggcGl4ZWwgaXMgYSBncmF5c2NhbGUgc2FtcGxlLlxuICBcdCAgIDIgICAgICAgOCwxNiAgICAgICAgRWFjaCBwaXhlbCBpcyBhbiBSLEcsQiB0cmlwbGUuXG4gIFx0ICAgMyAgICAgICAxLDIsNCw4ICAgICBFYWNoIHBpeGVsIGlzIGEgcGFsZXR0ZSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICBhIFBMVEUgY2h1bmsgbXVzdCBhcHBlYXIuXG4gIFx0ICAgNCAgICAgICA4LDE2ICAgICAgICBFYWNoIHBpeGVsIGlzIGEgZ3JheXNjYWxlIHNhbXBsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBmb2xsb3dlZCBieSBhbiBhbHBoYSBzYW1wbGUuXG4gIFx0ICAgNiAgICAgICA4LDE2ICAgICAgICBFYWNoIHBpeGVsIGlzIGFuIFIsRyxCIHRyaXBsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBmb2xsb3dlZCBieSBhbiBhbHBoYSBzYW1wbGUuXG4gICovXG5cbiAgLypcbiAgICogUE5HIGZpbHRlciBtZXRob2QgdHlwZXNcbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9QTkctRmlsdGVycy5odG1sXG4gICAqIEBzZWUgaHR0cDovL3d3dy5saWJwbmcub3JnL3B1Yi9wbmcvYm9vay9jaGFwdGVyMDkuaHRtbFxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgdGhlIHZhbHVlICdQcmVkaWN0b3InIGluIGRlY29kZSBwYXJhbXMgcmVsYXRlcyB0b1xuICAgKlxuICAgKiAxNSBpcyBcIm9wdGltYWwgcHJlZGljdGlvblwiLCB3aGljaCBtZWFucyB0aGUgcHJlZGljdGlvbiBhbGdvcml0aG0gY2FuIGNoYW5nZSBmcm9tIGxpbmUgdG8gbGluZS5cbiAgICogSW4gdGhhdCBjYXNlLCB5b3UgYWN0dWFsbHkgaGF2ZSB0byByZWFkIHRoZSBmaXJzdCBieXRlIG9mZiBlYWNoIGxpbmUgZm9yIHRoZSBwcmVkaWN0aW9uIGFsZ29ydGhpbSAod2hpY2ggc2hvdWxkIGJlIDAtNCwgY29ycmVzcG9uZGluZyB0byBQREYgMTAtMTQpIGFuZCBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIHVucHJlZGljdGlvbiBhbGdvcml0aG0gYmFzZWQgb24gdGhhdCBieXRlLlxuICAgKlxuICAgICAwICAgICAgIE5vbmVcbiAgICAgMSAgICAgICBTdWJcbiAgICAgMiAgICAgICBVcFxuICAgICAzICAgICAgIEF2ZXJhZ2VcbiAgICAgNCAgICAgICBQYWV0aFxuICAgKi9cblxuICB2YXIgZG9lc05vdEhhdmVQbmdKUyA9IGZ1bmN0aW9uIGRvZXNOb3RIYXZlUG5nSlMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBQTkcgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIEZsYXRlU3RyZWFtICE9PSAnZnVuY3Rpb24nO1xuICB9LFxuICAgICAgY2FuQ29tcHJlc3MgPSBmdW5jdGlvbiBjYW5Db21wcmVzcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0ganNQREZBUEkuaW1hZ2VfY29tcHJlc3Npb24uTk9ORSAmJiBoYXNDb21wcmVzc2lvbkpTKCk7XG4gIH0sXG4gICAgICBoYXNDb21wcmVzc2lvbkpTID0gZnVuY3Rpb24gaGFzQ29tcHJlc3Npb25KUygpIHtcbiAgICB2YXIgaW5zdCA9IHR5cGVvZiBEZWZsYXRlciA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoIWluc3QpIHRocm93IG5ldyBFcnJvcihcInJlcXVpcmVzIGRlZmxhdGUuanMgZm9yIGNvbXByZXNzaW9uXCIpO1xuICAgIHJldHVybiBpbnN0O1xuICB9LFxuICAgICAgY29tcHJlc3NCeXRlcyA9IGZ1bmN0aW9uIGNvbXByZXNzQnl0ZXMoYnl0ZXMsIGxpbmVMZW5ndGgsIGNvbG9yc1BlclBpeGVsLCBjb21wcmVzc2lvbikge1xuICAgIHZhciBsZXZlbCA9IDUsXG4gICAgICAgIGZpbHRlcl9tZXRob2QgPSBmaWx0ZXJVcDtcblxuICAgIHN3aXRjaCAoY29tcHJlc3Npb24pIHtcbiAgICAgIGNhc2UganNQREZBUEkuaW1hZ2VfY29tcHJlc3Npb24uRkFTVDpcbiAgICAgICAgbGV2ZWwgPSAzO1xuICAgICAgICBmaWx0ZXJfbWV0aG9kID0gZmlsdGVyU3ViO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBqc1BERkFQSS5pbWFnZV9jb21wcmVzc2lvbi5NRURJVU06XG4gICAgICAgIGxldmVsID0gNjtcbiAgICAgICAgZmlsdGVyX21ldGhvZCA9IGZpbHRlckF2ZXJhZ2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGpzUERGQVBJLmltYWdlX2NvbXByZXNzaW9uLlNMT1c6XG4gICAgICAgIGxldmVsID0gOTtcbiAgICAgICAgZmlsdGVyX21ldGhvZCA9IGZpbHRlclBhZXRoOyAvL3VzZXMgdG8gc3VtIHRvIGNob29zZSBiZXN0IGZpbHRlciBmb3IgZWFjaCBsaW5lXG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYnl0ZXMgPSBhcHBseVBuZ0ZpbHRlck1ldGhvZChieXRlcywgbGluZUxlbmd0aCwgY29sb3JzUGVyUGl4ZWwsIGZpbHRlcl9tZXRob2QpO1xuICAgIHZhciBoZWFkZXIgPSBuZXcgVWludDhBcnJheShjcmVhdGVabGliSGVhZGVyKGxldmVsKSk7XG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihieXRlcyk7XG4gICAgdmFyIGRlZmxhdGUgPSBuZXcgRGVmbGF0ZXIobGV2ZWwpO1xuICAgIHZhciBhID0gZGVmbGF0ZS5hcHBlbmQoYnl0ZXMpO1xuICAgIHZhciBjQnl0ZXMgPSBkZWZsYXRlLmZsdXNoKCk7XG4gICAgdmFyIGxlbiA9IGhlYWRlci5sZW5ndGggKyBhLmxlbmd0aCArIGNCeXRlcy5sZW5ndGg7XG4gICAgdmFyIGNtcGQgPSBuZXcgVWludDhBcnJheShsZW4gKyA0KTtcbiAgICBjbXBkLnNldChoZWFkZXIpO1xuICAgIGNtcGQuc2V0KGEsIGhlYWRlci5sZW5ndGgpO1xuICAgIGNtcGQuc2V0KGNCeXRlcywgaGVhZGVyLmxlbmd0aCArIGEubGVuZ3RoKTtcbiAgICBjbXBkW2xlbisrXSA9IGNoZWNrc3VtID4+PiAyNCAmIDB4ZmY7XG4gICAgY21wZFtsZW4rK10gPSBjaGVja3N1bSA+Pj4gMTYgJiAweGZmO1xuICAgIGNtcGRbbGVuKytdID0gY2hlY2tzdW0gPj4+IDggJiAweGZmO1xuICAgIGNtcGRbbGVuKytdID0gY2hlY2tzdW0gJiAweGZmO1xuICAgIHJldHVybiBqc1BERkFQSS5hcnJheUJ1ZmZlclRvQmluYXJ5U3RyaW5nKGNtcGQpO1xuICB9LFxuICAgICAgY3JlYXRlWmxpYkhlYWRlciA9IGZ1bmN0aW9uIGNyZWF0ZVpsaWJIZWFkZXIoYnl0ZXMsIGxldmVsKSB7XG4gICAgLypcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzE5NTAudHh0IGZvciB6bGliIGhlYWRlclxuICAgICAqL1xuICAgIHZhciBjbSA9IDg7XG4gICAgdmFyIGNpbmZvID0gTWF0aC5MT0cyRSAqIE1hdGgubG9nKDB4ODAwMCkgLSA4O1xuICAgIHZhciBjbWYgPSBjaW5mbyA8PCA0IHwgY207XG4gICAgdmFyIGhkciA9IGNtZiA8PCA4O1xuICAgIHZhciBmbGV2ZWwgPSBNYXRoLm1pbigzLCAobGV2ZWwgLSAxICYgMHhmZikgPj4gMSk7XG4gICAgaGRyIHw9IGZsZXZlbCA8PCA2O1xuICAgIGhkciB8PSAwOyAvL0ZESUNUXG5cbiAgICBoZHIgKz0gMzEgLSBoZHIgJSAzMTtcbiAgICByZXR1cm4gW2NtZiwgaGRyICYgMHhmZiAmIDB4ZmZdO1xuICB9LFxuICAgICAgYWRsZXIzMiA9IGZ1bmN0aW9uIGFkbGVyMzIoYXJyYXksIHBhcmFtKSB7XG4gICAgdmFyIGFkbGVyID0gMTtcbiAgICB2YXIgczEgPSBhZGxlciAmIDB4ZmZmZixcbiAgICAgICAgczIgPSBhZGxlciA+Pj4gMTYgJiAweGZmZmY7XG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgdGxlbjtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAobGVuID4gMCkge1xuICAgICAgdGxlbiA9IGxlbiA+IHBhcmFtID8gcGFyYW0gOiBsZW47XG4gICAgICBsZW4gLT0gdGxlbjtcblxuICAgICAgZG8ge1xuICAgICAgICBzMSArPSBhcnJheVtpKytdO1xuICAgICAgICBzMiArPSBzMTtcbiAgICAgIH0gd2hpbGUgKC0tdGxlbik7XG5cbiAgICAgIHMxICU9IDY1NTIxO1xuICAgICAgczIgJT0gNjU1MjE7XG4gICAgfVxuXG4gICAgcmV0dXJuIChzMiA8PCAxNiB8IHMxKSA+Pj4gMDtcbiAgfSxcbiAgICAgIGFwcGx5UG5nRmlsdGVyTWV0aG9kID0gZnVuY3Rpb24gYXBwbHlQbmdGaWx0ZXJNZXRob2QoYnl0ZXMsIGxpbmVMZW5ndGgsIGNvbG9yc1BlclBpeGVsLCBmaWx0ZXJfbWV0aG9kKSB7XG4gICAgdmFyIGxpbmVzID0gYnl0ZXMubGVuZ3RoIC8gbGluZUxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMubGVuZ3RoICsgbGluZXMpLFxuICAgICAgICBmaWx0ZXJfbWV0aG9kcyA9IGdldEZpbHRlck1ldGhvZHMoKSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxpbmUsXG4gICAgICAgIHByZXZMaW5lLFxuICAgICAgICBvZmZzZXQ7XG5cbiAgICBmb3IgKDsgaSA8IGxpbmVzOyBpKyspIHtcbiAgICAgIG9mZnNldCA9IGkgKiBsaW5lTGVuZ3RoO1xuICAgICAgbGluZSA9IGJ5dGVzLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGluZUxlbmd0aCk7XG5cbiAgICAgIGlmIChmaWx0ZXJfbWV0aG9kKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoZmlsdGVyX21ldGhvZChsaW5lLCBjb2xvcnNQZXJQaXhlbCwgcHJldkxpbmUpLCBvZmZzZXQgKyBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBqID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGZpbHRlcl9tZXRob2RzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBmb3IgKDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgcmVzdWx0c1tqXSA9IGZpbHRlcl9tZXRob2RzW2pdKGxpbmUsIGNvbG9yc1BlclBpeGVsLCBwcmV2TGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kID0gZ2V0SW5kZXhPZlNtYWxsZXN0U3VtKHJlc3VsdHMuY29uY2F0KCkpO1xuICAgICAgICByZXN1bHQuc2V0KHJlc3VsdHNbaW5kXSwgb2Zmc2V0ICsgaSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZMaW5lID0gbGluZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAgICAgZmlsdGVyTm9uZSA9IGZ1bmN0aW9uIGZpbHRlck5vbmUobGluZSwgY29sb3JzUGVyUGl4ZWwsIHByZXZMaW5lKSB7XG4gICAgLyp2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGluZS5sZW5ndGggKyAxKTtcbiAgICByZXN1bHRbMF0gPSAwO1xuICAgIHJlc3VsdC5zZXQobGluZSwgMSk7Ki9cbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkuYXBwbHkoW10sIGxpbmUpO1xuICAgIHJlc3VsdC51bnNoaWZ0KDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gICAgICBmaWx0ZXJTdWIgPSBmdW5jdGlvbiBmaWx0ZXJTdWIobGluZSwgY29sb3JzUGVyUGl4ZWwsIHByZXZMaW5lKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuID0gbGluZS5sZW5ndGgsXG4gICAgICAgIGxlZnQ7XG4gICAgcmVzdWx0WzBdID0gMTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxlZnQgPSBsaW5lW2kgLSBjb2xvcnNQZXJQaXhlbF0gfHwgMDtcbiAgICAgIHJlc3VsdFtpICsgMV0gPSBsaW5lW2ldIC0gbGVmdCArIDB4MDEwMCAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgICAgIGZpbHRlclVwID0gZnVuY3Rpb24gZmlsdGVyVXAobGluZSwgY29sb3JzUGVyUGl4ZWwsIHByZXZMaW5lKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuID0gbGluZS5sZW5ndGgsXG4gICAgICAgIHVwO1xuICAgIHJlc3VsdFswXSA9IDI7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB1cCA9IHByZXZMaW5lICYmIHByZXZMaW5lW2ldIHx8IDA7XG4gICAgICByZXN1bHRbaSArIDFdID0gbGluZVtpXSAtIHVwICsgMHgwMTAwICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAgICAgZmlsdGVyQXZlcmFnZSA9IGZ1bmN0aW9uIGZpbHRlckF2ZXJhZ2UobGluZSwgY29sb3JzUGVyUGl4ZWwsIHByZXZMaW5lKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuID0gbGluZS5sZW5ndGgsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHVwO1xuICAgIHJlc3VsdFswXSA9IDM7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZWZ0ID0gbGluZVtpIC0gY29sb3JzUGVyUGl4ZWxdIHx8IDA7XG4gICAgICB1cCA9IHByZXZMaW5lICYmIHByZXZMaW5lW2ldIHx8IDA7XG4gICAgICByZXN1bHRbaSArIDFdID0gbGluZVtpXSArIDB4MDEwMCAtIChsZWZ0ICsgdXAgPj4+IDEpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAgICAgZmlsdGVyUGFldGggPSBmdW5jdGlvbiBmaWx0ZXJQYWV0aChsaW5lLCBjb2xvcnNQZXJQaXhlbCwgcHJldkxpbmUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsZW4gPSBsaW5lLmxlbmd0aCxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdXAsXG4gICAgICAgIHVwTGVmdCxcbiAgICAgICAgcGFldGg7XG4gICAgcmVzdWx0WzBdID0gNDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxlZnQgPSBsaW5lW2kgLSBjb2xvcnNQZXJQaXhlbF0gfHwgMDtcbiAgICAgIHVwID0gcHJldkxpbmUgJiYgcHJldkxpbmVbaV0gfHwgMDtcbiAgICAgIHVwTGVmdCA9IHByZXZMaW5lICYmIHByZXZMaW5lW2kgLSBjb2xvcnNQZXJQaXhlbF0gfHwgMDtcbiAgICAgIHBhZXRoID0gcGFldGhQcmVkaWN0b3IobGVmdCwgdXAsIHVwTGVmdCk7XG4gICAgICByZXN1bHRbaSArIDFdID0gbGluZVtpXSAtIHBhZXRoICsgMHgwMTAwICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAgICAgcGFldGhQcmVkaWN0b3IgPSBmdW5jdGlvbiBwYWV0aFByZWRpY3RvcihsZWZ0LCB1cCwgdXBMZWZ0KSB7XG4gICAgdmFyIHAgPSBsZWZ0ICsgdXAgLSB1cExlZnQsXG4gICAgICAgIHBMZWZ0ID0gTWF0aC5hYnMocCAtIGxlZnQpLFxuICAgICAgICBwVXAgPSBNYXRoLmFicyhwIC0gdXApLFxuICAgICAgICBwVXBMZWZ0ID0gTWF0aC5hYnMocCAtIHVwTGVmdCk7XG4gICAgcmV0dXJuIHBMZWZ0IDw9IHBVcCAmJiBwTGVmdCA8PSBwVXBMZWZ0ID8gbGVmdCA6IHBVcCA8PSBwVXBMZWZ0ID8gdXAgOiB1cExlZnQ7XG4gIH0sXG4gICAgICBnZXRGaWx0ZXJNZXRob2RzID0gZnVuY3Rpb24gZ2V0RmlsdGVyTWV0aG9kcygpIHtcbiAgICByZXR1cm4gW2ZpbHRlck5vbmUsIGZpbHRlclN1YiwgZmlsdGVyVXAsIGZpbHRlckF2ZXJhZ2UsIGZpbHRlclBhZXRoXTtcbiAgfSxcbiAgICAgIGdldEluZGV4T2ZTbWFsbGVzdFN1bSA9IGZ1bmN0aW9uIGdldEluZGV4T2ZTbWFsbGVzdFN1bShhcnJheXMpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbiA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgIHN1bSxcbiAgICAgICAgbWluLFxuICAgICAgICBpbmQ7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgc3VtID0gYWJzU3VtKGFycmF5c1tpXS5zbGljZSgxKSk7XG5cbiAgICAgIGlmIChzdW0gPCBtaW4gfHwgIW1pbikge1xuICAgICAgICBtaW4gPSBzdW07XG4gICAgICAgIGluZCA9IGk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kO1xuICB9LFxuICAgICAgYWJzU3VtID0gZnVuY3Rpb24gYWJzU3VtKGFycmF5KSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHN1bSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgc3VtICs9IE1hdGguYWJzKGFycmF5W2krK10pO1xuICAgIH1cblxuICAgIHJldHVybiBzdW07XG4gIH0sXG4gICAgICBnZXRQcmVkaWN0b3JGcm9tQ29tcHJlc3Npb24gPSBmdW5jdGlvbiBnZXRQcmVkaWN0b3JGcm9tQ29tcHJlc3Npb24oY29tcHJlc3Npb24pIHtcbiAgICB2YXIgcHJlZGljdG9yO1xuXG4gICAgc3dpdGNoIChjb21wcmVzc2lvbikge1xuICAgICAgY2FzZSBqc1BERkFQSS5pbWFnZV9jb21wcmVzc2lvbi5GQVNUOlxuICAgICAgICBwcmVkaWN0b3IgPSAxMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UganNQREZBUEkuaW1hZ2VfY29tcHJlc3Npb24uTUVESVVNOlxuICAgICAgICBwcmVkaWN0b3IgPSAxMztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UganNQREZBUEkuaW1hZ2VfY29tcHJlc3Npb24uU0xPVzpcbiAgICAgICAgcHJlZGljdG9yID0gMTQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwcmVkaWN0b3IgPSAxMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWRpY3RvcjtcbiAgfTtcbiAgLyoqXG4gICpcbiAgKiBAbmFtZSBwcm9jZXNzUE5HXG4gICogQGZ1bmN0aW9uXG4gICogQGlnbm9yZVxuICAqL1xuXG5cbiAganNQREZBUEkucHJvY2Vzc1BORyA9IGZ1bmN0aW9uIChpbWFnZURhdGEsIGltYWdlSW5kZXgsIGFsaWFzLCBjb21wcmVzc2lvbiwgZGF0YUFzQmluYXJ5U3RyaW5nKSB7XG5cbiAgICB2YXIgY29sb3JTcGFjZSA9IHRoaXMuY29sb3Jfc3BhY2VzLkRFVklDRV9SR0IsXG4gICAgICAgIGRlY29kZSA9IHRoaXMuZGVjb2RlLkZMQVRFX0RFQ09ERSxcbiAgICAgICAgYnBjID0gOCxcbiAgICAgICAgaW1nLFxuICAgICAgICBkcCxcbiAgICAgICAgdHJucyxcbiAgICAgICAgY29sb3JzLFxuICAgICAgICBwYWwsXG4gICAgICAgIHNtYXNrO1xuICAgIC8qXHRpZih0aGlzLmlzU3RyaW5nKGltYWdlRGF0YSkpIHtcbiAgICBcdFx0fSovXG5cbiAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyKGltYWdlRGF0YSkpIGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGltYWdlRGF0YSk7XG5cbiAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyVmlldyhpbWFnZURhdGEpKSB7XG4gICAgICBpZiAoZG9lc05vdEhhdmVQbmdKUygpKSB0aHJvdyBuZXcgRXJyb3IoXCJQTkcgc3VwcG9ydCByZXF1aXJlcyBwbmcuanMgYW5kIHpsaWIuanNcIik7XG4gICAgICBpbWcgPSBuZXcgUE5HKGltYWdlRGF0YSk7XG4gICAgICBpbWFnZURhdGEgPSBpbWcuaW1nRGF0YTtcbiAgICAgIGJwYyA9IGltZy5iaXRzO1xuICAgICAgY29sb3JTcGFjZSA9IGltZy5jb2xvclNwYWNlO1xuICAgICAgY29sb3JzID0gaW1nLmNvbG9yczsgLy9sb2dJbWcoaW1nKTtcblxuICAgICAgLypcbiAgICAgICAqIGNvbG9yVHlwZSA2IC0gRWFjaCBwaXhlbCBpcyBhbiBSLEcsQiB0cmlwbGUsIGZvbGxvd2VkIGJ5IGFuIGFscGhhIHNhbXBsZS5cbiAgICAgICAqXG4gICAgICAgKiBjb2xvclR5cGUgNCAtIEVhY2ggcGl4ZWwgaXMgYSBncmF5c2NhbGUgc2FtcGxlLCBmb2xsb3dlZCBieSBhbiBhbHBoYSBzYW1wbGUuXG4gICAgICAgKlxuICAgICAgICogRXh0cmFjdCBhbHBoYSB0byBjcmVhdGUgdHdvIHNlcGFyYXRlIGltYWdlcywgdXNpbmcgdGhlIGFscGhhIGFzIGEgc01hc2tcbiAgICAgICAqL1xuXG4gICAgICBpZiAoWzQsIDZdLmluZGV4T2YoaW1nLmNvbG9yVHlwZSkgIT09IC0xKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIHByb2Nlc3NlcyA4IGJpdCBSR0JBIGFuZCBncmF5c2NhbGUgKyBhbHBoYSBpbWFnZXNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChpbWcuYml0cyA9PT0gOCkge1xuICAgICAgICAgIHZhciBwaXhlbHMgPSBpbWcucGl4ZWxCaXRsZW5ndGggPT0gMzIgPyBuZXcgVWludDMyQXJyYXkoaW1nLmRlY29kZVBpeGVscygpLmJ1ZmZlcikgOiBpbWcucGl4ZWxCaXRsZW5ndGggPT0gMTYgPyBuZXcgVWludDE2QXJyYXkoaW1nLmRlY29kZVBpeGVscygpLmJ1ZmZlcikgOiBuZXcgVWludDhBcnJheShpbWcuZGVjb2RlUGl4ZWxzKCkuYnVmZmVyKSxcbiAgICAgICAgICAgICAgbGVuID0gcGl4ZWxzLmxlbmd0aCxcbiAgICAgICAgICAgICAgaW1nRGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbiAqIGltZy5jb2xvcnMpLFxuICAgICAgICAgICAgICBhbHBoYURhdGEgPSBuZXcgVWludDhBcnJheShsZW4pLFxuICAgICAgICAgICAgICBwRGlmZiA9IGltZy5waXhlbEJpdGxlbmd0aCAtIGltZy5iaXRzLFxuICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgbiA9IDAsXG4gICAgICAgICAgICAgIHBpeGVsLFxuICAgICAgICAgICAgICBwYmw7XG5cbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBwaXhlbCA9IHBpeGVsc1tpXTtcbiAgICAgICAgICAgIHBibCA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYmwgPCBwRGlmZikge1xuICAgICAgICAgICAgICBpbWdEYXRhW24rK10gPSBwaXhlbCA+Pj4gcGJsICYgMHhmZjtcbiAgICAgICAgICAgICAgcGJsID0gcGJsICsgaW1nLmJpdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFscGhhRGF0YVtpXSA9IHBpeGVsID4+PiBwYmwgJiAweGZmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBwcm9jZXNzZXMgMTYgYml0IFJHQkEgYW5kIGdyYXlzY2FsZSArIGFscGhhIGltYWdlc1xuICAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChpbWcuYml0cyA9PT0gMTYpIHtcbiAgICAgICAgICB2YXIgcGl4ZWxzID0gbmV3IFVpbnQzMkFycmF5KGltZy5kZWNvZGVQaXhlbHMoKS5idWZmZXIpLFxuICAgICAgICAgICAgICBsZW4gPSBwaXhlbHMubGVuZ3RoLFxuICAgICAgICAgICAgICBpbWdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobGVuICogKDMyIC8gaW1nLnBpeGVsQml0bGVuZ3RoKSAqIGltZy5jb2xvcnMpLFxuICAgICAgICAgICAgICBhbHBoYURhdGEgPSBuZXcgVWludDhBcnJheShsZW4gKiAoMzIgLyBpbWcucGl4ZWxCaXRsZW5ndGgpKSxcbiAgICAgICAgICAgICAgaGFzQ29sb3JzID0gaW1nLmNvbG9ycyA+IDEsXG4gICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICBuID0gMCxcbiAgICAgICAgICAgICAgYSA9IDAsXG4gICAgICAgICAgICAgIHBpeGVsO1xuXG4gICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIHBpeGVsID0gcGl4ZWxzW2krK107XG4gICAgICAgICAgICBpbWdEYXRhW24rK10gPSBwaXhlbCA+Pj4gMCAmIDB4RkY7XG5cbiAgICAgICAgICAgIGlmIChoYXNDb2xvcnMpIHtcbiAgICAgICAgICAgICAgaW1nRGF0YVtuKytdID0gcGl4ZWwgPj4+IDE2ICYgMHhGRjtcbiAgICAgICAgICAgICAgcGl4ZWwgPSBwaXhlbHNbaSsrXTtcbiAgICAgICAgICAgICAgaW1nRGF0YVtuKytdID0gcGl4ZWwgPj4+IDAgJiAweEZGO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbHBoYURhdGFbYSsrXSA9IHBpeGVsID4+PiAxNiAmIDB4RkY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnBjID0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYW5Db21wcmVzcyhjb21wcmVzc2lvbikpIHtcbiAgICAgICAgICBpbWFnZURhdGEgPSBjb21wcmVzc0J5dGVzKGltZ0RhdGEsIGltZy53aWR0aCAqIGltZy5jb2xvcnMsIGltZy5jb2xvcnMsIGNvbXByZXNzaW9uKTtcbiAgICAgICAgICBzbWFzayA9IGNvbXByZXNzQnl0ZXMoYWxwaGFEYXRhLCBpbWcud2lkdGgsIDEsIGNvbXByZXNzaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbWFnZURhdGEgPSBpbWdEYXRhO1xuICAgICAgICAgIHNtYXNrID0gYWxwaGFEYXRhO1xuICAgICAgICAgIGRlY29kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAgKiBJbmRleGVkIHBuZy4gRWFjaCBwaXhlbCBpcyBhIHBhbGV0dGUgaW5kZXguXG4gICAgICAgKi9cblxuXG4gICAgICBpZiAoaW1nLmNvbG9yVHlwZSA9PT0gMykge1xuICAgICAgICBjb2xvclNwYWNlID0gdGhpcy5jb2xvcl9zcGFjZXMuSU5ERVhFRDtcbiAgICAgICAgcGFsID0gaW1nLnBhbGV0dGU7XG5cbiAgICAgICAgaWYgKGltZy50cmFuc3BhcmVuY3kuaW5kZXhlZCkge1xuICAgICAgICAgIHZhciB0cmFucyA9IGltZy50cmFuc3BhcmVuY3kuaW5kZXhlZDtcbiAgICAgICAgICB2YXIgdG90YWwgPSAwLFxuICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgbGVuID0gdHJhbnMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdG90YWwgKz0gdHJhbnNbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG90YWwgPSB0b3RhbCAvIDI1NTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIGEgc2luZ2xlIGNvbG9yIGlzIHNwZWNpZmllZCBhcyAxMDAlIHRyYW5zcGFyZW50ICgwKSxcbiAgICAgICAgICAgKiBzbyB3ZSBzZXQgdHJucyB0byB1c2UgYSAvTWFzayB3aXRoIHRoYXQgaW5kZXhcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIGlmICh0b3RhbCA9PT0gbGVuIC0gMSAmJiB0cmFucy5pbmRleE9mKDApICE9PSAtMSkge1xuICAgICAgICAgICAgdHJucyA9IFt0cmFucy5pbmRleE9mKDApXTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUgY29sb3VyIHdpdGhpbiB0aGUgcGFsZXR0ZSB0aGF0IHNwZWNpZmllc1xuICAgICAgICAgICAgICogYSB0cmFuc3BhcmVuY3kgdmFsdWUgbGVzcyB0aGFuIDI1NSwgc28gd2UgdW5yb2xsIHRoZSBwaXhlbHMgdG8gY3JlYXRlIGFuIGltYWdlIHNNYXNrXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICB9IGVsc2UgaWYgKHRvdGFsICE9PSBsZW4pIHtcbiAgICAgICAgICAgIHZhciBwaXhlbHMgPSBpbWcuZGVjb2RlUGl4ZWxzKCksXG4gICAgICAgICAgICAgICAgYWxwaGFEYXRhID0gbmV3IFVpbnQ4QXJyYXkocGl4ZWxzLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gcGl4ZWxzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBhbHBoYURhdGFbaV0gPSB0cmFuc1twaXhlbHNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzbWFzayA9IGNvbXByZXNzQnl0ZXMoYWxwaGFEYXRhLCBpbWcud2lkdGgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcHJlZGljdG9yID0gZ2V0UHJlZGljdG9yRnJvbUNvbXByZXNzaW9uKGNvbXByZXNzaW9uKTtcbiAgICAgIGlmIChkZWNvZGUgPT09IHRoaXMuZGVjb2RlLkZMQVRFX0RFQ09ERSkgZHAgPSAnL1ByZWRpY3RvciAnICsgcHJlZGljdG9yICsgJyAvQ29sb3JzICcgKyBjb2xvcnMgKyAnIC9CaXRzUGVyQ29tcG9uZW50ICcgKyBicGMgKyAnIC9Db2x1bW5zICcgKyBpbWcud2lkdGg7ZWxzZSAvL3JlbW92ZSAnUHJlZGljdG9yJyBhcyBpdCBhcHBsaWVzIHRvIHRoZSB0eXBlIG9mIHBuZyBmaWx0ZXIgYXBwbGllZCB0byBpdHMgSURBVCAtIHdlIG9ubHkgYXBwbHkgd2l0aCBjb21wcmVzc2lvblxuICAgICAgICBkcCA9ICcvQ29sb3JzICcgKyBjb2xvcnMgKyAnIC9CaXRzUGVyQ29tcG9uZW50ICcgKyBicGMgKyAnIC9Db2x1bW5zICcgKyBpbWcud2lkdGg7XG4gICAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyKGltYWdlRGF0YSkgfHwgdGhpcy5pc0FycmF5QnVmZmVyVmlldyhpbWFnZURhdGEpKSBpbWFnZURhdGEgPSB0aGlzLmFycmF5QnVmZmVyVG9CaW5hcnlTdHJpbmcoaW1hZ2VEYXRhKTtcbiAgICAgIGlmIChzbWFzayAmJiB0aGlzLmlzQXJyYXlCdWZmZXIoc21hc2spIHx8IHRoaXMuaXNBcnJheUJ1ZmZlclZpZXcoc21hc2spKSBzbWFzayA9IHRoaXMuYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyhzbWFzayk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbWFnZUluZm8oaW1hZ2VEYXRhLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIGNvbG9yU3BhY2UsIGJwYywgZGVjb2RlLCBpbWFnZUluZGV4LCBhbGlhcywgZHAsIHRybnMsIHBhbCwgc21hc2ssIHByZWRpY3Rvcik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgUE5HIGltYWdlIGRhdGEsIHRyeSB1c2luZyBKUEVHIGluc3RlYWQuXCIpO1xuICB9O1xufSkoanNQREYuQVBJKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IEFyYXMgQWJiYXNpIFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICovXG5cbi8qKlxuKiBqc1BERiBnaWYgU3VwcG9ydCBQbHVnSW5cbipcbiogQG5hbWUgZ2lmX3N1cHBvcnRcbiogQG1vZHVsZVxuKi9cbihmdW5jdGlvbiAoanNQREZBUEkpIHtcblxuICBqc1BERkFQSS5wcm9jZXNzR0lGODlBID0gZnVuY3Rpb24gKGltYWdlRGF0YSwgaW1hZ2VJbmRleCwgYWxpYXMsIGNvbXByZXNzaW9uLCBkYXRhQXNCaW5hcnlTdHJpbmcpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEdpZlJlYWRlcihpbWFnZURhdGEpO1xuICAgIHZhciB3aWR0aCA9IHJlYWRlci53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gcmVhZGVyLmhlaWdodDtcbiAgICB2YXIgcXUgPSAxMDA7XG4gICAgdmFyIHBpeGVscyA9IFtdO1xuICAgIHJlYWRlci5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBKDAsIHBpeGVscyk7XG4gICAgdmFyIHJhd0ltYWdlRGF0YSA9IHtcbiAgICAgIGRhdGE6IHBpeGVscyxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgICB2YXIgZW5jb2RlciA9IG5ldyBKUEVHRW5jb2RlcihxdSk7XG4gICAgdmFyIGRhdGEgPSBlbmNvZGVyLmVuY29kZShyYXdJbWFnZURhdGEsIHF1KTtcbiAgICByZXR1cm4ganNQREZBUEkucHJvY2Vzc0pQRUcuY2FsbCh0aGlzLCBkYXRhLCBpbWFnZUluZGV4LCBhbGlhcywgY29tcHJlc3Npb24pO1xuICB9O1xuXG4gIGpzUERGQVBJLnByb2Nlc3NHSUY4N0EgPSBqc1BERkFQSS5wcm9jZXNzR0lGODlBO1xufSkoanNQREYuQVBJKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggQXJhcyBBYmJhc2kgXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlXG4gKi9cblxuLyoqXG4qIGpzUERGIGJtcCBTdXBwb3J0IFBsdWdJblxuKiBAbmFtZSBibXBfc3VwcG9ydFxuKiBAbW9kdWxlXG4qL1xuKGZ1bmN0aW9uIChqc1BERkFQSSkge1xuXG4gIGpzUERGQVBJLnByb2Nlc3NCTVAgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhLCBpbWFnZUluZGV4LCBhbGlhcywgY29tcHJlc3Npb24sIGRhdGFBc0JpbmFyeVN0cmluZykge1xuICAgIHZhciByZWFkZXIgPSBuZXcgQm1wRGVjb2RlcihpbWFnZURhdGEsIGZhbHNlKTtcbiAgICB2YXIgd2lkdGggPSByZWFkZXIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlYWRlci5oZWlnaHQ7XG4gICAgdmFyIHF1ID0gMTAwO1xuICAgIHZhciBwaXhlbHMgPSByZWFkZXIuZ2V0RGF0YSgpO1xuICAgIHZhciByYXdJbWFnZURhdGEgPSB7XG4gICAgICBkYXRhOiBwaXhlbHMsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gICAgdmFyIGVuY29kZXIgPSBuZXcgSlBFR0VuY29kZXIocXUpO1xuICAgIHZhciBkYXRhID0gZW5jb2Rlci5lbmNvZGUocmF3SW1hZ2VEYXRhLCBxdSk7XG4gICAgcmV0dXJuIGpzUERGQVBJLnByb2Nlc3NKUEVHLmNhbGwodGhpcywgZGF0YSwgaW1hZ2VJbmRleCwgYWxpYXMsIGNvbXByZXNzaW9uKTtcbiAgfTtcbn0pKGpzUERGLkFQSSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICovXG5cbi8qKlxuICoganNQREYgc2V0TGFuZ3VhZ2UgUGx1Z2luXG4gKlxuICogQG5hbWUgc2V0TGFuZ3VhZ2VcbiAqIEBtb2R1bGVcbiAqL1xuKGZ1bmN0aW9uIChqc1BERkFQSSkge1xuICAvKipcbiAgKiBBZGQgTGFuZ3VhZ2UgVGFnIHRvIHRoZSBnZW5lcmF0ZWQgUERGXG4gICpcbiAgKiBAbmFtZSBzZXRMYW5ndWFnZVxuICAqIEBmdW5jdGlvbiBcbiAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ0NvZGUgVGhlIExhbmd1YWdlIGNvZGUgYXMgSVNPLTYzOS0xIChlLmcuICdlbicpIG9yIGFzIGNvdW50cnkgbGFuZ3VhZ2UgY29kZSAoZS5nLiAnZW4tR0InKS4gXG4gICogQHJldHVybnMge2pzUERGfVxuICAqIEBleGFtcGxlXG4gICogdmFyIGRvYyA9IG5ldyBqc1BERigpXG4gICogZG9jLnRleHQoMTAsIDEwLCAnVGhpcyBpcyBhIHRlc3QnKVxuICAqIGRvYy5zZXRMYW5ndWFnZShcImVuLVVTXCIpXG4gICogZG9jLnNhdmUoJ2VuZ2xpc2gucGRmJylcbiAgKi9cblxuICBqc1BERkFQSS5zZXRMYW5ndWFnZSA9IGZ1bmN0aW9uIChsYW5nQ29kZSkge1xuXG4gICAgdmFyIGxhbmdDb2RlcyA9IHtcbiAgICAgIFwiYWZcIjogXCJBZnJpa2FhbnNcIixcbiAgICAgIFwic3FcIjogXCJBbGJhbmlhblwiLFxuICAgICAgXCJhclwiOiBcIkFyYWJpYyAoU3RhbmRhcmQpXCIsXG4gICAgICBcImFyLURaXCI6IFwiQXJhYmljIChBbGdlcmlhKVwiLFxuICAgICAgXCJhci1CSFwiOiBcIkFyYWJpYyAoQmFocmFpbilcIixcbiAgICAgIFwiYXItRUdcIjogXCJBcmFiaWMgKEVneXB0KVwiLFxuICAgICAgXCJhci1JUVwiOiBcIkFyYWJpYyAoSXJhcSlcIixcbiAgICAgIFwiYXItSk9cIjogXCJBcmFiaWMgKEpvcmRhbilcIixcbiAgICAgIFwiYXItS1dcIjogXCJBcmFiaWMgKEt1d2FpdClcIixcbiAgICAgIFwiYXItTEJcIjogXCJBcmFiaWMgKExlYmFub24pXCIsXG4gICAgICBcImFyLUxZXCI6IFwiQXJhYmljIChMaWJ5YSlcIixcbiAgICAgIFwiYXItTUFcIjogXCJBcmFiaWMgKE1vcm9jY28pXCIsXG4gICAgICBcImFyLU9NXCI6IFwiQXJhYmljIChPbWFuKVwiLFxuICAgICAgXCJhci1RQVwiOiBcIkFyYWJpYyAoUWF0YXIpXCIsXG4gICAgICBcImFyLVNBXCI6IFwiQXJhYmljIChTYXVkaSBBcmFiaWEpXCIsXG4gICAgICBcImFyLVNZXCI6IFwiQXJhYmljIChTeXJpYSlcIixcbiAgICAgIFwiYXItVE5cIjogXCJBcmFiaWMgKFR1bmlzaWEpXCIsXG4gICAgICBcImFyLUFFXCI6IFwiQXJhYmljIChVLkEuRS4pXCIsXG4gICAgICBcImFyLVlFXCI6IFwiQXJhYmljIChZZW1lbilcIixcbiAgICAgIFwiYW5cIjogXCJBcmFnb25lc2VcIixcbiAgICAgIFwiaHlcIjogXCJBcm1lbmlhblwiLFxuICAgICAgXCJhc1wiOiBcIkFzc2FtZXNlXCIsXG4gICAgICBcImFzdFwiOiBcIkFzdHVyaWFuXCIsXG4gICAgICBcImF6XCI6IFwiQXplcmJhaWphbmlcIixcbiAgICAgIFwiZXVcIjogXCJCYXNxdWVcIixcbiAgICAgIFwiYmVcIjogXCJCZWxhcnVzaWFuXCIsXG4gICAgICBcImJuXCI6IFwiQmVuZ2FsaVwiLFxuICAgICAgXCJic1wiOiBcIkJvc25pYW5cIixcbiAgICAgIFwiYnJcIjogXCJCcmV0b25cIixcbiAgICAgIFwiYmdcIjogXCJCdWxnYXJpYW5cIixcbiAgICAgIFwibXlcIjogXCJCdXJtZXNlXCIsXG4gICAgICBcImNhXCI6IFwiQ2F0YWxhblwiLFxuICAgICAgXCJjaFwiOiBcIkNoYW1vcnJvXCIsXG4gICAgICBcImNlXCI6IFwiQ2hlY2hlblwiLFxuICAgICAgXCJ6aFwiOiBcIkNoaW5lc2VcIixcbiAgICAgIFwiemgtSEtcIjogXCJDaGluZXNlIChIb25nIEtvbmcpXCIsXG4gICAgICBcInpoLUNOXCI6IFwiQ2hpbmVzZSAoUFJDKVwiLFxuICAgICAgXCJ6aC1TR1wiOiBcIkNoaW5lc2UgKFNpbmdhcG9yZSlcIixcbiAgICAgIFwiemgtVFdcIjogXCJDaGluZXNlIChUYWl3YW4pXCIsXG4gICAgICBcImN2XCI6IFwiQ2h1dmFzaFwiLFxuICAgICAgXCJjb1wiOiBcIkNvcnNpY2FuXCIsXG4gICAgICBcImNyXCI6IFwiQ3JlZVwiLFxuICAgICAgXCJoclwiOiBcIkNyb2F0aWFuXCIsXG4gICAgICBcImNzXCI6IFwiQ3plY2hcIixcbiAgICAgIFwiZGFcIjogXCJEYW5pc2hcIixcbiAgICAgIFwibmxcIjogXCJEdXRjaCAoU3RhbmRhcmQpXCIsXG4gICAgICBcIm5sLUJFXCI6IFwiRHV0Y2ggKEJlbGdpYW4pXCIsXG4gICAgICBcImVuXCI6IFwiRW5nbGlzaFwiLFxuICAgICAgXCJlbi1BVVwiOiBcIkVuZ2xpc2ggKEF1c3RyYWxpYSlcIixcbiAgICAgIFwiZW4tQlpcIjogXCJFbmdsaXNoIChCZWxpemUpXCIsXG4gICAgICBcImVuLUNBXCI6IFwiRW5nbGlzaCAoQ2FuYWRhKVwiLFxuICAgICAgXCJlbi1JRVwiOiBcIkVuZ2xpc2ggKElyZWxhbmQpXCIsXG4gICAgICBcImVuLUpNXCI6IFwiRW5nbGlzaCAoSmFtYWljYSlcIixcbiAgICAgIFwiZW4tTlpcIjogXCJFbmdsaXNoIChOZXcgWmVhbGFuZClcIixcbiAgICAgIFwiZW4tUEhcIjogXCJFbmdsaXNoIChQaGlsaXBwaW5lcylcIixcbiAgICAgIFwiZW4tWkFcIjogXCJFbmdsaXNoIChTb3V0aCBBZnJpY2EpXCIsXG4gICAgICBcImVuLVRUXCI6IFwiRW5nbGlzaCAoVHJpbmlkYWQgJiBUb2JhZ28pXCIsXG4gICAgICBcImVuLUdCXCI6IFwiRW5nbGlzaCAoVW5pdGVkIEtpbmdkb20pXCIsXG4gICAgICBcImVuLVVTXCI6IFwiRW5nbGlzaCAoVW5pdGVkIFN0YXRlcylcIixcbiAgICAgIFwiZW4tWldcIjogXCJFbmdsaXNoIChaaW1iYWJ3ZSlcIixcbiAgICAgIFwiZW9cIjogXCJFc3BlcmFudG9cIixcbiAgICAgIFwiZXRcIjogXCJFc3RvbmlhblwiLFxuICAgICAgXCJmb1wiOiBcIkZhZXJvZXNlXCIsXG4gICAgICBcImZqXCI6IFwiRmlqaWFuXCIsXG4gICAgICBcImZpXCI6IFwiRmlubmlzaFwiLFxuICAgICAgXCJmclwiOiBcIkZyZW5jaCAoU3RhbmRhcmQpXCIsXG4gICAgICBcImZyLUJFXCI6IFwiRnJlbmNoIChCZWxnaXVtKVwiLFxuICAgICAgXCJmci1DQVwiOiBcIkZyZW5jaCAoQ2FuYWRhKVwiLFxuICAgICAgXCJmci1GUlwiOiBcIkZyZW5jaCAoRnJhbmNlKVwiLFxuICAgICAgXCJmci1MVVwiOiBcIkZyZW5jaCAoTHV4ZW1ib3VyZylcIixcbiAgICAgIFwiZnItTUNcIjogXCJGcmVuY2ggKE1vbmFjbylcIixcbiAgICAgIFwiZnItQ0hcIjogXCJGcmVuY2ggKFN3aXR6ZXJsYW5kKVwiLFxuICAgICAgXCJmeVwiOiBcIkZyaXNpYW5cIixcbiAgICAgIFwiZnVyXCI6IFwiRnJpdWxpYW5cIixcbiAgICAgIFwiZ2RcIjogXCJHYWVsaWMgKFNjb3RzKVwiLFxuICAgICAgXCJnZC1JRVwiOiBcIkdhZWxpYyAoSXJpc2gpXCIsXG4gICAgICBcImdsXCI6IFwiR2FsYWNpYW5cIixcbiAgICAgIFwia2FcIjogXCJHZW9yZ2lhblwiLFxuICAgICAgXCJkZVwiOiBcIkdlcm1hbiAoU3RhbmRhcmQpXCIsXG4gICAgICBcImRlLUFUXCI6IFwiR2VybWFuIChBdXN0cmlhKVwiLFxuICAgICAgXCJkZS1ERVwiOiBcIkdlcm1hbiAoR2VybWFueSlcIixcbiAgICAgIFwiZGUtTElcIjogXCJHZXJtYW4gKExpZWNodGVuc3RlaW4pXCIsXG4gICAgICBcImRlLUxVXCI6IFwiR2VybWFuIChMdXhlbWJvdXJnKVwiLFxuICAgICAgXCJkZS1DSFwiOiBcIkdlcm1hbiAoU3dpdHplcmxhbmQpXCIsXG4gICAgICBcImVsXCI6IFwiR3JlZWtcIixcbiAgICAgIFwiZ3VcIjogXCJHdWp1cmF0aVwiLFxuICAgICAgXCJodFwiOiBcIkhhaXRpYW5cIixcbiAgICAgIFwiaGVcIjogXCJIZWJyZXdcIixcbiAgICAgIFwiaGlcIjogXCJIaW5kaVwiLFxuICAgICAgXCJodVwiOiBcIkh1bmdhcmlhblwiLFxuICAgICAgXCJpc1wiOiBcIkljZWxhbmRpY1wiLFxuICAgICAgXCJpZFwiOiBcIkluZG9uZXNpYW5cIixcbiAgICAgIFwiaXVcIjogXCJJbnVrdGl0dXRcIixcbiAgICAgIFwiZ2FcIjogXCJJcmlzaFwiLFxuICAgICAgXCJpdFwiOiBcIkl0YWxpYW4gKFN0YW5kYXJkKVwiLFxuICAgICAgXCJpdC1DSFwiOiBcIkl0YWxpYW4gKFN3aXR6ZXJsYW5kKVwiLFxuICAgICAgXCJqYVwiOiBcIkphcGFuZXNlXCIsXG4gICAgICBcImtuXCI6IFwiS2FubmFkYVwiLFxuICAgICAgXCJrc1wiOiBcIkthc2htaXJpXCIsXG4gICAgICBcImtrXCI6IFwiS2F6YWtoXCIsXG4gICAgICBcImttXCI6IFwiS2htZXJcIixcbiAgICAgIFwia3lcIjogXCJLaXJnaGl6XCIsXG4gICAgICBcInRsaFwiOiBcIktsaW5nb25cIixcbiAgICAgIFwia29cIjogXCJLb3JlYW5cIixcbiAgICAgIFwia28tS1BcIjogXCJLb3JlYW4gKE5vcnRoIEtvcmVhKVwiLFxuICAgICAgXCJrby1LUlwiOiBcIktvcmVhbiAoU291dGggS29yZWEpXCIsXG4gICAgICBcImxhXCI6IFwiTGF0aW5cIixcbiAgICAgIFwibHZcIjogXCJMYXR2aWFuXCIsXG4gICAgICBcImx0XCI6IFwiTGl0aHVhbmlhblwiLFxuICAgICAgXCJsYlwiOiBcIkx1eGVtYm91cmdpc2hcIixcbiAgICAgIFwibWtcIjogXCJGWVJPIE1hY2Vkb25pYW5cIixcbiAgICAgIFwibXNcIjogXCJNYWxheVwiLFxuICAgICAgXCJtbFwiOiBcIk1hbGF5YWxhbVwiLFxuICAgICAgXCJtdFwiOiBcIk1hbHRlc2VcIixcbiAgICAgIFwibWlcIjogXCJNYW9yaVwiLFxuICAgICAgXCJtclwiOiBcIk1hcmF0aGlcIixcbiAgICAgIFwibW9cIjogXCJNb2xkYXZpYW5cIixcbiAgICAgIFwibnZcIjogXCJOYXZham9cIixcbiAgICAgIFwibmdcIjogXCJOZG9uZ2FcIixcbiAgICAgIFwibmVcIjogXCJOZXBhbGlcIixcbiAgICAgIFwibm9cIjogXCJOb3J3ZWdpYW5cIixcbiAgICAgIFwibmJcIjogXCJOb3J3ZWdpYW4gKEJva21hbClcIixcbiAgICAgIFwibm5cIjogXCJOb3J3ZWdpYW4gKE55bm9yc2spXCIsXG4gICAgICBcIm9jXCI6IFwiT2NjaXRhblwiLFxuICAgICAgXCJvclwiOiBcIk9yaXlhXCIsXG4gICAgICBcIm9tXCI6IFwiT3JvbW9cIixcbiAgICAgIFwiZmFcIjogXCJQZXJzaWFuXCIsXG4gICAgICBcImZhLUlSXCI6IFwiUGVyc2lhbi9JcmFuXCIsXG4gICAgICBcInBsXCI6IFwiUG9saXNoXCIsXG4gICAgICBcInB0XCI6IFwiUG9ydHVndWVzZVwiLFxuICAgICAgXCJwdC1CUlwiOiBcIlBvcnR1Z3Vlc2UgKEJyYXppbClcIixcbiAgICAgIFwicGFcIjogXCJQdW5qYWJpXCIsXG4gICAgICBcInBhLUlOXCI6IFwiUHVuamFiaSAoSW5kaWEpXCIsXG4gICAgICBcInBhLVBLXCI6IFwiUHVuamFiaSAoUGFraXN0YW4pXCIsXG4gICAgICBcInF1XCI6IFwiUXVlY2h1YVwiLFxuICAgICAgXCJybVwiOiBcIlJoYWV0by1Sb21hbmljXCIsXG4gICAgICBcInJvXCI6IFwiUm9tYW5pYW5cIixcbiAgICAgIFwicm8tTU9cIjogXCJSb21hbmlhbiAoTW9sZGF2aWEpXCIsXG4gICAgICBcInJ1XCI6IFwiUnVzc2lhblwiLFxuICAgICAgXCJydS1NT1wiOiBcIlJ1c3NpYW4gKE1vbGRhdmlhKVwiLFxuICAgICAgXCJzelwiOiBcIlNhbWkgKExhcHBpc2gpXCIsXG4gICAgICBcInNnXCI6IFwiU2FuZ29cIixcbiAgICAgIFwic2FcIjogXCJTYW5za3JpdFwiLFxuICAgICAgXCJzY1wiOiBcIlNhcmRpbmlhblwiLFxuICAgICAgXCJzZFwiOiBcIlNpbmRoaVwiLFxuICAgICAgXCJzaVwiOiBcIlNpbmdoYWxlc2VcIixcbiAgICAgIFwic3JcIjogXCJTZXJiaWFuXCIsXG4gICAgICBcInNrXCI6IFwiU2xvdmFrXCIsXG4gICAgICBcInNsXCI6IFwiU2xvdmVuaWFuXCIsXG4gICAgICBcInNvXCI6IFwiU29tYW5pXCIsXG4gICAgICBcInNiXCI6IFwiU29yYmlhblwiLFxuICAgICAgXCJlc1wiOiBcIlNwYW5pc2hcIixcbiAgICAgIFwiZXMtQVJcIjogXCJTcGFuaXNoIChBcmdlbnRpbmEpXCIsXG4gICAgICBcImVzLUJPXCI6IFwiU3BhbmlzaCAoQm9saXZpYSlcIixcbiAgICAgIFwiZXMtQ0xcIjogXCJTcGFuaXNoIChDaGlsZSlcIixcbiAgICAgIFwiZXMtQ09cIjogXCJTcGFuaXNoIChDb2xvbWJpYSlcIixcbiAgICAgIFwiZXMtQ1JcIjogXCJTcGFuaXNoIChDb3N0YSBSaWNhKVwiLFxuICAgICAgXCJlcy1ET1wiOiBcIlNwYW5pc2ggKERvbWluaWNhbiBSZXB1YmxpYylcIixcbiAgICAgIFwiZXMtRUNcIjogXCJTcGFuaXNoIChFY3VhZG9yKVwiLFxuICAgICAgXCJlcy1TVlwiOiBcIlNwYW5pc2ggKEVsIFNhbHZhZG9yKVwiLFxuICAgICAgXCJlcy1HVFwiOiBcIlNwYW5pc2ggKEd1YXRlbWFsYSlcIixcbiAgICAgIFwiZXMtSE5cIjogXCJTcGFuaXNoIChIb25kdXJhcylcIixcbiAgICAgIFwiZXMtTVhcIjogXCJTcGFuaXNoIChNZXhpY28pXCIsXG4gICAgICBcImVzLU5JXCI6IFwiU3BhbmlzaCAoTmljYXJhZ3VhKVwiLFxuICAgICAgXCJlcy1QQVwiOiBcIlNwYW5pc2ggKFBhbmFtYSlcIixcbiAgICAgIFwiZXMtUFlcIjogXCJTcGFuaXNoIChQYXJhZ3VheSlcIixcbiAgICAgIFwiZXMtUEVcIjogXCJTcGFuaXNoIChQZXJ1KVwiLFxuICAgICAgXCJlcy1QUlwiOiBcIlNwYW5pc2ggKFB1ZXJ0byBSaWNvKVwiLFxuICAgICAgXCJlcy1FU1wiOiBcIlNwYW5pc2ggKFNwYWluKVwiLFxuICAgICAgXCJlcy1VWVwiOiBcIlNwYW5pc2ggKFVydWd1YXkpXCIsXG4gICAgICBcImVzLVZFXCI6IFwiU3BhbmlzaCAoVmVuZXp1ZWxhKVwiLFxuICAgICAgXCJzeFwiOiBcIlN1dHVcIixcbiAgICAgIFwic3dcIjogXCJTd2FoaWxpXCIsXG4gICAgICBcInN2XCI6IFwiU3dlZGlzaFwiLFxuICAgICAgXCJzdi1GSVwiOiBcIlN3ZWRpc2ggKEZpbmxhbmQpXCIsXG4gICAgICBcInN2LVNWXCI6IFwiU3dlZGlzaCAoU3dlZGVuKVwiLFxuICAgICAgXCJ0YVwiOiBcIlRhbWlsXCIsXG4gICAgICBcInR0XCI6IFwiVGF0YXJcIixcbiAgICAgIFwidGVcIjogXCJUZWx1Z2FcIixcbiAgICAgIFwidGhcIjogXCJUaGFpXCIsXG4gICAgICBcInRpZ1wiOiBcIlRpZ3JlXCIsXG4gICAgICBcInRzXCI6IFwiVHNvbmdhXCIsXG4gICAgICBcInRuXCI6IFwiVHN3YW5hXCIsXG4gICAgICBcInRyXCI6IFwiVHVya2lzaFwiLFxuICAgICAgXCJ0a1wiOiBcIlR1cmttZW5cIixcbiAgICAgIFwidWtcIjogXCJVa3JhaW5pYW5cIixcbiAgICAgIFwiaHNiXCI6IFwiVXBwZXIgU29yYmlhblwiLFxuICAgICAgXCJ1clwiOiBcIlVyZHVcIixcbiAgICAgIFwidmVcIjogXCJWZW5kYVwiLFxuICAgICAgXCJ2aVwiOiBcIlZpZXRuYW1lc2VcIixcbiAgICAgIFwidm9cIjogXCJWb2xhcHVrXCIsXG4gICAgICBcIndhXCI6IFwiV2FsbG9vblwiLFxuICAgICAgXCJjeVwiOiBcIldlbHNoXCIsXG4gICAgICBcInhoXCI6IFwiWGhvc2FcIixcbiAgICAgIFwiamlcIjogXCJZaWRkaXNoXCIsXG4gICAgICBcInp1XCI6IFwiWnVsdVwiXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmludGVybmFsLmxhbmd1YWdlU2V0dGluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnRlcm5hbC5sYW5ndWFnZVNldHRpbmdzID0ge307XG4gICAgICB0aGlzLmludGVybmFsLmxhbmd1YWdlU2V0dGluZ3MuaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxhbmdDb2Rlc1tsYW5nQ29kZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnRlcm5hbC5sYW5ndWFnZVNldHRpbmdzLmxhbmd1YWdlQ29kZSA9IGxhbmdDb2RlO1xuXG4gICAgICBpZiAodGhpcy5pbnRlcm5hbC5sYW5ndWFnZVNldHRpbmdzLmlzU3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKFwicHV0Q2F0YWxvZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbC53cml0ZShcIi9MYW5nIChcIiArIHRoaXMuaW50ZXJuYWwubGFuZ3VhZ2VTZXR0aW5ncy5sYW5ndWFnZUNvZGUgKyBcIilcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmludGVybmFsLmxhbmd1YWdlU2V0dGluZ3MuaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKGpzUERGLkFQSSk7XG5cbi8qKiBAbGljZW5zZVxuICogTUlUIGxpY2Vuc2UuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgV2lsbG93IFN5c3RlbXMgQ29ycG9yYXRpb24sIHdpbGxvdy1zeXN0ZW1zLmNvbVxuICogICAgICAgICAgICAgICAyMDE0IERpZWdvIENhc29ycmFuLCBodHRwczovL2dpdGh1Yi5jb20vZGllZ29jclxuICpcbiAqIFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbioganNQREYgc3BsaXRfdGV4dF90b19zaXplIHBsdWdpbiBcbiogXG4qIEBuYW1lIHNwbGl0X3RleHRfdG9fc2l6ZVxuKiBAbW9kdWxlXG4qL1xuKGZ1bmN0aW9uIChBUEkpIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGVuZ3RoIG1hdGNoaW5nIGxlbmd0aCBvZiB0aGUgJ3dvcmQnIHN0cmluZywgd2l0aCBlYWNoXG4gICAqIGNlbGwgb2NjdXBpZWQgYnkgdGhlIHdpZHRoIG9mIHRoZSBjaGFyIGluIHRoYXQgcG9zaXRpb24uXG4gICAqIFxuICAgKiBAbmFtZSBnZXRDaGFyV2lkdGhzQXJyYXlcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG5cbiAgdmFyIGdldENoYXJXaWR0aHNBcnJheSA9IEFQSS5nZXRDaGFyV2lkdGhzQXJyYXkgPSBmdW5jdGlvbiAodGV4dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBhY3RpdmVGb250ID0gb3B0aW9ucy5mb250IHx8IHRoaXMuaW50ZXJuYWwuZ2V0Rm9udCgpO1xuICAgIHZhciBmb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgdGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpO1xuICAgIHZhciBjaGFyU3BhY2UgPSBvcHRpb25zLmNoYXJTcGFjZSB8fCB0aGlzLmludGVybmFsLmdldENoYXJTcGFjZSgpO1xuICAgIHZhciB3aWR0aHMgPSBvcHRpb25zLndpZHRocyA/IG9wdGlvbnMud2lkdGhzIDogYWN0aXZlRm9udC5tZXRhZGF0YS5Vbmljb2RlLndpZHRocztcbiAgICB2YXIgd2lkdGhzRnJhY3Rpb25PZiA9IHdpZHRocy5mb2YgPyB3aWR0aHMuZm9mIDogMTtcbiAgICB2YXIga2VybmluZyA9IG9wdGlvbnMua2VybmluZyA/IG9wdGlvbnMua2VybmluZyA6IGFjdGl2ZUZvbnQubWV0YWRhdGEuVW5pY29kZS5rZXJuaW5nO1xuICAgIHZhciBrZXJuaW5nRnJhY3Rpb25PZiA9IGtlcm5pbmcuZm9mID8ga2VybmluZy5mb2YgOiAxO1xuICAgIHZhciBpO1xuICAgIHZhciBsO1xuICAgIHZhciBjaGFyX2NvZGU7XG4gICAgdmFyIHByaW9yX2NoYXJfY29kZSA9IDA7IC8vZm9yIGtlcm5pbmdcblxuICAgIHZhciBkZWZhdWx0X2NoYXJfd2lkdGggPSB3aWR0aHNbMF0gfHwgd2lkdGhzRnJhY3Rpb25PZjtcbiAgICB2YXIgb3V0cHV0ID0gW107XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gdGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoYXJfY29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHR5cGVvZiBhY3RpdmVGb250Lm1ldGFkYXRhLndpZHRoT2ZTdHJpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvdXRwdXQucHVzaCgoYWN0aXZlRm9udC5tZXRhZGF0YS53aWR0aE9mR2x5cGgoYWN0aXZlRm9udC5tZXRhZGF0YS5jaGFyYWN0ZXJUb0dseXBoKGNoYXJfY29kZSkpICsgY2hhclNwYWNlICogKDEwMDAgLyBmb250U2l6ZSkgfHwgMCkgLyAxMDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCh3aWR0aHNbY2hhcl9jb2RlXSB8fCBkZWZhdWx0X2NoYXJfd2lkdGgpIC8gd2lkdGhzRnJhY3Rpb25PZiArIChrZXJuaW5nW2NoYXJfY29kZV0gJiYga2VybmluZ1tjaGFyX2NvZGVdW3ByaW9yX2NoYXJfY29kZV0gfHwgMCkgLyBrZXJuaW5nRnJhY3Rpb25PZik7XG4gICAgICB9XG5cbiAgICAgIHByaW9yX2NoYXJfY29kZSA9IGNoYXJfY29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBzdW0gb2YgYSBudW1iZXItYXJyYXlcbiAgICogXG4gICAqIEBuYW1lIGdldEFycmF5U3VtXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IG9mIG51bWJlcnNcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG5cblxuICB2YXIgZ2V0QXJyYXlTdW0gPSBBUEkuZ2V0QXJyYXlTdW0gPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgb3V0cHV0ID0gMDtcblxuICAgIHdoaWxlIChpKSB7XG4gICAgICBpLS07XG4gICAgICBvdXRwdXQgKz0gYXJyYXlbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbiAgLyoqXG4gICogUmV0dXJucyBhIHdpZHRocyBvZiBzdHJpbmcgaW4gYSBnaXZlbiBmb250LCBpZiB0aGUgZm9udCBzaXplIGlzIHNldCBhcyAxIHBvaW50LlxuICAqXG4gICogSW4gb3RoZXIgd29yZHMsIHRoaXMgaXMgXCJwcm9wb3J0aW9uYWxcIiB2YWx1ZS4gRm9yIDEgdW5pdCBvZiBmb250IHNpemUsIHRoZSBsZW5ndGhcbiAgKiBvZiB0aGUgc3RyaW5nIHdpbGwgYmUgdGhhdCBtdWNoLlxuICAqIFxuICAqIE11bHRpcGx5IGJ5IGZvbnQgc2l6ZSB0byBnZXQgYWN0dWFsIHdpZHRoIGluICpwb2ludHMqXG4gICogVGhlbiBkaXZpZGUgYnkgNzIgdG8gZ2V0IGluY2hlcyBvciBkaXZpZGUgYnkgKDcyLzI1LjYpIHRvIGdldCAnbW0nIGV0Yy5cbiAgKiBcbiAgKiBAbmFtZSBnZXRTdHJpbmdVbml0V2lkdGhcbiAgKiBAcHVibGljXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uc1xuICAqIEByZXR1cm5zIHtudW1iZXJ9IHJlc3VsdFxuICAqL1xuXG5cbiAgdmFyIGdldFN0cmluZ1VuaXRXaWR0aCA9IEFQSS5nZXRTdHJpbmdVbml0V2lkdGggPSBmdW5jdGlvbiAodGV4dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBmb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgdGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpO1xuICAgIHZhciBmb250ID0gb3B0aW9ucy5mb250IHx8IHRoaXMuaW50ZXJuYWwuZ2V0Rm9udCgpO1xuICAgIHZhciBjaGFyU3BhY2UgPSBvcHRpb25zLmNoYXJTcGFjZSB8fCB0aGlzLmludGVybmFsLmdldENoYXJTcGFjZSgpO1xuICAgIHZhciByZXN1bHQgPSAwO1xuXG4gICAgaWYgKHR5cGVvZiBmb250Lm1ldGFkYXRhLndpZHRoT2ZTdHJpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmVzdWx0ID0gZm9udC5tZXRhZGF0YS53aWR0aE9mU3RyaW5nKHRleHQsIGZvbnRTaXplLCBjaGFyU3BhY2UpIC8gZm9udFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGdldEFycmF5U3VtKGdldENoYXJXaWR0aHNBcnJheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvKipcbiAgcmV0dXJucyBhcnJheSBvZiBsaW5lc1xuICAqL1xuXG5cbiAgdmFyIHNwbGl0TG9uZ1dvcmQgPSBmdW5jdGlvbiBzcGxpdExvbmdXb3JkKHdvcmQsIHdpZHRoc19hcnJheSwgZmlyc3RMaW5lTWF4TGVuLCBtYXhMZW4pIHtcbiAgICB2YXIgYW5zd2VyID0gW107IC8vIDFzdCwgY2hvcCBvZmYgdGhlIHBpZWNlIHRoYXQgY2FuIGZpdCBvbiB0aGUgaGFuZ2luZyBsaW5lLlxuXG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsID0gd29yZC5sZW5ndGgsXG4gICAgICAgIHdvcmtpbmdMZW4gPSAwO1xuXG4gICAgd2hpbGUgKGkgIT09IGwgJiYgd29ya2luZ0xlbiArIHdpZHRoc19hcnJheVtpXSA8IGZpcnN0TGluZU1heExlbikge1xuICAgICAgd29ya2luZ0xlbiArPSB3aWR0aHNfYXJyYXlbaV07XG4gICAgICBpKys7XG4gICAgfSAvLyB0aGlzIGlzIGZpcnN0IGxpbmUuXG5cblxuICAgIGFuc3dlci5wdXNoKHdvcmQuc2xpY2UoMCwgaSkpOyAvLyAybmQuIFNwbGl0IHRoZSByZXN0IGludG8gbWF4TGVuIHBpZWNlcy5cblxuICAgIHZhciBzdGFydE9mTGluZSA9IGk7XG4gICAgd29ya2luZ0xlbiA9IDA7XG5cbiAgICB3aGlsZSAoaSAhPT0gbCkge1xuICAgICAgaWYgKHdvcmtpbmdMZW4gKyB3aWR0aHNfYXJyYXlbaV0gPiBtYXhMZW4pIHtcbiAgICAgICAgYW5zd2VyLnB1c2god29yZC5zbGljZShzdGFydE9mTGluZSwgaSkpO1xuICAgICAgICB3b3JraW5nTGVuID0gMDtcbiAgICAgICAgc3RhcnRPZkxpbmUgPSBpO1xuICAgICAgfVxuXG4gICAgICB3b3JraW5nTGVuICs9IHdpZHRoc19hcnJheVtpXTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRPZkxpbmUgIT09IGkpIHtcbiAgICAgIGFuc3dlci5wdXNoKHdvcmQuc2xpY2Uoc3RhcnRPZkxpbmUsIGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5zd2VyO1xuICB9OyAvLyBOb3RlLCBhbGwgc2l6aW5nIGlucHV0cyBmb3IgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGluIFwiZm9udCBtZWFzdXJlbWVudCB1bml0c1wiXG4gIC8vIEJ5IGRlZmF1bHQsIGZvciBQREYsIGl0J3MgXCJwb2ludFwiLlxuXG5cbiAgdmFyIHNwbGl0UGFyYWdyYXBoSW50b0xpbmVzID0gZnVuY3Rpb24gc3BsaXRQYXJhZ3JhcGhJbnRvTGluZXModGV4dCwgbWF4bGVuLCBvcHRpb25zKSB7XG4gICAgLy8gYXQgdGhpcyB0aW1lIHdvcmtzIG9ubHkgb24gV2VzdGVybiBzY3JpcHRzLCBvbmVzIHdpdGggc3BhY2UgY2hhclxuICAgIC8vIHNlcGFyYXRpbmcgdGhlIHdvcmRzLiBGZWVsIGZyZWUgdG8gZXhwYW5kLlxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBsaW5lID0gW10sXG4gICAgICAgIGxpbmVzID0gW2xpbmVdLFxuICAgICAgICBsaW5lX2xlbmd0aCA9IG9wdGlvbnMudGV4dEluZGVudCB8fCAwLFxuICAgICAgICBzZXBhcmF0b3JfbGVuZ3RoID0gMCxcbiAgICAgICAgY3VycmVudF93b3JkX2xlbmd0aCA9IDAsXG4gICAgICAgIHdvcmQsXG4gICAgICAgIHdpZHRoc19hcnJheSxcbiAgICAgICAgd29yZHMgPSB0ZXh0LnNwbGl0KCcgJyksXG4gICAgICAgIHNwYWNlQ2hhcldpZHRoID0gZ2V0Q2hhcldpZHRoc0FycmF5LmFwcGx5KHRoaXMsIFsnICcsIG9wdGlvbnNdKVswXSxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgdG1wLFxuICAgICAgICBsaW5lSW5kZW50O1xuXG4gICAgaWYgKG9wdGlvbnMubGluZUluZGVudCA9PT0gLTEpIHtcbiAgICAgIGxpbmVJbmRlbnQgPSB3b3Jkc1swXS5sZW5ndGggKyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lSW5kZW50ID0gb3B0aW9ucy5saW5lSW5kZW50IHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVJbmRlbnQpIHtcbiAgICAgIHZhciBwYWQgPSBBcnJheShsaW5lSW5kZW50KS5qb2luKFwiIFwiKSxcbiAgICAgICAgICB3cmRzID0gW107XG4gICAgICB3b3Jkcy5tYXAoZnVuY3Rpb24gKHdyZCkge1xuICAgICAgICB3cmQgPSB3cmQuc3BsaXQoL1xccypcXG4vKTtcblxuICAgICAgICBpZiAod3JkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB3cmRzID0gd3Jkcy5jb25jYXQod3JkLm1hcChmdW5jdGlvbiAod3JkLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiAoaWR4ICYmIHdyZC5sZW5ndGggPyBcIlxcblwiIDogXCJcIikgKyB3cmQ7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyZHMucHVzaCh3cmRbMF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdvcmRzID0gd3JkcztcbiAgICAgIGxpbmVJbmRlbnQgPSBnZXRTdHJpbmdVbml0V2lkdGguYXBwbHkodGhpcywgW3BhZCwgb3B0aW9uc10pO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGwgPSB3b3Jkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBmb3JjZSA9IDA7XG4gICAgICB3b3JkID0gd29yZHNbaV07XG5cbiAgICAgIGlmIChsaW5lSW5kZW50ICYmIHdvcmRbMF0gPT0gXCJcXG5cIikge1xuICAgICAgICB3b3JkID0gd29yZC5zdWJzdHIoMSk7XG4gICAgICAgIGZvcmNlID0gMTtcbiAgICAgIH1cblxuICAgICAgd2lkdGhzX2FycmF5ID0gZ2V0Q2hhcldpZHRoc0FycmF5LmFwcGx5KHRoaXMsIFt3b3JkLCBvcHRpb25zXSk7XG4gICAgICBjdXJyZW50X3dvcmRfbGVuZ3RoID0gZ2V0QXJyYXlTdW0od2lkdGhzX2FycmF5KTtcblxuICAgICAgaWYgKGxpbmVfbGVuZ3RoICsgc2VwYXJhdG9yX2xlbmd0aCArIGN1cnJlbnRfd29yZF9sZW5ndGggPiBtYXhsZW4gfHwgZm9yY2UpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRfd29yZF9sZW5ndGggPiBtYXhsZW4pIHtcbiAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgd2hlbiB5b3UgaGF2ZSBzcGFjZS1sZXNzIGxvbmcgVVJMcyBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAvLyB3ZSBqdXN0IGNob3AgdGhlc2UgdG8gc2l6ZS4gV2UgZG8gTk9UIGluc2VydCBoaXBoZW5zXG4gICAgICAgICAgdG1wID0gc3BsaXRMb25nV29yZC5hcHBseSh0aGlzLCBbd29yZCwgd2lkdGhzX2FycmF5LCBtYXhsZW4gLSAobGluZV9sZW5ndGggKyBzZXBhcmF0b3JfbGVuZ3RoKSwgbWF4bGVuXSk7IC8vIGZpcnN0IGxpbmUgd2UgYWRkIHRvIGV4aXN0aW5nIGxpbmUgb2JqZWN0XG5cbiAgICAgICAgICBsaW5lLnB1c2godG1wLnNoaWZ0KCkpOyAvLyBpdCdzIG9rIHRvIGhhdmUgZXh0cmEgc3BhY2UgaW5kaWNhdG9yIHRoZXJlXG4gICAgICAgICAgLy8gbGFzdCBsaW5lIHdlIG1ha2UgaW50byBuZXcgbGluZSBvYmplY3RcblxuICAgICAgICAgIGxpbmUgPSBbdG1wLnBvcCgpXTsgLy8gbGluZXMgaW4gdGhlIG1pZGRsZSB3ZSBhcHBlZCB0byBsaW5lcyBvYmplY3QgYXMgd2hvbGUgbGluZXNcblxuICAgICAgICAgIHdoaWxlICh0bXAubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKFt0bXAuc2hpZnQoKV0pOyAvLyBzaW5nbGUgZnJhZ21lbnQgb2NjdXBpZXMgd2hvbGUgbGluZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRfd29yZF9sZW5ndGggPSBnZXRBcnJheVN1bSh3aWR0aHNfYXJyYXkuc2xpY2Uod29yZC5sZW5ndGggLSAobGluZVswXSA/IGxpbmVbMF0ubGVuZ3RoIDogMCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBqdXN0IHB1dCBpdCBvbiBhIG5ldyBsaW5lXG4gICAgICAgICAgbGluZSA9IFt3b3JkXTtcbiAgICAgICAgfSAvLyBub3cgd2UgYXR0YWNoIG5ldyBsaW5lIHRvIGxpbmVzXG5cblxuICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICBsaW5lX2xlbmd0aCA9IGN1cnJlbnRfd29yZF9sZW5ndGggKyBsaW5lSW5kZW50O1xuICAgICAgICBzZXBhcmF0b3JfbGVuZ3RoID0gc3BhY2VDaGFyV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lLnB1c2god29yZCk7XG4gICAgICAgIGxpbmVfbGVuZ3RoICs9IHNlcGFyYXRvcl9sZW5ndGggKyBjdXJyZW50X3dvcmRfbGVuZ3RoO1xuICAgICAgICBzZXBhcmF0b3JfbGVuZ3RoID0gc3BhY2VDaGFyV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpbmVJbmRlbnQpIHtcbiAgICAgIHZhciBwb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIHBvc3RQcm9jZXNzKGxuLCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIChpZHggPyBwYWQgOiAnJykgKyBsbi5qb2luKFwiIFwiKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIHBvc3RQcm9jZXNzKGxuKSB7XG4gICAgICAgIHJldHVybiBsbi5qb2luKFwiIFwiKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzLm1hcChwb3N0UHJvY2Vzcyk7XG4gIH07XG4gIC8qKlxuICAqIFNwbGl0cyBhIGdpdmVuIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuIFVzZXMgJ3NpemUnIHZhbHVlXG4gICogKGluIG1lYXN1cmVtZW50IHVuaXRzIGRlY2xhcmVkIGFzIGRlZmF1bHQgZm9yIHRoZSBqc1BERiBpbnN0YW5jZSlcbiAgKiBhbmQgdGhlIGZvbnQncyBcIndpZHRoc1wiIGFuZCBcIktlcm5pbmdcIiB0YWJsZXMsIHdoZXJlIGF2YWlsYWJsZSwgdG9cbiAgKiBkZXRlcm1pbmUgZGlzcGxheSBsZW5ndGggb2YgYSBnaXZlbiBzdHJpbmcgZm9yIGEgZ2l2ZW4gZm9udC5cbiAgKiBcbiAgKiBXZSB1c2UgY2hhcmFjdGVyJ3MgMTAwJSBvZiB1bml0IHNpemUgKGhlaWdodCkgYXMgd2lkdGggd2hlbiBXaWR0aFxuICAqIHRhYmxlIG9yIG90aGVyIGRlZmF1bHQgd2lkdGggaXMgbm90IGF2YWlsYWJsZS5cbiAgKiBcbiAgKiBAbmFtZSBzcGxpdFRleHRUb1NpemVcbiAgKiBAcHVibGljXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVW5lbmNvZGVkLCByZWd1bGFyIEphdmFTY3JpcHQgKFVuaWNvZGUsIFVURi0xNiAvIFVDUy0yKSBzdHJpbmcuXG4gICogQHBhcmFtIHtudW1iZXJ9IHNpemUgTm9taW5hbCBudW1iZXIsIG1lYXN1cmVkIGluIHVuaXRzIGRlZmF1bHQgdG8gdGhpcyBpbnN0YW5jZSBvZiBqc1BERi5cbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBmbGFncyBuZWVkZWQgZm9yIGNob3BwZXIgdG8gZG8gdGhlIHJpZ2h0IHRoaW5nLlxuICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgQXJyYXkgd2l0aCBzdHJpbmdzIGNob3BwZWQgdG8gc2l6ZS5cbiAgKi9cblxuXG4gIEFQSS5zcGxpdFRleHRUb1NpemUgPSBmdW5jdGlvbiAodGV4dCwgbWF4bGVuLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBmc2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgdGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLFxuICAgICAgICBuZXdPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciB3aWR0aHMgPSB7XG4gICAgICAgIDA6IDFcbiAgICAgIH0sXG4gICAgICAgICAga2VybmluZyA9IHt9O1xuXG4gICAgICBpZiAoIW9wdGlvbnMud2lkdGhzIHx8ICFvcHRpb25zLmtlcm5pbmcpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmludGVybmFsLmdldEZvbnQob3B0aW9ucy5mb250TmFtZSwgb3B0aW9ucy5mb250U3R5bGUpLFxuICAgICAgICAgICAgZW5jb2RpbmcgPSAnVW5pY29kZSc7IC8vIE5PVCBVVEY4LCBOT1QgVVRGMTZCRS9MRSwgTk9UIFVDUzJCRS9MRVxuICAgICAgICAvLyBBY3R1YWwgSmF2YVNjcmlwdC1uYXRpdmUgU3RyaW5nJ3MgMTZiaXQgY2hhciBjb2RlcyB1c2VkLlxuICAgICAgICAvLyBubyBtdWx0aS1ieXRlIGxvZ2ljIGhlcmVcblxuICAgICAgICBpZiAoZi5tZXRhZGF0YVtlbmNvZGluZ10pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBmLm1ldGFkYXRhW2VuY29kaW5nXS53aWR0aHMgfHwgd2lkdGhzLFxuICAgICAgICAgICAga2VybmluZzogZi5tZXRhZGF0YVtlbmNvZGluZ10ua2VybmluZyB8fCBrZXJuaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9udDogZi5tZXRhZGF0YSxcbiAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmludGVybmFsLmdldEZvbnRTaXplKCksXG4gICAgICAgICAgICBjaGFyU3BhY2U6IHRoaXMuaW50ZXJuYWwuZ2V0Q2hhclNwYWNlKClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoczogb3B0aW9ucy53aWR0aHMsXG4gICAgICAgICAga2VybmluZzogb3B0aW9ucy5rZXJuaW5nXG4gICAgICAgIH07XG4gICAgICB9IC8vIHRoZW4gdXNlIGRlZmF1bHQgdmFsdWVzXG5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGhzOiB3aWR0aHMsXG4gICAgICAgIGtlcm5pbmc6IGtlcm5pbmdcbiAgICAgIH07XG4gICAgfS5jYWxsKHRoaXMsIG9wdGlvbnMpOyAvLyBmaXJzdCB3ZSBzcGxpdCBvbiBlbmQtb2YtbGluZSBjaGFyc1xuXG5cbiAgICB2YXIgcGFyYWdyYXBocztcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRleHQpKSB7XG4gICAgICBwYXJhZ3JhcGhzID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYWdyYXBocyA9IHRleHQuc3BsaXQoL1xccj9cXG4vKTtcbiAgICB9IC8vIG5vdyB3ZSBjb252ZXJ0IHNpemUgKG1heCBsZW5ndGggb2YgbGluZSkgaW50byBcImZvbnQgc2l6ZSB1bml0c1wiXG4gICAgLy8gYXQgcHJlc2VudCB0aW1lLCB0aGUgXCJmb250IHNpemUgdW5pdFwiIGlzIGFsd2F5cyAncG9pbnQnXG4gICAgLy8gJ3Byb3BvcnRpb25hbCcgbWVhbnMsIFwiaW4gcHJvcG9ydGlvbiB0byBmb250IHNpemVcIlxuXG5cbiAgICB2YXIgZm9udFVuaXRfbWF4TGVuID0gMS4wICogdGhpcy5pbnRlcm5hbC5zY2FsZUZhY3RvciAqIG1heGxlbiAvIGZzaXplOyAvLyBhdCB0aGlzIHRpbWUsIGZzaXplIGlzIGFsd2F5cyBpbiBcInBvaW50c1wiIHJlZ2FyZGxlc3Mgb2YgdGhlIGRlZmF1bHQgbWVhc3VyZW1lbnQgdW5pdCBvZiB0aGUgZG9jLlxuICAgIC8vIHRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlP1xuICAgIC8vIHVudGlsIHRoZW4sIHByb3BvcnRpb25hbF9tYXhsZW4gaXMgbGlrZWx5IHRvIGJlIGluICdwb2ludHMnXG4gICAgLy8gSWYgZmlyc3QgbGluZSBpcyB0byBiZSBpbmRlbnRlZCAoc2hvcnRlciBvciBsb25nZXIpIHRoYW4gbWF4TGVuXG4gICAgLy8gd2UgaW5kaWNhdGUgdGhhdCBieSB1c2luZyBDU1Mtc3R5bGUgXCJ0ZXh0LWluZGVudFwiIG9wdGlvbi5cbiAgICAvLyBoZXJlIGl0J3MgaW4gZm9udCB1bml0cyB0b28gKHdoaWNoIGlzIGxpa2VseSAncG9pbnRzJylcbiAgICAvLyBpdCBjYW4gYmUgbmVnYXRpdmUgKHdoaWNoIG1ha2VzIHRoZSBmaXJzdCBsaW5lIGxvbmdlciB0aGFuIG1heExlbilcblxuICAgIG5ld09wdGlvbnMudGV4dEluZGVudCA9IG9wdGlvbnMudGV4dEluZGVudCA/IG9wdGlvbnMudGV4dEluZGVudCAqIDEuMCAqIHRoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3IgLyBmc2l6ZSA6IDA7XG4gICAgbmV3T3B0aW9ucy5saW5lSW5kZW50ID0gb3B0aW9ucy5saW5lSW5kZW50O1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBvdXRwdXQgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBwYXJhZ3JhcGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LmNvbmNhdChzcGxpdFBhcmFncmFwaEludG9MaW5lcy5hcHBseSh0aGlzLCBbcGFyYWdyYXBoc1tpXSwgZm9udFVuaXRfbWF4TGVuLCBuZXdPcHRpb25zXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59KShqc1BERi5BUEkpO1xuXG4vKiogQGxpY2Vuc2VcbiBqc1BERiBzdGFuZGFyZF9mb250c19tZXRyaWNzIHBsdWdpblxuICogQ29weXJpZ2h0IChjKSAyMDEyIFdpbGxvdyBTeXN0ZW1zIENvcnBvcmF0aW9uLCB3aWxsb3ctc3lzdGVtcy5jb21cbiAqIE1JVCBsaWNlbnNlLlxuICogXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbihmdW5jdGlvbiAoQVBJKSB7XG4gIC8qXG4gICMgcmVmZXJlbmNlIChQeXRob24pIHZlcnNpb25zIG9mICdjb21wcmVzcycgYW5kICd1bmNvbXByZXNzJ1xuICAjIG9ubHkgJ3VuY29tcHJlc3MnIGZ1bmN0aW9uIGlzIGZlYXR1cmVkIGxvd2VyIGFzIEphdmFTY3JpcHRcbiAgIyBpZiB5b3Ugd2FudCB0byB1bml0IHRlc3QgXCJyb3VuZHRyaXBcIiwganVzdCB0cmFuc2NyaWJlIHRoZSByZWZlcmVuY2VcbiAgIyAnY29tcHJlc3MnIGZ1bmN0aW9uIGZyb20gUHl0aG9uIGludG8gSmF2YVNjcmlwdFxuICBcbiAgZGVmIGNvbXByZXNzKGRhdGEpOlxuICBcbiAgXHRrZXlzID0gICAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgXHR2YWx1ZXMgPSAna2xtbm9wcXJzdHV2d3h5eidcbiAgXHRtYXBwaW5nID0gZGljdCh6aXAoa2V5cywgdmFsdWVzKSlcbiAgXHR2YWxzID0gW11cbiAgXHRmb3Iga2V5IGluIGRhdGEua2V5cygpOlxuICBcdFx0dmFsdWUgPSBkYXRhW2tleV1cbiAgXHRcdHRyeTpcbiAgXHRcdFx0a2V5c3RyaW5nID0gaGV4KGtleSlbMjpdXG4gIFx0XHRcdGtleXN0cmluZyA9IGtleXN0cmluZ1s6LTFdICsgbWFwcGluZ1trZXlzdHJpbmdbLTE6XV1cbiAgXHRcdGV4Y2VwdDpcbiAgXHRcdFx0a2V5c3RyaW5nID0ga2V5LmpvaW4oW1wiJ1wiLFwiJ1wiXSlcbiAgXHRcdFx0I3ByaW50KCdLZXlzdHJpbmcgaXMgJXMnICUga2V5c3RyaW5nKVxuICBcbiAgXHRcdHRyeTpcbiAgXHRcdFx0aWYgdmFsdWUgPCAwOlxuICBcdFx0XHRcdHZhbHVlc3RyaW5nID0gaGV4KHZhbHVlKVszOl1cbiAgXHRcdFx0XHRudW1iZXJwcmVmaXggPSAnLSdcbiAgXHRcdFx0ZWxzZTpcbiAgXHRcdFx0XHR2YWx1ZXN0cmluZyA9IGhleCh2YWx1ZSlbMjpdXG4gIFx0XHRcdFx0bnVtYmVycHJlZml4ID0gJydcbiAgXHRcdFx0dmFsdWVzdHJpbmcgPSBudW1iZXJwcmVmaXggKyB2YWx1ZXN0cmluZ1s6LTFdICsgbWFwcGluZ1t2YWx1ZXN0cmluZ1stMTpdXVxuICBcdFx0ZXhjZXB0OlxuICBcdFx0XHRpZiB0eXBlKHZhbHVlKSA9PSBkaWN0OlxuICBcdFx0XHRcdHZhbHVlc3RyaW5nID0gY29tcHJlc3ModmFsdWUpXG4gIFx0XHRcdGVsc2U6XG4gIFx0XHRcdFx0cmFpc2UgRXhjZXB0aW9uKFwiRG9uJ3Qga25vdyB3aGF0IHRvIGRvIHdpdGggdmFsdWUgdHlwZSAlc1wiICUgdHlwZSh2YWx1ZSkpXG4gIFxuICBcdFx0dmFscy5hcHBlbmQoa2V5c3RyaW5nK3ZhbHVlc3RyaW5nKVxuICBcdFxuICBcdHJldHVybiAneycgKyAnJy5qb2luKHZhbHMpICsgJ30nXG4gIFxuICBkZWYgdW5jb21wcmVzcyhkYXRhKTpcbiAgXG4gIFx0ZGVjb2RlZCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBcdGVuY29kZWQgPSAna2xtbm9wcXJzdHV2d3h5eidcbiAgXHRtYXBwaW5nID0gZGljdCh6aXAoZW5jb2RlZCwgZGVjb2RlZCkpXG4gIFxuICBcdHNpZ24gPSArMVxuICBcdHN0cmluZ21vZGUgPSBGYWxzZVxuICBcdHN0cmluZ3BhcnRzID0gW11cbiAgXG4gIFx0b3V0cHV0ID0ge31cbiAgXG4gIFx0YWN0aXZlb2JqZWN0ID0gb3V0cHV0XG4gIFx0cGFyZW50Y2hhaW4gPSBbXVxuICBcbiAgXHRrZXlwYXJ0cyA9ICcnXG4gIFx0dmFsdWVwYXJ0cyA9ICcnXG4gIFxuICBcdGtleSA9IE5vbmVcbiAgXG4gIFx0ZW5kaW5nID0gc2V0KGVuY29kZWQpXG4gIFxuICBcdGkgPSAxXG4gIFx0bCA9IGxlbihkYXRhKSAtIDEgIyBzdHJpcHBpbmcgc3RhcnRpbmcsIGVuZGluZyB7fVxuICBcdHdoaWxlIGkgIT0gbDogIyBzdHJpcHBpbmcge31cbiAgXHRcdCMgLSwgeywgfSwgJyBhcmUgc3BlY2lhbC5cbiAgXG4gIFx0XHRjaCA9IGRhdGFbaV1cbiAgXHRcdGkgKz0gMVxuICBcbiAgXHRcdGlmIGNoID09IFwiJ1wiOlxuICBcdFx0XHRpZiBzdHJpbmdtb2RlOlxuICBcdFx0XHRcdCMgZW5kIG9mIHN0cmluZyBtb2RlXG4gIFx0XHRcdFx0c3RyaW5nbW9kZSA9IEZhbHNlXG4gIFx0XHRcdFx0a2V5ID0gJycuam9pbihzdHJpbmdwYXJ0cylcbiAgXHRcdFx0ZWxzZTpcbiAgXHRcdFx0XHQjIHN0YXJ0IG9mIHN0cmluZyBtb2RlXG4gIFx0XHRcdFx0c3RyaW5nbW9kZSA9IFRydWVcbiAgXHRcdFx0XHRzdHJpbmdwYXJ0cyA9IFtdXG4gIFx0XHRlbGlmIHN0cmluZ21vZGUgPT0gVHJ1ZTpcbiAgXHRcdFx0I3ByaW50KFwiQWRkaW5nICVzIHRvIHN0cmluZ3BhcnRcIiAlIGNoKVxuICBcdFx0XHRzdHJpbmdwYXJ0cy5hcHBlbmQoY2gpXG4gIFxuICBcdFx0ZWxpZiBjaCA9PSAneyc6XG4gIFx0XHRcdCMgc3RhcnQgb2Ygb2JqZWN0XG4gIFx0XHRcdHBhcmVudGNoYWluLmFwcGVuZCggW2FjdGl2ZW9iamVjdCwga2V5XSApXG4gIFx0XHRcdGFjdGl2ZW9iamVjdCA9IHt9XG4gIFx0XHRcdGtleSA9IE5vbmVcbiAgXHRcdFx0I0RFQlVHID0gVHJ1ZVxuICBcdFx0ZWxpZiBjaCA9PSAnfSc6XG4gIFx0XHRcdCMgZW5kIG9mIG9iamVjdFxuICBcdFx0XHRwYXJlbnQsIGtleSA9IHBhcmVudGNoYWluLnBvcCgpXG4gIFx0XHRcdHBhcmVudFtrZXldID0gYWN0aXZlb2JqZWN0XG4gIFx0XHRcdGtleSA9IE5vbmVcbiAgXHRcdFx0YWN0aXZlb2JqZWN0ID0gcGFyZW50XG4gIFx0XHRcdCNERUJVRyA9IEZhbHNlXG4gIFxuICBcdFx0ZWxpZiBjaCA9PSAnLSc6XG4gIFx0XHRcdHNpZ24gPSAtMVxuICBcdFx0ZWxzZTpcbiAgXHRcdFx0IyBtdXN0IGJlIG51bWJlclxuICBcdFx0XHRpZiBrZXkgPT0gTm9uZTpcbiAgXHRcdFx0XHQjZGVidWcoXCJJbiBLZXkuIEl0IGlzICclcycsIGNoIGlzICclcydcIiAlIChrZXlwYXJ0cywgY2gpKVxuICBcdFx0XHRcdGlmIGNoIGluIGVuZGluZzpcbiAgXHRcdFx0XHRcdCNkZWJ1ZyhcIkVuZCBvZiBrZXlcIilcbiAgXHRcdFx0XHRcdGtleXBhcnRzICs9IG1hcHBpbmdbY2hdXG4gIFx0XHRcdFx0XHRrZXkgPSBpbnQoa2V5cGFydHMsIDE2KSAqIHNpZ25cbiAgXHRcdFx0XHRcdHNpZ24gPSArMVxuICBcdFx0XHRcdFx0a2V5cGFydHMgPSAnJ1xuICBcdFx0XHRcdGVsc2U6XG4gIFx0XHRcdFx0XHRrZXlwYXJ0cyArPSBjaFxuICBcdFx0XHRlbHNlOlxuICBcdFx0XHRcdCNkZWJ1ZyhcIkluIHZhbHVlLiBJdCBpcyAnJXMnLCBjaCBpcyAnJXMnXCIgJSAodmFsdWVwYXJ0cywgY2gpKVxuICBcdFx0XHRcdGlmIGNoIGluIGVuZGluZzpcbiAgXHRcdFx0XHRcdCNkZWJ1ZyhcIkVuZCBvZiB2YWx1ZVwiKVxuICBcdFx0XHRcdFx0dmFsdWVwYXJ0cyArPSBtYXBwaW5nW2NoXVxuICBcdFx0XHRcdFx0YWN0aXZlb2JqZWN0W2tleV0gPSBpbnQodmFsdWVwYXJ0cywgMTYpICogc2lnblxuICBcdFx0XHRcdFx0c2lnbiA9ICsxXG4gIFx0XHRcdFx0XHRrZXkgPSBOb25lXG4gIFx0XHRcdFx0XHR2YWx1ZXBhcnRzID0gJydcbiAgXHRcdFx0XHRlbHNlOlxuICBcdFx0XHRcdFx0dmFsdWVwYXJ0cyArPSBjaFxuICBcbiAgXHRcdFx0I2RlYnVnKGFjdGl2ZW9iamVjdClcbiAgXG4gIFx0cmV0dXJuIG91dHB1dFxuICBcbiAgKi9cblxuICAvKipcbiAgVW5jb21wcmVzc2VzIGRhdGEgY29tcHJlc3NlZCBpbnRvIGN1c3RvbSwgYmFzZTE2LWxpa2UgZm9ybWF0LiBcbiAgQHB1YmxpY1xuICBAZnVuY3Rpb25cbiAgQHBhcmFtXG4gIEByZXR1cm5zIHtUeXBlfVxuICAqL1xuXG4gIHZhciB1bmNvbXByZXNzID0gZnVuY3Rpb24gdW5jb21wcmVzcyhkYXRhKSB7XG4gICAgdmFyIGRlY29kZWQgPSAnMDEyMzQ1Njc4OWFiY2RlZicsXG4gICAgICAgIGVuY29kZWQgPSAna2xtbm9wcXJzdHV2d3h5eicsXG4gICAgICAgIG1hcHBpbmcgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgbWFwcGluZ1tlbmNvZGVkW2ldXSA9IGRlY29kZWRbaV07XG4gICAgfVxuXG4gICAgdmFyIHVuZGVmLFxuICAgICAgICBvdXRwdXQgPSB7fSxcbiAgICAgICAgc2lnbiA9IDEsXG4gICAgICAgIHN0cmluZ3BhcnRzIC8vIHVuZGVmLiB3aWxsIGJlIFtdIGluIHN0cmluZyBtb2RlXG4gICAgLFxuICAgICAgICBhY3RpdmVvYmplY3QgPSBvdXRwdXQsXG4gICAgICAgIHBhcmVudGNoYWluID0gW10sXG4gICAgICAgIHBhcmVudF9rZXlfcGFpcixcbiAgICAgICAga2V5cGFydHMgPSAnJyxcbiAgICAgICAgdmFsdWVwYXJ0cyA9ICcnLFxuICAgICAgICBrZXkgLy8gdW5kZWYuIHdpbGwgYmUgVHJ1dGh5IHdoZW4gS2V5IGlzIHJlc29sdmVkLlxuICAgICxcbiAgICAgICAgZGF0YWxlbiA9IGRhdGEubGVuZ3RoIC0gMSAvLyBzdHJpcHBpbmcgZW5kaW5nIH1cbiAgICAsXG4gICAgICAgIGNoO1xuICAgIGkgPSAxOyAvLyBzdHJpcHBpbmcgc3RhcnRpbmcge1xuXG4gICAgd2hpbGUgKGkgIT0gZGF0YWxlbikge1xuICAgICAgLy8gLSB7IH0gJyBhcmUgc3BlY2lhbC5cbiAgICAgIGNoID0gZGF0YVtpXTtcbiAgICAgIGkgKz0gMTtcblxuICAgICAgaWYgKGNoID09IFwiJ1wiKSB7XG4gICAgICAgIGlmIChzdHJpbmdwYXJ0cykge1xuICAgICAgICAgIC8vIGVuZCBvZiBzdHJpbmcgbW9kZVxuICAgICAgICAgIGtleSA9IHN0cmluZ3BhcnRzLmpvaW4oJycpO1xuICAgICAgICAgIHN0cmluZ3BhcnRzID0gdW5kZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2Ygc3RyaW5nIG1vZGVcbiAgICAgICAgICBzdHJpbmdwYXJ0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZ3BhcnRzKSB7XG4gICAgICAgIHN0cmluZ3BhcnRzLnB1c2goY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSAneycpIHtcbiAgICAgICAgLy8gc3RhcnQgb2Ygb2JqZWN0XG4gICAgICAgIHBhcmVudGNoYWluLnB1c2goW2FjdGl2ZW9iamVjdCwga2V5XSk7XG4gICAgICAgIGFjdGl2ZW9iamVjdCA9IHt9O1xuICAgICAgICBrZXkgPSB1bmRlZjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gJ30nKSB7XG4gICAgICAgIC8vIGVuZCBvZiBvYmplY3RcbiAgICAgICAgcGFyZW50X2tleV9wYWlyID0gcGFyZW50Y2hhaW4ucG9wKCk7XG4gICAgICAgIHBhcmVudF9rZXlfcGFpclswXVtwYXJlbnRfa2V5X3BhaXJbMV1dID0gYWN0aXZlb2JqZWN0O1xuICAgICAgICBrZXkgPSB1bmRlZjtcbiAgICAgICAgYWN0aXZlb2JqZWN0ID0gcGFyZW50X2tleV9wYWlyWzBdO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSAnLScpIHtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbXVzdCBiZSBudW1iZXJcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWYpIHtcbiAgICAgICAgICBpZiAobWFwcGluZy5oYXNPd25Qcm9wZXJ0eShjaCkpIHtcbiAgICAgICAgICAgIGtleXBhcnRzICs9IG1hcHBpbmdbY2hdO1xuICAgICAgICAgICAga2V5ID0gcGFyc2VJbnQoa2V5cGFydHMsIDE2KSAqIHNpZ247XG4gICAgICAgICAgICBzaWduID0gKzE7XG4gICAgICAgICAgICBrZXlwYXJ0cyA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXlwYXJ0cyArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1hcHBpbmcuaGFzT3duUHJvcGVydHkoY2gpKSB7XG4gICAgICAgICAgICB2YWx1ZXBhcnRzICs9IG1hcHBpbmdbY2hdO1xuICAgICAgICAgICAgYWN0aXZlb2JqZWN0W2tleV0gPSBwYXJzZUludCh2YWx1ZXBhcnRzLCAxNikgKiBzaWduO1xuICAgICAgICAgICAgc2lnbiA9ICsxO1xuICAgICAgICAgICAga2V5ID0gdW5kZWY7XG4gICAgICAgICAgICB2YWx1ZXBhcnRzID0gJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcGFydHMgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBlbmQgd2hpbGVcblxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTsgLy8gZW5jb2RpbmcgPSAnVW5pY29kZScgXG4gIC8vIE5PVCBVVEY4LCBOT1QgVVRGMTZCRS9MRSwgTk9UIFVDUzJCRS9MRS4gTk8gY2xldmVyIEJPTSBiZWhhdmlvclxuICAvLyBBY3R1YWwgMTZiaXQgY2hhciBjb2RlcyB1c2VkLlxuICAvLyBubyBtdWx0aS1ieXRlIGxvZ2ljIGhlcmVcbiAgLy8gVW5pY29kZSBjaGFyYWN0ZXJzIHRvIFdpbkFuc2lFbmNvZGluZzpcbiAgLy8gezQwMjogMTMxLCA4MjExOiAxNTAsIDgyMTI6IDE1MSwgODIxNjogMTQ1LCA4MjE3OiAxNDYsIDgyMTg6IDEzMCwgODIyMDogMTQ3LCA4MjIxOiAxNDgsIDgyMjI6IDEzMiwgODIyNDogMTM0LCA4MjI1OiAxMzUsIDgyMjY6IDE0OSwgODIzMDogMTMzLCA4MzY0OiAxMjgsIDgyNDA6MTM3LCA4MjQ5OiAxMzksIDgyNTA6IDE1NSwgNzEwOiAxMzYsIDg0ODI6IDE1MywgMzM4OiAxNDAsIDMzOTogMTU2LCA3MzI6IDE1MiwgMzUyOiAxMzgsIDM1MzogMTU0LCAzNzY6IDE1OSwgMzgxOiAxNDIsIDM4MjogMTU4fVxuICAvLyBhcyB5b3UgY2FuIHNlZSwgYWxsIFVuaWNvZGUgY2hhcnMgYXJlIG91dHNpZGUgb2YgMC0yNTUgcmFuZ2UuIE5vIGNoYXIgY29kZSBjb25mbGljdHMuXG4gIC8vIHRoaXMgbWVhbnMgdGhhdCB5b3UgY2FuIGdpdmUgV2luIGNwMTI1MiBlbmNvZGVkIHN0cmluZ3MgdG8ganNQREYgZm9yIHJlbmRlcmluZyBkaXJlY3RseVxuICAvLyBhcyB3ZWxsIGFzIGdpdmUgc3RyaW5ncyB3aXRoIHNvbWUgKHN1cHBvcnRlZCBieSB0aGVzZSBmb250cykgVW5pY29kZSBjaGFyYWN0ZXJzIGFuZCBcbiAgLy8gdGhlc2Ugd2lsbCBiZSBtYXBwZWQgdG8gd2luIGNwMTI1MiBcbiAgLy8gZm9yIGV4YW1wbGUsIHlvdSBjYW4gc2VuZCBjaGFyIGNvZGUgKGNwMTI1MikgMHg4MCBvciAodW5pY29kZSkgMHgyMEFDLCBnZXR0aW5nIFwiRXVyb1wiIGdseXBoIGRpc3BsYXllZCBpbiBib3RoIGNhc2VzLlxuXG5cbiAgdmFyIGVuY29kaW5nQmxvY2sgPSB7XG4gICAgJ2NvZGVQYWdlcyc6IFsnV2luQW5zaUVuY29kaW5nJ10sXG4gICAgJ1dpbkFuc2lFbmNvZGluZyc6IHVuY29tcHJlc3MoXCJ7MTltOG4yMDFuOXEyMDFvOXIyMDFzOWwyMDF0OW0yMDF1OG0yMDF3OW4yMDF4OW8yMDF5OG8yMDJrOHEyMDJsOHIyMDJtOXAyMDJxOHAyMGF3OGsyMDNrOHQyMDN0OHYyMDN1OXYyY3E4czIxMm05dDE1bTh3MTVuOXcyZHc5czE2azh1MTZsOXUxN3M5ejE3eDh5MTd5OXl9XCIpXG4gIH0sXG4gICAgICBlbmNvZGluZ3MgPSB7XG4gICAgJ1VuaWNvZGUnOiB7XG4gICAgICAnQ291cmllcic6IGVuY29kaW5nQmxvY2ssXG4gICAgICAnQ291cmllci1Cb2xkJzogZW5jb2RpbmdCbG9jayxcbiAgICAgICdDb3VyaWVyLUJvbGRPYmxpcXVlJzogZW5jb2RpbmdCbG9jayxcbiAgICAgICdDb3VyaWVyLU9ibGlxdWUnOiBlbmNvZGluZ0Jsb2NrLFxuICAgICAgJ0hlbHZldGljYSc6IGVuY29kaW5nQmxvY2ssXG4gICAgICAnSGVsdmV0aWNhLUJvbGQnOiBlbmNvZGluZ0Jsb2NrLFxuICAgICAgJ0hlbHZldGljYS1Cb2xkT2JsaXF1ZSc6IGVuY29kaW5nQmxvY2ssXG4gICAgICAnSGVsdmV0aWNhLU9ibGlxdWUnOiBlbmNvZGluZ0Jsb2NrLFxuICAgICAgJ1RpbWVzLVJvbWFuJzogZW5jb2RpbmdCbG9jayxcbiAgICAgICdUaW1lcy1Cb2xkJzogZW5jb2RpbmdCbG9jayxcbiAgICAgICdUaW1lcy1Cb2xkSXRhbGljJzogZW5jb2RpbmdCbG9jayxcbiAgICAgICdUaW1lcy1JdGFsaWMnOiBlbmNvZGluZ0Jsb2NrIC8vXHQsICdTeW1ib2wnXG4gICAgICAvL1x0LCAnWmFwZkRpbmdiYXRzJ1xuXG4gICAgfVxuICB9LFxuICAgICAgZm9udE1ldHJpY3MgPSB7XG4gICAgJ1VuaWNvZGUnOiB7XG4gICAgICAvLyBhbGwgc2l6aW5nIG51bWJlcnMgYXJlIG4vZm9udE1ldHJpY3NGcmFjdGlvbk9mID0gb25lIGZvbnQgc2l6ZSB1bml0XG4gICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgaWYgZm9udE1ldHJpY3NGcmFjdGlvbk9mID0gMTAwMCwgYW5kIGxldHRlciBBJ3Mgd2lkdGggaXMgNDc2LCBpdCdzXG4gICAgICAvLyB3aWR0aCBpcyA0NzYvMTAwMCBvciA0Ny42JSBvZiBpdHMgaGVpZ2h0IChyZWdhcmRsZXNzIG9mIGZvbnQgc2l6ZSlcbiAgICAgIC8vIEF0IHRoaXMgdGltZSB0aGlzIHZhbHVlIGFwcGxpZXMgdG8gXCJ3aWR0aHNcIiBhbmQgXCJrZXJuaW5nXCIgbnVtYmVycy5cbiAgICAgIC8vIGNoYXIgY29kZSAwIHJlcHJlc2VudHMgXCJkZWZhdWx0XCIgKGF2ZXJhZ2UpIHdpZHRoIC0gdXNlIGl0IGZvciBjaGFycyBtaXNzaW5nIGluIHRoaXMgdGFibGUuXG4gICAgICAvLyBrZXkgJ2ZvZicgcmVwcmVzZW50cyB0aGUgXCJmb250TWV0cmljc0ZyYWN0aW9uT2ZcIiB2YWx1ZVxuICAgICAgJ0NvdXJpZXItT2JsaXF1ZSc6IHVuY29tcHJlc3MoXCJ7J3dpZHRocyd7azN3J2ZvZic2b30na2VybmluZyd7J2ZvZictNm99fVwiKSxcbiAgICAgICdUaW1lcy1Cb2xkSXRhbGljJzogdW5jb21wcmVzcyhcInsnd2lkdGhzJ3trM28ycTR5Y3gycjIwMW4zbTIwMW82bzIwMXMybDIwMXQybDIwMXUybDIwMXczbTIwMXgzbTIwMXkzbTJrMXQybDJyMjAybTJuMm4zbTJvM20ycDVuMjAycTZvMnIxdzJzMmwydDJsMnUzbTJ2M3QydzF0MngybDJ5MXQyejF3M2szbTNsM20zbTNtM24zbTNvM20zcDNtM3EzbTNyM20zczNtMjAzdDJsMjAzdTJsM3YybDN3M3QzeDN0M3kzdDN6M200azVuNGw0bTRtNG00bjRtNG80czRwNG00cTRtNHI0czRzNHk0dDJyNHUzbTR2NG00dzN4NHg1dDR5NHM0ejRzNWszeDVsNHM1bTRtNW4zcjVvM3g1cDRzNXE0bTVyNXQ1czRtNXQzeDV1M3g1djJsNXcxdzV4Mmw1eTN0NXozbTZrMmw2bDNtNm0zbTZuMnc2bzNtNnAydzZxMmw2cjNtNnMzcjZ0MXc2dTF3NnYzbTZ3MXc2eDR5NnkzcjZ6M203azNtN2wzbTdtMnI3bjJyN28xdzdwM3I3cTJ3N3I0bTdzM203dDJ3N3Uycjd2Mm43dzFxN3gybjd5M3QyMDJsM21jbDRtYWwycmFtM21hbjNtYW8zbWFwM21hcjNtYXMybGF0NHVhdTF1YXYzbWF3M3dheTR1YXoybGJrMnNibDN0J2ZvZic2b2JvMmxicDN0YnEzbWJyMXRiczJsYnUxeWJ2M21iejNtY2s0bTIwMmszbWNtNG1jbjRtY280bWNwNG1jcTV5Y3I0bWNzNG1jdDRtY3U0bWN2NG1jdzJyMm0zcmN5MnJjejJyZGw0c2RtNHNkbjRzZG80c2RwNHNkcTRzZHM0c2R0NHNkdTRzZHY0c2R3NHNkejNtZWszbWVsM21lbTNtZW4zbWVvM21lcDNtZXE0c2VyMndlczJ3ZXQyd2V1MndldjJ3ZXcxd2V4MXdleTF3ZXoxd2ZsM3JmbTNtZm4zbWZvM21mcDNtZnEzbWZyM3RmczNtZnQzcmZ1M3JmdjNyZnczcmZ6MncyMDNrNm8yMTJtNm8yZHcybDJjcTJsM3QzbTN1MmwxN3MzeDE5bTNtfSdrZXJuaW5nJ3tjbHs0cXU1a3Q1cXQ1cnMxN3NzNXRzfTIwMXN7MjAxc3N9MjAxdHtja3M0bHNjbXNjbnNjb3NjcHNjbHMyd3UyeXUyMDF0c30yMDF4ezJ3dTJ5dX0ya3syMDF0c30yd3s0cXg1a3g1b3U1cXg1cnMxN3N1NXR1fTJ4ezE3c3U1dHU1b3V9Mnl7NHF4NWt4NW91NXF4NXJzMTdzczV0c30nZm9mJy02b2ZuezE3c3c1dHc1b3U1cXc1cnN9N3R7Y2tzY2xzY21zY25zY29zY3BzNGxzfTN1ezE3c3U1dHU1b3M1cXN9M3Z7MTdzdTV0dTVvczVxc303cHsxN3N1NXR1fWNrezRxdTVrdDVxdDVyczE3c3M1dHN9NGx7NHF1NWt0NXF0NXJzMTdzczV0c31jbXs0cXU1a3Q1cXQ1cnMxN3NzNXRzfWNuezRxdTVrdDVxdDVyczE3c3M1dHN9Y297NHF1NWt0NXF0NXJzMTdzczV0c31jcHs0cXU1a3Q1cXQ1cnMxN3NzNXRzfTZsezRxdTVvdTVxdzVydDE3c3U1dHV9NXF7Y2t1Y2x1Y211Y251Y291Y3B1NGx1fTVye2NrdWNsdWNtdWNudWNvdWNwdTRsdX03cXtja3NjbHNjbXNjbnNjb3NjcHM0bHN9NnB7NHF1NW91NXF3NXJ0MTdzdzV0d31la3s0cXU1b3U1cXc1cnQxN3N1NXR1fWVsezRxdTVvdTVxdzVydDE3c3U1dHV9ZW17NHF1NW91NXF3NXJ0MTdzdTV0dX1lbns0cXU1b3U1cXc1cnQxN3N1NXR1fWVvezRxdTVvdTVxdzVydDE3c3U1dHV9ZXB7NHF1NW91NXF3NXJ0MTdzdTV0dX1lc3sxN3NzNXRzNXFzNHF1fWV0ezRxdTVvdTVxdzVydDE3c3c1dHd9ZXV7NHF1NW91NXF3NXJ0MTdzczV0c31ldnsxN3NzNXRzNXFzNHF1fTZ6ezE3c3c1dHc1b3U1cXc1cnN9Zm17MTdzdzV0dzVvdTVxdzVyc303bnsyMDF0c31mb3sxN3N3NXR3NW91NXF3NXJzfWZwezE3c3c1dHc1b3U1cXc1cnN9ZnF7MTdzdzV0dzVvdTVxdzVyc303cntja3NjbHNjbXNjbnNjb3NjcHM0bHN9ZnN7MTdzdzV0dzVvdTVxdzVyc31mdHsxN3N1NXR1fWZ1ezE3c3U1dHV9ZnZ7MTdzdTV0dX1md3sxN3N1NXR1fWZ6e2Nrc2Nsc2Ntc2Nuc2Nvc2NwczRsc319fVwiKSxcbiAgICAgICdIZWx2ZXRpY2EtQm9sZCc6IHVuY29tcHJlc3MoXCJ7J3dpZHRocyd7azNzMnE0c2N4MXcyMDFuM3IyMDFvNm8yMDFzMXcyMDF0MXcyMDF1MXcyMDF3M20yMDF4M20yMDF5M20yazF3MmwybDIwMm0ybjJuM3IybzNyMnA1dDIwMnE2bzJyMXMyczJsMnQybDJ1MnIydjN1MncxdzJ4MmwyeTF3MnoxdzNrM3IzbDNyM20zcjNuM3IzbzNyM3AzcjNxM3IzcjNyM3MzcjIwM3QybDIwM3UybDN2MmwzdzN1M3gzdTN5M3UzejN4NGs2bDRsNHM0bTRzNG40czRvNHM0cDRtNHEzeDRyNHk0czRzNHQxdzR1M3I0djRzNHczeDR4NW40eTRzNHo0eTVrNG01bDR5NW00czVuNG01bzN4NXA0czVxNG01cjV5NXM0bTV0NG01dTN4NXYybDV3MXc1eDJsNXkzdTV6M3I2azJsNmwzcjZtM3g2bjNyNm8zeDZwM3I2cTJsNnIzeDZzM3g2dDF3NnUxdzZ2M3I2dzF3Nng1dDZ5M3g2ejN4N2szeDdsM3g3bTJyN24zcjdvMmw3cDN4N3EzcjdyNHk3czNyN3Qzcjd1M203djJyN3cxdzd4MnI3eTN1MjAybDNyY2w0c2FsMmxhbTNyYW4zcmFvM3JhcDNyYXIzcmFzMmxhdDR0YXUycGF2M3JhdzN1YXk0dGF6MmxiazJzYmwzdSdmb2YnNm9ibzJsYnAzeGJxM3JicjF3YnMybGJ1Mm9idjNyYnozeGNrNHMyMDJrM3JjbTRzY240c2NvNHNjcDRzY3E2b2NyNHNjczRtY3Q0bWN1NG1jdjRtY3cxdzJtMnpjeTF3Y3oxd2RsNHNkbTR5ZG40eWRvNHlkcDR5ZHE0eWRzNHlkdDRzZHU0c2R2NHNkdzRzZHozeGVrM3JlbDNyZW0zcmVuM3JlbzNyZXAzcmVxNXRlcjNyZXMzcmV0M3JldTNyZXYzcmV3MXdleDF3ZXkxd2V6MXdmbDN4Zm0zeGZuM3hmbzN4ZnAzeGZxM3hmcjN1ZnMzeGZ0M3hmdTN4ZnYzeGZ3M3hmejNyMjAzazZvMjEybTZvMmR3MmwyY3EybDN0M3IzdTJsMTdzNG0xOW0zcn0na2VybmluZyd7Y2x7NHFzNWt1NW90NXFzMTdzdjV0dn0yMDF0ezJ3dzR3eTJ5d30yMDF3ezJrc30yMDF4ezJ3dzR3eTJ5d30ya3syMDF0czIwMXhzfTJ3ezdxczRxdTVrdzVvczVxdzVyczE3c3U1dHU3dHNmenN9Mnh7NW93NXFzfTJ5ezdxczRxdTVrdzVvczVxdzVyczE3c3U1dHU3dHNmenN9J2ZvZictNm83cHsxN3N1NXR1NW90fWNrezRxczVrdTVvdDVxczE3c3Y1dHZ9NGx7NHFzNWt1NW90NXFzMTdzdjV0dn1jbXs0cXM1a3U1b3Q1cXMxN3N2NXR2fWNuezRxczVrdTVvdDVxczE3c3Y1dHZ9Y297NHFzNWt1NW90NXFzMTdzdjV0dn1jcHs0cXM1a3U1b3Q1cXMxN3N2NXR2fTZsezE3c3Q1dHQ1b3N9MTdzezJrd2NsdmNtdmNudmNvdmNwdjRsdjR3d2Nrdn01b3sya3VjbHRjbXRjbnRjb3RjcHQ0bHQ0d3Rja3R9NXF7MmtzY2xzY21zY25zY29zY3BzNGxzNHd2Y2tzfTVyezJrczR3c301dHsya3djbHZjbXZjbnZjb3ZjcHY0bHY0d3dja3Z9ZW97MTdzdDV0dDVvc31mdXsxN3N1NXR1NW90fTZwezE3c3M1dHN9ZWt7MTdzdDV0dDVvc31lbHsxN3N0NXR0NW9zfWVtezE3c3Q1dHQ1b3N9ZW57MTdzdDV0dDVvc302b3syMDF0c31lcHsxN3N0NXR0NW9zfWVzezE3c3M1dHN9ZXR7MTdzczV0c31ldXsxN3NzNXRzfWV2ezE3c3M1dHN9Nnp7MTdzdTV0dTVvczVxdH1mbXsxN3N1NXR1NW9zNXF0fWZuezE3c3U1dHU1b3M1cXR9Zm97MTdzdTV0dTVvczVxdH1mcHsxN3N1NXR1NW9zNXF0fWZxezE3c3U1dHU1b3M1cXR9ZnN7MTdzdTV0dTVvczVxdH1mdHsxN3N1NXR1NW90fTdtezVvc31mdnsxN3N1NXR1NW90fWZ3ezE3c3U1dHU1b3R9fX1cIiksXG4gICAgICAnQ291cmllcic6IHVuY29tcHJlc3MoXCJ7J3dpZHRocyd7azN3J2ZvZic2b30na2VybmluZyd7J2ZvZictNm99fVwiKSxcbiAgICAgICdDb3VyaWVyLUJvbGRPYmxpcXVlJzogdW5jb21wcmVzcyhcInsnd2lkdGhzJ3trM3cnZm9mJzZvfSdrZXJuaW5nJ3snZm9mJy02b319XCIpLFxuICAgICAgJ1RpbWVzLUJvbGQnOiB1bmNvbXByZXNzKFwieyd3aWR0aHMne2szcTJxNW5jeDJyMjAxbjNtMjAxbzZvMjAxczJsMjAxdDJsMjAxdTJsMjAxdzNtMjAxeDNtMjAxeTNtMmsxdDJsMmwyMDJtMm4ybjNtMm8zbTJwNm8yMDJxNm8ycjF3MnMybDJ0MmwydTNtMnYzdDJ3MXQyeDJsMnkxdDJ6MXczazNtM2wzbTNtM20zbjNtM28zbTNwM20zcTNtM3IzbTNzM20yMDN0MmwyMDN1MmwzdjJsM3czdDN4M3QzeTN0M3ozbTRrNXg0bDRzNG00bTRuNHM0bzRzNHA0bTRxM3g0cjR5NHM0eTR0MnI0dTNtNHY0eTR3NG00eDV5NHk0czR6NHk1azN4NWw0eTVtNHM1bjNyNW80bTVwNHM1cTRzNXI2bzVzNHM1dDRzNXU0bTV2Mmw1dzF3NXgybDV5M3U1ejNtNmsybDZsM202bTNyNm4ydzZvM3I2cDJ3NnEybDZyM202czNyNnQxdzZ1Mmw2djNyNncxdzZ4NW42eTNyNnozbTdrM3I3bDNyN20ydzduMnI3bzJsN3AzcjdxM203cjRzN3MzbTd0M203dTJ3N3Yycjd3MXE3eDJyN3kzbzIwMmwzbWNsNHNhbDJsYW0zbWFuM21hbzNtYXAzbWFyM21hczJsYXQ0dWF1MXlhdjNtYXczdGF5NHVhejJsYmsyc2JsM3QnZm9mJzZvYm8ybGJwM3JicjF0YnMybGJ1MmxidjNtYnozbWNrNHMyMDJrM21jbTRzY240c2NvNHNjcDRzY3E2b2NyNHNjczRtY3Q0bWN1NG1jdjRtY3cycjJtM3JjeTJyY3oycmRsNHNkbTR5ZG40eWRvNHlkcDR5ZHE0eWRzNHlkdDRzZHU0c2R2NHNkdzRzZHozcmVrM21lbDNtZW0zbWVuM21lbzNtZXAzbWVxNHNlcjJ3ZXMyd2V0MndldTJ3ZXYyd2V3MXdleDF3ZXkxd2V6MXdmbDNyZm0zbWZuM21mbzNtZnAzbWZxM21mcjN0ZnMzbWZ0M3JmdTNyZnYzcmZ3M3JmejNtMjAzazZvMjEybTZvMmR3MmwyY3EybDN0M20zdTJsMTdzNHMxOW0zbX0na2VybmluZyd7Y2x7NHF0NWtzNW90NXF5NXJ3MTdzdjV0dn0yMDF0e2NrczRsc2Ntc2Nuc2Nvc2Nwc2NsczR3dn0ya3syMDF0c30yd3s0cXU1a3U3bXU1b3M1cXg1cnUxN3N1NXR1fTJ4ezE3c3U1dHU1b3U1cXN9Mnl7NHF2NWt2N211NW90NXF6NXJ1MTdzdTV0dX0nZm9mJy02bzd0e2Nrc2Nsc2Ntc2Nuc2Nvc2NwczRsc30zdXsxN3N1NXR1NW9zNXF1fTN2ezE3c3U1dHU1b3M1cXV9ZnV7MTdzdTV0dTVvdTVxdX03cHsxN3N1NXR1NW91NXF1fWNrezRxdDVrczVvdDVxeTVydzE3c3Y1dHZ9NGx7NHF0NWtzNW90NXF5NXJ3MTdzdjV0dn1jbXs0cXQ1a3M1b3Q1cXk1cncxN3N2NXR2fWNuezRxdDVrczVvdDVxeTVydzE3c3Y1dHZ9Y297NHF0NWtzNW90NXF5NXJ3MTdzdjV0dn1jcHs0cXQ1a3M1b3Q1cXk1cncxN3N2NXR2fTZsezE3c3Q1dHQ1b3U1cXV9MTdze2NrdWNsdWNtdWNudWNvdWNwdTRsdTR3dX01b3tja3VjbHVjbXVjbnVjb3VjcHU0bHU0d3V9NXF7Y2t6Y2x6Y216Y256Y296Y3B6NGx6NHd1fTVye2NreGNseGNteGNueGNveGNweDRseDR3dX01dHtja3VjbHVjbXVjbnVjb3VjcHU0bHU0d3V9N3F7Y2t1Y2x1Y211Y251Y291Y3B1NGx1fTZwezE3c3c1dHc1b3U1cXV9ZWt7MTdzdDV0dDVxdX1lbHsxN3N0NXR0NW91NXF1fWVtezE3c3Q1dHQ1cXV9ZW57MTdzdDV0dDVxdX1lb3sxN3N0NXR0NXF1fWVwezE3c3Q1dHQ1b3U1cXV9ZXN7MTdzczV0czVxdX1ldHsxN3N3NXR3NW91NXF1fWV1ezE3c3c1dHc1b3U1cXV9ZXZ7MTdzczV0czVxdX02ensxN3N3NXR3NW91NXF1NXJzfWZtezE3c3c1dHc1b3U1cXU1cnN9Zm57MTdzdzV0dzVvdTVxdTVyc31mb3sxN3N3NXR3NW91NXF1NXJzfWZwezE3c3c1dHc1b3U1cXU1cnN9ZnF7MTdzdzV0dzVvdTVxdTVyc303cntja3RjbHRjbXRjbnRjb3RjcHQ0bHQ1b3N9ZnN7MTdzdzV0dzVvdTVxdTVyc31mdHsxN3N1NXR1NW91NXF1fTdtezVvc31mdnsxN3N1NXR1NW91NXF1fWZ3ezE3c3U1dHU1b3U1cXV9Znp7Y2tzY2xzY21zY25zY29zY3BzNGxzfX19XCIpLFxuICAgICAgJ1N5bWJvbCc6IHVuY29tcHJlc3MoXCJ7J3dpZHRocyd7azN1YXc0cjE5bTNtMmsxdDJsMmwyMDJtMnkybjNtMnA1bjIwMnE2bzNrM20yczJsMnQybDJ2M3IydzF0M20zbTJ5MXQyejF3Ymsyc2JsM3InZm9mJzZvM24zbTNvM20zcDNtM3EzbTNyM20zczNtM3QzbTN1MXczdjF3M3czcjN4M3IzeTNyM3oyd2JwM3QzbDNtNXYybDV4Mmw1ejNtMnE0eWZyM3I3djNrN3cxbzd4M2t9J2tlcm5pbmcneydmb2YnLTZvfX1cIiksXG4gICAgICAnSGVsdmV0aWNhJzogdW5jb21wcmVzcyhcInsnd2lkdGhzJ3trM3AycTRtY3gxdzIwMW4zcjIwMW82bzIwMXMxcTIwMXQxcTIwMXUxcTIwMXcybDIwMXgybDIwMXkybDJrMXcybDF3MjAybTJuMm4zcjJvM3IycDV0MjAycTZvMnIxbjJzMmwydDJsMnUycjJ2M3UydzF3MngybDJ5MXcyejF3M2szcjNsM3IzbTNyM24zcjNvM3IzcDNyM3EzcjNyM3IzczNyMjAzdDJsMjAzdTJsM3YxdzN3M3UzeDN1M3kzdTN6M3I0azZwNGw0bTRtNG00bjRzNG80czRwNG00cTN4NHI0eTRzNHM0dDF3NHUzbTR2NG00dzNyNHg1bjR5NHM0ejR5NWs0bTVsNHk1bTRzNW40bTVvM3g1cDRzNXE0bTVyNXk1czRtNXQ0bTV1M3g1djF3NXcxdzV4MXc1eTJ6NXozcjZrMmw2bDNyNm0zcjZuM202bzNyNnAzcjZxMXc2cjNyNnMzcjZ0MXE2dTFxNnYzbTZ3MXE2eDVuNnkzcjZ6M3I3azNyN2wzcjdtMmw3bjNtN28xdzdwM3I3cTNtN3I0czdzM203dDNtN3UzbTd2Mmw3dzF1N3gybDd5M3UyMDJsM3JjbDRtYWwybGFtM3JhbjNyYW8zcmFwM3JhcjNyYXMybGF0NHRhdTJwYXYzcmF3M3VheTR0YXoybGJrMnNibDN1J2ZvZic2b2JvMmxicDNyYnIxd2JzMmxidTJvYnYzcmJ6M3hjazRtMjAyazNyY200bWNuNG1jbzRtY3A0bWNxNm9jcjRzY3M0bWN0NG1jdTRtY3Y0bWN3MXcybTJuY3kxd2N6MXdkbDRzZG00eWRuNHlkbzR5ZHA0eWRxNHlkczR5ZHQ0c2R1NHNkdjRzZHc0c2R6M3hlazNyZWwzcmVtM3JlbjNyZW8zcmVwM3JlcTV0ZXIzbWVzM3JldDNyZXUzcmV2M3JldzF3ZXgxd2V5MXdlejF3ZmwzcmZtM3JmbjNyZm8zcmZwM3JmcTNyZnIzdWZzM3hmdDNyZnUzcmZ2M3JmdzNyZnozbTIwM2s2bzIxMm02bzJkdzJsMmNxMmwzdDNyM3UxdzE3czRtMTltM3J9J2tlcm5pbmcnezVxezR3dn1jbHs0cXM1a3c1b3c1cXMxN3N2NXR2fTIwMXR7Mnd1NHcxazJ5dX0yMDF4ezJ3dTR3eTJ5dX0xN3N7Mmt0Y2x1Y211Y251NG90Y3B1NGx1NHd5Y291Y2t1fTJ3ezdxczRxejVrMW0xN3N5NW93NXF4NXJzZnN1NXR5N3R1Znp1fTJ4ezE3c3k1dHk1b3k1cXN9Mnl7N3FzNHF6NWsxbTE3c3k1b3c1cXg1cnNmc3U1dHk3dHVmenV9J2ZvZictNm83cHsxN3N2NXR2NW93fWNrezRxczVrdzVvdzVxczE3c3Y1dHZ9NGx7NHFzNWt3NW93NXFzMTdzdjV0dn1jbXs0cXM1a3c1b3c1cXMxN3N2NXR2fWNuezRxczVrdzVvdzVxczE3c3Y1dHZ9Y297NHFzNWt3NW93NXFzMTdzdjV0dn1jcHs0cXM1a3c1b3c1cXMxN3N2NXR2fTZsezE3c3k1dHk1b3d9ZG97MTdzdDV0dH00ensxN3N0NXR0fTdze2ZzdH1kbXsxN3N0NXR0fWRuezE3c3Q1dHR9NW97Y2t3Y2x3Y213Y253Y293Y3B3NGx3NHd2fWRwezE3c3Q1dHR9ZHF7MTdzdDV0dH03dHs1b3d9ZHN7MTdzdDV0dH01dHsya3RjbHVjbXVjbnU0b3RjcHU0bHU0d3ljb3Vja3V9ZnV7MTdzdjV0djVvd302cHsxN3N5NXR5NW93NXFzfWVrezE3c3k1dHk1b3d9ZWx7MTdzeTV0eTVvd31lbXsxN3N5NXR5NW93fWVuezV0eX1lb3sxN3N5NXR5NW93fWVwezE3c3k1dHk1b3d9ZXN7MTdzeTV0eTVxc31ldHsxN3N5NXR5NW93NXFzfWV1ezE3c3k1dHk1b3c1cXN9ZXZ7MTdzeTV0eTVvdzVxc302ensxN3N5NXR5NW93NXFzfWZtezE3c3k1dHk1b3c1cXN9Zm57MTdzeTV0eTVvdzVxc31mb3sxN3N5NXR5NW93NXFzfWZwezE3c3k1dHk1cXN9ZnF7MTdzeTV0eTVvdzVxc303cns1b3d9ZnN7MTdzeTV0eTVvdzVxc31mdHsxN3N2NXR2NW93fTdtezVvd31mdnsxN3N2NXR2NW93fWZ3ezE3c3Y1dHY1b3d9fX1cIiksXG4gICAgICAnSGVsdmV0aWNhLUJvbGRPYmxpcXVlJzogdW5jb21wcmVzcyhcInsnd2lkdGhzJ3trM3MycTRzY3gxdzIwMW4zcjIwMW82bzIwMXMxdzIwMXQxdzIwMXUxdzIwMXczbTIwMXgzbTIwMXkzbTJrMXcybDJsMjAybTJuMm4zcjJvM3IycDV0MjAycTZvMnIxczJzMmwydDJsMnUycjJ2M3UydzF3MngybDJ5MXcyejF3M2szcjNsM3IzbTNyM24zcjNvM3IzcDNyM3EzcjNyM3IzczNyMjAzdDJsMjAzdTJsM3YybDN3M3UzeDN1M3kzdTN6M3g0azZsNGw0czRtNHM0bjRzNG80czRwNG00cTN4NHI0eTRzNHM0dDF3NHUzcjR2NHM0dzN4NHg1bjR5NHM0ejR5NWs0bTVsNHk1bTRzNW40bTVvM3g1cDRzNXE0bTVyNXk1czRtNXQ0bTV1M3g1djJsNXcxdzV4Mmw1eTN1NXozcjZrMmw2bDNyNm0zeDZuM3I2bzN4NnAzcjZxMmw2cjN4NnMzeDZ0MXc2dTF3NnYzcjZ3MXc2eDV0NnkzeDZ6M3g3azN4N2wzeDdtMnI3bjNyN28ybDdwM3g3cTNyN3I0eTdzM3I3dDNyN3UzbTd2MnI3dzF3N3gycjd5M3UyMDJsM3JjbDRzYWwybGFtM3JhbjNyYW8zcmFwM3JhcjNyYXMybGF0NHRhdTJwYXYzcmF3M3VheTR0YXoybGJrMnNibDN1J2ZvZic2b2JvMmxicDN4YnEzcmJyMXdiczJsYnUyb2J2M3JiejN4Y2s0czIwMmszcmNtNHNjbjRzY280c2NwNHNjcTZvY3I0c2NzNG1jdDRtY3U0bWN2NG1jdzF3Mm0yemN5MXdjejF3ZGw0c2RtNHlkbjR5ZG80eWRwNHlkcTR5ZHM0eWR0NHNkdTRzZHY0c2R3NHNkejN4ZWszcmVsM3JlbTNyZW4zcmVvM3JlcDNyZXE1dGVyM3JlczNyZXQzcmV1M3JldjNyZXcxd2V4MXdleTF3ZXoxd2ZsM3hmbTN4Zm4zeGZvM3hmcDN4ZnEzeGZyM3VmczN4ZnQzeGZ1M3hmdjN4ZnczeGZ6M3IyMDNrNm8yMTJtNm8yZHcybDJjcTJsM3QzcjN1MmwxN3M0bTE5bTNyfSdrZXJuaW5nJ3tjbHs0cXM1a3U1b3Q1cXMxN3N2NXR2fTIwMXR7Mnd3NHd5Mnl3fTIwMXd7MmtzfTIwMXh7Mnd3NHd5Mnl3fTJrezIwMXRzMjAxeHN9Mnd7N3FzNHF1NWt3NW9zNXF3NXJzMTdzdTV0dTd0c2Z6c30yeHs1b3c1cXN9Mnl7N3FzNHF1NWt3NW9zNXF3NXJzMTdzdTV0dTd0c2Z6c30nZm9mJy02bzdwezE3c3U1dHU1b3R9Y2t7NHFzNWt1NW90NXFzMTdzdjV0dn00bHs0cXM1a3U1b3Q1cXMxN3N2NXR2fWNtezRxczVrdTVvdDVxczE3c3Y1dHZ9Y257NHFzNWt1NW90NXFzMTdzdjV0dn1jb3s0cXM1a3U1b3Q1cXMxN3N2NXR2fWNwezRxczVrdTVvdDVxczE3c3Y1dHZ9Nmx7MTdzdDV0dDVvc30xN3N7Mmt3Y2x2Y212Y252Y292Y3B2NGx2NHd3Y2t2fTVvezJrdWNsdGNtdGNudGNvdGNwdDRsdDR3dGNrdH01cXsya3NjbHNjbXNjbnNjb3NjcHM0bHM0d3Zja3N9NXJ7MmtzNHdzfTV0ezJrd2NsdmNtdmNudmNvdmNwdjRsdjR3d2Nrdn1lb3sxN3N0NXR0NW9zfWZ1ezE3c3U1dHU1b3R9NnB7MTdzczV0c31la3sxN3N0NXR0NW9zfWVsezE3c3Q1dHQ1b3N9ZW17MTdzdDV0dDVvc31lbnsxN3N0NXR0NW9zfTZvezIwMXRzfWVwezE3c3Q1dHQ1b3N9ZXN7MTdzczV0c31ldHsxN3NzNXRzfWV1ezE3c3M1dHN9ZXZ7MTdzczV0c302ensxN3N1NXR1NW9zNXF0fWZtezE3c3U1dHU1b3M1cXR9Zm57MTdzdTV0dTVvczVxdH1mb3sxN3N1NXR1NW9zNXF0fWZwezE3c3U1dHU1b3M1cXR9ZnF7MTdzdTV0dTVvczVxdH1mc3sxN3N1NXR1NW9zNXF0fWZ0ezE3c3U1dHU1b3R9N217NW9zfWZ2ezE3c3U1dHU1b3R9Znd7MTdzdTV0dTVvdH19fVwiKSxcbiAgICAgICdaYXBmRGluZ2JhdHMnOiB1bmNvbXByZXNzKFwieyd3aWR0aHMne2s0dTJrMXcnZm9mJzZvfSdrZXJuaW5nJ3snZm9mJy02b319XCIpLFxuICAgICAgJ0NvdXJpZXItQm9sZCc6IHVuY29tcHJlc3MoXCJ7J3dpZHRocyd7azN3J2ZvZic2b30na2VybmluZyd7J2ZvZictNm99fVwiKSxcbiAgICAgICdUaW1lcy1JdGFsaWMnOiB1bmNvbXByZXNzKFwieyd3aWR0aHMne2szbjJxNHljeDJsMjAxbjNtMjAxbzV0MjAxczJsMjAxdDJsMjAxdTJsMjAxdzNyMjAxeDNyMjAxeTNyMmsxdDJsMmwyMDJtMm4ybjNtMm8zbTJwNW4yMDJxNXQycjFwMnMybDJ0MmwydTNtMnY0bjJ3MXQyeDJsMnkxdDJ6MXczazNtM2wzbTNtM20zbjNtM28zbTNwM20zcTNtM3IzbTNzM20yMDN0MmwyMDN1MmwzdjJsM3c0bjN4NG4zeTRuM3ozbTRrNXc0bDN4NG0zeDRuNG00bzRzNHAzeDRxM3g0cjRzNHM0czR0Mmw0dTJ3NHY0bTR3M3I0eDVuNHk0bTR6NHM1azN4NWw0czVtM3g1bjNtNW8zcjVwNHM1cTN4NXI1bjVzM3g1dDNyNXUzcjV2MnI1dzF3NXgycjV5MnU1ejNtNmsybDZsM202bTNtNm4ydzZvM202cDJ3NnExdzZyM202czNtNnQxdzZ1MXc2djJ3NncxdzZ4NHM2eTNtNnozbTdrM203bDNtN20ycjduMnI3bzF3N3AzbTdxMnc3cjRtN3Mydzd0Mnc3dTJyN3Yyczd3MXY3eDJzN3kzcTIwMmwzbWNsM3hhbDJyYW0zbWFuM21hbzNtYXAzbWFyM21hczJsYXQ0d2F1MXZhdjNtYXc0bmF5NHdhejJsYmsyc2JsNG4nZm9mJzZvYm8ybGJwM21icTNvYnIxdGJzMmxidTF6YnYzbWJ6M21jazN4MjAyazNtY20zeGNuM3hjbzN4Y3AzeGNxNXRjcjRtY3MzeGN0M3hjdTN4Y3YzeGN3MmwybTJ1Y3kybGN6MmxkbDRtZG00c2RuNHNkbzRzZHA0c2RxNHNkczRzZHQ0c2R1NHNkdjRzZHc0c2R6M21lazNtZWwzbWVtM21lbjNtZW8zbWVwM21lcTRtZXIyd2VzMndldDJ3ZXUyd2V2MndldzF3ZXgxd2V5MXdlejF3ZmwzbWZtM21mbjNtZm8zbWZwM21mcTNtZnI0bmZzM21mdDNtZnUzbWZ2M21mdzNtZnoydzIwM2s2bzIxMm02bTJkdzJsMmNxMmwzdDNtM3UybDE3czNyMTltM219J2tlcm5pbmcne2NsezVrdDRxd30yMDFzezIwMXN3fTIwMXR7MjAxdHcyd3kyeXk2cS10fTIwMXh7Mnd5Mnl5fTJrezIwMXR3fTJ3ezdxczRxeTdyczVreTdtdzVvczVxeDVydTE3c3U1dHV9Mnh7MTdzczV0czVvc30yeXs3cXM0cXk3cnM1a3k3bXc1b3M1cXg1cnUxN3N1NXR1fSdmb2YnLTZvNnR7MTdzczV0czVxc303dHs1b3N9M3Z7NXFzfTdwezE3c3U1dHU1cXN9Y2t7NWt0NHF3fTRsezVrdDRxd31jbXs1a3Q0cXd9Y257NWt0NHF3fWNvezVrdDRxd31jcHs1a3Q0cXd9Nmx7NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX0xN3N7MmtzfTVxe2NrdmNsdmNtdmNudmNvdmNwdjRsdn01cntja3VjbHVjbXVjbnVjb3VjcHU0bHV9NXR7MmtzfTZwezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZWt7NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX1lbHs0cXM1a3M1b3U1cXc1cnUxN3N1NXR1fWVtezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZW57NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX1lb3s0cXM1a3M1b3U1cXc1cnUxN3N1NXR1fWVwezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZXN7NWtzNXFzNHFzfWV0ezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZXV7NHFzNWtzNXF3NXJ1MTdzdTV0dX1ldns1a3M1cXM0cXN9ZXh7MTdzczV0czVxc302ens0cXY1a3M1b3U1cXc1cnUxN3N1NXR1fWZtezRxdjVrczVvdTVxdzVydTE3c3U1dHV9Zm57NHF2NWtzNW91NXF3NXJ1MTdzdTV0dX1mb3s0cXY1a3M1b3U1cXc1cnUxN3N1NXR1fWZwezRxdjVrczVvdTVxdzVydTE3c3U1dHV9ZnF7NHF2NWtzNW91NXF3NXJ1MTdzdTV0dX03cns1b3N9ZnN7NHF2NWtzNW91NXF3NXJ1MTdzdTV0dX1mdHsxN3N1NXR1NXFzfWZ1ezE3c3U1dHU1cXN9ZnZ7MTdzdTV0dTVxc31md3sxN3N1NXR1NXFzfX19XCIpLFxuICAgICAgJ1RpbWVzLVJvbWFuJzogdW5jb21wcmVzcyhcInsnd2lkdGhzJ3trM24ycTR5Y3gybDIwMW4zbTIwMW82bzIwMXMybDIwMXQybDIwMXUybDIwMXcydzIwMXgydzIwMXkydzJrMXQybDJsMjAybTJuMm4zbTJvM20ycDVuMjAycTZvMnIxbTJzMmwydDJsMnUzbTJ2M3MydzF0MngybDJ5MXQyejF3M2szbTNsM20zbTNtM24zbTNvM20zcDNtM3EzbTNyM20zczNtMjAzdDJsMjAzdTJsM3YxdzN3M3MzeDNzM3kzczN6Mnc0azV3NGw0czRtNG00bjRtNG80czRwM3g0cTNyNHI0czRzNHM0dDJsNHUycjR2NHM0dzN4NHg1dDR5NHM0ejRzNWszcjVsNHM1bTRtNW4zcjVvM3g1cDRzNXE0czVyNXk1czRzNXQ0czV1M3g1djJsNXcxdzV4Mmw1eTJ6NXozbTZrMmw2bDJ3Nm0zbTZuMnc2bzNtNnAydzZxMmw2cjNtNnMzbTZ0MXc2dTF3NnYzbTZ3MXc2eDR5NnkzbTZ6M203azNtN2wzbTdtMmw3bjJyN28xdzdwM203cTNtN3I0czdzM203dDNtN3Uydzd2M2s3dzFvN3gzazd5M3EyMDJsM21jbDRzYWwybGFtM21hbjNtYW8zbWFwM21hcjNtYXMybGF0NHdhdTF2YXYzbWF3M3NheTR3YXoybGJrMnNibDNzJ2ZvZic2b2JvMmxicDNtYnEyeGJyMXRiczJsYnUxemJ2M21iejJ3Y2s0czIwMmszbWNtNHNjbjRzY280c2NwNHNjcTV0Y3I0bWNzM3hjdDN4Y3UzeGN2M3hjdzJsMm0ydGN5MmxjejJsZGw0c2RtNHNkbjRzZG80c2RwNHNkcTRzZHM0c2R0NHNkdTRzZHY0c2R3NHNkejNtZWsyd2VsMndlbTJ3ZW4yd2VvMndlcDJ3ZXE0bWVyMndlczJ3ZXQyd2V1MndldjJ3ZXcxd2V4MXdleTF3ZXoxd2ZsM21mbTNtZm4zbWZvM21mcDNtZnEzbWZyM3NmczNtZnQzbWZ1M21mdjNtZnczbWZ6M20yMDNrNm8yMTJtNm0yZHcybDJjcTJsM3QzbTN1MXcxN3M0czE5bTNtfSdrZXJuaW5nJ3tjbHs0cXM1a3UxN3N3NW91NXF5NXJ3MjAxc3M1dHcyMDF3c30yMDFzezIwMXNzfTIwMXR7Y2t3NGx3Y213Y253Y293Y3B3Y2x3NHd1MjAxdHN9Mmt7MjAxdHN9Mnd7NHFzNWt3NW9zNXF4NXJ1MTdzeDV0eH0yeHsxN3N3NXR3NW91NXF1fTJ5ezRxczVrdzVvczVxeDVydTE3c3g1dHh9J2ZvZictNm83dHtja3VjbHVjbXVjbnVjb3VjcHU0bHU1b3M1cnN9M3V7MTdzdTV0dTVxc30zdnsxN3N1NXR1NXFzfTdwezE3c3c1dHc1cXN9Y2t7NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9NGx7NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Y217NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Y257NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Y297NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Y3B7NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Nmx7MTdzdTV0dTVvczVxdzVyc30xN3N7Mmt0Y2x2Y212Y252Y292Y3B2NGx2NHd1Y2t2fTVve2Nrd2Nsd2Ntd2Nud2Nvd2NwdzRsdzR3dX01cXtja3ljbHljbXljbnljb3ljcHk0bHk0d3U1bXN9NXJ7Y2t0Y2x0Y210Y250Y290Y3B0NGx0NHdzfTV0ezJrdGNsdmNtdmNudmNvdmNwdjRsdjR3dWNrdn03cXtja3NjbHNjbXNjbnNjb3NjcHM0bHN9NnB7MTdzdTV0dTVxdzVyc31la3s1cXM1cnN9ZWx7MTdzdTV0dTVvczVxdzVyc31lbXsxN3N1NXR1NW9zNXFzNXJzfWVuezE3c3U1cXM1cnN9ZW97NXFzNXJzfWVwezE3c3U1dHU1b3M1cXc1cnN9ZXN7NXFzfWV0ezE3c3U1dHU1cXc1cnN9ZXV7MTdzdTV0dTVxczVyc31ldns1cXN9Nnp7MTdzdjV0djVvczVxeDVyc31mbXs1b3M1cXQ1cnN9Zm57MTdzdjV0djVvczVxeDVyc31mb3sxN3N2NXR2NW9zNXF4NXJzfWZwezVvczVxdDVyc31mcXs1b3M1cXQ1cnN9N3J7Y2t1Y2x1Y211Y251Y291Y3B1NGx1NW9zfWZzezE3c3Y1dHY1b3M1cXg1cnN9ZnR7MTdzczV0czVxc31mdXsxN3N3NXR3NXFzfWZ2ezE3c3c1dHc1cXN9Znd7MTdzczV0czVxc31mentja3VjbHVjbXVjbnVjb3VjcHU0bHU1b3M1cnN9fX1cIiksXG4gICAgICAnSGVsdmV0aWNhLU9ibGlxdWUnOiB1bmNvbXByZXNzKFwieyd3aWR0aHMne2szcDJxNG1jeDF3MjAxbjNyMjAxbzZvMjAxczFxMjAxdDFxMjAxdTFxMjAxdzJsMjAxeDJsMjAxeTJsMmsxdzJsMXcyMDJtMm4ybjNyMm8zcjJwNXQyMDJxNm8ycjFuMnMybDJ0MmwydTJyMnYzdTJ3MXcyeDJsMnkxdzJ6MXczazNyM2wzcjNtM3IzbjNyM28zcjNwM3IzcTNyM3IzcjNzM3IyMDN0MmwyMDN1MmwzdjF3M3czdTN4M3UzeTN1M3ozcjRrNnA0bDRtNG00bTRuNHM0bzRzNHA0bTRxM3g0cjR5NHM0czR0MXc0dTNtNHY0bTR3M3I0eDVuNHk0czR6NHk1azRtNWw0eTVtNHM1bjRtNW8zeDVwNHM1cTRtNXI1eTVzNG01dDRtNXUzeDV2MXc1dzF3NXgxdzV5Mno1ejNyNmsybDZsM3I2bTNyNm4zbTZvM3I2cDNyNnExdzZyM3I2czNyNnQxcTZ1MXE2djNtNncxcTZ4NW42eTNyNnozcjdrM3I3bDNyN20ybDduM203bzF3N3AzcjdxM203cjRzN3MzbTd0M203dTNtN3YybDd3MXU3eDJsN3kzdTIwMmwzcmNsNG1hbDJsYW0zcmFuM3JhbzNyYXAzcmFyM3JhczJsYXQ0dGF1MnBhdjNyYXczdWF5NHRhejJsYmsyc2JsM3UnZm9mJzZvYm8ybGJwM3JicjF3YnMybGJ1Mm9idjNyYnozeGNrNG0yMDJrM3JjbTRtY240bWNvNG1jcDRtY3E2b2NyNHNjczRtY3Q0bWN1NG1jdjRtY3cxdzJtMm5jeTF3Y3oxd2RsNHNkbTR5ZG40eWRvNHlkcDR5ZHE0eWRzNHlkdDRzZHU0c2R2NHNkdzRzZHozeGVrM3JlbDNyZW0zcmVuM3JlbzNyZXAzcmVxNXRlcjNtZXMzcmV0M3JldTNyZXYzcmV3MXdleDF3ZXkxd2V6MXdmbDNyZm0zcmZuM3JmbzNyZnAzcmZxM3JmcjN1ZnMzeGZ0M3JmdTNyZnYzcmZ3M3JmejNtMjAzazZvMjEybTZvMmR3MmwyY3EybDN0M3IzdTF3MTdzNG0xOW0zcn0na2VybmluZyd7NXF7NHd2fWNsezRxczVrdzVvdzVxczE3c3Y1dHZ9MjAxdHsyd3U0dzFrMnl1fTIwMXh7Mnd1NHd5Mnl1fTE3c3sya3RjbHVjbXVjbnU0b3RjcHU0bHU0d3ljb3Vja3V9Mnd7N3FzNHF6NWsxbTE3c3k1b3c1cXg1cnNmc3U1dHk3dHVmenV9Mnh7MTdzeTV0eTVveTVxc30yeXs3cXM0cXo1azFtMTdzeTVvdzVxeDVyc2ZzdTV0eTd0dWZ6dX0nZm9mJy02bzdwezE3c3Y1dHY1b3d9Y2t7NHFzNWt3NW93NXFzMTdzdjV0dn00bHs0cXM1a3c1b3c1cXMxN3N2NXR2fWNtezRxczVrdzVvdzVxczE3c3Y1dHZ9Y257NHFzNWt3NW93NXFzMTdzdjV0dn1jb3s0cXM1a3c1b3c1cXMxN3N2NXR2fWNwezRxczVrdzVvdzVxczE3c3Y1dHZ9Nmx7MTdzeTV0eTVvd31kb3sxN3N0NXR0fTR6ezE3c3Q1dHR9N3N7ZnN0fWRtezE3c3Q1dHR9ZG57MTdzdDV0dH01b3tja3djbHdjbXdjbndjb3djcHc0bHc0d3Z9ZHB7MTdzdDV0dH1kcXsxN3N0NXR0fTd0ezVvd31kc3sxN3N0NXR0fTV0ezJrdGNsdWNtdWNudTRvdGNwdTRsdTR3eWNvdWNrdX1mdXsxN3N2NXR2NW93fTZwezE3c3k1dHk1b3c1cXN9ZWt7MTdzeTV0eTVvd31lbHsxN3N5NXR5NW93fWVtezE3c3k1dHk1b3d9ZW57NXR5fWVvezE3c3k1dHk1b3d9ZXB7MTdzeTV0eTVvd31lc3sxN3N5NXR5NXFzfWV0ezE3c3k1dHk1b3c1cXN9ZXV7MTdzeTV0eTVvdzVxc31ldnsxN3N5NXR5NW93NXFzfTZ6ezE3c3k1dHk1b3c1cXN9Zm17MTdzeTV0eTVvdzVxc31mbnsxN3N5NXR5NW93NXFzfWZvezE3c3k1dHk1b3c1cXN9ZnB7MTdzeTV0eTVxc31mcXsxN3N5NXR5NW93NXFzfTdyezVvd31mc3sxN3N5NXR5NW93NXFzfWZ0ezE3c3Y1dHY1b3d9N217NW93fWZ2ezE3c3Y1dHY1b3d9Znd7MTdzdjV0djVvd319fVwiKVxuICAgIH1cbiAgfTtcbiAgLypcbiAgVGhpcyBldmVudCBoYW5kbGVyIGlzIGZpcmVkIHdoZW4gYSBuZXcganNQREYgb2JqZWN0IGlzIGluaXRpYWxpemVkXG4gIFRoaXMgZXZlbnQgaGFuZGxlciBhcHBlbmRzIG1ldHJpY3MgZGF0YSB0byBzdGFuZGFyZCBmb250cyB3aXRoaW5cbiAgdGhhdCBqc1BERiBpbnN0YW5jZS4gVGhlIG1ldHJpY3MgYXJlIG1hcHBlZCBvdmVyIFVuaWNvZGUgY2hhcmFjdGVyXG4gIGNvZGVzLCBOT1QgQ0lEcyBvciBvdGhlciBjb2RlcyBtYXRjaGluZyB0aGUgU3RhbmRhcmRFbmNvZGluZyB0YWJsZSBvZiB0aGVcbiAgc3RhbmRhcmQgUERGIGZvbnRzLlxuICBGdXR1cmU6XG4gIEFsc28gaW5jbHVkZWQgaXMgdGhlIGVuY29kaW5nIG1hcGluZyB0YWJsZSwgY29udmVydGluZyBVbmljb2RlIChVQ1MtMiwgVVRGLTE2KVxuICBjaGFyIGNvZGVzIHRvIFN0YW5kYXJkRW5jb2RpbmcgY2hhcmFjdGVyIGNvZGVzLiBUaGUgZW5jb2RpbmcgdGFibGUgaXMgdG8gYmUgdXNlZFxuICBzb21ld2hlcmUgYXJvdW5kIFwicGRmRXNjYXBlXCIgY2FsbC5cbiAgKi9cblxuICBBUEkuZXZlbnRzLnB1c2goWydhZGRGb250JywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZm9udCA9IGRhdGEuZm9udDtcbiAgICB2YXIgbWV0cmljcyxcbiAgICAgICAgdW5pY29kZV9zZWN0aW9uLFxuICAgICAgICBlbmNvZGluZyA9ICdVbmljb2RlJyxcbiAgICAgICAgZW5jb2RpbmdCbG9jaztcbiAgICBtZXRyaWNzID0gZm9udE1ldHJpY3NbZW5jb2RpbmddW2ZvbnQucG9zdFNjcmlwdE5hbWVdO1xuXG4gICAgaWYgKG1ldHJpY3MpIHtcbiAgICAgIGlmIChmb250Lm1ldGFkYXRhW2VuY29kaW5nXSkge1xuICAgICAgICB1bmljb2RlX3NlY3Rpb24gPSBmb250Lm1ldGFkYXRhW2VuY29kaW5nXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaWNvZGVfc2VjdGlvbiA9IGZvbnQubWV0YWRhdGFbZW5jb2RpbmddID0ge307XG4gICAgICB9XG5cbiAgICAgIHVuaWNvZGVfc2VjdGlvbi53aWR0aHMgPSBtZXRyaWNzLndpZHRocztcbiAgICAgIHVuaWNvZGVfc2VjdGlvbi5rZXJuaW5nID0gbWV0cmljcy5rZXJuaW5nO1xuICAgIH1cblxuICAgIGVuY29kaW5nQmxvY2sgPSBlbmNvZGluZ3NbZW5jb2RpbmddW2ZvbnQucG9zdFNjcmlwdE5hbWVdO1xuXG4gICAgaWYgKGVuY29kaW5nQmxvY2spIHtcbiAgICAgIGlmIChmb250Lm1ldGFkYXRhW2VuY29kaW5nXSkge1xuICAgICAgICB1bmljb2RlX3NlY3Rpb24gPSBmb250Lm1ldGFkYXRhW2VuY29kaW5nXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaWNvZGVfc2VjdGlvbiA9IGZvbnQubWV0YWRhdGFbZW5jb2RpbmddID0ge307XG4gICAgICB9XG5cbiAgICAgIHVuaWNvZGVfc2VjdGlvbi5lbmNvZGluZyA9IGVuY29kaW5nQmxvY2s7XG5cbiAgICAgIGlmIChlbmNvZGluZ0Jsb2NrLmNvZGVQYWdlcyAmJiBlbmNvZGluZ0Jsb2NrLmNvZGVQYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgZm9udC5lbmNvZGluZyA9IGVuY29kaW5nQmxvY2suY29kZVBhZ2VzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfV0pOyAvLyBlbmQgb2YgYWRkaW5nIGV2ZW50IGhhbmRsZXJcbn0pKGpzUERGLkFQSSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICovXG5cbi8qKlxuKiBAbmFtZSB0dGZzdXBwb3J0XG4qIEBtb2R1bGVcbiovXG4oZnVuY3Rpb24gKGpzUERGLCBnbG9iYWwpIHtcblxuICBqc1BERi5BUEkuZXZlbnRzLnB1c2goWydhZGRGb250JywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZm9udCA9IGRhdGEuZm9udDtcbiAgICB2YXIgaW5zdGFuY2UgPSBkYXRhLmluc3RhbmNlO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnN0YW5jZS5leGlzdHNGaWxlSW5WRlMoZm9udC5wb3N0U2NyaXB0TmFtZSkpIHtcbiAgICAgIHZhciBmaWxlID0gaW5zdGFuY2UuZ2V0RmlsZUZyb21WRlMoZm9udC5wb3N0U2NyaXB0TmFtZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZmlsZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGlzIG5vdCBzdG9yZWQgYXMgc3RyaW5nLWRhdGEgaW4gdkZTLCBpbXBvcnQgZm9udHMgb3IgcmVtb3ZlIGRlY2xhcmF0aW9uIGRvYy5hZGRGb250KCdcIiArIGZvbnQucG9zdFNjcmlwdE5hbWUgKyBcIicpLlwiKTtcbiAgICAgIH1cblxuICAgICAgZm9udC5tZXRhZGF0YSA9IGpzUERGLkFQSS5UVEZGb250Lm9wZW4oZm9udC5wb3N0U2NyaXB0TmFtZSwgZm9udC5mb250TmFtZSwgZmlsZSwgZm9udC5lbmNvZGluZyk7XG4gICAgICBmb250Lm1ldGFkYXRhLlVuaWNvZGUgPSBmb250Lm1ldGFkYXRhLlVuaWNvZGUgfHwge1xuICAgICAgICBlbmNvZGluZzoge30sXG4gICAgICAgIGtlcm5pbmc6IHt9LFxuICAgICAgICB3aWR0aHM6IFtdXG4gICAgICB9O1xuICAgICAgZm9udC5tZXRhZGF0YS5nbHlJZHNVc2VkID0gWzBdO1xuICAgIH0gZWxzZSBpZiAoZm9udC5pc1N0YW5kYXJkRm9udCA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgZG9lcyBub3QgZXhpc3QgaW4gdkZTLCBpbXBvcnQgZm9udHMgb3IgcmVtb3ZlIGRlY2xhcmF0aW9uIGRvYy5hZGRGb250KCdcIiArIGZvbnQucG9zdFNjcmlwdE5hbWUgKyBcIicpLlwiKTtcbiAgICB9XG4gIH1dKTsgLy8gZW5kIG9mIGFkZGluZyBldmVudCBoYW5kbGVyXG59KShqc1BERiwgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZiB8fCB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkpO1xuXG4vKiogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxMiBXaWxsb3cgU3lzdGVtcyBDb3Jwb3JhdGlvbiwgd2lsbG93LXN5c3RlbXMuY29tXG4gKiBcbiAqIFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4oZnVuY3Rpb24gKGpzUERGQVBJKSB7XG4gIC8qKlxuICAqIFBhcnNlcyBTVkcgWE1MIGFuZCBjb252ZXJ0cyBvbmx5IHNvbWUgb2YgdGhlIFNWRyBlbGVtZW50cyBpbnRvXG4gICogUERGIGVsZW1lbnRzLlxuICAqXG4gICogU3VwcG9ydHM6XG4gICogcGF0aHNcbiAgKiBcbiAgKiBAbmFtZSBhZGRTdmdcbiAgKiBAcHVibGljXG4gICogQGZ1bmN0aW9uIFxuICAqIEBwYXJhbSB7c3RyaW5nfSBTVkctRGF0YSBhcyBUZXh0XG4gICogQHBhcmFtIHtudW1iZXJ9IHggQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCBsZWZ0IGVkZ2Ugb2YgdGhlIHBhZ2VcbiAgKiBAcGFyYW0ge251bWJlcn0geSBDb29yZGluYXRlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KSBhZ2FpbnN0IHVwcGVyIGVkZ2Ugb2YgdGhlIHBhZ2VcbiAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggb2YgU1ZHIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KVxuICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgb2YgU1ZHIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KVxuICAqIEByZXR1cm5zIHtPYmplY3R9IGpzUERGLWluc3RhbmNlXG4gICovXG5cbiAganNQREZBUEkuYWRkU3ZnID0gZnVuY3Rpb24gKHN2Z3RleHQsIHgsIHksIHcsIGgpIHtcbiAgICAvLyAndGhpcycgaXMgX2pzUERGIG9iamVjdCByZXR1cm5lZCB3aGVuIGpzUERGIGlzIGluaXRlZCAobmV3IGpzUERGKCkpXG4gICAgdmFyIHVuZGVmO1xuXG4gICAgaWYgKHggPT09IHVuZGVmIHx8IHkgPT09IHVuZGVmKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRTVkcgbmVlZHMgdmFsdWVzIGZvciAneCcgYW5kICd5J1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbmplY3RDU1MoY3NzYm9keSwgZG9jdW1lbnQpIHtcbiAgICAgIHZhciBzdHlsZXRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZXRhZy50eXBlID0gJ3RleHQvY3NzJztcblxuICAgICAgaWYgKHN0eWxldGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgLy8gaWVcbiAgICAgICAgc3R5bGV0YWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzYm9keTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyc1xuICAgICAgICBzdHlsZXRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3Nib2R5KSk7XG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChzdHlsZXRhZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlV29ya2VyTm9kZShkb2N1bWVudCkge1xuICAgICAgdmFyIGZyYW1lSUQgPSAnY2hpbGRmcmFtZScgLy8gRGF0ZS5ub3coKS50b1N0cmluZygpICsgJ18nICsgKE1hdGgucmFuZG9tKCkgKiAxMDApLnRvU3RyaW5nKClcbiAgICAgICxcbiAgICAgICAgICBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgSW5qZWN0Q1NTKCcuanNQREZfc2lsbHlzdmdfaWZyYW1lIHtkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7fScsIGRvY3VtZW50KTtcbiAgICAgIGZyYW1lLm5hbWUgPSBmcmFtZUlEO1xuICAgICAgZnJhbWUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoXCJmcmFtZWJvcmRlclwiLCBcIjBcIik7XG4gICAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzY3JvbGxpbmdcIiwgXCJub1wiKTtcbiAgICAgIGZyYW1lLnNldEF0dHJpYnV0ZShcInNlYW1sZXNzXCIsIFwic2VhbWxlc3NcIik7XG4gICAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImpzUERGX3NpbGx5c3ZnX2lmcmFtZVwiKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhbWUpO1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0dGFjaFNWR1RvV29ya2VyTm9kZShzdmd0ZXh0LCBmcmFtZSkge1xuICAgICAgdmFyIGZyYW1lZG9jID0gKGZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgZnJhbWUuY29udGVudERvY3VtZW50KS5kb2N1bWVudDtcbiAgICAgIGZyYW1lZG9jLndyaXRlKHN2Z3RleHQpO1xuICAgICAgZnJhbWVkb2MuY2xvc2UoKTtcbiAgICAgIHJldHVybiBmcmFtZWRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3ZnJylbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFBhdGhUb1BERkxpbmVzQXJncyhwYXRoKSB7XG4gICAgICAvLyAtIHN0YXJ0aW5nIGNvb3JkaW5hdGUgcGFpclxuICAgICAgLy8gLSBhcnJheSBvZiBhcnJheXMgb2YgdmVjdG9yIHNoaWZ0cyAoMi1sZW4gZm9yIGxpbmUsIDYgbGVuIGZvciBiZXppZXIpXG4gICAgICAvLyAtIHNjYWxlIGFycmF5IFtob3Jpem9udGFsLCB2ZXJ0aWNhbF0gcmF0aW9zXG4gICAgICAvLyAtIHN0eWxlIChzdHJva2UsIGZpbGwsIGJvdGgpXG5cbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChwYXRoWzFdKSxcbiAgICAgICAgICB5ID0gcGFyc2VGbG9hdChwYXRoWzJdKSxcbiAgICAgICAgICB2ZWN0b3JzID0gW10sXG4gICAgICAgICAgcG9zaXRpb24gPSAzLFxuICAgICAgICAgIGxlbiA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBsZW4pIHtcbiAgICAgICAgaWYgKHBhdGhbcG9zaXRpb25dID09PSAnYycpIHtcbiAgICAgICAgICB2ZWN0b3JzLnB1c2goW3BhcnNlRmxvYXQocGF0aFtwb3NpdGlvbiArIDFdKSwgcGFyc2VGbG9hdChwYXRoW3Bvc2l0aW9uICsgMl0pLCBwYXJzZUZsb2F0KHBhdGhbcG9zaXRpb24gKyAzXSksIHBhcnNlRmxvYXQocGF0aFtwb3NpdGlvbiArIDRdKSwgcGFyc2VGbG9hdChwYXRoW3Bvc2l0aW9uICsgNV0pLCBwYXJzZUZsb2F0KHBhdGhbcG9zaXRpb24gKyA2XSldKTtcbiAgICAgICAgICBwb3NpdGlvbiArPSA3O1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGhbcG9zaXRpb25dID09PSAnbCcpIHtcbiAgICAgICAgICB2ZWN0b3JzLnB1c2goW3BhcnNlRmxvYXQocGF0aFtwb3NpdGlvbiArIDFdKSwgcGFyc2VGbG9hdChwYXRoW3Bvc2l0aW9uICsgMl0pXSk7XG4gICAgICAgICAgcG9zaXRpb24gKz0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3NpdGlvbiArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbeCwgeSwgdmVjdG9yc107XG4gICAgfVxuXG4gICAgdmFyIHdvcmtlcm5vZGUgPSBjcmVhdGVXb3JrZXJOb2RlKGRvY3VtZW50KSxcbiAgICAgICAgc3Znbm9kZSA9IGF0dGFjaFNWR1RvV29ya2VyTm9kZShzdmd0ZXh0LCB3b3JrZXJub2RlKSxcbiAgICAgICAgc2NhbGUgPSBbMSwgMV0sXG4gICAgICAgIHN2Z3cgPSBwYXJzZUZsb2F0KHN2Z25vZGUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSxcbiAgICAgICAgc3ZnaCA9IHBhcnNlRmxvYXQoc3Znbm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtcblxuICAgIGlmIChzdmd3ICYmIHN2Z2gpIHtcbiAgICAgIC8vIHNldHRpbmcgYm90aCB3IGFuZCBoIG1ha2VzIGltYWdlIHN0cmV0Y2ggdG8gc2l6ZS5cbiAgICAgIC8vIHRoaXMgbWF5IGRpc3RvcnQgdGhlIGltYWdlLCBidXQgZml0cyB5b3VyIGRlbWFuZGVkIHNpemVcbiAgICAgIGlmICh3ICYmIGgpIHtcbiAgICAgICAgc2NhbGUgPSBbdyAvIHN2Z3csIGggLyBzdmdoXTtcbiAgICAgIH0gLy8gaWYgb25seSBvbmUgaXMgc2V0LCB0aGF0IHZhbHVlIGlzIHNldCBhcyBtYXggYW5kIFNWR1xuICAgICAgLy8gaXMgc2NhbGVkIHByb3BvcnRpb25hdGVseS5cbiAgICAgIGVsc2UgaWYgKHcpIHtcbiAgICAgICAgICBzY2FsZSA9IFt3IC8gc3ZndywgdyAvIHN2Z3ddO1xuICAgICAgICB9IGVsc2UgaWYgKGgpIHtcbiAgICAgICAgICBzY2FsZSA9IFtoIC8gc3ZnaCwgaCAvIHN2Z2hdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIHRtcCxcbiAgICAgICAgbGluZXNhcmdzLFxuICAgICAgICBpdGVtcyA9IHN2Z25vZGUuY2hpbGROb2RlcztcblxuICAgIGZvciAoaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRtcCA9IGl0ZW1zW2ldO1xuXG4gICAgICBpZiAodG1wLnRhZ05hbWUgJiYgdG1wLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1BBVEgnKSB7XG4gICAgICAgIGxpbmVzYXJncyA9IGNvbnZlcnRQYXRoVG9QREZMaW5lc0FyZ3ModG1wLmdldEF0dHJpYnV0ZShcImRcIikuc3BsaXQoJyAnKSk7IC8vIHBhdGggc3RhcnQgeCBjb29yZGluYXRlXG5cbiAgICAgICAgbGluZXNhcmdzWzBdID0gbGluZXNhcmdzWzBdICogc2NhbGVbMF0gKyB4OyAvLyB3aGVyZSB4IGlzIHVwcGVyIGxlZnQgWCBvZiBpbWFnZVxuICAgICAgICAvLyBwYXRoIHN0YXJ0IHkgY29vcmRpbmF0ZVxuXG4gICAgICAgIGxpbmVzYXJnc1sxXSA9IGxpbmVzYXJnc1sxXSAqIHNjYWxlWzFdICsgeTsgLy8gd2hlcmUgeSBpcyB1cHBlciBsZWZ0IFkgb2YgaW1hZ2VcbiAgICAgICAgLy8gdGhlIHJlc3Qgb2YgbGluZXMgYXJlIHZlY3RvcnMuIHRoZXNlIHdpbGwgYWRqdXN0IHdpdGggc2NhbGUgdmFsdWUgYXV0by5cblxuICAgICAgICB0aGlzLmxpbmVzLmNhbGwodGhpcywgbGluZXNhcmdzWzJdIC8vIGxpbmVzXG4gICAgICAgICwgbGluZXNhcmdzWzBdIC8vIHN0YXJ0aW5nIHhcbiAgICAgICAgLCBsaW5lc2FyZ3NbMV0gLy8gc3RhcnRpbmcgeVxuICAgICAgICAsIHNjYWxlKTtcbiAgICAgIH1cbiAgICB9IC8vIGNsZWFuIHVwXG4gICAgLy8gd29ya2Vybm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdvcmtlcm5vZGUpXG5cblxuICAgIHJldHVybiB0aGlzO1xuICB9OyAvL2ZhbGxiYWNrXG5cblxuICBqc1BERkFQSS5hZGRTVkcgPSBqc1BERkFQSS5hZGRTdmc7XG4gIC8qKlxuICAqIFBhcnNlcyBTVkcgWE1MIGFuZCBzYXZlcyBpdCBhcyBpbWFnZSBpbnRvIHRoZSBQREYuXG4gICpcbiAgKiBEZXBlbmRzIG9uIGNhbnZhcy1lbGVtZW50IGFuZCBjYW52Z1xuICAqXG4gICogQG5hbWUgYWRkU3ZnQXNJbWFnZVxuICAqIEBwdWJsaWNcbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0ge3N0cmluZ30gU1ZHLURhdGEgYXMgVGV4dFxuICAqIEBwYXJhbSB7bnVtYmVyfSB4IENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgbGVmdCBlZGdlIG9mIHRoZSBwYWdlXG4gICogQHBhcmFtIHtudW1iZXJ9IHkgQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCB1cHBlciBlZGdlIG9mIHRoZSBwYWdlXG4gICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIG9mIFNWRy1JbWFnZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudClcbiAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IG9mIFNWRy1JbWFnZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudClcbiAgKiBAcGFyYW0ge3N0cmluZ30gYWxpYXMgb2YgU1ZHLUltYWdlIChpZiB1c2VkIG11bHRpcGxlIHRpbWVzKVxuICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wcmVzc2lvbiBvZiB0aGUgZ2VuZXJhdGVkIEpQRUcsIGNhbiBoYXZlIHRoZSB2YWx1ZXMgJ05PTkUnLCAnRkFTVCcsICdNRURJVU0nIGFuZCAnU0xPVydcbiAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gb2YgdGhlIGltYWdlIGluIGRlZ3JlZXMgKDAtMzU5KVxuICAqIFxuICAqIEByZXR1cm5zIGpzUERGIGpzUERGLWluc3RhbmNlXG4gICovXG5cbiAganNQREZBUEkuYWRkU3ZnQXNJbWFnZSA9IGZ1bmN0aW9uIChzdmcsIHgsIHksIHcsIGgsIGFsaWFzLCBjb21wcmVzc2lvbiwgcm90YXRpb24pIHtcbiAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGLmFkZFN2Z0FzSW1hZ2U6IEludmFsaWQgY29vcmRpbmF0ZXMnLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb3JkaW5hdGVzIHBhc3NlZCB0byBqc1BERi5hZGRTdmdBc0ltYWdlJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKHcpIHx8IGlzTmFOKGgpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdqc1BERi5hZGRTdmdBc0ltYWdlOiBJbnZhbGlkIG1lYXN1cmVtZW50cycsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVhc3VyZW1lbnRzICh3aWR0aCBhbmQvb3IgaGVpZ2h0KSBwYXNzZWQgdG8ganNQREYuYWRkU3ZnQXNJbWFnZScpO1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB3O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJyNmZmYnOyAvLy8gc2V0IHdoaXRlIGZpbGwgc3R5bGVcblxuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpOyAvL2xvYWQgYSBzdmcgc25pcHBldCBpbiB0aGUgY2FudmFzIHdpdGggaWQgPSAnZHJhd2luZ0FyZWEnXG5cbiAgICBjYW52ZyhjYW52YXMsIHN2Zywge1xuICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgICBpZ25vcmVEaW1lbnNpb25zOiB0cnVlLFxuICAgICAgaWdub3JlQ2xlYXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFkZEltYWdlKGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9qcGVnXCIsIDEuMCksIHgsIHksIHcsIGgsIGNvbXByZXNzaW9uLCByb3RhdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KShqc1BERi5BUEkpO1xuXG4vKiogXG4gKiBAbGljZW5zZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgRWR1YXJkbyBNZW5lemVzIGRlIE1vcmFpcywgZWR1YXJkby5tb3JhaXNAdXNwLmJyXG4gKiBcbiAqIFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIGpzUERGIHRvdGFsX3BhZ2VzIHBsdWdpblxuICogQG5hbWUgdG90YWxfcGFnZXNcbiAqIEBtb2R1bGVcbiAqL1xuKGZ1bmN0aW9uIChqc1BERkFQSSkge1xuICAvKipcbiAgKiBAbmFtZSBwdXRUb3RhbFBhZ2VzXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtzdHJpbmd9IHBhZ2VFeHByZXNzaW9uIFJlZ3VsYXIgRXhwcmVzc2lvblxuICAqIEByZXR1cm5zIHtqc1BERn0ganNQREYtaW5zdGFuY2VcbiAgKi9cblxuICBqc1BERkFQSS5wdXRUb3RhbFBhZ2VzID0gZnVuY3Rpb24gKHBhZ2VFeHByZXNzaW9uKSB7XG5cbiAgICB2YXIgcmVwbGFjZUV4cHJlc3Npb247XG4gICAgdmFyIHRvdGFsTnVtYmVyT2ZQYWdlcyA9IDA7XG5cbiAgICBpZiAocGFyc2VJbnQodGhpcy5pbnRlcm5hbC5nZXRGb250KCkuaWQuc3Vic3RyKDEpLCAxMCkgPCAxNSkge1xuICAgICAgcmVwbGFjZUV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKHBhZ2VFeHByZXNzaW9uLCAnZycpO1xuICAgICAgdG90YWxOdW1iZXJPZlBhZ2VzID0gdGhpcy5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VFeHByZXNzaW9uID0gbmV3IFJlZ0V4cCh0aGlzLnBkZkVzY2FwZTE2KHBhZ2VFeHByZXNzaW9uLCB0aGlzLmludGVybmFsLmdldEZvbnQoKSksICdnJyk7XG4gICAgICB0b3RhbE51bWJlck9mUGFnZXMgPSB0aGlzLnBkZkVzY2FwZTE2KHRoaXMuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpICsgJycsIHRoaXMuaW50ZXJuYWwuZ2V0Rm9udCgpKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuID0gMTsgbiA8PSB0aGlzLmludGVybmFsLmdldE51bWJlck9mUGFnZXMoKTsgbisrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW50ZXJuYWwucGFnZXNbbl0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbC5wYWdlc1tuXVtpXSA9IHRoaXMuaW50ZXJuYWwucGFnZXNbbl1baV0ucmVwbGFjZShyZXBsYWNlRXhwcmVzc2lvbiwgdG90YWxOdW1iZXJPZlBhZ2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKGpzUERGLkFQSSk7XG5cbi8qKlxuICoganNQREYgdmlld2VyUHJlZmVyZW5jZXMgUGx1Z2luXG4gKiBAYXV0aG9yIEFyYXMgQWJiYXNpIChnaXRodWIuY29tL2FyYXNhYmJhc2kpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqL1xuXG4vKipcbiogQWRkcyB0aGUgYWJpbGl0eSB0byBzZXQgVmlld2VyUHJlZmVyZW5jZXMgYW5kIGJ5IHRodXNcbiogY29udHJvbGxpbmcgdGhlIHdheSB0aGUgZG9jdW1lbnQgaXMgdG8gYmUgcHJlc2VudGVkIG9uIHRoZVxuKiBzY3JlZW4gb3IgaW4gcHJpbnQuXG4qIEBuYW1lIHZpZXdlcnByZWZlcmVuY2VzXG4qIEBtb2R1bGVcbiovXG4oZnVuY3Rpb24gKGpzUERGQVBJKSB7XG4gIC8qKlxuICAgKiBTZXQgdGhlIFZpZXdlclByZWZlcmVuY2VzIG9mIHRoZSBnZW5lcmF0ZWQgUERGXG4gICAqXG4gICAqIEBuYW1lIHZpZXdlclByZWZlcmVuY2VzXG4gICogQGZ1bmN0aW9uXG4gICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBcnJheSB3aXRoIHRoZSBWaWV3ZXJQcmVmZXJlbmNlczxiciAvPlxuICAgKiBFeGFtcGxlOiBkb2Mudmlld2VyUHJlZmVyZW5jZXMoe1wiRml0V2luZG93XCI6dHJ1ZX0pOzxiciAvPlxuICAgKiA8YnIgLz5cbiAgICogWW91IGNhbiBzZXQgZm9sbG93aW5nIHByZWZlcmVuY2VzOjxiciAvPlxuICAgKiA8YnIvPlxuICAgKiA8Yj5IaWRlVG9vbGJhcjwvYj4gPGk+KGJvb2xlYW4pPC9pPjxiciAvPlxuICAgKiBEZWZhdWx0IHZhbHVlOiBmYWxzZTxiciAvPlxuICAgKiA8YnIgLz5cbiAgICogPGI+SGlkZU1lbnViYXI8L2I+IDxpPihib29sZWFuKTwvaT48YnIgLz5cbiAgICogRGVmYXVsdCB2YWx1ZTogZmFsc2UuPGJyIC8+XG4gICAqIDxiciAvPlxuICAgKiA8Yj5IaWRlV2luZG93VUk8L2I+IDxpPihib29sZWFuKTwvaT48YnIgLz5cbiAgICogRGVmYXVsdCB2YWx1ZTogZmFsc2UuPGJyIC8+XG4gICAqIDxiciAvPlxuICAgKiA8Yj5GaXRXaW5kb3c8L2I+IDxpPihib29sZWFuKTwvaT48YnIgLz5cbiAgICogRGVmYXVsdCB2YWx1ZTogZmFsc2UuPGJyIC8+XG4gICAqIDxiciAvPlxuICAgKiA8Yj5DZW50ZXJXaW5kb3c8L2I+IDxpPihib29sZWFuKTwvaT48YnIgLz5cbiAgICogRGVmYXVsdCB2YWx1ZTogZmFsc2U8YnIgLz5cbiAgICogPGJyIC8+XG4gICAqIDxiPkRpc3BsYXlEb2NUaXRsZTwvYj4gPGk+KGJvb2xlYW4pPC9pPjxiciAvPlxuICAgKiBEZWZhdWx0IHZhbHVlOiBmYWxzZS48YnIgLz5cbiAgICogPGJyIC8+XG4gICAqIDxiPk5vbkZ1bGxTY3JlZW5QYWdlTW9kZTwvYj4gPGk+KHN0cmluZyk8L2k+PGJyIC8+XG4gICAqIFBvc3NpYmxlIHZhbHVlczogVXNlTm9uZSwgVXNlT3V0bGluZXMsIFVzZVRodW1icywgVXNlT0M8YnIgLz5cbiAgICogRGVmYXVsdCB2YWx1ZTogVXNlTm9uZTxici8+XG4gICAqIDxiciAvPlxuICAgKiA8Yj5EaXJlY3Rpb248L2I+IDxpPihzdHJpbmcpPC9pPjxiciAvPlxuICAgKiBQb3NzaWJsZSB2YWx1ZXM6IEwyUiwgUjJMPGJyIC8+XG4gICAqIERlZmF1bHQgdmFsdWU6IEwyUi48YnIgLz5cbiAgICogPGJyIC8+XG4gICAqIDxiPlZpZXdBcmVhPC9iPiA8aT4oc3RyaW5nKTwvaT48YnIgLz5cbiAgICogUG9zc2libGUgdmFsdWVzOiBNZWRpYUJveCwgQ3JvcEJveCwgVHJpbUJveCwgQmxlZWRCb3gsIEFydEJveDxiciAvPlxuICAgKiBEZWZhdWx0IHZhbHVlOiBDcm9wQm94LjxiciAvPlxuICAgKiA8YnIgLz5cbiAgICogPGI+Vmlld0NsaXA8L2I+IDxpPihzdHJpbmcpPC9pPjxiciAvPlxuICAgKiBQb3NzaWJsZSB2YWx1ZXM6IE1lZGlhQm94LCBDcm9wQm94LCBUcmltQm94LCBCbGVlZEJveCwgQXJ0Qm94PGJyIC8+XG4gICAqIERlZmF1bHQgdmFsdWU6IENyb3BCb3g8YnIgLz5cbiAgICogPGJyIC8+XG4gICAqIDxiPlByaW50QXJlYTwvYj4gPGk+KHN0cmluZyk8L2k+PGJyIC8+XG4gICAqIFBvc3NpYmxlIHZhbHVlczogTWVkaWFCb3gsIENyb3BCb3gsIFRyaW1Cb3gsIEJsZWVkQm94LCBBcnRCb3g8YnIgLz5cbiAgICogRGVmYXVsdCB2YWx1ZTogQ3JvcEJveDxiciAvPlxuICAgKiA8YnIgLz5cbiAgICogPGI+UHJpbnRDbGlwPC9iPiA8aT4oc3RyaW5nKTwvaT48YnIgLz5cbiAgICogUG9zc2libGUgdmFsdWVzOiBNZWRpYUJveCwgQ3JvcEJveCwgVHJpbUJveCwgQmxlZWRCb3gsIEFydEJveDxiciAvPlxuICAgKiBEZWZhdWx0IHZhbHVlOiBDcm9wQm94LjxiciAvPlxuICAgKiA8YnIgLz5cbiAgICogPGI+UHJpbnRTY2FsaW5nPC9iPiA8aT4oc3RyaW5nKTwvaT48YnIgLz5cbiAgICogUG9zc2libGUgdmFsdWVzOiBBcHBEZWZhdWx0LCBOb25lPGJyIC8+XG4gICAqIERlZmF1bHQgdmFsdWU6IEFwcERlZmF1bHQuPGJyIC8+XG4gICAqIDxiciAvPlxuICAgKiA8Yj5EdXBsZXg8L2I+IDxpPihzdHJpbmcpPC9pPjxiciAvPlxuICAgKiBQb3NzaWJsZSB2YWx1ZXM6IFNpbXBsZXgsIER1cGxleEZsaXBMb25nRWRnZSwgRHVwbGV4RmxpcFNob3J0RWRnZVxuICAgKiBEZWZhdWx0IHZhbHVlOiBub25lPGJyIC8+XG4gICAqIDxiciAvPlxuICAgKiA8Yj5QaWNrVHJheUJ5UERGU2l6ZTwvYj4gPGk+KGJvb2xlYW4pPC9pPjxiciAvPlxuICAgKiBEZWZhdWx0IHZhbHVlOiBmYWxzZTxiciAvPlxuICAgKiA8YnIgLz5cbiAgICogPGI+UHJpbnRQYWdlUmFuZ2U8L2I+IDxpPihBcnJheSk8L2k+PGJyIC8+XG4gICAqIEV4YW1wbGU6IFtbMSw1XSwgWzcsOV1dPGJyIC8+XG4gICAqIERlZmF1bHQgdmFsdWU6IGFzIGRlZmluZWQgYnkgUERGIHZpZXdlciBhcHBsaWNhdGlvbjxiciAvPlxuICAgKiA8YnIgLz5cbiAgICogPGI+TnVtQ29waWVzPC9iPiA8aT4oTnVtYmVyKTwvaT48YnIgLz5cbiAgICogUG9zc2libGUgdmFsdWVzOiAxLCAyLCAzLCA0LCA1PGJyIC8+XG4gICAqIERlZmF1bHQgdmFsdWU6IDE8YnIgLz5cbiAgICogPGJyIC8+XG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgUERGIFJlZmVyZW5jZSwgc2l4dGggZWRpdGlvbiBvbiBQYWdlIDU3N1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvUmVzZXQgVHJ1ZSB0byByZXNldCB0aGUgc2V0dGluZ3NcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIGpzUERGIGpzUERGLWluc3RhbmNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBkb2MgPSBuZXcganNQREYoKVxuICAgKiBkb2MudGV4dCgnVGhpcyBpcyBhIHRlc3QnLCAxMCwgMTApXG4gICAqIGRvYy52aWV3ZXJQcmVmZXJlbmNlcyh7J0ZpdFdpbmRvdyc6IHRydWV9LCB0cnVlKVxuICAgKiBkb2Muc2F2ZShcInZpZXdlclByZWZlcmVuY2VzLnBkZlwiKVxuICAgKlxuICAgKiAvLyBFeGFtcGxlIHByaW50aW5nIDEwIGNvcGllcywgdXNpbmcgY3JvcGJveCwgYW5kIGhpZGluZyBVSS5cbiAgICogZG9jLnZpZXdlclByZWZlcmVuY2VzKHtcbiAgICogICAnSGlkZVdpbmRvd1VJJzogdHJ1ZSxcbiAgICogICAnUHJpbnRBcmVhJzogJ0Nyb3BCb3gnLFxuICAgKiAgICdOdW1Db3BpZXMnOiAxMFxuICAgKiB9KVxuICAgKi9cblxuICBqc1BERkFQSS52aWV3ZXJQcmVmZXJlbmNlcyA9IGZ1bmN0aW9uIChvcHRpb25zLCBkb1Jlc2V0KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgZG9SZXNldCA9IGRvUmVzZXQgfHwgZmFsc2U7XG4gICAgdmFyIGNvbmZpZ3VyYXRpb247XG4gICAgdmFyIGNvbmZpZ3VyYXRpb25UZW1wbGF0ZSA9IHtcbiAgICAgIFwiSGlkZVRvb2xiYXJcIjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICBleHBsaWNpdFNldDogZmFsc2UsXG4gICAgICAgIHZhbHVlU2V0OiBbdHJ1ZSwgZmFsc2VdLFxuICAgICAgICBwZGZWZXJzaW9uOiAxLjNcbiAgICAgIH0sXG4gICAgICBcIkhpZGVNZW51YmFyXCI6IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgZXhwbGljaXRTZXQ6IGZhbHNlLFxuICAgICAgICB2YWx1ZVNldDogW3RydWUsIGZhbHNlXSxcbiAgICAgICAgcGRmVmVyc2lvbjogMS4zXG4gICAgICB9LFxuICAgICAgXCJIaWRlV2luZG93VUlcIjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICBleHBsaWNpdFNldDogZmFsc2UsXG4gICAgICAgIHZhbHVlU2V0OiBbdHJ1ZSwgZmFsc2VdLFxuICAgICAgICBwZGZWZXJzaW9uOiAxLjNcbiAgICAgIH0sXG4gICAgICBcIkZpdFdpbmRvd1wiOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIGV4cGxpY2l0U2V0OiBmYWxzZSxcbiAgICAgICAgdmFsdWVTZXQ6IFt0cnVlLCBmYWxzZV0sXG4gICAgICAgIHBkZlZlcnNpb246IDEuM1xuICAgICAgfSxcbiAgICAgIFwiQ2VudGVyV2luZG93XCI6IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgZXhwbGljaXRTZXQ6IGZhbHNlLFxuICAgICAgICB2YWx1ZVNldDogW3RydWUsIGZhbHNlXSxcbiAgICAgICAgcGRmVmVyc2lvbjogMS4zXG4gICAgICB9LFxuICAgICAgXCJEaXNwbGF5RG9jVGl0bGVcIjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICBleHBsaWNpdFNldDogZmFsc2UsXG4gICAgICAgIHZhbHVlU2V0OiBbdHJ1ZSwgZmFsc2VdLFxuICAgICAgICBwZGZWZXJzaW9uOiAxLjRcbiAgICAgIH0sXG4gICAgICBcIk5vbkZ1bGxTY3JlZW5QYWdlTW9kZVwiOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJVc2VOb25lXCIsXG4gICAgICAgIHZhbHVlOiBcIlVzZU5vbmVcIixcbiAgICAgICAgdHlwZTogXCJuYW1lXCIsXG4gICAgICAgIGV4cGxpY2l0U2V0OiBmYWxzZSxcbiAgICAgICAgdmFsdWVTZXQ6IFtcIlVzZU5vbmVcIiwgXCJVc2VPdXRsaW5lc1wiLCBcIlVzZVRodW1ic1wiLCBcIlVzZU9DXCJdLFxuICAgICAgICBwZGZWZXJzaW9uOiAxLjNcbiAgICAgIH0sXG4gICAgICBcIkRpcmVjdGlvblwiOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJMMlJcIixcbiAgICAgICAgdmFsdWU6IFwiTDJSXCIsXG4gICAgICAgIHR5cGU6IFwibmFtZVwiLFxuICAgICAgICBleHBsaWNpdFNldDogZmFsc2UsXG4gICAgICAgIHZhbHVlU2V0OiBbXCJMMlJcIiwgXCJSMkxcIl0sXG4gICAgICAgIHBkZlZlcnNpb246IDEuM1xuICAgICAgfSxcbiAgICAgIFwiVmlld0FyZWFcIjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiQ3JvcEJveFwiLFxuICAgICAgICB2YWx1ZTogXCJDcm9wQm94XCIsXG4gICAgICAgIHR5cGU6IFwibmFtZVwiLFxuICAgICAgICBleHBsaWNpdFNldDogZmFsc2UsXG4gICAgICAgIHZhbHVlU2V0OiBbXCJNZWRpYUJveFwiLCBcIkNyb3BCb3hcIiwgXCJUcmltQm94XCIsIFwiQmxlZWRCb3hcIiwgXCJBcnRCb3hcIl0sXG4gICAgICAgIHBkZlZlcnNpb246IDEuNFxuICAgICAgfSxcbiAgICAgIFwiVmlld0NsaXBcIjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiQ3JvcEJveFwiLFxuICAgICAgICB2YWx1ZTogXCJDcm9wQm94XCIsXG4gICAgICAgIHR5cGU6IFwibmFtZVwiLFxuICAgICAgICBleHBsaWNpdFNldDogZmFsc2UsXG4gICAgICAgIHZhbHVlU2V0OiBbXCJNZWRpYUJveFwiLCBcIkNyb3BCb3hcIiwgXCJUcmltQm94XCIsIFwiQmxlZWRCb3hcIiwgXCJBcnRCb3hcIl0sXG4gICAgICAgIHBkZlZlcnNpb246IDEuNFxuICAgICAgfSxcbiAgICAgIFwiUHJpbnRBcmVhXCI6IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIkNyb3BCb3hcIixcbiAgICAgICAgdmFsdWU6IFwiQ3JvcEJveFwiLFxuICAgICAgICB0eXBlOiBcIm5hbWVcIixcbiAgICAgICAgZXhwbGljaXRTZXQ6IGZhbHNlLFxuICAgICAgICB2YWx1ZVNldDogW1wiTWVkaWFCb3hcIiwgXCJDcm9wQm94XCIsIFwiVHJpbUJveFwiLCBcIkJsZWVkQm94XCIsIFwiQXJ0Qm94XCJdLFxuICAgICAgICBwZGZWZXJzaW9uOiAxLjRcbiAgICAgIH0sXG4gICAgICBcIlByaW50Q2xpcFwiOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJDcm9wQm94XCIsXG4gICAgICAgIHZhbHVlOiBcIkNyb3BCb3hcIixcbiAgICAgICAgdHlwZTogXCJuYW1lXCIsXG4gICAgICAgIGV4cGxpY2l0U2V0OiBmYWxzZSxcbiAgICAgICAgdmFsdWVTZXQ6IFtcIk1lZGlhQm94XCIsIFwiQ3JvcEJveFwiLCBcIlRyaW1Cb3hcIiwgXCJCbGVlZEJveFwiLCBcIkFydEJveFwiXSxcbiAgICAgICAgcGRmVmVyc2lvbjogMS40XG4gICAgICB9LFxuICAgICAgXCJQcmludFNjYWxpbmdcIjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiQXBwRGVmYXVsdFwiLFxuICAgICAgICB2YWx1ZTogXCJBcHBEZWZhdWx0XCIsXG4gICAgICAgIHR5cGU6IFwibmFtZVwiLFxuICAgICAgICBleHBsaWNpdFNldDogZmFsc2UsXG4gICAgICAgIHZhbHVlU2V0OiBbXCJBcHBEZWZhdWx0XCIsIFwiTm9uZVwiXSxcbiAgICAgICAgcGRmVmVyc2lvbjogMS42XG4gICAgICB9LFxuICAgICAgXCJEdXBsZXhcIjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiXCIsXG4gICAgICAgIHZhbHVlOiBcIm5vbmVcIixcbiAgICAgICAgdHlwZTogXCJuYW1lXCIsXG4gICAgICAgIGV4cGxpY2l0U2V0OiBmYWxzZSxcbiAgICAgICAgdmFsdWVTZXQ6IFtcIlNpbXBsZXhcIiwgXCJEdXBsZXhGbGlwU2hvcnRFZGdlXCIsIFwiRHVwbGV4RmxpcExvbmdFZGdlXCIsIFwibm9uZVwiXSxcbiAgICAgICAgcGRmVmVyc2lvbjogMS43XG4gICAgICB9LFxuICAgICAgXCJQaWNrVHJheUJ5UERGU2l6ZVwiOiB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIGV4cGxpY2l0U2V0OiBmYWxzZSxcbiAgICAgICAgdmFsdWVTZXQ6IFt0cnVlLCBmYWxzZV0sXG4gICAgICAgIHBkZlZlcnNpb246IDEuN1xuICAgICAgfSxcbiAgICAgIFwiUHJpbnRQYWdlUmFuZ2VcIjoge1xuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiXCIsXG4gICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGV4cGxpY2l0U2V0OiBmYWxzZSxcbiAgICAgICAgdmFsdWVTZXQ6IG51bGwsXG4gICAgICAgIHBkZlZlcnNpb246IDEuN1xuICAgICAgfSxcbiAgICAgIFwiTnVtQ29waWVzXCI6IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAxLFxuICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICAgIGV4cGxpY2l0U2V0OiBmYWxzZSxcbiAgICAgICAgdmFsdWVTZXQ6IG51bGwsXG4gICAgICAgIHBkZlZlcnNpb246IDEuN1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNvbmZpZ3VyYXRpb25LZXlzID0gT2JqZWN0LmtleXMoY29uZmlndXJhdGlvblRlbXBsYXRlKTtcbiAgICB2YXIgcmFuZ2VBcnJheSA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGsgPSAwO1xuICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB2YXIgbWV0aG9kO1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGZ1bmN0aW9uIGFycmF5Q29udGFpbnNFbGVtZW50KGFycmF5LCBlbGVtZW50KSB7XG4gICAgICB2YXIgaXRlcmF0b3I7XG4gICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAoaXRlcmF0b3IgPSAwOyBpdGVyYXRvciA8IGFycmF5Lmxlbmd0aDsgaXRlcmF0b3IgKz0gMSkge1xuICAgICAgICBpZiAoYXJyYXlbaXRlcmF0b3JdID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWwudmlld2VycHJlZmVyZW5jZXMgPSB7fTtcbiAgICAgIHRoaXMuaW50ZXJuYWwudmlld2VycHJlZmVyZW5jZXMuY29uZmlndXJhdGlvbiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uZmlndXJhdGlvblRlbXBsYXRlKSk7XG4gICAgICB0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbmZpZ3VyYXRpb24gPSB0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmNvbmZpZ3VyYXRpb247XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gXCJyZXNldFwiIHx8IGRvUmVzZXQgPT09IHRydWUpIHtcbiAgICAgIHZhciBsZW4gPSBjb25maWd1cmF0aW9uS2V5cy5sZW5ndGg7XG5cbiAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsgKz0gMSkge1xuICAgICAgICBjb25maWd1cmF0aW9uW2NvbmZpZ3VyYXRpb25LZXlzW2tdXS52YWx1ZSA9IGNvbmZpZ3VyYXRpb25bY29uZmlndXJhdGlvbktleXNba11dLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgY29uZmlndXJhdGlvbltjb25maWd1cmF0aW9uS2V5c1trXV0uZXhwbGljaXRTZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihvcHRpb25zKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChtZXRob2QgaW4gb3B0aW9ucykge1xuICAgICAgICB2YWx1ZSA9IG9wdGlvbnNbbWV0aG9kXTtcblxuICAgICAgICBpZiAoYXJyYXlDb250YWluc0VsZW1lbnQoY29uZmlndXJhdGlvbktleXMsIG1ldGhvZCkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uW21ldGhvZF0udHlwZSA9PT0gXCJib29sZWFuXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvblttZXRob2RdLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb25maWd1cmF0aW9uW21ldGhvZF0udHlwZSA9PT0gXCJuYW1lXCIgJiYgYXJyYXlDb250YWluc0VsZW1lbnQoY29uZmlndXJhdGlvblttZXRob2RdLnZhbHVlU2V0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25bbWV0aG9kXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlndXJhdGlvblttZXRob2RdLnR5cGUgPT09IFwiaW50ZWdlclwiICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uW21ldGhvZF0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ3VyYXRpb25bbWV0aG9kXS50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAodmFsdWVbaV0ubGVuZ3RoID09PSAxICYmIHR5cGVvZiB2YWx1ZVtpXVswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJhbmdlQXJyYXkucHVzaChTdHJpbmcodmFsdWVbaV0gLSAxKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVbaV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2YWx1ZVtpXS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtpXVtqXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIHJhbmdlQXJyYXkucHVzaChbdmFsdWVbaV1bMF0gLSAxLCB2YWx1ZVtpXVsxXSAtIDFdLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlndXJhdGlvblttZXRob2RdLnZhbHVlID0gXCJbXCIgKyByYW5nZUFycmF5LmpvaW4oXCIgXCIpICsgXCJdXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25bbWV0aG9kXS52YWx1ZSA9IGNvbmZpZ3VyYXRpb25bbWV0aG9kXS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uZmlndXJhdGlvblttZXRob2RdLmV4cGxpY2l0U2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmlzU3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZShcInB1dENhdGFsb2dcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGRmRGljdCA9IFtdO1xuICAgICAgICB2YXIgdlByZWY7XG5cbiAgICAgICAgZm9yICh2UHJlZiBpbiBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bdlByZWZdLmV4cGxpY2l0U2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvblt2UHJlZl0udHlwZSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgICAgcGRmRGljdC5wdXNoKFwiL1wiICsgdlByZWYgKyBcIiAvXCIgKyBjb25maWd1cmF0aW9uW3ZQcmVmXS52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZGZEaWN0LnB1c2goXCIvXCIgKyB2UHJlZiArIFwiIFwiICsgY29uZmlndXJhdGlvblt2UHJlZl0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZGZEaWN0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuaW50ZXJuYWwud3JpdGUoXCIvVmlld2VyUHJlZmVyZW5jZXNcXG48PFxcblwiICsgcGRmRGljdC5qb2luKFwiXFxuXCIpICsgXCJcXG4+PlwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcm5hbC52aWV3ZXJwcmVmZXJlbmNlcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKGpzUERGLkFQSSk7XG5cbi8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBcbiAqIGpzUERGIFhNUCBtZXRhZGF0YSBwbHVnaW5cbiAqIENvcHlyaWdodCAoYykgMjAxNiBKdXNzaSBVdHVuZW4sIHUtanVzc2lAc3VvbWkyNC5maVxuICogXG4gKiBcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLypnbG9iYWwganNQREYgKi9cblxuLyoqXG4qIEBuYW1lIHhtcF9tZXRhZGF0YVxuKiBAbW9kdWxlXG4qL1xuKGZ1bmN0aW9uIChqc1BERkFQSSkge1xuXG4gIHZhciB4bXBtZXRhZGF0YSA9IFwiXCI7XG4gIHZhciB4bXBuYW1lc3BhY2V1cmkgPSBcIlwiO1xuICB2YXIgbWV0YWRhdGFfb2JqZWN0X251bWJlciA9IFwiXCI7XG4gIC8qKlxuICAqIEFkZHMgWE1QIGZvcm1hdHRlZCBtZXRhZGF0YSB0byBQREZcbiAgKlxuICAqIEBuYW1lIGFkZE1ldGFkYXRhXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtTdHJpbmd9IG1ldGFkYXRhIFRoZSBhY3R1YWwgbWV0YWRhdGEgdG8gYmUgYWRkZWQuIFRoZSBtZXRhZGF0YSBzaGFsbCBiZSBzdG9yZWQgYXMgWE1QIHNpbXBsZSB2YWx1ZS4gTm90ZSB0aGF0IGlmIHRoZSBtZXRhZGF0YSBzdHJpbmcgY29udGFpbnMgWE1MIG1hcmt1cCBjaGFyYWN0ZXJzIFwiPFwiLCBcIj5cIiBvciBcIiZcIiwgdGhvc2UgY2hhcmFjdGVycyBzaG91bGQgYmUgd3JpdHRlbiB1c2luZyBYTUwgZW50aXRpZXMuXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXVyaSBTZXRzIHRoZSBuYW1lc3BhY2UgVVJJIGZvciB0aGUgbWV0YWRhdGEuIExhc3QgY2hhcmFjdGVyIHNob3VsZCBiZSBzbGFzaCBvciBoYXNoLlxuICAqIEByZXR1cm5zIHtqc1BERn0ganNQREYtaW5zdGFuY2VcbiAgKi9cblxuICBqc1BERkFQSS5hZGRNZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgbmFtZXNwYWNldXJpKSB7XG4gICAgeG1wbmFtZXNwYWNldXJpID0gbmFtZXNwYWNldXJpIHx8IFwiaHR0cDovL2pzcGRmLmRlZmF1bHQubmFtZXNwYWNldXJpL1wiOyAvL1RoZSBuYW1lc3BhY2UgVVJJIGZvciBhbiBYTVAgbmFtZSBzaGFsbCBub3QgYmUgZW1wdHlcblxuICAgIHhtcG1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgdGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCdwb3N0UHV0UmVzb3VyY2VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF4bXBtZXRhZGF0YSkge1xuICAgICAgICBtZXRhZGF0YV9vYmplY3RfbnVtYmVyID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4bXBtZXRhX2JlZ2lubmluZyA9ICc8eDp4bXBtZXRhIHhtbG5zOng9XCJhZG9iZTpuczptZXRhL1wiPic7XG4gICAgICAgIHZhciByZGZfYmVnaW5uaW5nID0gJzxyZGY6UkRGIHhtbG5zOnJkZj1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD1cIlwiIHhtbG5zOmpzcGRmPVwiJyArIHhtcG5hbWVzcGFjZXVyaSArICdcIj48anNwZGY6bWV0YWRhdGE+JztcbiAgICAgICAgdmFyIHJkZl9lbmRpbmcgPSAnPC9qc3BkZjptZXRhZGF0YT48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+JztcbiAgICAgICAgdmFyIHhtcG1ldGFfZW5kaW5nID0gJzwveDp4bXBtZXRhPic7XG4gICAgICAgIHZhciB1dGY4X3htcG1ldGFfYmVnaW5uaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHhtcG1ldGFfYmVnaW5uaW5nKSk7XG4gICAgICAgIHZhciB1dGY4X3JkZl9iZWdpbm5pbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQocmRmX2JlZ2lubmluZykpO1xuICAgICAgICB2YXIgdXRmOF9tZXRhZGF0YSA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh4bXBtZXRhZGF0YSkpO1xuICAgICAgICB2YXIgdXRmOF9yZGZfZW5kaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHJkZl9lbmRpbmcpKTtcbiAgICAgICAgdmFyIHV0ZjhfeG1wbWV0YV9lbmRpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoeG1wbWV0YV9lbmRpbmcpKTtcbiAgICAgICAgdmFyIHRvdGFsX2xlbiA9IHV0ZjhfcmRmX2JlZ2lubmluZy5sZW5ndGggKyB1dGY4X21ldGFkYXRhLmxlbmd0aCArIHV0ZjhfcmRmX2VuZGluZy5sZW5ndGggKyB1dGY4X3htcG1ldGFfYmVnaW5uaW5nLmxlbmd0aCArIHV0ZjhfeG1wbWV0YV9lbmRpbmcubGVuZ3RoO1xuICAgICAgICBtZXRhZGF0YV9vYmplY3RfbnVtYmVyID0gdGhpcy5pbnRlcm5hbC5uZXdPYmplY3QoKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbC53cml0ZSgnPDwgL1R5cGUgL01ldGFkYXRhIC9TdWJ0eXBlIC9YTUwgL0xlbmd0aCAnICsgdG90YWxfbGVuICsgJyA+PicpO1xuICAgICAgICB0aGlzLmludGVybmFsLndyaXRlKCdzdHJlYW0nKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbC53cml0ZSh1dGY4X3htcG1ldGFfYmVnaW5uaW5nICsgdXRmOF9yZGZfYmVnaW5uaW5nICsgdXRmOF9tZXRhZGF0YSArIHV0ZjhfcmRmX2VuZGluZyArIHV0ZjhfeG1wbWV0YV9lbmRpbmcpO1xuICAgICAgICB0aGlzLmludGVybmFsLndyaXRlKCdlbmRzdHJlYW0nKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbC53cml0ZSgnZW5kb2JqJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCdwdXRDYXRhbG9nJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1ldGFkYXRhX29iamVjdF9udW1iZXIpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbC53cml0ZSgnL01ldGFkYXRhICcgKyBtZXRhZGF0YV9vYmplY3RfbnVtYmVyICsgJyAwIFInKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKGpzUERGLkFQSSk7XG5cbi8qKlxuKiBAbmFtZSB1dGY4XG4qIEBtb2R1bGVcbiovXG4oZnVuY3Rpb24gKGpzUERGLCBnbG9iYWwpIHtcblxuICB2YXIganNQREZBUEkgPSBqc1BERi5BUEk7XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiBmdW5jdGlvbiA6IHRvSGV4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLyogY29tbWVudCA6IFJlcGxhY2Ugc3RyIHdpdGggYSBoZXggc3RyaW5nLiAgICAgICAqL1xuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICBmdW5jdGlvbiB0b0hleChzdHIpIHtcbiAgICB2YXIgaGV4ID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgaGV4ICs9ICcnICsgc3RyLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpO1xuICAgIH1cblxuICAgIHJldHVybiBoZXg7XG4gIH1cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiBmdW5jdGlvbiA6IHBkZkVzY2FwZTE2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gIC8qIGNvbW1lbnQgOiBUaGUgY2hhcmFjdGVyIGlkIG9mIGEgMi1ieXRlIHN0cmluZyBpcyBjb252ZXJ0ZWQgdG8gYSBoZXhhZGVjaW1hbCBudW1iZXIgYnkgb2J0YWluaW5nICovXG5cbiAgLyogICB0aGUgY29ycmVzcG9uZGluZyBnbHlwaCBpZCBhbmQgd2lkdGgsIGFuZCB0aGVuIGFkZGluZyBwYWRkaW5nIHRvIHRoZSBzdHJpbmcuICAgICAgICAgICAgICAgICAgKi9cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIHBkZkVzY2FwZTE2ID0ganNQREZBUEkucGRmRXNjYXBlMTYgPSBmdW5jdGlvbiAodGV4dCwgZm9udCkge1xuICAgIHZhciB3aWR0aHMgPSBmb250Lm1ldGFkYXRhLlVuaWNvZGUud2lkdGhzO1xuICAgIHZhciBwYWR6ID0gW1wiXCIsIFwiMFwiLCBcIjAwXCIsIFwiMDAwXCIsIFwiMDAwMFwiXTtcbiAgICB2YXIgYXIgPSBbXCJcIl07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHQubGVuZ3RoLCB0OyBpIDwgbDsgKytpKSB7XG4gICAgICB0ID0gZm9udC5tZXRhZGF0YS5jaGFyYWN0ZXJUb0dseXBoKHRleHQuY2hhckNvZGVBdChpKSk7XG4gICAgICBmb250Lm1ldGFkYXRhLmdseUlkc1VzZWQucHVzaCh0KTtcbiAgICAgIGZvbnQubWV0YWRhdGEudG9Vbmljb2RlW3RdID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAod2lkdGhzLmluZGV4T2YodCkgPT0gLTEpIHtcbiAgICAgICAgd2lkdGhzLnB1c2godCk7XG4gICAgICAgIHdpZHRocy5wdXNoKFtwYXJzZUludChmb250Lm1ldGFkYXRhLndpZHRoT2ZHbHlwaCh0KSwgMTApXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ID09ICcwJykge1xuICAgICAgICAvL1NwYWNlcyBhcmUgbm90IGFsbG93ZWQgaW4gY21hcC5cbiAgICAgICAgcmV0dXJuIGFyLmpvaW4oXCJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdC50b1N0cmluZygxNik7XG4gICAgICAgIGFyLnB1c2gocGFkels0IC0gdC5sZW5ndGhdLCB0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXIuam9pbihcIlwiKTtcbiAgfTtcblxuICB2YXIgdG9Vbmljb2RlQ21hcCA9IGZ1bmN0aW9uIHRvVW5pY29kZUNtYXAobWFwKSB7XG4gICAgdmFyIGNvZGUsIGNvZGVzLCByYW5nZSwgdW5pY29kZSwgdW5pY29kZU1hcCwgX2ksIF9sZW47XG5cbiAgICB1bmljb2RlTWFwID0gJy9DSURJbml0IC9Qcm9jU2V0IGZpbmRyZXNvdXJjZSBiZWdpblxcbjEyIGRpY3QgYmVnaW5cXG5iZWdpbmNtYXBcXG4vQ0lEU3lzdGVtSW5mbyA8PFxcbiAgL1JlZ2lzdHJ5IChBZG9iZSlcXG4gIC9PcmRlcmluZyAoVUNTKVxcbiAgL1N1cHBsZW1lbnQgMFxcbj4+IGRlZlxcbi9DTWFwTmFtZSAvQWRvYmUtSWRlbnRpdHktVUNTIGRlZlxcbi9DTWFwVHlwZSAyIGRlZlxcbjEgYmVnaW5jb2Rlc3BhY2VyYW5nZVxcbjwwMDAwPjxmZmZmPlxcbmVuZGNvZGVzcGFjZXJhbmdlJztcbiAgICBjb2RlcyA9IE9iamVjdC5rZXlzKG1hcCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuICAgIHJhbmdlID0gW107XG5cbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGNvZGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBjb2RlID0gY29kZXNbX2ldO1xuXG4gICAgICBpZiAocmFuZ2UubGVuZ3RoID49IDEwMCkge1xuICAgICAgICB1bmljb2RlTWFwICs9IFwiXFxuXCIgKyByYW5nZS5sZW5ndGggKyBcIiBiZWdpbmJmY2hhclxcblwiICsgcmFuZ2Uuam9pbignXFxuJykgKyBcIlxcbmVuZGJmY2hhclwiO1xuICAgICAgICByYW5nZSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB1bmljb2RlID0gKCcwMDAwJyArIG1hcFtjb2RlXS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgIGNvZGUgPSAoJzAwMDAnICsgKCtjb2RlKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgIHJhbmdlLnB1c2goXCI8XCIgKyBjb2RlICsgXCI+PFwiICsgdW5pY29kZSArIFwiPlwiKTtcbiAgICB9XG5cbiAgICBpZiAocmFuZ2UubGVuZ3RoKSB7XG4gICAgICB1bmljb2RlTWFwICs9IFwiXFxuXCIgKyByYW5nZS5sZW5ndGggKyBcIiBiZWdpbmJmY2hhclxcblwiICsgcmFuZ2Uuam9pbignXFxuJykgKyBcIlxcbmVuZGJmY2hhclxcblwiO1xuICAgIH1cblxuICAgIHVuaWNvZGVNYXAgKz0gJ2VuZGNtYXBcXG5DTWFwTmFtZSBjdXJyZW50ZGljdCAvQ01hcCBkZWZpbmVyZXNvdXJjZSBwb3BcXG5lbmRcXG5lbmQnO1xuICAgIHJldHVybiB1bmljb2RlTWFwO1xuICB9O1xuXG4gIHZhciBpZGVudGl0eUhGdW5jdGlvbiA9IGZ1bmN0aW9uIGlkZW50aXR5SEZ1bmN0aW9uKGZvbnQsIG91dCwgbmV3T2JqZWN0LCBwdXRTdHJlYW0pIHtcbiAgICBpZiAoZm9udC5tZXRhZGF0YSBpbnN0YW5jZW9mIGpzUERGLkFQSS5UVEZGb250ICYmIGZvbnQuZW5jb2RpbmcgPT09ICdJZGVudGl0eS1IJykge1xuICAgICAgLy9UYWcgd2l0aCBJZGVudGl0eS1IXG4gICAgICB2YXIgd2lkdGhzID0gZm9udC5tZXRhZGF0YS5Vbmljb2RlLndpZHRocztcbiAgICAgIHZhciBkYXRhID0gZm9udC5tZXRhZGF0YS5zdWJzZXQuZW5jb2RlKGZvbnQubWV0YWRhdGEuZ2x5SWRzVXNlZCwgMSk7XG4gICAgICB2YXIgcGRmT3V0cHV0ID0gZGF0YTtcbiAgICAgIHZhciBwZGZPdXRwdXQyID0gXCJcIjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZGZPdXRwdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGRmT3V0cHV0MiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBkZk91dHB1dFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmb250VGFibGUgPSBuZXdPYmplY3QoKTtcbiAgICAgIHB1dFN0cmVhbSh7XG4gICAgICAgIGRhdGE6IHBkZk91dHB1dDIsXG4gICAgICAgIGFkZExlbmd0aDE6IHRydWVcbiAgICAgIH0pO1xuICAgICAgb3V0KCdlbmRvYmonKTtcbiAgICAgIHZhciBjbWFwID0gbmV3T2JqZWN0KCk7XG4gICAgICB2YXIgY21hcERhdGEgPSB0b1VuaWNvZGVDbWFwKGZvbnQubWV0YWRhdGEudG9Vbmljb2RlKTtcbiAgICAgIHB1dFN0cmVhbSh7XG4gICAgICAgIGRhdGE6IGNtYXBEYXRhLFxuICAgICAgICBhZGRMZW5ndGgxOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG91dCgnZW5kb2JqJyk7XG4gICAgICB2YXIgZm9udERlc2NyaXB0b3IgPSBuZXdPYmplY3QoKTtcbiAgICAgIG91dCgnPDwnKTtcbiAgICAgIG91dCgnL1R5cGUgL0ZvbnREZXNjcmlwdG9yJyk7XG4gICAgICBvdXQoJy9Gb250TmFtZSAvJyArIGZvbnQuZm9udE5hbWUpO1xuICAgICAgb3V0KCcvRm9udEZpbGUyICcgKyBmb250VGFibGUgKyAnIDAgUicpO1xuICAgICAgb3V0KCcvRm9udEJCb3ggJyArIGpzUERGLkFQSS5QREZPYmplY3QuY29udmVydChmb250Lm1ldGFkYXRhLmJib3gpKTtcbiAgICAgIG91dCgnL0ZsYWdzICcgKyBmb250Lm1ldGFkYXRhLmZsYWdzKTtcbiAgICAgIG91dCgnL1N0ZW1WICcgKyBmb250Lm1ldGFkYXRhLnN0ZW1WKTtcbiAgICAgIG91dCgnL0l0YWxpY0FuZ2xlICcgKyBmb250Lm1ldGFkYXRhLml0YWxpY0FuZ2xlKTtcbiAgICAgIG91dCgnL0FzY2VudCAnICsgZm9udC5tZXRhZGF0YS5hc2NlbmRlcik7XG4gICAgICBvdXQoJy9EZXNjZW50ICcgKyBmb250Lm1ldGFkYXRhLmRlY2VuZGVyKTtcbiAgICAgIG91dCgnL0NhcEhlaWdodCAnICsgZm9udC5tZXRhZGF0YS5jYXBIZWlnaHQpO1xuICAgICAgb3V0KCc+PicpO1xuICAgICAgb3V0KCdlbmRvYmonKTtcbiAgICAgIHZhciBEZXNjZW5kYW50Rm9udCA9IG5ld09iamVjdCgpO1xuICAgICAgb3V0KCc8PCcpO1xuICAgICAgb3V0KCcvVHlwZSAvRm9udCcpO1xuICAgICAgb3V0KCcvQmFzZUZvbnQgLycgKyBmb250LmZvbnROYW1lKTtcbiAgICAgIG91dCgnL0ZvbnREZXNjcmlwdG9yICcgKyBmb250RGVzY3JpcHRvciArICcgMCBSJyk7XG4gICAgICBvdXQoJy9XICcgKyBqc1BERi5BUEkuUERGT2JqZWN0LmNvbnZlcnQod2lkdGhzKSk7XG4gICAgICBvdXQoJy9DSURUb0dJRE1hcCAvSWRlbnRpdHknKTtcbiAgICAgIG91dCgnL0RXIDEwMDAnKTtcbiAgICAgIG91dCgnL1N1YnR5cGUgL0NJREZvbnRUeXBlMicpO1xuICAgICAgb3V0KCcvQ0lEU3lzdGVtSW5mbycpO1xuICAgICAgb3V0KCc8PCcpO1xuICAgICAgb3V0KCcvU3VwcGxlbWVudCAwJyk7XG4gICAgICBvdXQoJy9SZWdpc3RyeSAoQWRvYmUpJyk7XG4gICAgICBvdXQoJy9PcmRlcmluZyAoJyArIGZvbnQuZW5jb2RpbmcgKyAnKScpO1xuICAgICAgb3V0KCc+PicpO1xuICAgICAgb3V0KCc+PicpO1xuICAgICAgb3V0KCdlbmRvYmonKTtcbiAgICAgIGZvbnQub2JqZWN0TnVtYmVyID0gbmV3T2JqZWN0KCk7XG4gICAgICBvdXQoJzw8Jyk7XG4gICAgICBvdXQoJy9UeXBlIC9Gb250Jyk7XG4gICAgICBvdXQoJy9TdWJ0eXBlIC9UeXBlMCcpO1xuICAgICAgb3V0KCcvVG9Vbmljb2RlICcgKyBjbWFwICsgJyAwIFInKTtcbiAgICAgIG91dCgnL0Jhc2VGb250IC8nICsgZm9udC5mb250TmFtZSk7XG4gICAgICBvdXQoJy9FbmNvZGluZyAvJyArIGZvbnQuZW5jb2RpbmcpO1xuICAgICAgb3V0KCcvRGVzY2VuZGFudEZvbnRzIFsnICsgRGVzY2VuZGFudEZvbnQgKyAnIDAgUl0nKTtcbiAgICAgIG91dCgnPj4nKTtcbiAgICAgIG91dCgnZW5kb2JqJyk7XG4gICAgICBmb250LmlzQWxyZWFkeVB1dHRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIGpzUERGQVBJLmV2ZW50cy5wdXNoKFsncHV0Rm9udCcsIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWRlbnRpdHlIRnVuY3Rpb24oYXJncy5mb250LCBhcmdzLm91dCwgYXJncy5uZXdPYmplY3QsIGFyZ3MucHV0U3RyZWFtKTtcbiAgfV0pO1xuXG4gIHZhciB3aW5BbnNpRW5jb2RpbmdGdW5jdGlvbiA9IGZ1bmN0aW9uIHdpbkFuc2lFbmNvZGluZ0Z1bmN0aW9uKGZvbnQsIG91dCwgbmV3T2JqZWN0LCBwdXRTdHJlYW0pIHtcbiAgICBpZiAoZm9udC5tZXRhZGF0YSBpbnN0YW5jZW9mIGpzUERGLkFQSS5UVEZGb250ICYmIGZvbnQuZW5jb2RpbmcgPT09ICdXaW5BbnNpRW5jb2RpbmcnKSB7XG4gICAgICAvL1RhZyB3aXRoIFdpbkFuc2kgZW5jb2RpbmdcbiAgICAgIHZhciB3aWR0aHMgPSBmb250Lm1ldGFkYXRhLlVuaWNvZGUud2lkdGhzO1xuICAgICAgdmFyIGRhdGEgPSBmb250Lm1ldGFkYXRhLnJhd0RhdGE7XG4gICAgICB2YXIgcGRmT3V0cHV0ID0gZGF0YTtcbiAgICAgIHZhciBwZGZPdXRwdXQyID0gXCJcIjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZGZPdXRwdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGRmT3V0cHV0MiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBkZk91dHB1dFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmb250VGFibGUgPSBuZXdPYmplY3QoKTtcbiAgICAgIHB1dFN0cmVhbSh7XG4gICAgICAgIGRhdGE6IHBkZk91dHB1dDIsXG4gICAgICAgIGFkZExlbmd0aDE6IHRydWVcbiAgICAgIH0pO1xuICAgICAgb3V0KCdlbmRvYmonKTtcbiAgICAgIHZhciBjbWFwID0gbmV3T2JqZWN0KCk7XG4gICAgICB2YXIgY21hcERhdGEgPSB0b1VuaWNvZGVDbWFwKGZvbnQubWV0YWRhdGEudG9Vbmljb2RlKTtcbiAgICAgIHB1dFN0cmVhbSh7XG4gICAgICAgIGRhdGE6IGNtYXBEYXRhLFxuICAgICAgICBhZGRMZW5ndGgxOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG91dCgnZW5kb2JqJyk7XG4gICAgICB2YXIgZm9udERlc2NyaXB0b3IgPSBuZXdPYmplY3QoKTtcbiAgICAgIG91dCgnPDwnKTtcbiAgICAgIG91dCgnL0Rlc2NlbnQgJyArIGZvbnQubWV0YWRhdGEuZGVjZW5kZXIpO1xuICAgICAgb3V0KCcvQ2FwSGVpZ2h0ICcgKyBmb250Lm1ldGFkYXRhLmNhcEhlaWdodCk7XG4gICAgICBvdXQoJy9TdGVtViAnICsgZm9udC5tZXRhZGF0YS5zdGVtVik7XG4gICAgICBvdXQoJy9UeXBlIC9Gb250RGVzY3JpcHRvcicpO1xuICAgICAgb3V0KCcvRm9udEZpbGUyICcgKyBmb250VGFibGUgKyAnIDAgUicpO1xuICAgICAgb3V0KCcvRmxhZ3MgOTYnKTtcbiAgICAgIG91dCgnL0ZvbnRCQm94ICcgKyBqc1BERi5BUEkuUERGT2JqZWN0LmNvbnZlcnQoZm9udC5tZXRhZGF0YS5iYm94KSk7XG4gICAgICBvdXQoJy9Gb250TmFtZSAvJyArIGZvbnQuZm9udE5hbWUpO1xuICAgICAgb3V0KCcvSXRhbGljQW5nbGUgJyArIGZvbnQubWV0YWRhdGEuaXRhbGljQW5nbGUpO1xuICAgICAgb3V0KCcvQXNjZW50ICcgKyBmb250Lm1ldGFkYXRhLmFzY2VuZGVyKTtcbiAgICAgIG91dCgnPj4nKTtcbiAgICAgIG91dCgnZW5kb2JqJyk7XG4gICAgICBmb250Lm9iamVjdE51bWJlciA9IG5ld09iamVjdCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnQubWV0YWRhdGEuaG10eC53aWR0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9udC5tZXRhZGF0YS5obXR4LndpZHRoc1tpXSA9IHBhcnNlSW50KGZvbnQubWV0YWRhdGEuaG10eC53aWR0aHNbaV0gKiAoMTAwMCAvIGZvbnQubWV0YWRhdGEuaGVhZC51bml0c1BlckVtKSk7IC8vQ2hhbmdlIHRoZSB3aWR0aCBvZiBFbSB1bml0cyB0byBQb2ludCB1bml0cy5cbiAgICAgIH1cblxuICAgICAgb3V0KCc8PC9TdWJ0eXBlL1RydWVUeXBlL1R5cGUvRm9udC9Ub1VuaWNvZGUgJyArIGNtYXAgKyAnIDAgUi9CYXNlRm9udC8nICsgZm9udC5mb250TmFtZSArICcvRm9udERlc2NyaXB0b3IgJyArIGZvbnREZXNjcmlwdG9yICsgJyAwIFInICsgJy9FbmNvZGluZy8nICsgZm9udC5lbmNvZGluZyArICcgL0ZpcnN0Q2hhciAyOSAvTGFzdENoYXIgMjU1IC9XaWR0aHMgJyArIGpzUERGLkFQSS5QREZPYmplY3QuY29udmVydChmb250Lm1ldGFkYXRhLmhtdHgud2lkdGhzKSArICc+PicpO1xuICAgICAgb3V0KCdlbmRvYmonKTtcbiAgICAgIGZvbnQuaXNBbHJlYWR5UHV0dGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAganNQREZBUEkuZXZlbnRzLnB1c2goWydwdXRGb250JywgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB3aW5BbnNpRW5jb2RpbmdGdW5jdGlvbihhcmdzLmZvbnQsIGFyZ3Mub3V0LCBhcmdzLm5ld09iamVjdCwgYXJncy5wdXRTdHJlYW0pO1xuICB9XSk7XG5cbiAgdmFyIHV0ZjhUZXh0RnVuY3Rpb24gPSBmdW5jdGlvbiB1dGY4VGV4dEZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB2YXIgdGV4dCA9IGFyZ3MudGV4dCB8fCAnJztcbiAgICB2YXIgeCA9IGFyZ3MueDtcbiAgICB2YXIgeSA9IGFyZ3MueTtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgbXV0ZXggPSBhcmdzLm11dGV4IHx8IHt9O1xuICAgIHZhciBwZGZFc2NhcGUgPSBtdXRleC5wZGZFc2NhcGU7XG4gICAgdmFyIGFjdGl2ZUZvbnRLZXkgPSBtdXRleC5hY3RpdmVGb250S2V5O1xuICAgIHZhciBmb250cyA9IG11dGV4LmZvbnRzO1xuICAgIHZhciBrZXksXG4gICAgICAgIGZvbnRTaXplID0gbXV0ZXguYWN0aXZlRm9udFNpemU7XG4gICAgdmFyIHN0ciA9ICcnLFxuICAgICAgICBzID0gMCxcbiAgICAgICAgY21hcENvbmZpcm07XG4gICAgdmFyIHN0clRleHQgPSAnJztcbiAgICB2YXIga2V5ID0gYWN0aXZlRm9udEtleTtcbiAgICB2YXIgZW5jb2RpbmcgPSBmb250c1trZXldLmVuY29kaW5nO1xuXG4gICAgaWYgKGZvbnRzW2tleV0uZW5jb2RpbmcgIT09ICdJZGVudGl0eS1IJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgbXV0ZXg6IG11dGV4XG4gICAgICB9O1xuICAgIH1cbiAgICBzdHJUZXh0ID0gdGV4dDtcbiAgICBrZXkgPSBhY3RpdmVGb250S2V5O1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0ZXh0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgc3RyVGV4dCA9IHRleHRbMF07XG4gICAgfVxuXG4gICAgZm9yIChzID0gMDsgcyA8IHN0clRleHQubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgIGlmIChmb250c1trZXldLm1ldGFkYXRhLmhhc093blByb3BlcnR5KCdjbWFwJykpIHtcbiAgICAgICAgY21hcENvbmZpcm0gPSBmb250c1trZXldLm1ldGFkYXRhLmNtYXAudW5pY29kZS5jb2RlTWFwW3N0clRleHRbc10uY2hhckNvZGVBdCgwKV07XG4gICAgICAgIC8qXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGV4dCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAvLyBmb3IgKGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRleHRbc10pID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICBjbWFwQ29uZmlybSA9IGZvbnRzW2tleV0ubWV0YWRhdGEuY21hcC51bmljb2RlLmNvZGVNYXBbc3RyVGV4dFtzXVswXS5jaGFyQ29kZUF0KDApXTsgLy9NYWtlIHN1cmUgdGhlIGNtYXAgaGFzIHRoZSBjb3JyZXNwb25kaW5nIGdseXBoIGlkXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIC8vfVxuICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNtYXBDb25maXJtID0gZm9udHNba2V5XS5tZXRhZGF0YS5jbWFwLnVuaWNvZGUuY29kZU1hcFtzdHJUZXh0W3NdLmNoYXJDb2RlQXQoMCldOyAvL01ha2Ugc3VyZSB0aGUgY21hcCBoYXMgdGhlIGNvcnJlc3BvbmRpbmcgZ2x5cGggaWRcbiAgICAgICAgfSovXG4gICAgICB9XG5cbiAgICAgIGlmICghY21hcENvbmZpcm0pIHtcbiAgICAgICAgaWYgKHN0clRleHRbc10uY2hhckNvZGVBdCgwKSA8IDI1NiAmJiBmb250c1trZXldLm1ldGFkYXRhLmhhc093blByb3BlcnR5KCdVbmljb2RlJykpIHtcbiAgICAgICAgICBzdHIgKz0gc3RyVGV4dFtzXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBzdHJUZXh0W3NdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgIGlmIChwYXJzZUludChrZXkuc2xpY2UoMSkpIDwgMTQgfHwgZW5jb2RpbmcgPT09ICdXaW5BbnNpRW5jb2RpbmcnKSB7XG4gICAgICAvL0ZvciB0aGUgZGVmYXVsdCAxMyBmb250XG4gICAgICByZXN1bHQgPSB0b0hleChwZGZFc2NhcGUoc3RyLCBrZXkpKTtcbiAgICB9IGVsc2UgaWYgKGVuY29kaW5nID09PSAnSWRlbnRpdHktSCcpIHtcbiAgICAgIHJlc3VsdCA9IHBkZkVzY2FwZTE2KHN0ciwgZm9udHNba2V5XSk7XG4gICAgfVxuXG4gICAgbXV0ZXguaXNIZXggPSB0cnVlO1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBtdXRleDogbXV0ZXhcbiAgICB9O1xuICB9O1xuXG4gIHZhciB1dGY4RXNjYXBlRnVuY3Rpb24gPSBmdW5jdGlvbiB1dGY4RXNjYXBlRnVuY3Rpb24ocGFybXMpIHtcbiAgICB2YXIgdGV4dCA9IHBhcm1zLnRleHQgfHwgJycsXG4gICAgICAgIHggPSBwYXJtcy54LFxuICAgICAgICB5ID0gcGFybXMueSxcbiAgICAgICAgb3B0aW9ucyA9IHBhcm1zLm9wdGlvbnMsXG4gICAgICAgIG11dGV4ID0gcGFybXMubXV0ZXg7XG4gICAgdmFyIGxhbmcgPSBvcHRpb25zLmxhbmc7XG4gICAgdmFyIHRtcFRleHQgPSBbXTtcbiAgICB2YXIgYXJncyA9IHtcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBtdXRleDogbXV0ZXhcbiAgICB9O1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0ZXh0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRleHRbaV0pID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgaWYgKHRleHRbaV0ubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0bXBUZXh0LnB1c2goW3V0ZjhUZXh0RnVuY3Rpb24oT2JqZWN0LmFzc2lnbih7fSwgYXJncywge1xuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0W2ldWzBdXG4gICAgICAgICAgICB9KSkudGV4dCwgdGV4dFtpXVsxXSwgdGV4dFtpXVsyXV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXBUZXh0LnB1c2godXRmOFRleHRGdW5jdGlvbihPYmplY3QuYXNzaWduKHt9LCBhcmdzLCB7XG4gICAgICAgICAgICAgIHRleHQ6IHRleHRbaV1cbiAgICAgICAgICAgIH0pKS50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wVGV4dC5wdXNoKHV0ZjhUZXh0RnVuY3Rpb24oT2JqZWN0LmFzc2lnbih7fSwgYXJncywge1xuICAgICAgICAgICAgdGV4dDogdGV4dFtpXVxuICAgICAgICAgIH0pKS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXJtcy50ZXh0ID0gdG1wVGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFybXMudGV4dCA9IHV0ZjhUZXh0RnVuY3Rpb24oT2JqZWN0LmFzc2lnbih7fSwgYXJncywge1xuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9KSkudGV4dDtcbiAgICB9XG4gIH07XG5cbiAganNQREZBUEkuZXZlbnRzLnB1c2goWydwb3N0UHJvY2Vzc1RleHQnLCB1dGY4RXNjYXBlRnVuY3Rpb25dKTtcbn0pKGpzUERGLCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmIHx8IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93IHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSk7XG5cbi8qKlxuICoganNQREYgdmlydHVhbCBGaWxlU3lzdGVtIGZ1bmN0aW9uYWxpdHlcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqL1xuXG4vKipcbiogVXNlIHRoZSB2RlMgdG8gaGFuZGxlIGZpbGVzXG4qIFxuKiBAbmFtZSB2RlNcbiogQG1vZHVsZVxuKi9cbihmdW5jdGlvbiAoanNQREZBUEkpIHtcblxuICB2YXIgX2luaXRpYWxpemVWRlMgPSBmdW5jdGlvbiBfaW5pdGlhbGl6ZVZGUyhpbnN0YW5jZSkge1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnZGUyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaW5zdGFuY2UudkZTID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIC8qKiBcbiAgKiBDaGVjayBpZiB0aGUgZmlsZSBleGlzdHMgaW4gdGhlIHZGU1xuICAqIFxuICAqIEBuYW1lIGV4aXN0c0ZpbGVJblZGU1xuICAqIEBmdW5jdGlvbiBcbiAgKiBAcGFyYW0ge3N0cmluZ30gUG9zc2libGUgZmlsZW5hbWUgaW4gdGhlIHZGUy5cbiAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgKiBAZXhhbXBsZVxuICAqIGRvYy5leGlzdHNGaWxlSW5WRlMoXCJzb21lRmlsZS50eHRcIik7XG4gICovXG5cblxuICBqc1BERkFQSS5leGlzdHNGaWxlSW5WRlMgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICBpZiAoX2luaXRpYWxpemVWRlModGhpcy5pbnRlcm5hbCkpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5pbnRlcm5hbC52RlNbZmlsZW5hbWVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqXG4gICogQWRkIGEgZmlsZSB0byB0aGUgdkZTXG4gICpcbiAgKiBAbmFtZSBhZGRGaWxlVG9WRlNcbiAgKiBAZnVuY3Rpb24gXG4gICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHdoaWNoIHNob3VsZCBiZSBhZGRlZC5cbiAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZWNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIGZpbGUuXG4gICogQHJldHVybnMge2pzUERGfVxuICAqIEBleGFtcGxlXG4gICogZG9jLmFkZEZpbGVUb1ZGUyhcInNvbWVGaWxlLnR4dFwiLCBcIkJBREZBQ0UxXCIpO1xuICAqL1xuXG5cbiAganNQREZBUEkuYWRkRmlsZVRvVkZTID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBmaWxlY29udGVudCkge1xuICAgIF9pbml0aWFsaXplVkZTKHRoaXMuaW50ZXJuYWwpO1xuXG4gICAgdGhpcy5pbnRlcm5hbC52RlNbZmlsZW5hbWVdID0gZmlsZWNvbnRlbnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKiBcbiAgKiBHZXQgdGhlIGZpbGUgZnJvbSB0aGUgdkZTXG4gICogXG4gICogQG5hbWUgZ2V0RmlsZUZyb21WRlNcbiAgKiBAZnVuY3Rpb24gXG4gICogQHBhcmFtIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBmaWxlIHdoaWNoIGdldHMgcmVxdWVzdGVkLlxuICAqIEByZXR1cm5zIHtzdHJpbmd9IFxuICAqIEBleGFtcGxlXG4gICogZG9jLmdldEZpbGVGcm9tVkZTKFwic29tZUZpbGUudHh0XCIpO1xuICAqL1xuXG5cbiAganNQREZBUEkuZ2V0RmlsZUZyb21WRlMgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICBfaW5pdGlhbGl6ZVZGUyh0aGlzLmludGVybmFsKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5pbnRlcm5hbC52RlNbZmlsZW5hbWVdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC52RlNbZmlsZW5hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xufSkoanNQREYuQVBJKTtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxMiBjaGljazMwNyA8Y2hpY2szMDdAZ21haWwuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGpzUERGLCBjYWxsYmFjaykge1xuICBqc1BERi5BUEkuYWRsZXIzMmNzID0gY2FsbGJhY2soKTtcbn0pKGpzUERGLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBfaGFzQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICdmdW5jdGlvbic7XG5cbiAgdmFyIF9CdWZmZXIgPSBudWxsLFxuICAgICAgX2lzQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX2hhc0FycmF5QnVmZmVyKSByZXR1cm4gZnVuY3Rpb24gX2lzQnVmZmVyKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBidWZmZXIuQnVmZmVyID09PSAnZnVuY3Rpb24nKSBfQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcjtcbiAgICB9IGNhdGNoIChlcnJvcikge31cblxuICAgIHJldHVybiBmdW5jdGlvbiBfaXNCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IF9CdWZmZXIgIT09IG51bGwgJiYgdmFsdWUgaW5zdGFuY2VvZiBfQnVmZmVyO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgX3V0ZjhUb0JpbmFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX0J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIF91dGY4VG9CaW5hcnkodXRmOFN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IF9CdWZmZXIodXRmOFN0cmluZywgJ3V0ZjgnKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gX3V0ZjhUb0JpbmFyeSh1dGY4U3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cmluZykpO1xuICAgICAgfTtcbiAgICB9XG4gIH0oKTtcblxuICB2YXIgTU9EID0gNjU1MjE7XG5cbiAgdmFyIF91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGNoZWNrc3VtLCBiaW5hcnlTdHJpbmcpIHtcbiAgICB2YXIgYSA9IGNoZWNrc3VtICYgMHhGRkZGLFxuICAgICAgICBiID0gY2hlY2tzdW0gPj4+IDE2O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYSA9IChhICsgKGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpICYgMHhGRikpICUgTU9EO1xuICAgICAgYiA9IChiICsgYSkgJSBNT0Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIChiIDw8IDE2IHwgYSkgPj4+IDA7XG4gIH07XG5cbiAgdmFyIF91cGRhdGVVaW50OEFycmF5ID0gZnVuY3Rpb24gX3VwZGF0ZVVpbnQ4QXJyYXkoY2hlY2tzdW0sIHVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgYSA9IGNoZWNrc3VtICYgMHhGRkZGLFxuICAgICAgICBiID0gY2hlY2tzdW0gPj4+IDE2O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHVpbnQ4QXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGEgPSAoYSArIHVpbnQ4QXJyYXlbaV0pICUgTU9EO1xuICAgICAgYiA9IChiICsgYSkgJSBNT0Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIChiIDw8IDE2IHwgYSkgPj4+IDA7XG4gIH07XG5cbiAgdmFyIGV4cG9ydHMgPSB7fTtcblxuICB2YXIgQWRsZXIzMiA9IGV4cG9ydHMuQWRsZXIzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3RvciA9IGZ1bmN0aW9uIEFkbGVyMzIoY2hlY2tzdW0pIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb25zdHJ1Y3RvciBjYW5ub3QgY2FsbGVkIGJlIGFzIGEgZnVuY3Rpb24uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNGaW5pdGUoY2hlY2tzdW0gPSBjaGVja3N1bSA9PSBudWxsID8gMSA6ICtjaGVja3N1bSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudHMgbmVlZHMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrc3VtID0gY2hlY2tzdW0gPj4+IDA7XG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IGN0b3IucHJvdG90eXBlID0ge307XG4gICAgcHJvdG8uY29uc3RydWN0b3IgPSBjdG9yO1xuXG4gICAgY3Rvci5mcm9tID0gZnVuY3Rpb24gKGZyb20pIHtcbiAgICAgIGZyb20ucHJvdG90eXBlID0gcHJvdG87XG4gICAgICByZXR1cm4gZnJvbTtcbiAgICB9KGZ1bmN0aW9uIGZyb20oYmluYXJ5U3RyaW5nKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgY3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgY2Fubm90IGNhbGxlZCBiZSBhcyBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmluYXJ5U3RyaW5nID09IG51bGwpIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBzdHJpbmcuJyk7XG4gICAgICB0aGlzLmNoZWNrc3VtID0gX3VwZGF0ZSgxLCBiaW5hcnlTdHJpbmcudG9TdHJpbmcoKSk7XG4gICAgfSk7XG5cbiAgICBjdG9yLmZyb21VdGY4ID0gZnVuY3Rpb24gKGZyb21VdGY4KSB7XG4gICAgICBmcm9tVXRmOC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHJldHVybiBmcm9tVXRmODtcbiAgICB9KGZ1bmN0aW9uIGZyb21VdGY4KHV0ZjhTdHJpbmcpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb25zdHJ1Y3RvciBjYW5ub3QgY2FsbGVkIGJlIGFzIGEgZnVuY3Rpb24uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGY4U3RyaW5nID09IG51bGwpIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBzdHJpbmcuJyk7XG5cbiAgICAgIHZhciBiaW5hcnlTdHJpbmcgPSBfdXRmOFRvQmluYXJ5KHV0ZjhTdHJpbmcudG9TdHJpbmcoKSk7XG5cbiAgICAgIHRoaXMuY2hlY2tzdW0gPSBfdXBkYXRlKDEsIGJpbmFyeVN0cmluZyk7XG4gICAgfSk7XG5cbiAgICBpZiAoX2hhc0FycmF5QnVmZmVyKSB7XG4gICAgICBjdG9yLmZyb21CdWZmZXIgPSBmdW5jdGlvbiAoZnJvbUJ1ZmZlcikge1xuICAgICAgICBmcm9tQnVmZmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICByZXR1cm4gZnJvbUJ1ZmZlcjtcbiAgICAgIH0oZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGN0b3IpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgY2Fubm90IGNhbGxlZCBiZSBhcyBhIGZ1bmN0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfaXNCdWZmZXIoYnVmZmVyKSkgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBBcnJheUJ1ZmZlci4nKTtcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tzdW0gPSBfdXBkYXRlVWludDhBcnJheSgxLCBhcnJheSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoYmluYXJ5U3RyaW5nKSB7XG4gICAgICBpZiAoYmluYXJ5U3RyaW5nID09IG51bGwpIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBzdHJpbmcuJyk7XG4gICAgICBiaW5hcnlTdHJpbmcgPSBiaW5hcnlTdHJpbmcudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrc3VtID0gX3VwZGF0ZSh0aGlzLmNoZWNrc3VtLCBiaW5hcnlTdHJpbmcpO1xuICAgIH07XG5cbiAgICBwcm90by51cGRhdGVVdGY4ID0gZnVuY3Rpb24gdXBkYXRlVXRmOCh1dGY4U3RyaW5nKSB7XG4gICAgICBpZiAodXRmOFN0cmluZyA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgc3RyaW5nLicpO1xuXG4gICAgICB2YXIgYmluYXJ5U3RyaW5nID0gX3V0ZjhUb0JpbmFyeSh1dGY4U3RyaW5nLnRvU3RyaW5nKCkpO1xuXG4gICAgICByZXR1cm4gdGhpcy5jaGVja3N1bSA9IF91cGRhdGUodGhpcy5jaGVja3N1bSwgYmluYXJ5U3RyaW5nKTtcbiAgICB9O1xuXG4gICAgaWYgKF9oYXNBcnJheUJ1ZmZlcikge1xuICAgICAgcHJvdG8udXBkYXRlQnVmZmVyID0gZnVuY3Rpb24gdXBkYXRlQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICBpZiAoIV9pc0J1ZmZlcihidWZmZXIpKSB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIEFycmF5QnVmZmVyLicpO1xuICAgICAgICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja3N1bSA9IF91cGRhdGVVaW50OEFycmF5KHRoaXMuY2hlY2tzdW0sIGFycmF5KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgQWRsZXIzMih0aGlzLmNoZWNrc3VtKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGN0b3I7XG4gIH0oKTtcblxuICBleHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKGJpbmFyeVN0cmluZykge1xuICAgIGlmIChiaW5hcnlTdHJpbmcgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIHN0cmluZy4nKTtcbiAgICByZXR1cm4gX3VwZGF0ZSgxLCBiaW5hcnlTdHJpbmcudG9TdHJpbmcoKSk7XG4gIH07XG5cbiAgZXhwb3J0cy5mcm9tVXRmOCA9IGZ1bmN0aW9uIGZyb21VdGY4KHV0ZjhTdHJpbmcpIHtcbiAgICBpZiAodXRmOFN0cmluZyA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgc3RyaW5nLicpO1xuXG4gICAgdmFyIGJpbmFyeVN0cmluZyA9IF91dGY4VG9CaW5hcnkodXRmOFN0cmluZy50b1N0cmluZygpKTtcblxuICAgIHJldHVybiBfdXBkYXRlKDEsIGJpbmFyeVN0cmluZyk7XG4gIH07XG5cbiAgaWYgKF9oYXNBcnJheUJ1ZmZlcikge1xuICAgIGV4cG9ydHMuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICBpZiAoIV9pc0J1ZmZlcihidWZmZXIpKSB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWQgdG8gYmUgQXJyYXlCdWZmZXIuJyk7XG4gICAgICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgcmV0dXJuIF91cGRhdGVVaW50OEFycmF5KDEsIGFycmF5KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG59KTtcblxuLyoqXG4qIFVuaWNvZGUgQmlkaSBFbmdpbmUgYmFzZWQgb24gdGhlIHdvcmsgb2YgQWxleCBTaGVuc2lzIChAYXN0aGVuc2lzKVxuKiBNSVQgTGljZW5zZVxuKi9cbihmdW5jdGlvbiAoanNQREYpIHtcbiAgLyoqXG4gICAqIFRhYmxlIG9mIFVuaWNvZGUgdHlwZXMuXG4gICAqXG4gICAqIEdlbmVyYXRlZCBieTpcbiAgICpcbiAgICogdmFyIGJpZGkgPSByZXF1aXJlKFwiLi9iaWRpL2luZGV4XCIpO1xuICAgKiB2YXIgYmlkaV9hY2N1bXVsYXRlID0gYmlkaS5zbGljZSgwLCAyNTYpLmNvbmNhdChiaWRpLnNsaWNlKDB4MDUwMCwgMHgwNTAwICsgMjU2ICogMykpLlxuICAgKiBjb25jYXQoYmlkaS5zbGljZSgweDIwMDAsIDB4MjAwMCArIDI1NikpLmNvbmNhdChiaWRpLnNsaWNlKDB4RkIwMCwgMHhGQjAwICsgMjU2KSkuXG4gICAqIGNvbmNhdChiaWRpLnNsaWNlKDB4RkUwMCwgMHhGRTAwICsgMiAqIDI1NikpO1xuICAgKlxuICAgKiBmb3IoIHZhciBpID0gMDsgaSA8IGJpZGlfYWNjdW11bGF0ZS5sZW5ndGg7IGkrKykge1xuICAgKiBcdGlmKGJpZGlfYWNjdW11bGF0ZVtpXSA9PT0gdW5kZWZpbmVkIHx8IGJpZGlfYWNjdW11bGF0ZVtpXSA9PT0gJ09OJylcbiAgICogXHRcdGJpZGlfYWNjdW11bGF0ZVtpXSA9ICdOJzsgLy9tYXJrIGFzIG5ldXRyYWwgdG8gY29uc2VydmUgc3BhY2UgYW5kIHN1YnN0aXR1dGUgdW5kZWZpbmVkXG4gICAqIH1cbiAgICogdmFyIGJpZGlBY2N1bXVsYXRlU3RyID0gJ3JldHVybiBbIFwiJyArIGJpZGlfYWNjdW11bGF0ZS50b1N0cmluZygpLnJlcGxhY2UoLywvZywgJ1wiLCBcIicpICsgJ1wiIF07JztcbiAgICogcmVxdWlyZShcImZzXCIpLndyaXRlRmlsZSgndW5pY29kZS10eXBlcy5qcycsIGJpZGlBY2N1bXVsYXRlU3RyKTtcbiAgICpcbiAgICogQmFzZWQgb246XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3VuaWNvZGUtOC4wLjBcbiAgICovXG5cbiAgdmFyIGJpZGlVbmljb2RlVHlwZXMgPSBbXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJTXCIsIFwiQlwiLCBcIlNcIiwgXCJXU1wiLCBcIkJcIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQlwiLCBcIkJcIiwgXCJCXCIsIFwiU1wiLCBcIldTXCIsIFwiTlwiLCBcIk5cIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIkVTXCIsIFwiQ1NcIiwgXCJFU1wiLCBcIkNTXCIsIFwiQ1NcIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkNTXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkNTXCIsIFwiTlwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIkxcIiwgXCJOXCIsIFwiTlwiLCBcIkJOXCIsIFwiTlwiLCBcIk5cIiwgXCJFVFwiLCBcIkVUXCIsIFwiRU5cIiwgXCJFTlwiLCBcIk5cIiwgXCJMXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiRU5cIiwgXCJMXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIk5cIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTlwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTlwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTlwiLCBcIk5cIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTlwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIk5cIiwgXCJMXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJFVFwiLCBcIk5cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJSXCIsIFwiTlNNXCIsIFwiUlwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIlJcIiwgXCJOU01cIiwgXCJOU01cIiwgXCJSXCIsIFwiTlNNXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJBTlwiLCBcIkFOXCIsIFwiQU5cIiwgXCJBTlwiLCBcIkFOXCIsIFwiQU5cIiwgXCJOXCIsIFwiTlwiLCBcIkFMXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkFMXCIsIFwiQ1NcIiwgXCJBTFwiLCBcIk5cIiwgXCJOXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiQUxcIiwgXCJBTFwiLCBcIk5cIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJBTlwiLCBcIkFOXCIsIFwiQU5cIiwgXCJBTlwiLCBcIkFOXCIsIFwiQU5cIiwgXCJBTlwiLCBcIkFOXCIsIFwiQU5cIiwgXCJBTlwiLCBcIkVUXCIsIFwiQU5cIiwgXCJBTlwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIk5TTVwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJBTlwiLCBcIk5cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJBTFwiLCBcIkFMXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIkFMXCIsIFwiQUxcIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJOXCIsIFwiQUxcIiwgXCJBTFwiLCBcIk5TTVwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5cIiwgXCJOXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIkFMXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiUlwiLCBcIlJcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiUlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiV1NcIiwgXCJXU1wiLCBcIldTXCIsIFwiV1NcIiwgXCJXU1wiLCBcIldTXCIsIFwiV1NcIiwgXCJXU1wiLCBcIldTXCIsIFwiV1NcIiwgXCJXU1wiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkxcIiwgXCJSXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiV1NcIiwgXCJCXCIsIFwiTFJFXCIsIFwiUkxFXCIsIFwiUERGXCIsIFwiTFJPXCIsIFwiUkxPXCIsIFwiQ1NcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiQ1NcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIldTXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIk5cIiwgXCJMUklcIiwgXCJSTElcIiwgXCJGU0lcIiwgXCJQRElcIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJCTlwiLCBcIkJOXCIsIFwiQk5cIiwgXCJFTlwiLCBcIkxcIiwgXCJOXCIsIFwiTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVTXCIsIFwiRVNcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJMXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFU1wiLCBcIkVTXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJFVFwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlNNXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJSXCIsIFwiTlNNXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIkVTXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIk5cIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIk5cIiwgXCJSXCIsIFwiTlwiLCBcIlJcIiwgXCJSXCIsIFwiTlwiLCBcIlJcIiwgXCJSXCIsIFwiTlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJSXCIsIFwiUlwiLCBcIlJcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5TTVwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOU01cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIkNTXCIsIFwiTlwiLCBcIkNTXCIsIFwiTlwiLCBcIk5cIiwgXCJDU1wiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIkVUXCIsIFwiTlwiLCBcIk5cIiwgXCJFU1wiLCBcIkVTXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJFVFwiLCBcIkVUXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiTlwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIkFMXCIsIFwiQUxcIiwgXCJBTFwiLCBcIk5cIiwgXCJOXCIsIFwiQk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJFVFwiLCBcIkVUXCIsIFwiRVRcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIkVTXCIsIFwiQ1NcIiwgXCJFU1wiLCBcIkNTXCIsIFwiQ1NcIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkVOXCIsIFwiRU5cIiwgXCJFTlwiLCBcIkNTXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJOXCIsIFwiTlwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIk5cIiwgXCJOXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJMXCIsIFwiTlwiLCBcIk5cIiwgXCJMXCIsIFwiTFwiLCBcIkxcIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJFVFwiLCBcIkVUXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiRVRcIiwgXCJFVFwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIiwgXCJOXCIsIFwiTlwiLCBcIk5cIl07XG4gIC8qKlxuICAgKiBVbmljb2RlIEJpZGkgYWxnb3JpdGhtIGNvbXBsaWFudCBCaWRpIGVuZ2luZS5cbiAgICogRm9yIHJlZmVyZW5jZSBzZWUgaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5L1xuICAqL1xuXG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvciAoIG9wdGlvbnMgKVxuICAgKlxuICAgKiBJbml0aWFsaXplcyBCaWRpIGVuZ2luZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gU2VlICdzZXRPcHRpb25zJyBiZWxvdyBmb3IgZGV0YWlsZWQgZGVzY3JpcHRpb24uXG4gICAqIG9wdGlvbnMgYXJlIGNhc2hlZCBiZXR3ZWVuIGludm9jYXRpb24gb2YgJ2RvQmlkaVJlb3JkZXInIG1ldGhvZFxuICAgKlxuICAgKiBzYW1wbGUgdXNhZ2UgcGF0dGVybiBvZiBCaWRpRW5naW5lOlxuICAgKiB2YXIgb3B0ID0ge1xuICAgKiBcdGlzSW5wdXRWaXN1YWw6IHRydWUsXG4gICAqIFx0aXNJbnB1dFJ0bDogZmFsc2UsXG4gICAqIFx0aXNPdXRwdXRWaXN1YWw6IGZhbHNlLFxuICAgKiBcdGlzT3V0cHV0UnRsOiBmYWxzZSxcbiAgICogXHRpc1N5bW1ldHJpY1N3YXBwaW5nOiB0cnVlXG4gICAqIH1cbiAgICogdmFyIHNvdXJjZVRvVGFyZ2V0ID0gW10sIGxldmVscyA9IFtdO1xuICAgKiB2YXIgYmlkaUVuZyA9IEdsb2JhbGl6ZS5iaWRpRW5naW5lKG9wdCk7XG4gICAqIHZhciBzcmMgPSBcInRleHQgc3RyaW5nIHRvIGJlIHJlb3JkZXJlZFwiO1xuICAgKiB2YXIgcmV0ID0gYmlkaUVuZy5kb0JpZGlSZW9yZGVyKHNyYywgc291cmNlVG9UYXJnZXQsIGxldmVscyk7XG4gICAqL1xuXG4gIGpzUERGLl9fYmlkaUVuZ2luZV9fID0ganNQREYucHJvdG90eXBlLl9fYmlkaUVuZ2luZV9fID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgX1VOSUNPREVfVFlQRVMgPSBfYmlkaVVuaWNvZGVUeXBlcztcbiAgICB2YXIgX1NUQVRFX1RBQkxFX0xUUiA9IFtbMCwgMywgMCwgMSwgMCwgMCwgMF0sIFswLCAzLCAwLCAxLCAyLCAyLCAwXSwgWzAsIDMsIDAsIDB4MTEsIDIsIDAsIDFdLCBbMCwgMywgNSwgNSwgNCwgMSwgMF0sIFswLCAzLCAweDE1LCAweDE1LCA0LCAwLCAxXSwgWzAsIDMsIDUsIDUsIDQsIDIsIDBdXTtcbiAgICB2YXIgX1NUQVRFX1RBQkxFX1JUTCA9IFtbMiwgMCwgMSwgMSwgMCwgMSwgMF0sIFsyLCAwLCAxLCAxLCAwLCAyLCAwXSwgWzIsIDAsIDIsIDEsIDMsIDIsIDBdLCBbMiwgMCwgMiwgMHgyMSwgMywgMSwgMV1dO1xuICAgIHZhciBfVFlQRV9OQU1FU19NQVAgPSB7XG4gICAgICBcIkxcIjogMCxcbiAgICAgIFwiUlwiOiAxLFxuICAgICAgXCJFTlwiOiAyLFxuICAgICAgXCJBTlwiOiAzLFxuICAgICAgXCJOXCI6IDQsXG4gICAgICBcIkJcIjogNSxcbiAgICAgIFwiU1wiOiA2XG4gICAgfTtcbiAgICB2YXIgX1VOSUNPREVfUkFOR0VTX01BUCA9IHtcbiAgICAgIDA6IDAsXG4gICAgICA1OiAxLFxuICAgICAgNjogMixcbiAgICAgIDc6IDMsXG4gICAgICAweDIwOiA0LFxuICAgICAgMHhGQjogNSxcbiAgICAgIDB4RkU6IDYsXG4gICAgICAweEZGOiA3XG4gICAgfTtcbiAgICB2YXIgX1NXQVBfVEFCTEUgPSBbXCIoXCIsIFwiKVwiLCBcIihcIiwgXCI8XCIsIFwiPlwiLCBcIjxcIiwgXCJbXCIsIFwiXVwiLCBcIltcIiwgXCJ7XCIsIFwifVwiLCBcIntcIiwgXCJcXHhBQlwiLCBcIlxceEJCXCIsIFwiXFx4QUJcIiwgXCJcXHUyMDM5XCIsIFwiXFx1MjAzQVwiLCBcIlxcdTIwMzlcIiwgXCJcXHUyMDQ1XCIsIFwiXFx1MjA0NlwiLCBcIlxcdTIwNDVcIiwgXCJcXHUyMDdEXCIsIFwiXFx1MjA3RVwiLCBcIlxcdTIwN0RcIiwgXCJcXHUyMDhEXCIsIFwiXFx1MjA4RVwiLCBcIlxcdTIwOERcIiwgXCJcXHUyMjY0XCIsIFwiXFx1MjI2NVwiLCBcIlxcdTIyNjRcIiwgXCJcXHUyMzI5XCIsIFwiXFx1MjMyQVwiLCBcIlxcdTIzMjlcIiwgXCJcXHVGRTU5XCIsIFwiXFx1RkU1QVwiLCBcIlxcdUZFNTlcIiwgXCJcXHVGRTVCXCIsIFwiXFx1RkU1Q1wiLCBcIlxcdUZFNUJcIiwgXCJcXHVGRTVEXCIsIFwiXFx1RkU1RVwiLCBcIlxcdUZFNURcIiwgXCJcXHVGRTY0XCIsIFwiXFx1RkU2NVwiLCBcIlxcdUZFNjRcIl07XG5cbiAgICB2YXIgX0xUUl9SQU5HRVNfUkVHX0VYUFIgPSBuZXcgUmVnRXhwKC9eKFsxLTR8OV18MVswLTldfDJbMC05XXwzWzAxNjhdfDRbMDQ1ODldfDVbMDEyXXw3Wzc4XXwxNTl8MTZbMC05XXwxN1swLTJdfDIxWzU2OV18MjJbMDM0ODldfDI1MCkkLyk7XG5cbiAgICB2YXIgX2xhc3RBcmFiaWMgPSBmYWxzZSxcbiAgICAgICAgX2hhc1ViYXRCLFxuICAgICAgICBfaGFzVWJhdFMsXG4gICAgICAgIERJUl9MVFIgPSAwLFxuICAgICAgICBESVJfUlRMID0gMSxcbiAgICAgICAgX2lzSW5WaXN1YWwsXG4gICAgICAgIF9pc0luUnRsLFxuICAgICAgICBfaXNPdXRWaXN1YWwsXG4gICAgICAgIF9pc091dFJ0bCxcbiAgICAgICAgX2lzU3ltbWV0cmljU3dhcHBpbmcsXG4gICAgICAgIF9kaXIgPSBESVJfTFRSO1xuXG4gICAgdGhpcy5fX2JpZGlFbmdpbmVfXyA9IHt9O1xuXG4gICAgdmFyIF9pbml0ID0gZnVuY3Rpb24gX2luaXQodGV4dCwgc291cmNlVG9UYXJnZXRNYXApIHtcbiAgICAgIGlmIChzb3VyY2VUb1RhcmdldE1hcCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzb3VyY2VUb1RhcmdldE1hcFtpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF9pc0luUnRsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX2lzSW5SdGwgPSBfaXNDb250ZXh0dWFsRGlyUnRsKHRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzT3V0UnRsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX2lzT3V0UnRsID0gX2lzQ29udGV4dHVhbERpclJ0bCh0ZXh0KTtcbiAgICAgIH1cbiAgICB9OyAvLyBmb3IgcmVmZXJlbmNlIHNlZSAzLjIgaW4gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5L1xuICAgIC8vXG5cblxuICAgIHZhciBfZ2V0Q2hhclR5cGUgPSBmdW5jdGlvbiBfZ2V0Q2hhclR5cGUoY2gpIHtcbiAgICAgIHZhciBjaGFyQ29kZSA9IGNoLmNoYXJDb2RlQXQoKSxcbiAgICAgICAgICByYW5nZSA9IGNoYXJDb2RlID4+IDgsXG4gICAgICAgICAgcmFuZ2VJZHggPSBfVU5JQ09ERV9SQU5HRVNfTUFQW3JhbmdlXTtcblxuICAgICAgaWYgKHJhbmdlSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9VTklDT0RFX1RZUEVTW3JhbmdlSWR4ICogMjU2ICsgKGNoYXJDb2RlICYgMHhGRildO1xuICAgICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gMHhGQyB8fCByYW5nZSA9PT0gMHhGRCkge1xuICAgICAgICByZXR1cm4gXCJBTFwiO1xuICAgICAgfSBlbHNlIGlmIChfTFRSX1JBTkdFU19SRUdfRVhQUi50ZXN0KHJhbmdlKSkge1xuICAgICAgICAvL3VubGlrZWx5IGNhc2VcbiAgICAgICAgcmV0dXJuIFwiTFwiO1xuICAgICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gOCkge1xuICAgICAgICAvLyBldmVuIGxlc3MgbGlrZWx5XG4gICAgICAgIHJldHVybiBcIlJcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiTlwiOyAvL3VuZGVmaW5lZCB0eXBlLCBtYXJrIGFzIG5ldXRyYWxcbiAgICB9O1xuXG4gICAgdmFyIF9pc0NvbnRleHR1YWxEaXJSdGwgPSBmdW5jdGlvbiBfaXNDb250ZXh0dWFsRGlyUnRsKHRleHQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBjaGFyVHlwZTsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hhclR5cGUgPSBfZ2V0Q2hhclR5cGUodGV4dC5jaGFyQXQoaSkpO1xuXG4gICAgICAgIGlmIChjaGFyVHlwZSA9PT0gXCJMXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhclR5cGUgPT09IFwiUlwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07IC8vIGZvciByZWZlcmVuY2Ugc2VlIDMuMy40ICYgMy4zLjUgaW4gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5L1xuICAgIC8vXG5cblxuICAgIHZhciBfcmVzb2x2ZUNoYXJUeXBlID0gZnVuY3Rpb24gX3Jlc29sdmVDaGFyVHlwZShjaGFycywgdHlwZXMsIHJlc29sdmVkVHlwZXMsIGluZGV4KSB7XG4gICAgICB2YXIgY1R5cGUgPSB0eXBlc1tpbmRleF0sXG4gICAgICAgICAgd1R5cGUsXG4gICAgICAgICAgblR5cGUsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBsZW47XG5cbiAgICAgIHN3aXRjaCAoY1R5cGUpIHtcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgY2FzZSBcIlJcIjpcbiAgICAgICAgICBfbGFzdEFyYWJpYyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJOXCI6XG4gICAgICAgIGNhc2UgXCJBTlwiOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJFTlwiOlxuICAgICAgICAgIGlmIChfbGFzdEFyYWJpYykge1xuICAgICAgICAgICAgY1R5cGUgPSBcIkFOXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkFMXCI6XG4gICAgICAgICAgX2xhc3RBcmFiaWMgPSB0cnVlO1xuICAgICAgICAgIGNUeXBlID0gXCJSXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIldTXCI6XG4gICAgICAgICAgY1R5cGUgPSBcIk5cIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiQ1NcIjpcbiAgICAgICAgICBpZiAoaW5kZXggPCAxIHx8IGluZGV4ICsgMSA+PSB0eXBlcy5sZW5ndGggfHwgKHdUeXBlID0gcmVzb2x2ZWRUeXBlc1tpbmRleCAtIDFdKSAhPT0gXCJFTlwiICYmIHdUeXBlICE9PSBcIkFOXCIgfHwgKG5UeXBlID0gdHlwZXNbaW5kZXggKyAxXSkgIT09IFwiRU5cIiAmJiBuVHlwZSAhPT0gXCJBTlwiKSB7XG4gICAgICAgICAgICBjVHlwZSA9IFwiTlwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX2xhc3RBcmFiaWMpIHtcbiAgICAgICAgICAgIG5UeXBlID0gXCJBTlwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNUeXBlID0gblR5cGUgPT09IHdUeXBlID8gblR5cGUgOiBcIk5cIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiRVNcIjpcbiAgICAgICAgICB3VHlwZSA9IGluZGV4ID4gMCA/IHJlc29sdmVkVHlwZXNbaW5kZXggLSAxXSA6IFwiQlwiO1xuICAgICAgICAgIGNUeXBlID0gd1R5cGUgPT09IFwiRU5cIiAmJiBpbmRleCArIDEgPCB0eXBlcy5sZW5ndGggJiYgdHlwZXNbaW5kZXggKyAxXSA9PT0gXCJFTlwiID8gXCJFTlwiIDogXCJOXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkVUXCI6XG4gICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiByZXNvbHZlZFR5cGVzW2luZGV4IC0gMV0gPT09IFwiRU5cIikge1xuICAgICAgICAgICAgY1R5cGUgPSBcIkVOXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKF9sYXN0QXJhYmljKSB7XG4gICAgICAgICAgICBjVHlwZSA9IFwiTlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSA9IGluZGV4ICsgMTtcbiAgICAgICAgICBsZW4gPSB0eXBlcy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiB0eXBlc1tpXSA9PT0gXCJFVFwiKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgPCBsZW4gJiYgdHlwZXNbaV0gPT09IFwiRU5cIikge1xuICAgICAgICAgICAgY1R5cGUgPSBcIkVOXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNUeXBlID0gXCJOXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIk5TTVwiOlxuICAgICAgICAgIGlmIChfaXNJblZpc3VhbCAmJiAhX2lzSW5SdGwpIHtcbiAgICAgICAgICAgIC8vVi0+TFxuICAgICAgICAgICAgbGVuID0gdHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgaSA9IGluZGV4ICsgMTtcblxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgdHlwZXNbaV0gPT09IFwiTlNNXCIpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgICAgICB2YXIgYyA9IGNoYXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgdmFyIHJ0bENhbmRpZGF0ZSA9IGMgPj0gMHgwNTkxICYmIGMgPD0gMHgwOEZGIHx8IGMgPT09IDB4RkIxRTtcbiAgICAgICAgICAgICAgd1R5cGUgPSB0eXBlc1tpXTtcblxuICAgICAgICAgICAgICBpZiAocnRsQ2FuZGlkYXRlICYmICh3VHlwZSA9PT0gXCJSXCIgfHwgd1R5cGUgPT09IFwiQUxcIikpIHtcbiAgICAgICAgICAgICAgICBjVHlwZSA9IFwiUlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGluZGV4IDwgMSB8fCAod1R5cGUgPSB0eXBlc1tpbmRleCAtIDFdKSA9PT0gXCJCXCIpIHtcbiAgICAgICAgICAgIGNUeXBlID0gXCJOXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNUeXBlID0gcmVzb2x2ZWRUeXBlc1tpbmRleCAtIDFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJCXCI6XG4gICAgICAgICAgX2xhc3RBcmFiaWMgPSBmYWxzZTtcbiAgICAgICAgICBfaGFzVWJhdEIgPSB0cnVlO1xuICAgICAgICAgIGNUeXBlID0gX2RpcjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIF9oYXNVYmF0UyA9IHRydWU7XG4gICAgICAgICAgY1R5cGUgPSBcIk5cIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTFJFXCI6XG4gICAgICAgIGNhc2UgXCJSTEVcIjpcbiAgICAgICAgY2FzZSBcIkxST1wiOlxuICAgICAgICBjYXNlIFwiUkxPXCI6XG4gICAgICAgIGNhc2UgXCJQREZcIjpcbiAgICAgICAgICBfbGFzdEFyYWJpYyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJCTlwiOlxuICAgICAgICAgIGNUeXBlID0gXCJOXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjVHlwZTtcbiAgICB9O1xuXG4gICAgdmFyIF9oYW5kbGVVYmF0UyA9IGZ1bmN0aW9uIF9oYW5kbGVVYmF0Uyh0eXBlcywgbGV2ZWxzLCBsZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVzW2ldID09PSBcIlNcIikge1xuICAgICAgICAgIGxldmVsc1tpXSA9IF9kaXI7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBpZiAodHlwZXNbal0gPT09IFwiV1NcIikge1xuICAgICAgICAgICAgICBsZXZlbHNbal0gPSBfZGlyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfaW52ZXJ0U3RyaW5nID0gZnVuY3Rpb24gX2ludmVydFN0cmluZyh0ZXh0LCBzb3VyY2VUb1RhcmdldE1hcCwgbGV2ZWxzKSB7XG4gICAgICB2YXIgY2hhckFycmF5ID0gdGV4dC5zcGxpdChcIlwiKTtcblxuICAgICAgaWYgKGxldmVscykge1xuICAgICAgICBfY29tcHV0ZUxldmVscyhjaGFyQXJyYXksIGxldmVscywge1xuICAgICAgICAgIGhpTGV2ZWw6IF9kaXJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNoYXJBcnJheS5yZXZlcnNlKCk7XG4gICAgICBzb3VyY2VUb1RhcmdldE1hcCAmJiBzb3VyY2VUb1RhcmdldE1hcC5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gY2hhckFycmF5LmpvaW4oXCJcIik7XG4gICAgfTsgLy8gRm9yIHJlZmVyZW5jZSBzZWUgMy4zIGluIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS9cbiAgICAvL1xuXG5cbiAgICB2YXIgX2NvbXB1dGVMZXZlbHMgPSBmdW5jdGlvbiBfY29tcHV0ZUxldmVscyhjaGFycywgbGV2ZWxzLCBwYXJhbXMpIHtcbiAgICAgIHZhciBhY3Rpb24sXG4gICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbmV3TGV2ZWwsXG4gICAgICAgICAgcHJldlN0YXRlLFxuICAgICAgICAgIGNvbmRQb3MgPSAtMSxcbiAgICAgICAgICBsZW4gPSBjaGFycy5sZW5ndGgsXG4gICAgICAgICAgbmV3U3RhdGUgPSAwLFxuICAgICAgICAgIHJlc29sdmVkVHlwZXMgPSBbXSxcbiAgICAgICAgICBzdGF0ZVRhYmxlID0gX2RpciA/IF9TVEFURV9UQUJMRV9SVEwgOiBfU1RBVEVfVEFCTEVfTFRSLFxuICAgICAgICAgIHR5cGVzID0gW107XG4gICAgICBfbGFzdEFyYWJpYyA9IGZhbHNlO1xuICAgICAgX2hhc1ViYXRCID0gZmFsc2U7XG4gICAgICBfaGFzVWJhdFMgPSBmYWxzZTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHR5cGVzW2ldID0gX2dldENoYXJUeXBlKGNoYXJzW2ldKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICAgIHByZXZTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICByZXNvbHZlZFR5cGVzW2luZGV4XSA9IF9yZXNvbHZlQ2hhclR5cGUoY2hhcnMsIHR5cGVzLCByZXNvbHZlZFR5cGVzLCBpbmRleCk7XG4gICAgICAgIG5ld1N0YXRlID0gc3RhdGVUYWJsZVtwcmV2U3RhdGVdW19UWVBFX05BTUVTX01BUFtyZXNvbHZlZFR5cGVzW2luZGV4XV1dO1xuICAgICAgICBhY3Rpb24gPSBuZXdTdGF0ZSAmIDB4RjA7XG4gICAgICAgIG5ld1N0YXRlICY9IDB4MEY7XG4gICAgICAgIGxldmVsc1tpbmRleF0gPSBuZXdMZXZlbCA9IHN0YXRlVGFibGVbbmV3U3RhdGVdWzVdO1xuXG4gICAgICAgIGlmIChhY3Rpb24gPiAwKSB7XG4gICAgICAgICAgaWYgKGFjdGlvbiA9PT0gMHgxMCkge1xuICAgICAgICAgICAgZm9yIChpID0gY29uZFBvczsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgbGV2ZWxzW2ldID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZFBvcyA9IC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25kUG9zID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZGl0aW9uID0gc3RhdGVUYWJsZVtuZXdTdGF0ZV1bNl07XG5cbiAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgIGlmIChjb25kUG9zID09PSAtMSkge1xuICAgICAgICAgICAgY29uZFBvcyA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29uZFBvcyA+IC0xKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBjb25kUG9zOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICBsZXZlbHNbaV0gPSBuZXdMZXZlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZFBvcyA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlc1tpbmRleF0gPT09IFwiQlwiKSB7XG4gICAgICAgICAgbGV2ZWxzW2luZGV4XSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXMuaGlMZXZlbCB8PSBuZXdMZXZlbDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9oYXNVYmF0Uykge1xuICAgICAgICBfaGFuZGxlVWJhdFModHlwZXMsIGxldmVscywgbGVuKTtcbiAgICAgIH1cbiAgICB9OyAvLyBmb3IgcmVmZXJlbmNlIHNlZSAzLjQgaW4gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5L1xuICAgIC8vXG5cblxuICAgIHZhciBfaW52ZXJ0QnlMZXZlbCA9IGZ1bmN0aW9uIF9pbnZlcnRCeUxldmVsKGxldmVsLCBjaGFyQXJyYXksIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMsIHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy5oaUxldmVsIDwgbGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGV2ZWwgPT09IDEgJiYgX2RpciA9PT0gRElSX1JUTCAmJiAhX2hhc1ViYXRCKSB7XG4gICAgICAgIGNoYXJBcnJheS5yZXZlcnNlKCk7XG4gICAgICAgIHNvdXJjZVRvVGFyZ2V0TWFwICYmIHNvdXJjZVRvVGFyZ2V0TWFwLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2gsXG4gICAgICAgICAgaGlnaCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgbG93LFxuICAgICAgICAgIGxlbiA9IGNoYXJBcnJheS5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSAwO1xuXG4gICAgICB3aGlsZSAoc3RhcnQgPCBsZW4pIHtcbiAgICAgICAgaWYgKGxldmVsc1tzdGFydF0gPj0gbGV2ZWwpIHtcbiAgICAgICAgICBlbmQgPSBzdGFydCArIDE7XG5cbiAgICAgICAgICB3aGlsZSAoZW5kIDwgbGVuICYmIGxldmVsc1tlbmRdID49IGxldmVsKSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGxvdyA9IHN0YXJ0LCBoaWdoID0gZW5kIC0gMTsgbG93IDwgaGlnaDsgbG93KyssIGhpZ2gtLSkge1xuICAgICAgICAgICAgY2ggPSBjaGFyQXJyYXlbbG93XTtcbiAgICAgICAgICAgIGNoYXJBcnJheVtsb3ddID0gY2hhckFycmF5W2hpZ2hdO1xuICAgICAgICAgICAgY2hhckFycmF5W2hpZ2hdID0gY2g7XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2VUb1RhcmdldE1hcCkge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVRvVGFyZ2V0TWFwW2xvd107XG4gICAgICAgICAgICAgIHNvdXJjZVRvVGFyZ2V0TWFwW2xvd10gPSBzb3VyY2VUb1RhcmdldE1hcFtoaWdoXTtcbiAgICAgICAgICAgICAgc291cmNlVG9UYXJnZXRNYXBbaGlnaF0gPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0Kys7XG4gICAgICB9XG4gICAgfTsgLy8gZm9yIHJlZmVyZW5jZSBzZWUgNyAmIEJEMTYgaW4gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5L1xuICAgIC8vXG5cblxuICAgIHZhciBfc3ltbWV0cmljU3dhcCA9IGZ1bmN0aW9uIF9zeW1tZXRyaWNTd2FwKGNoYXJBcnJheSwgbGV2ZWxzLCBwYXJhbXMpIHtcbiAgICAgIGlmIChwYXJhbXMuaGlMZXZlbCAhPT0gMCAmJiBfaXNTeW1tZXRyaWNTd2FwcGluZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaW5kZXg7IGkgPCBjaGFyQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobGV2ZWxzW2ldID09PSAxKSB7XG4gICAgICAgICAgICBpbmRleCA9IF9TV0FQX1RBQkxFLmluZGV4T2YoY2hhckFycmF5W2ldKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgY2hhckFycmF5W2ldID0gX1NXQVBfVEFCTEVbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9yZW9yZGVyID0gZnVuY3Rpb24gX3Jlb3JkZXIodGV4dCwgc291cmNlVG9UYXJnZXRNYXAsIGxldmVscykge1xuICAgICAgdmFyIGNoYXJBcnJheSA9IHRleHQuc3BsaXQoXCJcIiksXG4gICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICBoaUxldmVsOiBfZGlyXG4gICAgICB9O1xuXG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICBsZXZlbHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgX2NvbXB1dGVMZXZlbHMoY2hhckFycmF5LCBsZXZlbHMsIHBhcmFtcyk7XG5cbiAgICAgIF9zeW1tZXRyaWNTd2FwKGNoYXJBcnJheSwgbGV2ZWxzLCBwYXJhbXMpO1xuXG4gICAgICBfaW52ZXJ0QnlMZXZlbChESVJfUlRMICsgMSwgY2hhckFycmF5LCBzb3VyY2VUb1RhcmdldE1hcCwgbGV2ZWxzLCBwYXJhbXMpO1xuXG4gICAgICBfaW52ZXJ0QnlMZXZlbChESVJfUlRMLCBjaGFyQXJyYXksIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMsIHBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBjaGFyQXJyYXkuam9pbihcIlwiKTtcbiAgICB9OyAvLyBkb0JpZGlSZW9yZGVyKCB0ZXh0LCBzb3VyY2VUb1RhcmdldE1hcCwgbGV2ZWxzIClcbiAgICAvLyBQZXJmb3JtcyBCaWRpIHJlb3JkZXJpbmcgYnkgaW1wbGVtZW50aW5nIFVuaWNvZGUgQmlkaSBhbGdvcml0aG0uXG4gICAgLy8gUmV0dXJucyByZW9yZGVyZWQgc3RyaW5nXG4gICAgLy8gQHRleHQgW1N0cmluZ106XG4gICAgLy8gLSBpbnB1dCBzdHJpbmcgdG8gYmUgcmVvcmRlcmVkLCB0aGlzIGlzIGlucHV0IHBhcmFtZXRlclxuICAgIC8vICRzb3VyY2VUb1RhcmdldE1hcCBbQXJyYXldIChvcHRpb25hbClcbiAgICAvLyAtIHJlc3VsdGFudCBtYXBwaW5nIGJldHdlZW4gaW5wdXQgYW5kIG91dHB1dCBzdHJpbmdzLCB0aGlzIGlzIG91dHB1dCBwYXJhbWV0ZXJcbiAgICAvLyAkbGV2ZWxzIFtBcnJheV0gKG9wdGlvbmFsKVxuICAgIC8vIC0gYXJyYXkgb2YgY2FsY3VsYXRlZCBCaWRpIGxldmVscywgLCB0aGlzIGlzIG91dHB1dCBwYXJhbWV0ZXJcblxuXG4gICAgdGhpcy5fX2JpZGlFbmdpbmVfXy5kb0JpZGlSZW9yZGVyID0gZnVuY3Rpb24gKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMpIHtcbiAgICAgIF9pbml0KHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwKTtcblxuICAgICAgaWYgKCFfaXNJblZpc3VhbCAmJiBfaXNPdXRWaXN1YWwgJiYgIV9pc091dFJ0bCkge1xuICAgICAgICAvLyBMTFRSLT5WTFRSLCBMUlRMLT5WTFRSXG4gICAgICAgIF9kaXIgPSBfaXNJblJ0bCA/IERJUl9SVEwgOiBESVJfTFRSO1xuICAgICAgICB0ZXh0ID0gX3Jlb3JkZXIodGV4dCwgc291cmNlVG9UYXJnZXRNYXAsIGxldmVscyk7XG4gICAgICB9IGVsc2UgaWYgKF9pc0luVmlzdWFsICYmIF9pc091dFZpc3VhbCAmJiBfaXNJblJ0bCBeIF9pc091dFJ0bCkge1xuICAgICAgICAvLyBWUlRMLT5WTFRSLCBWTFRSLT5WUlRMXG4gICAgICAgIF9kaXIgPSBfaXNJblJ0bCA/IERJUl9SVEwgOiBESVJfTFRSO1xuICAgICAgICB0ZXh0ID0gX2ludmVydFN0cmluZyh0ZXh0LCBzb3VyY2VUb1RhcmdldE1hcCwgbGV2ZWxzKTtcbiAgICAgIH0gZWxzZSBpZiAoIV9pc0luVmlzdWFsICYmIF9pc091dFZpc3VhbCAmJiBfaXNPdXRSdGwpIHtcbiAgICAgICAgLy8gTExUUi0+VlJUTCwgTFJUTC0+VlJUTFxuICAgICAgICBfZGlyID0gX2lzSW5SdGwgPyBESVJfUlRMIDogRElSX0xUUjtcbiAgICAgICAgdGV4dCA9IF9yZW9yZGVyKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMpO1xuICAgICAgICB0ZXh0ID0gX2ludmVydFN0cmluZyh0ZXh0LCBzb3VyY2VUb1RhcmdldE1hcCk7XG4gICAgICB9IGVsc2UgaWYgKF9pc0luVmlzdWFsICYmICFfaXNJblJ0bCAmJiAhX2lzT3V0VmlzdWFsICYmICFfaXNPdXRSdGwpIHtcbiAgICAgICAgLy8gVkxUUi0+TExUUlxuICAgICAgICBfZGlyID0gRElSX0xUUjtcbiAgICAgICAgdGV4dCA9IF9yZW9yZGVyKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMpO1xuICAgICAgfSBlbHNlIGlmIChfaXNJblZpc3VhbCAmJiAhX2lzT3V0VmlzdWFsICYmIF9pc0luUnRsIF4gX2lzT3V0UnRsKSB7XG4gICAgICAgIC8vIFZMVFItPkxSVEwsIFZSVEwtPkxMVFJcbiAgICAgICAgdGV4dCA9IF9pbnZlcnRTdHJpbmcodGV4dCwgc291cmNlVG9UYXJnZXRNYXApO1xuXG4gICAgICAgIGlmIChfaXNJblJ0bCkge1xuICAgICAgICAgIC8vTExUUiAtPiBWTFRSXG4gICAgICAgICAgX2RpciA9IERJUl9MVFI7XG4gICAgICAgICAgdGV4dCA9IF9yZW9yZGVyKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vTFJUTCAtPiBWUlRMXG4gICAgICAgICAgX2RpciA9IERJUl9SVEw7XG4gICAgICAgICAgdGV4dCA9IF9yZW9yZGVyKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMpO1xuICAgICAgICAgIHRleHQgPSBfaW52ZXJ0U3RyaW5nKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfaXNJblZpc3VhbCAmJiBfaXNJblJ0bCAmJiAhX2lzT3V0VmlzdWFsICYmIF9pc091dFJ0bCkge1xuICAgICAgICAvLyAgVlJUTC0+TFJUTFxuICAgICAgICBfZGlyID0gRElSX1JUTDtcbiAgICAgICAgdGV4dCA9IF9yZW9yZGVyKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMpO1xuICAgICAgICB0ZXh0ID0gX2ludmVydFN0cmluZyh0ZXh0LCBzb3VyY2VUb1RhcmdldE1hcCk7XG4gICAgICB9IGVsc2UgaWYgKCFfaXNJblZpc3VhbCAmJiAhX2lzT3V0VmlzdWFsICYmIF9pc0luUnRsIF4gX2lzT3V0UnRsKSB7XG4gICAgICAgIC8vIExSVEwtPkxMVFIsIExMVFItPkxSVExcbiAgICAgICAgdmFyIGlzU3ltbWV0cmljU3dhcHBpbmdPcmlnID0gX2lzU3ltbWV0cmljU3dhcHBpbmc7XG5cbiAgICAgICAgaWYgKF9pc0luUnRsKSB7XG4gICAgICAgICAgLy9MUlRMLT5MTFRSXG4gICAgICAgICAgX2RpciA9IERJUl9SVEw7XG4gICAgICAgICAgdGV4dCA9IF9yZW9yZGVyKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMpO1xuICAgICAgICAgIF9kaXIgPSBESVJfTFRSO1xuICAgICAgICAgIF9pc1N5bW1ldHJpY1N3YXBwaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGV4dCA9IF9yZW9yZGVyKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMpO1xuICAgICAgICAgIF9pc1N5bW1ldHJpY1N3YXBwaW5nID0gaXNTeW1tZXRyaWNTd2FwcGluZ09yaWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9MTFRSLT5MUlRMXG4gICAgICAgICAgX2RpciA9IERJUl9MVFI7XG4gICAgICAgICAgdGV4dCA9IF9yZW9yZGVyKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwLCBsZXZlbHMpO1xuICAgICAgICAgIHRleHQgPSBfaW52ZXJ0U3RyaW5nKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwKTtcbiAgICAgICAgICBfZGlyID0gRElSX1JUTDtcbiAgICAgICAgICBfaXNTeW1tZXRyaWNTd2FwcGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRleHQgPSBfcmVvcmRlcih0ZXh0LCBzb3VyY2VUb1RhcmdldE1hcCwgbGV2ZWxzKTtcbiAgICAgICAgICBfaXNTeW1tZXRyaWNTd2FwcGluZyA9IGlzU3ltbWV0cmljU3dhcHBpbmdPcmlnO1xuICAgICAgICAgIHRleHQgPSBfaW52ZXJ0U3RyaW5nKHRleHQsIHNvdXJjZVRvVGFyZ2V0TWFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICogQG5hbWUgc2V0T3B0aW9ucyggb3B0aW9ucyApXG4gICAgKiBAZnVuY3Rpb24gXG4gICAgKiBTZXRzIG9wdGlvbnMgZm9yIEJpZGkgY29udmVyc2lvblxuICAgICogQHBhcmFtIHtPYmplY3R9OlxuICAgICogLSBpc0lucHV0VmlzdWFsIHtib29sZWFufSAoZGVmYXVsdHMgdG8gZmFsc2UpOiBhbGxvd2VkIHZhbHVlczogdHJ1ZShWaXN1YWwgbW9kZSksIGZhbHNlKExvZ2ljYWwgbW9kZSlcbiAgICAqIC0gaXNJbnB1dFJ0bCB7Ym9vbGVhbn06IGFsbG93ZWQgdmFsdWVzIHRydWUoUmlnaHQtdG8tbGVmdCBkaXJlY3Rpb24pLCBmYWxzZSAoTGVmdC10by1yaWdodCBkaXJlY3RpaW9uKSwgdW5kZWZpbmVkKENvbnRlY3R1YWwgZGlyZWN0aW9uLCBpLmUuZGlyZWN0aW9uIGRlZmluZWQgYnkgZmlyc3Qgc3Ryb25nIGNoYXJhY3RlciBvZiBpbnB1dCBzdHJpbmcpXG4gICAgKiAtIGlzT3V0cHV0VmlzdWFsIHtib29sZWFufSAoZGVmYXVsdHMgdG8gZmFsc2UpOiBhbGxvd2VkIHZhbHVlczogdHJ1ZShWaXN1YWwgbW9kZSksIGZhbHNlKExvZ2ljYWwgbW9kZSlcbiAgICAqIC0gaXNPdXRwdXRSdGwge2Jvb2xlYW59OiBhbGxvd2VkIHZhbHVlcyB0cnVlKFJpZ2h0LXRvLWxlZnQgZGlyZWN0aW9uKSwgZmFsc2UgKExlZnQtdG8tcmlnaHQgZGlyZWN0aWlvbiksIHVuZGVmaW5lZChDb250ZWN0dWFsIGRpcmVjdGlvbiwgaS5lLmRpcmVjdGlvbiBkZWZpbmVkIGJ5IGZpcnN0IHN0cm9uZyBjaGFyYWN0ZXJvZiBpbnB1dCBzdHJpbmcpXG4gICAgKiAtIGlzU3ltbWV0cmljU3dhcHBpbmcge2Jvb2xlYW59IChkZWZhdWx0cyB0byBmYWxzZSk6IGFsbG93ZWQgdmFsdWVzIHRydWUobmVlZHMgc3ltbWV0cmljIHN3YXBwaW5nKSwgZmFsc2UgKG5vIG5lZWQgaW4gc3ltbWV0cmljIHN3YXBwaW5nKSxcbiAgICAqL1xuXG5cbiAgICB0aGlzLl9fYmlkaUVuZ2luZV9fLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgX2lzSW5WaXN1YWwgPSBvcHRpb25zLmlzSW5wdXRWaXN1YWw7XG4gICAgICAgIF9pc091dFZpc3VhbCA9IG9wdGlvbnMuaXNPdXRwdXRWaXN1YWw7XG4gICAgICAgIF9pc0luUnRsID0gb3B0aW9ucy5pc0lucHV0UnRsO1xuICAgICAgICBfaXNPdXRSdGwgPSBvcHRpb25zLmlzT3V0cHV0UnRsO1xuICAgICAgICBfaXNTeW1tZXRyaWNTd2FwcGluZyA9IG9wdGlvbnMuaXNTeW1tZXRyaWNTd2FwcGluZztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fX2JpZGlFbmdpbmVfXy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMuX19iaWRpRW5naW5lX187XG4gIH07XG5cbiAgdmFyIF9iaWRpVW5pY29kZVR5cGVzID0gYmlkaVVuaWNvZGVUeXBlcztcbiAgdmFyIGJpZGlFbmdpbmUgPSBuZXcganNQREYuX19iaWRpRW5naW5lX18oe1xuICAgIGlzSW5wdXRWaXN1YWw6IHRydWVcbiAgfSk7XG5cbiAgdmFyIGJpZGlFbmdpbmVGdW5jdGlvbiA9IGZ1bmN0aW9uIGJpZGlFbmdpbmVGdW5jdGlvbihhcmdzKSB7XG4gICAgdmFyIHRleHQgPSBhcmdzLnRleHQ7XG4gICAgdmFyIHggPSBhcmdzLng7XG4gICAgdmFyIHkgPSBhcmdzLnk7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnMgfHwge307XG4gICAgdmFyIG11dGV4ID0gYXJncy5tdXRleCB8fCB7fTtcbiAgICB2YXIgbGFuZyA9IG9wdGlvbnMubGFuZztcbiAgICB2YXIgdG1wVGV4dCA9IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0ZXh0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdG1wVGV4dCA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRleHRbaV0pID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgdG1wVGV4dC5wdXNoKFtiaWRpRW5naW5lLmRvQmlkaVJlb3JkZXIodGV4dFtpXVswXSksIHRleHRbaV1bMV0sIHRleHRbaV1bMl1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0bXBUZXh0LnB1c2goW2JpZGlFbmdpbmUuZG9CaWRpUmVvcmRlcih0ZXh0W2ldKV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFyZ3MudGV4dCA9IHRtcFRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MudGV4dCA9IGJpZGlFbmdpbmUuZG9CaWRpUmVvcmRlcih0ZXh0KTtcbiAgICB9XG4gIH07XG5cbiAganNQREYuQVBJLmV2ZW50cy5wdXNoKFsncG9zdFByb2Nlc3NUZXh0JywgYmlkaUVuZ2luZUZ1bmN0aW9uXSk7XG59KShqc1BERik7XG5cbi8qXG4gIENvcHlyaWdodCAoYykgMjAwOCwgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWRcbiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgXG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCBcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICBcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgXG4gICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAgXG4gICogTmVpdGhlciB0aGUgbmFtZSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBub3IgdGhlIG5hbWVzIG9mIGl0cyBcbiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSBcbiAgICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBU1xuICBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgXG4gIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qXG5KUEVHIGVuY29kZXIgcG9ydGVkIHRvIEphdmFTY3JpcHQgYW5kIG9wdGltaXplZCBieSBBbmRyZWFzIFJpdHRlciwgd3d3LmJ5dGVzdHJvbS5ldSwgMTEvMjAwOVxuXG5CYXNpYyBHVUkgYmxvY2tpbmcganBlZyBlbmNvZGVyXG4qL1xuZnVuY3Rpb24gSlBFR0VuY29kZXIocXVhbGl0eSkge1xuICB2YXIgZmZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIFlUYWJsZSA9IG5ldyBBcnJheSg2NCk7XG4gIHZhciBVVlRhYmxlID0gbmV3IEFycmF5KDY0KTtcbiAgdmFyIGZkdGJsX1kgPSBuZXcgQXJyYXkoNjQpO1xuICB2YXIgZmR0YmxfVVYgPSBuZXcgQXJyYXkoNjQpO1xuICB2YXIgWURDX0hUO1xuICB2YXIgVVZEQ19IVDtcbiAgdmFyIFlBQ19IVDtcbiAgdmFyIFVWQUNfSFQ7XG4gIHZhciBiaXRjb2RlID0gbmV3IEFycmF5KDY1NTM1KTtcbiAgdmFyIGNhdGVnb3J5ID0gbmV3IEFycmF5KDY1NTM1KTtcbiAgdmFyIG91dHB1dGZEQ1RRdWFudCA9IG5ldyBBcnJheSg2NCk7XG4gIHZhciBEVSA9IG5ldyBBcnJheSg2NCk7XG4gIHZhciBieXRlb3V0ID0gW107XG4gIHZhciBieXRlbmV3ID0gMDtcbiAgdmFyIGJ5dGVwb3MgPSA3O1xuICB2YXIgWURVID0gbmV3IEFycmF5KDY0KTtcbiAgdmFyIFVEVSA9IG5ldyBBcnJheSg2NCk7XG4gIHZhciBWRFUgPSBuZXcgQXJyYXkoNjQpO1xuICB2YXIgY2x0ID0gbmV3IEFycmF5KDI1Nik7XG4gIHZhciBSR0JfWVVWX1RBQkxFID0gbmV3IEFycmF5KDIwNDgpO1xuICB2YXIgY3VycmVudFF1YWxpdHk7XG4gIHZhciBaaWdaYWcgPSBbMCwgMSwgNSwgNiwgMTQsIDE1LCAyNywgMjgsIDIsIDQsIDcsIDEzLCAxNiwgMjYsIDI5LCA0MiwgMywgOCwgMTIsIDE3LCAyNSwgMzAsIDQxLCA0MywgOSwgMTEsIDE4LCAyNCwgMzEsIDQwLCA0NCwgNTMsIDEwLCAxOSwgMjMsIDMyLCAzOSwgNDUsIDUyLCA1NCwgMjAsIDIyLCAzMywgMzgsIDQ2LCA1MSwgNTUsIDYwLCAyMSwgMzQsIDM3LCA0NywgNTAsIDU2LCA1OSwgNjEsIDM1LCAzNiwgNDgsIDQ5LCA1NywgNTgsIDYyLCA2M107XG4gIHZhciBzdGRfZGNfbHVtaW5hbmNlX25yY29kZXMgPSBbMCwgMCwgMSwgNSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gIHZhciBzdGRfZGNfbHVtaW5hbmNlX3ZhbHVlcyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTFdO1xuICB2YXIgc3RkX2FjX2x1bWluYW5jZV9ucmNvZGVzID0gWzAsIDAsIDIsIDEsIDMsIDMsIDIsIDQsIDMsIDUsIDUsIDQsIDQsIDAsIDAsIDEsIDB4N2RdO1xuICB2YXIgc3RkX2FjX2x1bWluYW5jZV92YWx1ZXMgPSBbMHgwMSwgMHgwMiwgMHgwMywgMHgwMCwgMHgwNCwgMHgxMSwgMHgwNSwgMHgxMiwgMHgyMSwgMHgzMSwgMHg0MSwgMHgwNiwgMHgxMywgMHg1MSwgMHg2MSwgMHgwNywgMHgyMiwgMHg3MSwgMHgxNCwgMHgzMiwgMHg4MSwgMHg5MSwgMHhhMSwgMHgwOCwgMHgyMywgMHg0MiwgMHhiMSwgMHhjMSwgMHgxNSwgMHg1MiwgMHhkMSwgMHhmMCwgMHgyNCwgMHgzMywgMHg2MiwgMHg3MiwgMHg4MiwgMHgwOSwgMHgwYSwgMHgxNiwgMHgxNywgMHgxOCwgMHgxOSwgMHgxYSwgMHgyNSwgMHgyNiwgMHgyNywgMHgyOCwgMHgyOSwgMHgyYSwgMHgzNCwgMHgzNSwgMHgzNiwgMHgzNywgMHgzOCwgMHgzOSwgMHgzYSwgMHg0MywgMHg0NCwgMHg0NSwgMHg0NiwgMHg0NywgMHg0OCwgMHg0OSwgMHg0YSwgMHg1MywgMHg1NCwgMHg1NSwgMHg1NiwgMHg1NywgMHg1OCwgMHg1OSwgMHg1YSwgMHg2MywgMHg2NCwgMHg2NSwgMHg2NiwgMHg2NywgMHg2OCwgMHg2OSwgMHg2YSwgMHg3MywgMHg3NCwgMHg3NSwgMHg3NiwgMHg3NywgMHg3OCwgMHg3OSwgMHg3YSwgMHg4MywgMHg4NCwgMHg4NSwgMHg4NiwgMHg4NywgMHg4OCwgMHg4OSwgMHg4YSwgMHg5MiwgMHg5MywgMHg5NCwgMHg5NSwgMHg5NiwgMHg5NywgMHg5OCwgMHg5OSwgMHg5YSwgMHhhMiwgMHhhMywgMHhhNCwgMHhhNSwgMHhhNiwgMHhhNywgMHhhOCwgMHhhOSwgMHhhYSwgMHhiMiwgMHhiMywgMHhiNCwgMHhiNSwgMHhiNiwgMHhiNywgMHhiOCwgMHhiOSwgMHhiYSwgMHhjMiwgMHhjMywgMHhjNCwgMHhjNSwgMHhjNiwgMHhjNywgMHhjOCwgMHhjOSwgMHhjYSwgMHhkMiwgMHhkMywgMHhkNCwgMHhkNSwgMHhkNiwgMHhkNywgMHhkOCwgMHhkOSwgMHhkYSwgMHhlMSwgMHhlMiwgMHhlMywgMHhlNCwgMHhlNSwgMHhlNiwgMHhlNywgMHhlOCwgMHhlOSwgMHhlYSwgMHhmMSwgMHhmMiwgMHhmMywgMHhmNCwgMHhmNSwgMHhmNiwgMHhmNywgMHhmOCwgMHhmOSwgMHhmYV07XG4gIHZhciBzdGRfZGNfY2hyb21pbmFuY2VfbnJjb2RlcyA9IFswLCAwLCAzLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwXTtcbiAgdmFyIHN0ZF9kY19jaHJvbWluYW5jZV92YWx1ZXMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExXTtcbiAgdmFyIHN0ZF9hY19jaHJvbWluYW5jZV9ucmNvZGVzID0gWzAsIDAsIDIsIDEsIDIsIDQsIDQsIDMsIDQsIDcsIDUsIDQsIDQsIDAsIDEsIDIsIDB4NzddO1xuICB2YXIgc3RkX2FjX2Nocm9taW5hbmNlX3ZhbHVlcyA9IFsweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDExLCAweDA0LCAweDA1LCAweDIxLCAweDMxLCAweDA2LCAweDEyLCAweDQxLCAweDUxLCAweDA3LCAweDYxLCAweDcxLCAweDEzLCAweDIyLCAweDMyLCAweDgxLCAweDA4LCAweDE0LCAweDQyLCAweDkxLCAweGExLCAweGIxLCAweGMxLCAweDA5LCAweDIzLCAweDMzLCAweDUyLCAweGYwLCAweDE1LCAweDYyLCAweDcyLCAweGQxLCAweDBhLCAweDE2LCAweDI0LCAweDM0LCAweGUxLCAweDI1LCAweGYxLCAweDE3LCAweDE4LCAweDE5LCAweDFhLCAweDI2LCAweDI3LCAweDI4LCAweDI5LCAweDJhLCAweDM1LCAweDM2LCAweDM3LCAweDM4LCAweDM5LCAweDNhLCAweDQzLCAweDQ0LCAweDQ1LCAweDQ2LCAweDQ3LCAweDQ4LCAweDQ5LCAweDRhLCAweDUzLCAweDU0LCAweDU1LCAweDU2LCAweDU3LCAweDU4LCAweDU5LCAweDVhLCAweDYzLCAweDY0LCAweDY1LCAweDY2LCAweDY3LCAweDY4LCAweDY5LCAweDZhLCAweDczLCAweDc0LCAweDc1LCAweDc2LCAweDc3LCAweDc4LCAweDc5LCAweDdhLCAweDgyLCAweDgzLCAweDg0LCAweDg1LCAweDg2LCAweDg3LCAweDg4LCAweDg5LCAweDhhLCAweDkyLCAweDkzLCAweDk0LCAweDk1LCAweDk2LCAweDk3LCAweDk4LCAweDk5LCAweDlhLCAweGEyLCAweGEzLCAweGE0LCAweGE1LCAweGE2LCAweGE3LCAweGE4LCAweGE5LCAweGFhLCAweGIyLCAweGIzLCAweGI0LCAweGI1LCAweGI2LCAweGI3LCAweGI4LCAweGI5LCAweGJhLCAweGMyLCAweGMzLCAweGM0LCAweGM1LCAweGM2LCAweGM3LCAweGM4LCAweGM5LCAweGNhLCAweGQyLCAweGQzLCAweGQ0LCAweGQ1LCAweGQ2LCAweGQ3LCAweGQ4LCAweGQ5LCAweGRhLCAweGUyLCAweGUzLCAweGU0LCAweGU1LCAweGU2LCAweGU3LCAweGU4LCAweGU5LCAweGVhLCAweGYyLCAweGYzLCAweGY0LCAweGY1LCAweGY2LCAweGY3LCAweGY4LCAweGY5LCAweGZhXTtcblxuICBmdW5jdGlvbiBpbml0UXVhbnRUYWJsZXMoc2YpIHtcbiAgICB2YXIgWVFUID0gWzE2LCAxMSwgMTAsIDE2LCAyNCwgNDAsIDUxLCA2MSwgMTIsIDEyLCAxNCwgMTksIDI2LCA1OCwgNjAsIDU1LCAxNCwgMTMsIDE2LCAyNCwgNDAsIDU3LCA2OSwgNTYsIDE0LCAxNywgMjIsIDI5LCA1MSwgODcsIDgwLCA2MiwgMTgsIDIyLCAzNywgNTYsIDY4LCAxMDksIDEwMywgNzcsIDI0LCAzNSwgNTUsIDY0LCA4MSwgMTA0LCAxMTMsIDkyLCA0OSwgNjQsIDc4LCA4NywgMTAzLCAxMjEsIDEyMCwgMTAxLCA3MiwgOTIsIDk1LCA5OCwgMTEyLCAxMDAsIDEwMywgOTldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICB2YXIgdCA9IGZmbG9vcigoWVFUW2ldICogc2YgKyA1MCkgLyAxMDApO1xuXG4gICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgdCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHQgPiAyNTUpIHtcbiAgICAgICAgdCA9IDI1NTtcbiAgICAgIH1cblxuICAgICAgWVRhYmxlW1ppZ1phZ1tpXV0gPSB0O1xuICAgIH1cblxuICAgIHZhciBVVlFUID0gWzE3LCAxOCwgMjQsIDQ3LCA5OSwgOTksIDk5LCA5OSwgMTgsIDIxLCAyNiwgNjYsIDk5LCA5OSwgOTksIDk5LCAyNCwgMjYsIDU2LCA5OSwgOTksIDk5LCA5OSwgOTksIDQ3LCA2NiwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5XTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgdmFyIHUgPSBmZmxvb3IoKFVWUVRbal0gKiBzZiArIDUwKSAvIDEwMCk7XG5cbiAgICAgIGlmICh1IDwgMSkge1xuICAgICAgICB1ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAodSA+IDI1NSkge1xuICAgICAgICB1ID0gMjU1O1xuICAgICAgfVxuXG4gICAgICBVVlRhYmxlW1ppZ1phZ1tqXV0gPSB1O1xuICAgIH1cblxuICAgIHZhciBhYXNmID0gWzEuMCwgMS4zODcwMzk4NDUsIDEuMzA2NTYyOTY1LCAxLjE3NTg3NTYwMiwgMS4wLCAwLjc4NTY5NDk1OCwgMC41NDExOTYxMDAsIDAuMjc1ODk5Mzc5XTtcbiAgICB2YXIgayA9IDA7XG5cbiAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCA4OyByb3crKykge1xuICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgODsgY29sKyspIHtcbiAgICAgICAgZmR0YmxfWVtrXSA9IDEuMCAvIChZVGFibGVbWmlnWmFnW2tdXSAqIGFhc2Zbcm93XSAqIGFhc2ZbY29sXSAqIDguMCk7XG4gICAgICAgIGZkdGJsX1VWW2tdID0gMS4wIC8gKFVWVGFibGVbWmlnWmFnW2tdXSAqIGFhc2Zbcm93XSAqIGFhc2ZbY29sXSAqIDguMCk7XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlSHVmZm1hblRibChucmNvZGVzLCBzdGRfdGFibGUpIHtcbiAgICB2YXIgY29kZXZhbHVlID0gMDtcbiAgICB2YXIgcG9zX2luX3RhYmxlID0gMDtcbiAgICB2YXIgSFQgPSBuZXcgQXJyYXkoKTtcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDw9IDE2OyBrKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IG5yY29kZXNba107IGorKykge1xuICAgICAgICBIVFtzdGRfdGFibGVbcG9zX2luX3RhYmxlXV0gPSBbXTtcbiAgICAgICAgSFRbc3RkX3RhYmxlW3Bvc19pbl90YWJsZV1dWzBdID0gY29kZXZhbHVlO1xuICAgICAgICBIVFtzdGRfdGFibGVbcG9zX2luX3RhYmxlXV1bMV0gPSBrO1xuICAgICAgICBwb3NfaW5fdGFibGUrKztcbiAgICAgICAgY29kZXZhbHVlKys7XG4gICAgICB9XG5cbiAgICAgIGNvZGV2YWx1ZSAqPSAyO1xuICAgIH1cblxuICAgIHJldHVybiBIVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRIdWZmbWFuVGJsKCkge1xuICAgIFlEQ19IVCA9IGNvbXB1dGVIdWZmbWFuVGJsKHN0ZF9kY19sdW1pbmFuY2VfbnJjb2Rlcywgc3RkX2RjX2x1bWluYW5jZV92YWx1ZXMpO1xuICAgIFVWRENfSFQgPSBjb21wdXRlSHVmZm1hblRibChzdGRfZGNfY2hyb21pbmFuY2VfbnJjb2Rlcywgc3RkX2RjX2Nocm9taW5hbmNlX3ZhbHVlcyk7XG4gICAgWUFDX0hUID0gY29tcHV0ZUh1ZmZtYW5UYmwoc3RkX2FjX2x1bWluYW5jZV9ucmNvZGVzLCBzdGRfYWNfbHVtaW5hbmNlX3ZhbHVlcyk7XG4gICAgVVZBQ19IVCA9IGNvbXB1dGVIdWZmbWFuVGJsKHN0ZF9hY19jaHJvbWluYW5jZV9ucmNvZGVzLCBzdGRfYWNfY2hyb21pbmFuY2VfdmFsdWVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDYXRlZ29yeU51bWJlcigpIHtcbiAgICB2YXIgbnJsb3dlciA9IDE7XG4gICAgdmFyIG5ydXBwZXIgPSAyO1xuXG4gICAgZm9yICh2YXIgY2F0ID0gMTsgY2F0IDw9IDE1OyBjYXQrKykge1xuICAgICAgLy9Qb3NpdGl2ZSBudW1iZXJzXG4gICAgICBmb3IgKHZhciBuciA9IG5ybG93ZXI7IG5yIDwgbnJ1cHBlcjsgbnIrKykge1xuICAgICAgICBjYXRlZ29yeVszMjc2NyArIG5yXSA9IGNhdDtcbiAgICAgICAgYml0Y29kZVszMjc2NyArIG5yXSA9IFtdO1xuICAgICAgICBiaXRjb2RlWzMyNzY3ICsgbnJdWzFdID0gY2F0O1xuICAgICAgICBiaXRjb2RlWzMyNzY3ICsgbnJdWzBdID0gbnI7XG4gICAgICB9IC8vTmVnYXRpdmUgbnVtYmVyc1xuXG5cbiAgICAgIGZvciAodmFyIG5ybmVnID0gLShucnVwcGVyIC0gMSk7IG5ybmVnIDw9IC1ucmxvd2VyOyBucm5lZysrKSB7XG4gICAgICAgIGNhdGVnb3J5WzMyNzY3ICsgbnJuZWddID0gY2F0O1xuICAgICAgICBiaXRjb2RlWzMyNzY3ICsgbnJuZWddID0gW107XG4gICAgICAgIGJpdGNvZGVbMzI3NjcgKyBucm5lZ11bMV0gPSBjYXQ7XG4gICAgICAgIGJpdGNvZGVbMzI3NjcgKyBucm5lZ11bMF0gPSBucnVwcGVyIC0gMSArIG5ybmVnO1xuICAgICAgfVxuXG4gICAgICBucmxvd2VyIDw8PSAxO1xuICAgICAgbnJ1cHBlciA8PD0gMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0UkdCWVVWVGFibGUoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgUkdCX1lVVl9UQUJMRVtpXSA9IDE5NTk1ICogaTtcbiAgICAgIFJHQl9ZVVZfVEFCTEVbaSArIDI1NiA+PiAwXSA9IDM4NDcwICogaTtcbiAgICAgIFJHQl9ZVVZfVEFCTEVbaSArIDUxMiA+PiAwXSA9IDc0NzEgKiBpICsgMHg4MDAwO1xuICAgICAgUkdCX1lVVl9UQUJMRVtpICsgNzY4ID4+IDBdID0gLTExMDU5ICogaTtcbiAgICAgIFJHQl9ZVVZfVEFCTEVbaSArIDEwMjQgPj4gMF0gPSAtMjE3MDkgKiBpO1xuICAgICAgUkdCX1lVVl9UQUJMRVtpICsgMTI4MCA+PiAwXSA9IDMyNzY4ICogaSArIDB4ODA3RkZGO1xuICAgICAgUkdCX1lVVl9UQUJMRVtpICsgMTUzNiA+PiAwXSA9IC0yNzQzOSAqIGk7XG4gICAgICBSR0JfWVVWX1RBQkxFW2kgKyAxNzkyID4+IDBdID0gLTUzMjkgKiBpO1xuICAgIH1cbiAgfSAvLyBJTyBmdW5jdGlvbnNcblxuXG4gIGZ1bmN0aW9uIHdyaXRlQml0cyhicykge1xuICAgIHZhciB2YWx1ZSA9IGJzWzBdO1xuICAgIHZhciBwb3N2YWwgPSBic1sxXSAtIDE7XG5cbiAgICB3aGlsZSAocG9zdmFsID49IDApIHtcbiAgICAgIGlmICh2YWx1ZSAmIDEgPDwgcG9zdmFsKSB7XG4gICAgICAgIGJ5dGVuZXcgfD0gMSA8PCBieXRlcG9zO1xuICAgICAgfVxuXG4gICAgICBwb3N2YWwtLTtcbiAgICAgIGJ5dGVwb3MtLTtcblxuICAgICAgaWYgKGJ5dGVwb3MgPCAwKSB7XG4gICAgICAgIGlmIChieXRlbmV3ID09IDB4RkYpIHtcbiAgICAgICAgICB3cml0ZUJ5dGUoMHhGRik7XG4gICAgICAgICAgd3JpdGVCeXRlKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlQnl0ZShieXRlbmV3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVwb3MgPSA3O1xuICAgICAgICBieXRlbmV3ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUJ5dGUodmFsdWUpIHtcbiAgICAvL2J5dGVvdXQucHVzaChjbHRbdmFsdWVdKTsgLy8gd3JpdGUgY2hhciBkaXJlY3RseSBpbnN0ZWFkIG9mIGNvbnZlcnRpbmcgbGF0ZXJcbiAgICBieXRlb3V0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVXb3JkKHZhbHVlKSB7XG4gICAgd3JpdGVCeXRlKHZhbHVlID4+IDggJiAweEZGKTtcbiAgICB3cml0ZUJ5dGUodmFsdWUgJiAweEZGKTtcbiAgfSAvLyBEQ1QgJiBxdWFudGl6YXRpb24gY29yZVxuXG5cbiAgZnVuY3Rpb24gZkRDVFF1YW50KGRhdGEsIGZkdGJsKSB7XG4gICAgdmFyIGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNztcbiAgICAvKiBQYXNzIDE6IHByb2Nlc3Mgcm93cy4gKi9cblxuICAgIHZhciBkYXRhT2ZmID0gMDtcbiAgICB2YXIgaTtcbiAgICB2YXIgSTggPSA4O1xuICAgIHZhciBJNjQgPSA2NDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBJODsgKytpKSB7XG4gICAgICBkMCA9IGRhdGFbZGF0YU9mZl07XG4gICAgICBkMSA9IGRhdGFbZGF0YU9mZiArIDFdO1xuICAgICAgZDIgPSBkYXRhW2RhdGFPZmYgKyAyXTtcbiAgICAgIGQzID0gZGF0YVtkYXRhT2ZmICsgM107XG4gICAgICBkNCA9IGRhdGFbZGF0YU9mZiArIDRdO1xuICAgICAgZDUgPSBkYXRhW2RhdGFPZmYgKyA1XTtcbiAgICAgIGQ2ID0gZGF0YVtkYXRhT2ZmICsgNl07XG4gICAgICBkNyA9IGRhdGFbZGF0YU9mZiArIDddO1xuICAgICAgdmFyIHRtcDAgPSBkMCArIGQ3O1xuICAgICAgdmFyIHRtcDcgPSBkMCAtIGQ3O1xuICAgICAgdmFyIHRtcDEgPSBkMSArIGQ2O1xuICAgICAgdmFyIHRtcDYgPSBkMSAtIGQ2O1xuICAgICAgdmFyIHRtcDIgPSBkMiArIGQ1O1xuICAgICAgdmFyIHRtcDUgPSBkMiAtIGQ1O1xuICAgICAgdmFyIHRtcDMgPSBkMyArIGQ0O1xuICAgICAgdmFyIHRtcDQgPSBkMyAtIGQ0O1xuICAgICAgLyogRXZlbiBwYXJ0ICovXG5cbiAgICAgIHZhciB0bXAxMCA9IHRtcDAgKyB0bXAzO1xuICAgICAgLyogcGhhc2UgMiAqL1xuXG4gICAgICB2YXIgdG1wMTMgPSB0bXAwIC0gdG1wMztcbiAgICAgIHZhciB0bXAxMSA9IHRtcDEgKyB0bXAyO1xuICAgICAgdmFyIHRtcDEyID0gdG1wMSAtIHRtcDI7XG4gICAgICBkYXRhW2RhdGFPZmZdID0gdG1wMTAgKyB0bXAxMTtcbiAgICAgIC8qIHBoYXNlIDMgKi9cblxuICAgICAgZGF0YVtkYXRhT2ZmICsgNF0gPSB0bXAxMCAtIHRtcDExO1xuICAgICAgdmFyIHoxID0gKHRtcDEyICsgdG1wMTMpICogMC43MDcxMDY3ODE7XG4gICAgICAvKiBjNCAqL1xuXG4gICAgICBkYXRhW2RhdGFPZmYgKyAyXSA9IHRtcDEzICsgejE7XG4gICAgICAvKiBwaGFzZSA1ICovXG5cbiAgICAgIGRhdGFbZGF0YU9mZiArIDZdID0gdG1wMTMgLSB6MTtcbiAgICAgIC8qIE9kZCBwYXJ0ICovXG5cbiAgICAgIHRtcDEwID0gdG1wNCArIHRtcDU7XG4gICAgICAvKiBwaGFzZSAyICovXG5cbiAgICAgIHRtcDExID0gdG1wNSArIHRtcDY7XG4gICAgICB0bXAxMiA9IHRtcDYgKyB0bXA3O1xuICAgICAgLyogVGhlIHJvdGF0b3IgaXMgbW9kaWZpZWQgZnJvbSBmaWcgNC04IHRvIGF2b2lkIGV4dHJhIG5lZ2F0aW9ucy4gKi9cblxuICAgICAgdmFyIHo1ID0gKHRtcDEwIC0gdG1wMTIpICogMC4zODI2ODM0MzM7XG4gICAgICAvKiBjNiAqL1xuXG4gICAgICB2YXIgejIgPSAwLjU0MTE5NjEwMCAqIHRtcDEwICsgejU7XG4gICAgICAvKiBjMi1jNiAqL1xuXG4gICAgICB2YXIgejQgPSAxLjMwNjU2Mjk2NSAqIHRtcDEyICsgejU7XG4gICAgICAvKiBjMitjNiAqL1xuXG4gICAgICB2YXIgejMgPSB0bXAxMSAqIDAuNzA3MTA2NzgxO1xuICAgICAgLyogYzQgKi9cblxuICAgICAgdmFyIHoxMSA9IHRtcDcgKyB6MztcbiAgICAgIC8qIHBoYXNlIDUgKi9cblxuICAgICAgdmFyIHoxMyA9IHRtcDcgLSB6MztcbiAgICAgIGRhdGFbZGF0YU9mZiArIDVdID0gejEzICsgejI7XG4gICAgICAvKiBwaGFzZSA2ICovXG5cbiAgICAgIGRhdGFbZGF0YU9mZiArIDNdID0gejEzIC0gejI7XG4gICAgICBkYXRhW2RhdGFPZmYgKyAxXSA9IHoxMSArIHo0O1xuICAgICAgZGF0YVtkYXRhT2ZmICsgN10gPSB6MTEgLSB6NDtcbiAgICAgIGRhdGFPZmYgKz0gODtcbiAgICAgIC8qIGFkdmFuY2UgcG9pbnRlciB0byBuZXh0IHJvdyAqL1xuICAgIH1cbiAgICAvKiBQYXNzIDI6IHByb2Nlc3MgY29sdW1ucy4gKi9cblxuXG4gICAgZGF0YU9mZiA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgSTg7ICsraSkge1xuICAgICAgZDAgPSBkYXRhW2RhdGFPZmZdO1xuICAgICAgZDEgPSBkYXRhW2RhdGFPZmYgKyA4XTtcbiAgICAgIGQyID0gZGF0YVtkYXRhT2ZmICsgMTZdO1xuICAgICAgZDMgPSBkYXRhW2RhdGFPZmYgKyAyNF07XG4gICAgICBkNCA9IGRhdGFbZGF0YU9mZiArIDMyXTtcbiAgICAgIGQ1ID0gZGF0YVtkYXRhT2ZmICsgNDBdO1xuICAgICAgZDYgPSBkYXRhW2RhdGFPZmYgKyA0OF07XG4gICAgICBkNyA9IGRhdGFbZGF0YU9mZiArIDU2XTtcbiAgICAgIHZhciB0bXAwcDIgPSBkMCArIGQ3O1xuICAgICAgdmFyIHRtcDdwMiA9IGQwIC0gZDc7XG4gICAgICB2YXIgdG1wMXAyID0gZDEgKyBkNjtcbiAgICAgIHZhciB0bXA2cDIgPSBkMSAtIGQ2O1xuICAgICAgdmFyIHRtcDJwMiA9IGQyICsgZDU7XG4gICAgICB2YXIgdG1wNXAyID0gZDIgLSBkNTtcbiAgICAgIHZhciB0bXAzcDIgPSBkMyArIGQ0O1xuICAgICAgdmFyIHRtcDRwMiA9IGQzIC0gZDQ7XG4gICAgICAvKiBFdmVuIHBhcnQgKi9cblxuICAgICAgdmFyIHRtcDEwcDIgPSB0bXAwcDIgKyB0bXAzcDI7XG4gICAgICAvKiBwaGFzZSAyICovXG5cbiAgICAgIHZhciB0bXAxM3AyID0gdG1wMHAyIC0gdG1wM3AyO1xuICAgICAgdmFyIHRtcDExcDIgPSB0bXAxcDIgKyB0bXAycDI7XG4gICAgICB2YXIgdG1wMTJwMiA9IHRtcDFwMiAtIHRtcDJwMjtcbiAgICAgIGRhdGFbZGF0YU9mZl0gPSB0bXAxMHAyICsgdG1wMTFwMjtcbiAgICAgIC8qIHBoYXNlIDMgKi9cblxuICAgICAgZGF0YVtkYXRhT2ZmICsgMzJdID0gdG1wMTBwMiAtIHRtcDExcDI7XG4gICAgICB2YXIgejFwMiA9ICh0bXAxMnAyICsgdG1wMTNwMikgKiAwLjcwNzEwNjc4MTtcbiAgICAgIC8qIGM0ICovXG5cbiAgICAgIGRhdGFbZGF0YU9mZiArIDE2XSA9IHRtcDEzcDIgKyB6MXAyO1xuICAgICAgLyogcGhhc2UgNSAqL1xuXG4gICAgICBkYXRhW2RhdGFPZmYgKyA0OF0gPSB0bXAxM3AyIC0gejFwMjtcbiAgICAgIC8qIE9kZCBwYXJ0ICovXG5cbiAgICAgIHRtcDEwcDIgPSB0bXA0cDIgKyB0bXA1cDI7XG4gICAgICAvKiBwaGFzZSAyICovXG5cbiAgICAgIHRtcDExcDIgPSB0bXA1cDIgKyB0bXA2cDI7XG4gICAgICB0bXAxMnAyID0gdG1wNnAyICsgdG1wN3AyO1xuICAgICAgLyogVGhlIHJvdGF0b3IgaXMgbW9kaWZpZWQgZnJvbSBmaWcgNC04IHRvIGF2b2lkIGV4dHJhIG5lZ2F0aW9ucy4gKi9cblxuICAgICAgdmFyIHo1cDIgPSAodG1wMTBwMiAtIHRtcDEycDIpICogMC4zODI2ODM0MzM7XG4gICAgICAvKiBjNiAqL1xuXG4gICAgICB2YXIgejJwMiA9IDAuNTQxMTk2MTAwICogdG1wMTBwMiArIHo1cDI7XG4gICAgICAvKiBjMi1jNiAqL1xuXG4gICAgICB2YXIgejRwMiA9IDEuMzA2NTYyOTY1ICogdG1wMTJwMiArIHo1cDI7XG4gICAgICAvKiBjMitjNiAqL1xuXG4gICAgICB2YXIgejNwMiA9IHRtcDExcDIgKiAwLjcwNzEwNjc4MTtcbiAgICAgIC8qIGM0ICovXG5cbiAgICAgIHZhciB6MTFwMiA9IHRtcDdwMiArIHozcDI7XG4gICAgICAvKiBwaGFzZSA1ICovXG5cbiAgICAgIHZhciB6MTNwMiA9IHRtcDdwMiAtIHozcDI7XG4gICAgICBkYXRhW2RhdGFPZmYgKyA0MF0gPSB6MTNwMiArIHoycDI7XG4gICAgICAvKiBwaGFzZSA2ICovXG5cbiAgICAgIGRhdGFbZGF0YU9mZiArIDI0XSA9IHoxM3AyIC0gejJwMjtcbiAgICAgIGRhdGFbZGF0YU9mZiArIDhdID0gejExcDIgKyB6NHAyO1xuICAgICAgZGF0YVtkYXRhT2ZmICsgNTZdID0gejExcDIgLSB6NHAyO1xuICAgICAgZGF0YU9mZisrO1xuICAgICAgLyogYWR2YW5jZSBwb2ludGVyIHRvIG5leHQgY29sdW1uICovXG4gICAgfSAvLyBRdWFudGl6ZS9kZXNjYWxlIHRoZSBjb2VmZmljaWVudHNcblxuXG4gICAgdmFyIGZEQ1RRdWFudDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBJNjQ7ICsraSkge1xuICAgICAgLy8gQXBwbHkgdGhlIHF1YW50aXphdGlvbiBhbmQgc2NhbGluZyBmYWN0b3IgJiBSb3VuZCB0byBuZWFyZXN0IGludGVnZXJcbiAgICAgIGZEQ1RRdWFudCA9IGRhdGFbaV0gKiBmZHRibFtpXTtcbiAgICAgIG91dHB1dGZEQ1RRdWFudFtpXSA9IGZEQ1RRdWFudCA+IDAuMCA/IGZEQ1RRdWFudCArIDAuNSB8IDAgOiBmRENUUXVhbnQgLSAwLjUgfCAwOyAvL291dHB1dGZEQ1RRdWFudFtpXSA9IGZyb3VuZChmRENUUXVhbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRmRENUUXVhbnQ7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUFQUDAoKSB7XG4gICAgd3JpdGVXb3JkKDB4RkZFMCk7IC8vIG1hcmtlclxuXG4gICAgd3JpdGVXb3JkKDE2KTsgLy8gbGVuZ3RoXG5cbiAgICB3cml0ZUJ5dGUoMHg0QSk7IC8vIEpcblxuICAgIHdyaXRlQnl0ZSgweDQ2KTsgLy8gRlxuXG4gICAgd3JpdGVCeXRlKDB4NDkpOyAvLyBJXG5cbiAgICB3cml0ZUJ5dGUoMHg0Nik7IC8vIEZcblxuICAgIHdyaXRlQnl0ZSgwKTsgLy8gPSBcIkpGSUZcIiwnXFwwJ1xuXG4gICAgd3JpdGVCeXRlKDEpOyAvLyB2ZXJzaW9uaGlcblxuICAgIHdyaXRlQnl0ZSgxKTsgLy8gdmVyc2lvbmxvXG5cbiAgICB3cml0ZUJ5dGUoMCk7IC8vIHh5dW5pdHNcblxuICAgIHdyaXRlV29yZCgxKTsgLy8geGRlbnNpdHlcblxuICAgIHdyaXRlV29yZCgxKTsgLy8geWRlbnNpdHlcblxuICAgIHdyaXRlQnl0ZSgwKTsgLy8gdGh1bWJud2lkdGhcblxuICAgIHdyaXRlQnl0ZSgwKTsgLy8gdGh1bWJuaGVpZ2h0XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZVNPRjAod2lkdGgsIGhlaWdodCkge1xuICAgIHdyaXRlV29yZCgweEZGQzApOyAvLyBtYXJrZXJcblxuICAgIHdyaXRlV29yZCgxNyk7IC8vIGxlbmd0aCwgdHJ1ZWNvbG9yIFlVViBKUEdcblxuICAgIHdyaXRlQnl0ZSg4KTsgLy8gcHJlY2lzaW9uXG5cbiAgICB3cml0ZVdvcmQoaGVpZ2h0KTtcbiAgICB3cml0ZVdvcmQod2lkdGgpO1xuICAgIHdyaXRlQnl0ZSgzKTsgLy8gbnJvZmNvbXBvbmVudHNcblxuICAgIHdyaXRlQnl0ZSgxKTsgLy8gSWRZXG5cbiAgICB3cml0ZUJ5dGUoMHgxMSk7IC8vIEhWWVxuXG4gICAgd3JpdGVCeXRlKDApOyAvLyBRVFlcblxuICAgIHdyaXRlQnl0ZSgyKTsgLy8gSWRVXG5cbiAgICB3cml0ZUJ5dGUoMHgxMSk7IC8vIEhWVVxuXG4gICAgd3JpdGVCeXRlKDEpOyAvLyBRVFVcblxuICAgIHdyaXRlQnl0ZSgzKTsgLy8gSWRWXG5cbiAgICB3cml0ZUJ5dGUoMHgxMSk7IC8vIEhWVlxuXG4gICAgd3JpdGVCeXRlKDEpOyAvLyBRVFZcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlRFFUKCkge1xuICAgIHdyaXRlV29yZCgweEZGREIpOyAvLyBtYXJrZXJcblxuICAgIHdyaXRlV29yZCgxMzIpOyAvLyBsZW5ndGhcblxuICAgIHdyaXRlQnl0ZSgwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgd3JpdGVCeXRlKFlUYWJsZVtpXSk7XG4gICAgfVxuXG4gICAgd3JpdGVCeXRlKDEpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICB3cml0ZUJ5dGUoVVZUYWJsZVtqXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVESFQoKSB7XG4gICAgd3JpdGVXb3JkKDB4RkZDNCk7IC8vIG1hcmtlclxuXG4gICAgd3JpdGVXb3JkKDB4MDFBMik7IC8vIGxlbmd0aFxuXG4gICAgd3JpdGVCeXRlKDApOyAvLyBIVFlEQ2luZm9cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgd3JpdGVCeXRlKHN0ZF9kY19sdW1pbmFuY2VfbnJjb2Rlc1tpICsgMV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDExOyBqKyspIHtcbiAgICAgIHdyaXRlQnl0ZShzdGRfZGNfbHVtaW5hbmNlX3ZhbHVlc1tqXSk7XG4gICAgfVxuXG4gICAgd3JpdGVCeXRlKDB4MTApOyAvLyBIVFlBQ2luZm9cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgMTY7IGsrKykge1xuICAgICAgd3JpdGVCeXRlKHN0ZF9hY19sdW1pbmFuY2VfbnJjb2Rlc1trICsgMV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGwgPSAwOyBsIDw9IDE2MTsgbCsrKSB7XG4gICAgICB3cml0ZUJ5dGUoc3RkX2FjX2x1bWluYW5jZV92YWx1ZXNbbF0pO1xuICAgIH1cblxuICAgIHdyaXRlQnl0ZSgxKTsgLy8gSFRVRENpbmZvXG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IDE2OyBtKyspIHtcbiAgICAgIHdyaXRlQnl0ZShzdGRfZGNfY2hyb21pbmFuY2VfbnJjb2Rlc1ttICsgMV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIG4gPSAwOyBuIDw9IDExOyBuKyspIHtcbiAgICAgIHdyaXRlQnl0ZShzdGRfZGNfY2hyb21pbmFuY2VfdmFsdWVzW25dKTtcbiAgICB9XG5cbiAgICB3cml0ZUJ5dGUoMHgxMSk7IC8vIEhUVUFDaW5mb1xuXG4gICAgZm9yICh2YXIgbyA9IDA7IG8gPCAxNjsgbysrKSB7XG4gICAgICB3cml0ZUJ5dGUoc3RkX2FjX2Nocm9taW5hbmNlX25yY29kZXNbbyArIDFdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwID0gMDsgcCA8PSAxNjE7IHArKykge1xuICAgICAgd3JpdGVCeXRlKHN0ZF9hY19jaHJvbWluYW5jZV92YWx1ZXNbcF0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlU09TKCkge1xuICAgIHdyaXRlV29yZCgweEZGREEpOyAvLyBtYXJrZXJcblxuICAgIHdyaXRlV29yZCgxMik7IC8vIGxlbmd0aFxuXG4gICAgd3JpdGVCeXRlKDMpOyAvLyBucm9mY29tcG9uZW50c1xuXG4gICAgd3JpdGVCeXRlKDEpOyAvLyBJZFlcblxuICAgIHdyaXRlQnl0ZSgwKTsgLy8gSFRZXG5cbiAgICB3cml0ZUJ5dGUoMik7IC8vIElkVVxuXG4gICAgd3JpdGVCeXRlKDB4MTEpOyAvLyBIVFVcblxuICAgIHdyaXRlQnl0ZSgzKTsgLy8gSWRWXG5cbiAgICB3cml0ZUJ5dGUoMHgxMSk7IC8vIEhUVlxuXG4gICAgd3JpdGVCeXRlKDApOyAvLyBTc1xuXG4gICAgd3JpdGVCeXRlKDB4M2YpOyAvLyBTZVxuXG4gICAgd3JpdGVCeXRlKDApOyAvLyBCZlxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0RVKENEVSwgZmR0YmwsIERDLCBIVERDLCBIVEFDKSB7XG4gICAgdmFyIEVPQiA9IEhUQUNbMHgwMF07XG4gICAgdmFyIE0xNnplcm9lcyA9IEhUQUNbMHhGMF07XG4gICAgdmFyIHBvcztcbiAgICB2YXIgSTE2ID0gMTY7XG4gICAgdmFyIEk2MyA9IDYzO1xuICAgIHZhciBJNjQgPSA2NDtcbiAgICB2YXIgRFVfRENUID0gZkRDVFF1YW50KENEVSwgZmR0YmwpOyAvL1ppZ1phZyByZW9yZGVyXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IEk2NDsgKytqKSB7XG4gICAgICBEVVtaaWdaYWdbal1dID0gRFVfRENUW2pdO1xuICAgIH1cblxuICAgIHZhciBEaWZmID0gRFVbMF0gLSBEQztcbiAgICBEQyA9IERVWzBdOyAvL0VuY29kZSBEQ1xuXG4gICAgaWYgKERpZmYgPT0gMCkge1xuICAgICAgd3JpdGVCaXRzKEhURENbMF0pOyAvLyBEaWZmIG1pZ2h0IGJlIDBcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gMzI3NjcgKyBEaWZmO1xuICAgICAgd3JpdGVCaXRzKEhURENbY2F0ZWdvcnlbcG9zXV0pO1xuICAgICAgd3JpdGVCaXRzKGJpdGNvZGVbcG9zXSk7XG4gICAgfSAvL0VuY29kZSBBQ3NcblxuXG4gICAgdmFyIGVuZDBwb3MgPSA2MzsgLy8gd2FzIGNvbnN0Li4uIHdoaWNoIGlzIGNyYXp5XG5cbiAgICBmb3IgKDsgZW5kMHBvcyA+IDAgJiYgRFVbZW5kMHBvc10gPT0gMDsgZW5kMHBvcy0tKSB7fVxuXG4gICAgaWYgKGVuZDBwb3MgPT0gMCkge1xuICAgICAgd3JpdGVCaXRzKEVPQik7XG4gICAgICByZXR1cm4gREM7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciBsbmc7XG5cbiAgICB3aGlsZSAoaSA8PSBlbmQwcG9zKSB7XG4gICAgICB2YXIgc3RhcnRwb3MgPSBpO1xuXG4gICAgICBmb3IgKDsgRFVbaV0gPT0gMCAmJiBpIDw9IGVuZDBwb3M7ICsraSkge31cblxuICAgICAgdmFyIG5yemVyb2VzID0gaSAtIHN0YXJ0cG9zO1xuXG4gICAgICBpZiAobnJ6ZXJvZXMgPj0gSTE2KSB7XG4gICAgICAgIGxuZyA9IG5yemVyb2VzID4+IDQ7XG5cbiAgICAgICAgZm9yICh2YXIgbnJtYXJrZXIgPSAxOyBucm1hcmtlciA8PSBsbmc7ICsrbnJtYXJrZXIpIHtcbiAgICAgICAgICB3cml0ZUJpdHMoTTE2emVyb2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5yemVyb2VzID0gbnJ6ZXJvZXMgJiAweEY7XG4gICAgICB9XG5cbiAgICAgIHBvcyA9IDMyNzY3ICsgRFVbaV07XG4gICAgICB3cml0ZUJpdHMoSFRBQ1sobnJ6ZXJvZXMgPDwgNCkgKyBjYXRlZ29yeVtwb3NdXSk7XG4gICAgICB3cml0ZUJpdHMoYml0Y29kZVtwb3NdKTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoZW5kMHBvcyAhPSBJNjMpIHtcbiAgICAgIHdyaXRlQml0cyhFT0IpO1xuICAgIH1cblxuICAgIHJldHVybiBEQztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDaGFyTG9va3VwVGFibGUoKSB7XG4gICAgdmFyIHNmY2MgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgLy8vLy8gQUNIVFVORyAvLyAyNTVcbiAgICAgIGNsdFtpXSA9IHNmY2MoaSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lbmNvZGUgPSBmdW5jdGlvbiAoaW1hZ2UsIHF1YWxpdHkpIC8vIGltYWdlIGRhdGEgb2JqZWN0XG4gIHtcbiAgICB2YXIgdGltZV9zdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGlmIChxdWFsaXR5KSBzZXRRdWFsaXR5KHF1YWxpdHkpOyAvLyBJbml0aWFsaXplIGJpdCB3cml0ZXJcblxuICAgIGJ5dGVvdXQgPSBuZXcgQXJyYXkoKTtcbiAgICBieXRlbmV3ID0gMDtcbiAgICBieXRlcG9zID0gNzsgLy8gQWRkIEpQRUcgaGVhZGVyc1xuXG4gICAgd3JpdGVXb3JkKDB4RkZEOCk7IC8vIFNPSVxuXG4gICAgd3JpdGVBUFAwKCk7XG4gICAgd3JpdGVEUVQoKTtcbiAgICB3cml0ZVNPRjAoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgd3JpdGVESFQoKTtcbiAgICB3cml0ZVNPUygpOyAvLyBFbmNvZGUgOHg4IG1hY3JvYmxvY2tzXG5cbiAgICB2YXIgRENZID0gMDtcbiAgICB2YXIgRENVID0gMDtcbiAgICB2YXIgRENWID0gMDtcbiAgICBieXRlbmV3ID0gMDtcbiAgICBieXRlcG9zID0gNztcbiAgICB0aGlzLmVuY29kZS5kaXNwbGF5TmFtZSA9IFwiX2VuY29kZV9cIjtcbiAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2UuZGF0YTtcbiAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIHZhciBxdWFkV2lkdGggPSB3aWR0aCAqIDQ7XG4gICAgdmFyIHgsXG4gICAgICAgIHkgPSAwO1xuICAgIHZhciByLCBnLCBiO1xuICAgIHZhciBzdGFydCwgcCwgY29sLCByb3csIHBvcztcblxuICAgIHdoaWxlICh5IDwgaGVpZ2h0KSB7XG4gICAgICB4ID0gMDtcblxuICAgICAgd2hpbGUgKHggPCBxdWFkV2lkdGgpIHtcbiAgICAgICAgc3RhcnQgPSBxdWFkV2lkdGggKiB5ICsgeDtcbiAgICAgICAgcCA9IHN0YXJ0O1xuICAgICAgICBjb2wgPSAtMTtcbiAgICAgICAgcm93ID0gMDtcblxuICAgICAgICBmb3IgKHBvcyA9IDA7IHBvcyA8IDY0OyBwb3MrKykge1xuICAgICAgICAgIHJvdyA9IHBvcyA+PiAzOyAvLyAvOFxuXG4gICAgICAgICAgY29sID0gKHBvcyAmIDcpICogNDsgLy8gJThcblxuICAgICAgICAgIHAgPSBzdGFydCArIHJvdyAqIHF1YWRXaWR0aCArIGNvbDtcblxuICAgICAgICAgIGlmICh5ICsgcm93ID49IGhlaWdodCkge1xuICAgICAgICAgICAgLy8gcGFkZGluZyBib3R0b21cbiAgICAgICAgICAgIHAgLT0gcXVhZFdpZHRoICogKHkgKyAxICsgcm93IC0gaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeCArIGNvbCA+PSBxdWFkV2lkdGgpIHtcbiAgICAgICAgICAgIC8vIHBhZGRpbmcgcmlnaHRcdFxuICAgICAgICAgICAgcCAtPSB4ICsgY29sIC0gcXVhZFdpZHRoICsgNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByID0gaW1hZ2VEYXRhW3ArK107XG4gICAgICAgICAgZyA9IGltYWdlRGF0YVtwKytdO1xuICAgICAgICAgIGIgPSBpbWFnZURhdGFbcCsrXTtcbiAgICAgICAgICAvKiAvLyBjYWxjdWxhdGUgWVVWIHZhbHVlcyBkeW5hbWljYWxseVxuICAgICAgICAgIFlEVVtwb3NdPSgoKCAwLjI5OTAwKSpyKyggMC41ODcwMCkqZysoIDAuMTE0MDApKmIpKS0xMjg7IC8vLTB4ODBcbiAgICAgICAgICBVRFVbcG9zXT0oKCgtMC4xNjg3NCkqcisoLTAuMzMxMjYpKmcrKCAwLjUwMDAwKSpiKSk7XG4gICAgICAgICAgVkRVW3Bvc109KCgoIDAuNTAwMDApKnIrKC0wLjQxODY5KSpnKygtMC4wODEzMSkqYikpO1xuICAgICAgICAgICovXG4gICAgICAgICAgLy8gdXNlIGxvb2t1cCB0YWJsZSAoc2xpZ2h0bHkgZmFzdGVyKVxuXG4gICAgICAgICAgWURVW3Bvc10gPSAoUkdCX1lVVl9UQUJMRVtyXSArIFJHQl9ZVVZfVEFCTEVbZyArIDI1NiA+PiAwXSArIFJHQl9ZVVZfVEFCTEVbYiArIDUxMiA+PiAwXSA+PiAxNikgLSAxMjg7XG4gICAgICAgICAgVURVW3Bvc10gPSAoUkdCX1lVVl9UQUJMRVtyICsgNzY4ID4+IDBdICsgUkdCX1lVVl9UQUJMRVtnICsgMTAyNCA+PiAwXSArIFJHQl9ZVVZfVEFCTEVbYiArIDEyODAgPj4gMF0gPj4gMTYpIC0gMTI4O1xuICAgICAgICAgIFZEVVtwb3NdID0gKFJHQl9ZVVZfVEFCTEVbciArIDEyODAgPj4gMF0gKyBSR0JfWVVWX1RBQkxFW2cgKyAxNTM2ID4+IDBdICsgUkdCX1lVVl9UQUJMRVtiICsgMTc5MiA+PiAwXSA+PiAxNikgLSAxMjg7XG4gICAgICAgIH1cblxuICAgICAgICBEQ1kgPSBwcm9jZXNzRFUoWURVLCBmZHRibF9ZLCBEQ1ksIFlEQ19IVCwgWUFDX0hUKTtcbiAgICAgICAgRENVID0gcHJvY2Vzc0RVKFVEVSwgZmR0YmxfVVYsIERDVSwgVVZEQ19IVCwgVVZBQ19IVCk7XG4gICAgICAgIERDViA9IHByb2Nlc3NEVShWRFUsIGZkdGJsX1VWLCBEQ1YsIFVWRENfSFQsIFVWQUNfSFQpO1xuICAgICAgICB4ICs9IDMyO1xuICAgICAgfVxuXG4gICAgICB5ICs9IDg7XG4gICAgfSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gRG8gdGhlIGJpdCBhbGlnbm1lbnQgb2YgdGhlIEVPSSBtYXJrZXJcblxuXG4gICAgaWYgKGJ5dGVwb3MgPj0gMCkge1xuICAgICAgdmFyIGZpbGxiaXRzID0gW107XG4gICAgICBmaWxsYml0c1sxXSA9IGJ5dGVwb3MgKyAxO1xuICAgICAgZmlsbGJpdHNbMF0gPSAoMSA8PCBieXRlcG9zICsgMSkgLSAxO1xuICAgICAgd3JpdGVCaXRzKGZpbGxiaXRzKTtcbiAgICB9XG5cbiAgICB3cml0ZVdvcmQoMHhGRkQ5KTsgLy9FT0lcblxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlb3V0KTtcbiAgfTtcblxuICBmdW5jdGlvbiBzZXRRdWFsaXR5KHF1YWxpdHkpIHtcbiAgICBpZiAocXVhbGl0eSA8PSAwKSB7XG4gICAgICBxdWFsaXR5ID0gMTtcbiAgICB9XG5cbiAgICBpZiAocXVhbGl0eSA+IDEwMCkge1xuICAgICAgcXVhbGl0eSA9IDEwMDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFF1YWxpdHkgPT0gcXVhbGl0eSkgcmV0dXJuOyAvLyBkb24ndCByZWNhbGMgaWYgdW5jaGFuZ2VkXG5cbiAgICB2YXIgc2YgPSAwO1xuXG4gICAgaWYgKHF1YWxpdHkgPCA1MCkge1xuICAgICAgc2YgPSBNYXRoLmZsb29yKDUwMDAgLyBxdWFsaXR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2YgPSBNYXRoLmZsb29yKDIwMCAtIHF1YWxpdHkgKiAyKTtcbiAgICB9XG5cbiAgICBpbml0UXVhbnRUYWJsZXMoc2YpO1xuICAgIGN1cnJlbnRRdWFsaXR5ID0gcXVhbGl0eTsgLy9jb25zb2xlLmxvZygnUXVhbGl0eSBzZXQgdG86ICcrcXVhbGl0eSArJyUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmFyIHRpbWVfc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAoIXF1YWxpdHkpIHF1YWxpdHkgPSA1MDsgLy8gQ3JlYXRlIHRhYmxlc1xuXG4gICAgaW5pdENoYXJMb29rdXBUYWJsZSgpO1xuICAgIGluaXRIdWZmbWFuVGJsKCk7XG4gICAgaW5pdENhdGVnb3J5TnVtYmVyKCk7XG4gICAgaW5pdFJHQllVVlRhYmxlKCk7XG4gICAgc2V0UXVhbGl0eShxdWFsaXR5KTtcbiAgICB2YXIgZHVyYXRpb24gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRpbWVfc3RhcnQ7IC8vY29uc29sZS5sb2coJ0luaXRpYWxpemF0aW9uICcrIGR1cmF0aW9uICsgJ21zJyk7XG4gIH1cblxuICBpbml0KCk7XG59XG4vKnJvbGx1cC1rZWVwZXItc3RhcnQqL1xuXG53aW5kb3cudG1wID0gSlBFR0VuY29kZXI7XG4vKnJvbGx1cC1rZWVwZXItZW5kKi9cblxuLyoqXG4gKiBAYXV0aG9yIHNoYW96aWxlZVxuICpcbiAqIEJtcCBmb3JtYXQgZGVjb2RlcixzdXBwb3J0IDFiaXQgNGJpdCA4Yml0IDI0Yml0IGJtcFxuICpcbiAqL1xuZnVuY3Rpb24gQm1wRGVjb2RlcihidWZmZXIsIGlzX3dpdGhfYWxwaGEpIHtcbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgdGhpcy5kYXRhdiA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyKTtcbiAgdGhpcy5pc193aXRoX2FscGhhID0gISFpc193aXRoX2FscGhhO1xuICB0aGlzLmJvdHRvbV91cCA9IHRydWU7XG4gIHRoaXMuZmxhZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5idWZmZXJbMF0pICsgU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmJ1ZmZlclsxXSk7XG4gIHRoaXMucG9zICs9IDI7XG4gIGlmIChbXCJCTVwiLCBcIkJBXCIsIFwiQ0lcIiwgXCJDUFwiLCBcIklDXCIsIFwiUFRcIl0uaW5kZXhPZih0aGlzLmZsYWcpID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBCTVAgRmlsZVwiKTtcbiAgdGhpcy5wYXJzZUhlYWRlcigpO1xuICB0aGlzLnBhcnNlQkdSKCk7XG59XG5cbkJtcERlY29kZXIucHJvdG90eXBlLnBhcnNlSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZpbGVTaXplID0gdGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsIHRydWUpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLnJlc2VydmVkID0gdGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsIHRydWUpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLm9mZnNldCA9IHRoaXMuZGF0YXYuZ2V0VWludDMyKHRoaXMucG9zLCB0cnVlKTtcbiAgdGhpcy5wb3MgKz0gNDtcbiAgdGhpcy5oZWFkZXJTaXplID0gdGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsIHRydWUpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLndpZHRoID0gdGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsIHRydWUpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLmhlaWdodCA9IHRoaXMuZGF0YXYuZ2V0SW50MzIodGhpcy5wb3MsIHRydWUpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLnBsYW5lcyA9IHRoaXMuZGF0YXYuZ2V0VWludDE2KHRoaXMucG9zLCB0cnVlKTtcbiAgdGhpcy5wb3MgKz0gMjtcbiAgdGhpcy5iaXRQUCA9IHRoaXMuZGF0YXYuZ2V0VWludDE2KHRoaXMucG9zLCB0cnVlKTtcbiAgdGhpcy5wb3MgKz0gMjtcbiAgdGhpcy5jb21wcmVzcyA9IHRoaXMuZGF0YXYuZ2V0VWludDMyKHRoaXMucG9zLCB0cnVlKTtcbiAgdGhpcy5wb3MgKz0gNDtcbiAgdGhpcy5yYXdTaXplID0gdGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsIHRydWUpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLmhyID0gdGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsIHRydWUpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLnZyID0gdGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsIHRydWUpO1xuICB0aGlzLnBvcyArPSA0O1xuICB0aGlzLmNvbG9ycyA9IHRoaXMuZGF0YXYuZ2V0VWludDMyKHRoaXMucG9zLCB0cnVlKTtcbiAgdGhpcy5wb3MgKz0gNDtcbiAgdGhpcy5pbXBvcnRhbnRDb2xvcnMgPSB0aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywgdHJ1ZSk7XG4gIHRoaXMucG9zICs9IDQ7XG5cbiAgaWYgKHRoaXMuYml0UFAgPT09IDE2ICYmIHRoaXMuaXNfd2l0aF9hbHBoYSkge1xuICAgIHRoaXMuYml0UFAgPSAxNTtcbiAgfVxuXG4gIGlmICh0aGlzLmJpdFBQIDwgMTUpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5jb2xvcnMgPT09IDAgPyAxIDw8IHRoaXMuYml0UFAgOiB0aGlzLmNvbG9ycztcbiAgICB0aGlzLnBhbGV0dGUgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBibHVlID0gdGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCB0cnVlKTtcbiAgICAgIHZhciBncmVlbiA9IHRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywgdHJ1ZSk7XG4gICAgICB2YXIgcmVkID0gdGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCB0cnVlKTtcbiAgICAgIHZhciBxdWFkID0gdGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCB0cnVlKTtcbiAgICAgIHRoaXMucGFsZXR0ZVtpXSA9IHtcbiAgICAgICAgcmVkOiByZWQsXG4gICAgICAgIGdyZWVuOiBncmVlbixcbiAgICAgICAgYmx1ZTogYmx1ZSxcbiAgICAgICAgcXVhZDogcXVhZFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG4gICAgdGhpcy5oZWlnaHQgKj0gLTE7XG4gICAgdGhpcy5ib3R0b21fdXAgPSBmYWxzZTtcbiAgfVxufTtcblxuQm1wRGVjb2Rlci5wcm90b3R5cGUucGFyc2VCR1IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9zID0gdGhpcy5vZmZzZXQ7XG5cbiAgdHJ5IHtcbiAgICB2YXIgYml0biA9IFwiYml0XCIgKyB0aGlzLmJpdFBQO1xuICAgIHZhciBsZW4gPSB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiA0O1xuICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgdGhpc1tiaXRuXSgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5sb2coXCJiaXQgZGVjb2RlIGVycm9yOlwiICsgZSk7XG4gIH1cbn07XG5cbkJtcERlY29kZXIucHJvdG90eXBlLmJpdDEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB4bGVuID0gTWF0aC5jZWlsKHRoaXMud2lkdGggLyA4KTtcbiAgdmFyIG1vZGUgPSB4bGVuICUgNDtcbiAgdmFyIHkgPSB0aGlzLmhlaWdodCA+PSAwID8gdGhpcy5oZWlnaHQgLSAxIDogLXRoaXMuaGVpZ2h0O1xuXG4gIGZvciAodmFyIHkgPSB0aGlzLmhlaWdodCAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmJvdHRvbV91cCA/IHkgOiB0aGlzLmhlaWdodCAtIDEgLSB5O1xuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB4bGVuOyB4KyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCB0cnVlKTtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGxpbmUgKiB0aGlzLndpZHRoICogNCArIHggKiA4ICogNDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgaWYgKHggKiA4ICsgaSA8IHRoaXMud2lkdGgpIHtcbiAgICAgICAgICB2YXIgcmdiID0gdGhpcy5wYWxldHRlW2IgPj4gNyAtIGkgJiAweDFdO1xuICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIGkgKiA0XSA9IHJnYi5ibHVlO1xuICAgICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIGkgKiA0ICsgMV0gPSByZ2IuZ3JlZW47XG4gICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgaSAqIDQgKyAyXSA9IHJnYi5yZWQ7XG4gICAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgaSAqIDQgKyAzXSA9IDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kZSAhPSAwKSB7XG4gICAgICB0aGlzLnBvcyArPSA0IC0gbW9kZTtcbiAgICB9XG4gIH1cbn07XG5cbkJtcERlY29kZXIucHJvdG90eXBlLmJpdDQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB4bGVuID0gTWF0aC5jZWlsKHRoaXMud2lkdGggLyAyKTtcbiAgdmFyIG1vZGUgPSB4bGVuICUgNDtcblxuICBmb3IgKHZhciB5ID0gdGhpcy5oZWlnaHQgLSAxOyB5ID49IDA7IHktLSkge1xuICAgIHZhciBsaW5lID0gdGhpcy5ib3R0b21fdXAgPyB5IDogdGhpcy5oZWlnaHQgLSAxIC0geTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgeGxlbjsgeCsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywgdHJ1ZSk7XG4gICAgICB2YXIgbG9jYXRpb24gPSBsaW5lICogdGhpcy53aWR0aCAqIDQgKyB4ICogMiAqIDQ7XG4gICAgICB2YXIgYmVmb3JlID0gYiA+PiA0O1xuICAgICAgdmFyIGFmdGVyID0gYiAmIDB4MEY7XG4gICAgICB2YXIgcmdiID0gdGhpcy5wYWxldHRlW2JlZm9yZV07XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb25dID0gcmdiLmJsdWU7XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAxXSA9IHJnYi5ncmVlbjtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDJdID0gcmdiLnJlZDtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDNdID0gMHhGRjtcbiAgICAgIGlmICh4ICogMiArIDEgPj0gdGhpcy53aWR0aCkgYnJlYWs7XG4gICAgICByZ2IgPSB0aGlzLnBhbGV0dGVbYWZ0ZXJdO1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgNF0gPSByZ2IuYmx1ZTtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDQgKyAxXSA9IHJnYi5ncmVlbjtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDQgKyAyXSA9IHJnYi5yZWQ7XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyA0ICsgM10gPSAweEZGO1xuICAgIH1cblxuICAgIGlmIChtb2RlICE9IDApIHtcbiAgICAgIHRoaXMucG9zICs9IDQgLSBtb2RlO1xuICAgIH1cbiAgfVxufTtcblxuQm1wRGVjb2Rlci5wcm90b3R5cGUuYml0OCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1vZGUgPSB0aGlzLndpZHRoICUgNDtcblxuICBmb3IgKHZhciB5ID0gdGhpcy5oZWlnaHQgLSAxOyB5ID49IDA7IHktLSkge1xuICAgIHZhciBsaW5lID0gdGhpcy5ib3R0b21fdXAgPyB5IDogdGhpcy5oZWlnaHQgLSAxIC0geTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywgdHJ1ZSk7XG4gICAgICB2YXIgbG9jYXRpb24gPSBsaW5lICogdGhpcy53aWR0aCAqIDQgKyB4ICogNDtcblxuICAgICAgaWYgKGIgPCB0aGlzLnBhbGV0dGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnBhbGV0dGVbYl07XG4gICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbl0gPSByZ2IucmVkO1xuICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAxXSA9IHJnYi5ncmVlbjtcbiAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMl0gPSByZ2IuYmx1ZTtcbiAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgM10gPSAweEZGO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uXSA9IDB4RkY7XG4gICAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDFdID0gMHhGRjtcbiAgICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMl0gPSAweEZGO1xuICAgICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAzXSA9IDB4RkY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgIT0gMCkge1xuICAgICAgdGhpcy5wb3MgKz0gNCAtIG1vZGU7XG4gICAgfVxuICB9XG59O1xuXG5CbXBEZWNvZGVyLnByb3RvdHlwZS5iaXQxNSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRpZl93ID0gdGhpcy53aWR0aCAlIDM7XG5cbiAgdmFyIF8xMTExMSA9IHBhcnNlSW50KFwiMTExMTFcIiwgMiksXG4gICAgICBfMV81ID0gXzExMTExO1xuXG4gIGZvciAodmFyIHkgPSB0aGlzLmhlaWdodCAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmJvdHRvbV91cCA/IHkgOiB0aGlzLmhlaWdodCAtIDEgLSB5O1xuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgIHZhciBCID0gdGhpcy5kYXRhdi5nZXRVaW50MTYodGhpcy5wb3MsIHRydWUpO1xuICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgIHZhciBibHVlID0gKEIgJiBfMV81KSAvIF8xXzUgKiAyNTUgfCAwO1xuICAgICAgdmFyIGdyZWVuID0gKEIgPj4gNSAmIF8xXzUpIC8gXzFfNSAqIDI1NSB8IDA7XG4gICAgICB2YXIgcmVkID0gKEIgPj4gMTAgJiBfMV81KSAvIF8xXzUgKiAyNTUgfCAwO1xuICAgICAgdmFyIGFscGhhID0gQiA+PiAxNSA/IDB4RkYgOiAweDAwO1xuICAgICAgdmFyIGxvY2F0aW9uID0gbGluZSAqIHRoaXMud2lkdGggKiA0ICsgeCAqIDQ7XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb25dID0gcmVkO1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMV0gPSBncmVlbjtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDJdID0gYmx1ZTtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDNdID0gYWxwaGE7XG4gICAgfSAvL3NraXAgZXh0cmEgYnl0ZXNcblxuXG4gICAgdGhpcy5wb3MgKz0gZGlmX3c7XG4gIH1cbn07XG5cbkJtcERlY29kZXIucHJvdG90eXBlLmJpdDE2ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGlmX3cgPSB0aGlzLndpZHRoICUgMztcblxuICB2YXIgXzExMTExID0gcGFyc2VJbnQoXCIxMTExMVwiLCAyKSxcbiAgICAgIF8xXzUgPSBfMTExMTE7XG5cbiAgdmFyIF8xMTExMTEgPSBwYXJzZUludChcIjExMTExMVwiLCAyKSxcbiAgICAgIF8xXzYgPSBfMTExMTExO1xuXG4gIGZvciAodmFyIHkgPSB0aGlzLmhlaWdodCAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmJvdHRvbV91cCA/IHkgOiB0aGlzLmhlaWdodCAtIDEgLSB5O1xuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgIHZhciBCID0gdGhpcy5kYXRhdi5nZXRVaW50MTYodGhpcy5wb3MsIHRydWUpO1xuICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgIHZhciBhbHBoYSA9IDB4RkY7XG4gICAgICB2YXIgYmx1ZSA9IChCICYgXzFfNSkgLyBfMV81ICogMjU1IHwgMDtcbiAgICAgIHZhciBncmVlbiA9IChCID4+IDUgJiBfMV82KSAvIF8xXzYgKiAyNTUgfCAwO1xuICAgICAgdmFyIHJlZCA9IChCID4+IDExKSAvIF8xXzUgKiAyNTUgfCAwO1xuICAgICAgdmFyIGxvY2F0aW9uID0gbGluZSAqIHRoaXMud2lkdGggKiA0ICsgeCAqIDQ7XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb25dID0gcmVkO1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMV0gPSBncmVlbjtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDJdID0gYmx1ZTtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDNdID0gYWxwaGE7XG4gICAgfSAvL3NraXAgZXh0cmEgYnl0ZXNcblxuXG4gICAgdGhpcy5wb3MgKz0gZGlmX3c7XG4gIH1cbn07XG5cbkJtcERlY29kZXIucHJvdG90eXBlLmJpdDI0ID0gZnVuY3Rpb24gKCkge1xuICAvL3doZW4gaGVpZ2h0ID4gMFxuICBmb3IgKHZhciB5ID0gdGhpcy5oZWlnaHQgLSAxOyB5ID49IDA7IHktLSkge1xuICAgIHZhciBsaW5lID0gdGhpcy5ib3R0b21fdXAgPyB5IDogdGhpcy5oZWlnaHQgLSAxIC0geTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICB2YXIgYmx1ZSA9IHRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywgdHJ1ZSk7XG4gICAgICB2YXIgZ3JlZW4gPSB0aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssIHRydWUpO1xuICAgICAgdmFyIHJlZCA9IHRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywgdHJ1ZSk7XG4gICAgICB2YXIgbG9jYXRpb24gPSBsaW5lICogdGhpcy53aWR0aCAqIDQgKyB4ICogNDtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbl0gPSByZWQ7XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAxXSA9IGdyZWVuO1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgMl0gPSBibHVlO1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uICsgM10gPSAweEZGO1xuICAgIH0gLy9za2lwIGV4dHJhIGJ5dGVzXG5cblxuICAgIHRoaXMucG9zICs9IHRoaXMud2lkdGggJSA0O1xuICB9XG59O1xuLyoqXG4gKiBhZGQgMzJiaXQgZGVjb2RlIGZ1bmNcbiAqIEBhdXRob3Igc291Ym9rXG4gKi9cblxuXG5CbXBEZWNvZGVyLnByb3RvdHlwZS5iaXQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgLy93aGVuIGhlaWdodCA+IDBcbiAgZm9yICh2YXIgeSA9IHRoaXMuaGVpZ2h0IC0gMTsgeSA+PSAwOyB5LS0pIHtcbiAgICB2YXIgbGluZSA9IHRoaXMuYm90dG9tX3VwID8geSA6IHRoaXMuaGVpZ2h0IC0gMSAtIHk7XG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuICAgICAgdmFyIGJsdWUgPSB0aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssIHRydWUpO1xuICAgICAgdmFyIGdyZWVuID0gdGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCB0cnVlKTtcbiAgICAgIHZhciByZWQgPSB0aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssIHRydWUpO1xuICAgICAgdmFyIGFscGhhID0gdGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCB0cnVlKTtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGxpbmUgKiB0aGlzLndpZHRoICogNCArIHggKiA0O1xuICAgICAgdGhpcy5kYXRhW2xvY2F0aW9uXSA9IHJlZDtcbiAgICAgIHRoaXMuZGF0YVtsb2NhdGlvbiArIDFdID0gZ3JlZW47XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAyXSA9IGJsdWU7XG4gICAgICB0aGlzLmRhdGFbbG9jYXRpb24gKyAzXSA9IGFscGhhO1xuICAgIH0gLy9za2lwIGV4dHJhIGJ5dGVzXG4gICAgLy90aGlzLnBvcyArPSAodGhpcy53aWR0aCAlIDQpO1xuXG4gIH1cbn07XG5cbkJtcERlY29kZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmRhdGE7XG59O1xuLypyb2xsdXAta2VlcGVyLXN0YXJ0Ki9cblxuXG53aW5kb3cudG1wID0gQm1wRGVjb2Rlcjtcbi8qcm9sbHVwLWtlZXBlci1lbmQqL1xuXG4vKlxuIENvcHlyaWdodCAoYykgMjAxMyBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXG4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxuIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG4gSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qXG4gKiBUaGlzIHByb2dyYW0gaXMgYmFzZWQgb24gSlpsaWIgMS4wLjIgeW1uaywgSkNyYWZ0LEluYy5cbiAqIEpabGliIGlzIGJhc2VkIG9uIHpsaWItMS4xLjMsIHNvIGFsbCBjcmVkaXQgc2hvdWxkIGdvIGF1dGhvcnNcbiAqIEplYW4tbG91cCBHYWlsbHkoamxvdXBAZ3ppcC5vcmcpIGFuZCBNYXJrIEFkbGVyKG1hZGxlckBhbHVtbmkuY2FsdGVjaC5lZHUpXG4gKiBhbmQgY29udHJpYnV0b3JzIG9mIHpsaWIuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsKSB7XG5cbiAgdmFyIE1BWF9CSVRTID0gMTU7XG4gIHZhciBEX0NPREVTID0gMzA7XG4gIHZhciBCTF9DT0RFUyA9IDE5O1xuICB2YXIgTEVOR1RIX0NPREVTID0gMjk7XG4gIHZhciBMSVRFUkFMUyA9IDI1NjtcbiAgdmFyIExfQ09ERVMgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4gIHZhciBIRUFQX1NJWkUgPSAyICogTF9DT0RFUyArIDE7XG4gIHZhciBFTkRfQkxPQ0sgPSAyNTY7IC8vIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHNcblxuICB2YXIgTUFYX0JMX0JJVFMgPSA3OyAvLyByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpXG5cbiAgdmFyIFJFUF8zXzYgPSAxNjsgLy8gcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudClcblxuICB2YXIgUkVQWl8zXzEwID0gMTc7IC8vIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudClcblxuICB2YXIgUkVQWl8xMV8xMzggPSAxODsgLy8gVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICAvLyBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0XG4gIC8vIGxlbmd0aCBjb2Rlcy5cblxuICB2YXIgQnVmX3NpemUgPSA4ICogMjsgLy8gSlpsaWIgdmVyc2lvbiA6IFwiMS4wLjJcIlxuXG4gIHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTsgLy8gY29tcHJlc3Npb24gc3RyYXRlZ3lcblxuICB2YXIgWl9GSUxURVJFRCA9IDE7XG4gIHZhciBaX0hVRkZNQU5fT05MWSA9IDI7XG4gIHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwO1xuICB2YXIgWl9OT19GTFVTSCA9IDA7XG4gIHZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuICB2YXIgWl9GVUxMX0ZMVVNIID0gMztcbiAgdmFyIFpfRklOSVNIID0gNDtcbiAgdmFyIFpfT0sgPSAwO1xuICB2YXIgWl9TVFJFQU1fRU5EID0gMTtcbiAgdmFyIFpfTkVFRF9ESUNUID0gMjtcbiAgdmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7XG4gIHZhciBaX0RBVEFfRVJST1IgPSAtMztcbiAgdmFyIFpfQlVGX0VSUk9SID0gLTU7IC8vIFRyZWVcbiAgLy8gc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93XG5cbiAgdmFyIF9kaXN0X2NvZGUgPSBbMCwgMSwgMiwgMywgNCwgNCwgNSwgNSwgNiwgNiwgNiwgNiwgNywgNywgNywgNywgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAwLCAwLCAxNiwgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjldO1xuXG4gIGZ1bmN0aW9uIFRyZWUoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzOyAvLyBkeW5fdHJlZTsgLy8gdGhlIGR5bmFtaWMgdHJlZVxuICAgIC8vIG1heF9jb2RlOyAvLyBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3lcbiAgICAvLyBzdGF0X2Rlc2M7IC8vIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlXG4gICAgLy8gQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdFxuICAgIC8vIGxlbmd0aFxuICAgIC8vIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAgICAvLyBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICAgIC8vIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAgLy8gT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICAgIC8vIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICAgIC8vIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICAgIC8vIG5vdCBudWxsLlxuXG4gICAgZnVuY3Rpb24gZ2VuX2JpdGxlbihzKSB7XG4gICAgICB2YXIgdHJlZSA9IHRoYXQuZHluX3RyZWU7XG4gICAgICB2YXIgc3RyZWUgPSB0aGF0LnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgICAgIHZhciBleHRyYSA9IHRoYXQuc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gICAgICB2YXIgYmFzZSA9IHRoYXQuc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gICAgICB2YXIgbWF4X2xlbmd0aCA9IHRoYXQuc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gICAgICB2YXIgaDsgLy8gaGVhcCBpbmRleFxuXG4gICAgICB2YXIgbiwgbTsgLy8gaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzXG5cbiAgICAgIHZhciBiaXRzOyAvLyBiaXQgbGVuZ3RoXG5cbiAgICAgIHZhciB4Yml0czsgLy8gZXh0cmEgYml0c1xuXG4gICAgICB2YXIgZjsgLy8gZnJlcXVlbmN5XG5cbiAgICAgIHZhciBvdmVyZmxvdyA9IDA7IC8vIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlXG5cbiAgICAgIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgICAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgICAgIH0gLy8gSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICAgIC8vIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuXG5cbiAgICAgIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdID0gMDsgLy8gcm9vdCBvZiB0aGUgaGVhcFxuXG4gICAgICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgICAgIG4gPSBzLmhlYXBbaF07XG4gICAgICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXSAqIDIgKyAxXSArIDE7XG5cbiAgICAgICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICAgICAgb3ZlcmZsb3crKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IGJpdHM7IC8vIFdlIG92ZXJ3cml0ZSB0cmVlW24qMisxXSB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkXG5cbiAgICAgICAgaWYgKG4gPiB0aGF0Lm1heF9jb2RlKSBjb250aW51ZTsgLy8gbm90IGEgbGVhZiBub2RlXG5cbiAgICAgICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgICAgICB4Yml0cyA9IDA7XG4gICAgICAgIGlmIChuID49IGJhc2UpIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgICAgICBmID0gdHJlZVtuICogMl07XG4gICAgICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgICAgIGlmIChzdHJlZSkgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXSArIHhiaXRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG92ZXJmbG93ID09PSAwKSByZXR1cm47IC8vIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzXG4gICAgICAvLyBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOlxuXG4gICAgICBkbyB7XG4gICAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkge1xuICAgICAgICAgIGJpdHMtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMuYmxfY291bnRbYml0c10tLTsgLy8gbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlXG5cbiAgICAgICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLy8gbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlclxuXG4gICAgICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTsgLy8gVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgICAgLy8gYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG5cbiAgICAgICAgb3ZlcmZsb3cgLT0gMjtcbiAgICAgIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgICAgIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgICAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcblxuICAgICAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgICAgICBpZiAobSA+IHRoYXQubWF4X2NvZGUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXSAhPSBiaXRzKSB7XG4gICAgICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0pICogdHJlZVttICogMl07XG4gICAgICAgICAgICB0cmVlW20gKiAyICsgMV0gPSBiaXRzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYVxuICAgIC8vIGZhc3RlclxuICAgIC8vIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAgICAvLyBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG5cblxuICAgIGZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgLy8gdGhlIHZhbHVlIHRvIGludmVydFxuICAgIGxlbiAvLyBpdHMgYml0IGxlbmd0aFxuICAgICkge1xuICAgICAgdmFyIHJlcyA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgICAgICBjb2RlID4+Pj0gMTtcbiAgICAgICAgcmVzIDw8PSAxO1xuICAgICAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcblxuICAgICAgcmV0dXJuIHJlcyA+Pj4gMTtcbiAgICB9IC8vIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICAgIC8vIG9wdGltYWwpLlxuICAgIC8vIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gICAgLy8gdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAgICAvLyBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICAgIC8vIHplcm8gY29kZSBsZW5ndGguXG5cblxuICAgIGZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCAvLyB0aGUgdHJlZSB0byBkZWNvcmF0ZVxuICAgIG1heF9jb2RlLCAvLyBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3lcbiAgICBibF9jb3VudCAvLyBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoXG4gICAgKSB7XG4gICAgICB2YXIgbmV4dF9jb2RlID0gW107IC8vIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaFxuICAgICAgLy8gYml0IGxlbmd0aFxuXG4gICAgICB2YXIgY29kZSA9IDA7IC8vIHJ1bm5pbmcgY29kZSB2YWx1ZVxuXG4gICAgICB2YXIgYml0czsgLy8gYml0IGluZGV4XG5cbiAgICAgIHZhciBuOyAvLyBjb2RlIGluZGV4XG5cbiAgICAgIHZhciBsZW47IC8vIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgICAgLy8gd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG5cbiAgICAgIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgICAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSA8PCAxO1xuICAgICAgfSAvLyBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAgICAvLyBtdXN0IGJlIGFsbCBvbmVzLlxuICAgICAgLy8gQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAgICAgLy8gXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgICAgIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuXG4gICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICAgICAgbGVuID0gdHJlZVtuICogMiArIDFdO1xuICAgICAgICBpZiAobGVuID09PSAwKSBjb250aW51ZTsgLy8gTm93IHJldmVyc2UgdGhlIGJpdHNcblxuICAgICAgICB0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcbiAgICAgIH1cbiAgICB9IC8vIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICAgIC8vIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgLy8gSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICAgIC8vIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAgICAvLyBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICAgIC8vIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cblxuXG4gICAgdGhhdC5idWlsZF90cmVlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgIHZhciB0cmVlID0gdGhhdC5keW5fdHJlZTtcbiAgICAgIHZhciBzdHJlZSA9IHRoYXQuc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICAgICAgdmFyIGVsZW1zID0gdGhhdC5zdGF0X2Rlc2MuZWxlbXM7XG4gICAgICB2YXIgbiwgbTsgLy8gaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHNcblxuICAgICAgdmFyIG1heF9jb2RlID0gLTE7IC8vIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeVxuXG4gICAgICB2YXIgbm9kZTsgLy8gbmV3IG5vZGUgYmVpbmcgY3JlYXRlZFxuICAgICAgLy8gQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgICAgLy8gaGVhcFsxXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICAgIC8vIGhlYXBbMF0gaXMgbm90IHVzZWQuXG5cbiAgICAgIHMuaGVhcF9sZW4gPSAwO1xuICAgICAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICAgICAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICAgICAgaWYgKHRyZWVbbiAqIDJdICE9PSAwKSB7XG4gICAgICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICAgICAgcy5kZXB0aFtuXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJlZVtuICogMiArIDFdID0gMDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgICAgLy8gYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAgICAvLyBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgICAgLy8gdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cblxuXG4gICAgICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICAgICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDA7XG4gICAgICAgIHRyZWVbbm9kZSAqIDJdID0gMTtcbiAgICAgICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgICAgIHMub3B0X2xlbi0tO1xuICAgICAgICBpZiAoc3RyZWUpIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdOyAvLyBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHNcbiAgICAgIH1cblxuICAgICAgdGhhdC5tYXhfY29kZSA9IG1heF9jb2RlOyAvLyBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAgICAvLyBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcblxuICAgICAgZm9yIChuID0gTWF0aC5mbG9vcihzLmhlYXBfbGVuIC8gMik7IG4gPj0gMTsgbi0tKSB7XG4gICAgICAgIHMucHFkb3duaGVhcCh0cmVlLCBuKTtcbiAgICAgIH0gLy8gQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgICAgLy8gZnJlcXVlbnQgbm9kZXMuXG5cblxuICAgICAgbm9kZSA9IGVsZW1zOyAvLyBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWVcblxuICAgICAgZG8ge1xuICAgICAgICAvLyBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3lcbiAgICAgICAgbiA9IHMuaGVhcFsxXTtcbiAgICAgICAgcy5oZWFwWzFdID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgICAgIHMucHFkb3duaGVhcCh0cmVlLCAxKTtcbiAgICAgICAgbSA9IHMuaGVhcFsxXTsgLy8gbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3lcblxuICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8vIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3lcblxuICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07IC8vIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtXG5cbiAgICAgICAgdHJlZVtub2RlICogMl0gPSB0cmVlW24gKiAyXSArIHRyZWVbbSAqIDJdO1xuICAgICAgICBzLmRlcHRoW25vZGVdID0gTWF0aC5tYXgocy5kZXB0aFtuXSwgcy5kZXB0aFttXSkgKyAxO1xuICAgICAgICB0cmVlW24gKiAyICsgMV0gPSB0cmVlW20gKiAyICsgMV0gPSBub2RlOyAvLyBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcFxuXG4gICAgICAgIHMuaGVhcFsxXSA9IG5vZGUrKztcbiAgICAgICAgcy5wcWRvd25oZWFwKHRyZWUsIDEpO1xuICAgICAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMV07IC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICAgIC8vIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cblxuICAgICAgZ2VuX2JpdGxlbihzKTsgLy8gVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2Rlc1xuXG4gICAgICBnZW5fY29kZXModHJlZSwgdGhhdC5tYXhfY29kZSwgcy5ibF9jb3VudCk7XG4gICAgfTtcbiAgfVxuXG4gIFRyZWUuX2xlbmd0aF9jb2RlID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI4XTtcbiAgVHJlZS5iYXNlX2xlbmd0aCA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCAxMCwgMTIsIDE0LCAxNiwgMjAsIDI0LCAyOCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAwXTtcbiAgVHJlZS5iYXNlX2Rpc3QgPSBbMCwgMSwgMiwgMywgNCwgNiwgOCwgMTIsIDE2LCAyNCwgMzIsIDQ4LCA2NCwgOTYsIDEyOCwgMTkyLCAyNTYsIDM4NCwgNTEyLCA3NjgsIDEwMjQsIDE1MzYsIDIwNDgsIDMwNzIsIDQwOTYsIDYxNDQsIDgxOTIsIDEyMjg4LCAxNjM4NCwgMjQ1NzZdOyAvLyBNYXBwaW5nIGZyb20gYSBkaXN0YW5jZSB0byBhIGRpc3RhbmNlIGNvZGUuIGRpc3QgaXMgdGhlIGRpc3RhbmNlIC0gMSBhbmRcbiAgLy8gbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuIF9kaXN0X2NvZGVbMjU2XSBhbmQgX2Rpc3RfY29kZVsyNTddIGFyZSBuZXZlclxuICAvLyB1c2VkLlxuXG4gIFRyZWUuZF9jb2RlID0gZnVuY3Rpb24gKGRpc3QpIHtcbiAgICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG4gIH07IC8vIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGVcblxuXG4gIFRyZWUuZXh0cmFfbGJpdHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMF07IC8vIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZVxuXG4gIFRyZWUuZXh0cmFfZGJpdHMgPSBbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzXTsgLy8gZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGVcblxuICBUcmVlLmV4dHJhX2JsYml0cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyLCAzLCA3XTtcbiAgVHJlZS5ibF9vcmRlciA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTsgLy8gU3RhdGljVHJlZVxuXG4gIGZ1bmN0aW9uIFN0YXRpY1RyZWUoc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuc3RhdGljX3RyZWUgPSBzdGF0aWNfdHJlZTtcbiAgICB0aGF0LmV4dHJhX2JpdHMgPSBleHRyYV9iaXRzO1xuICAgIHRoYXQuZXh0cmFfYmFzZSA9IGV4dHJhX2Jhc2U7XG4gICAgdGhhdC5lbGVtcyA9IGVsZW1zO1xuICAgIHRoYXQubWF4X2xlbmd0aCA9IG1heF9sZW5ndGg7XG4gIH1cblxuICBTdGF0aWNUcmVlLnN0YXRpY19sdHJlZSA9IFsxMiwgOCwgMTQwLCA4LCA3NiwgOCwgMjA0LCA4LCA0NCwgOCwgMTcyLCA4LCAxMDgsIDgsIDIzNiwgOCwgMjgsIDgsIDE1NiwgOCwgOTIsIDgsIDIyMCwgOCwgNjAsIDgsIDE4OCwgOCwgMTI0LCA4LCAyNTIsIDgsIDIsIDgsIDEzMCwgOCwgNjYsIDgsIDE5NCwgOCwgMzQsIDgsIDE2MiwgOCwgOTgsIDgsIDIyNiwgOCwgMTgsIDgsIDE0NiwgOCwgODIsIDgsIDIxMCwgOCwgNTAsIDgsIDE3OCwgOCwgMTE0LCA4LCAyNDIsIDgsIDEwLCA4LCAxMzgsIDgsIDc0LCA4LCAyMDIsIDgsIDQyLCA4LCAxNzAsIDgsIDEwNiwgOCwgMjM0LCA4LCAyNiwgOCwgMTU0LCA4LCA5MCwgOCwgMjE4LCA4LCA1OCwgOCwgMTg2LCA4LCAxMjIsIDgsIDI1MCwgOCwgNiwgOCwgMTM0LCA4LCA3MCwgOCwgMTk4LCA4LCAzOCwgOCwgMTY2LCA4LCAxMDIsIDgsIDIzMCwgOCwgMjIsIDgsIDE1MCwgOCwgODYsIDgsIDIxNCwgOCwgNTQsIDgsIDE4MiwgOCwgMTE4LCA4LCAyNDYsIDgsIDE0LCA4LCAxNDIsIDgsIDc4LCA4LCAyMDYsIDgsIDQ2LCA4LCAxNzQsIDgsIDExMCwgOCwgMjM4LCA4LCAzMCwgOCwgMTU4LCA4LCA5NCwgOCwgMjIyLCA4LCA2MiwgOCwgMTkwLCA4LCAxMjYsIDgsIDI1NCwgOCwgMSwgOCwgMTI5LCA4LCA2NSwgOCwgMTkzLCA4LCAzMywgOCwgMTYxLCA4LCA5NywgOCwgMjI1LCA4LCAxNywgOCwgMTQ1LCA4LCA4MSwgOCwgMjA5LCA4LCA0OSwgOCwgMTc3LCA4LCAxMTMsIDgsIDI0MSwgOCwgOSwgOCwgMTM3LCA4LCA3MywgOCwgMjAxLCA4LCA0MSwgOCwgMTY5LCA4LCAxMDUsIDgsIDIzMywgOCwgMjUsIDgsIDE1MywgOCwgODksIDgsIDIxNywgOCwgNTcsIDgsIDE4NSwgOCwgMTIxLCA4LCAyNDksIDgsIDUsIDgsIDEzMywgOCwgNjksIDgsIDE5NywgOCwgMzcsIDgsIDE2NSwgOCwgMTAxLCA4LCAyMjksIDgsIDIxLCA4LCAxNDksIDgsIDg1LCA4LCAyMTMsIDgsIDUzLCA4LCAxODEsIDgsIDExNywgOCwgMjQ1LCA4LCAxMywgOCwgMTQxLCA4LCA3NywgOCwgMjA1LCA4LCA0NSwgOCwgMTczLCA4LCAxMDksIDgsIDIzNywgOCwgMjksIDgsIDE1NywgOCwgOTMsIDgsIDIyMSwgOCwgNjEsIDgsIDE4OSwgOCwgMTI1LCA4LCAyNTMsIDgsIDE5LCA5LCAyNzUsIDksIDE0NywgOSwgNDAzLCA5LCA4MywgOSwgMzM5LCA5LCAyMTEsIDksIDQ2NywgOSwgNTEsIDksIDMwNywgOSwgMTc5LCA5LCA0MzUsIDksIDExNSwgOSwgMzcxLCA5LCAyNDMsIDksIDQ5OSwgOSwgMTEsIDksIDI2NywgOSwgMTM5LCA5LCAzOTUsIDksIDc1LCA5LCAzMzEsIDksIDIwMywgOSwgNDU5LCA5LCA0MywgOSwgMjk5LCA5LCAxNzEsIDksIDQyNywgOSwgMTA3LCA5LCAzNjMsIDksIDIzNSwgOSwgNDkxLCA5LCAyNywgOSwgMjgzLCA5LCAxNTUsIDksIDQxMSwgOSwgOTEsIDksIDM0NywgOSwgMjE5LCA5LCA0NzUsIDksIDU5LCA5LCAzMTUsIDksIDE4NywgOSwgNDQzLCA5LCAxMjMsIDksIDM3OSwgOSwgMjUxLCA5LCA1MDcsIDksIDcsIDksIDI2MywgOSwgMTM1LCA5LCAzOTEsIDksIDcxLCA5LCAzMjcsIDksIDE5OSwgOSwgNDU1LCA5LCAzOSwgOSwgMjk1LCA5LCAxNjcsIDksIDQyMywgOSwgMTAzLCA5LCAzNTksIDksIDIzMSwgOSwgNDg3LCA5LCAyMywgOSwgMjc5LCA5LCAxNTEsIDksIDQwNywgOSwgODcsIDksIDM0MywgOSwgMjE1LCA5LCA0NzEsIDksIDU1LCA5LCAzMTEsIDksIDE4MywgOSwgNDM5LCA5LCAxMTksIDksIDM3NSwgOSwgMjQ3LCA5LCA1MDMsIDksIDE1LCA5LCAyNzEsIDksIDE0MywgOSwgMzk5LCA5LCA3OSwgOSwgMzM1LCA5LCAyMDcsIDksIDQ2MywgOSwgNDcsIDksIDMwMywgOSwgMTc1LCA5LCA0MzEsIDksIDExMSwgOSwgMzY3LCA5LCAyMzksIDksIDQ5NSwgOSwgMzEsIDksIDI4NywgOSwgMTU5LCA5LCA0MTUsIDksIDk1LCA5LCAzNTEsIDksIDIyMywgOSwgNDc5LCA5LCA2MywgOSwgMzE5LCA5LCAxOTEsIDksIDQ0NywgOSwgMTI3LCA5LCAzODMsIDksIDI1NSwgOSwgNTExLCA5LCAwLCA3LCA2NCwgNywgMzIsIDcsIDk2LCA3LCAxNiwgNywgODAsIDcsIDQ4LCA3LCAxMTIsIDcsIDgsIDcsIDcyLCA3LCA0MCwgNywgMTA0LCA3LCAyNCwgNywgODgsIDcsIDU2LCA3LCAxMjAsIDcsIDQsIDcsIDY4LCA3LCAzNiwgNywgMTAwLCA3LCAyMCwgNywgODQsIDcsIDUyLCA3LCAxMTYsIDcsIDMsIDgsIDEzMSwgOCwgNjcsIDgsIDE5NSwgOCwgMzUsIDgsIDE2MywgOCwgOTksIDgsIDIyNywgOF07XG4gIFN0YXRpY1RyZWUuc3RhdGljX2R0cmVlID0gWzAsIDUsIDE2LCA1LCA4LCA1LCAyNCwgNSwgNCwgNSwgMjAsIDUsIDEyLCA1LCAyOCwgNSwgMiwgNSwgMTgsIDUsIDEwLCA1LCAyNiwgNSwgNiwgNSwgMjIsIDUsIDE0LCA1LCAzMCwgNSwgMSwgNSwgMTcsIDUsIDksIDUsIDI1LCA1LCA1LCA1LCAyMSwgNSwgMTMsIDUsIDI5LCA1LCAzLCA1LCAxOSwgNSwgMTEsIDUsIDI3LCA1LCA3LCA1LCAyMywgNV07XG4gIFN0YXRpY1RyZWUuc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlLCBUcmVlLmV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgU3RhdGljVHJlZS5zdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWUoU3RhdGljVHJlZS5zdGF0aWNfZHRyZWUsIFRyZWUuZXh0cmFfZGJpdHMsIDAsIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgU3RhdGljVHJlZS5zdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKG51bGwsIFRyZWUuZXh0cmFfYmxiaXRzLCAwLCBCTF9DT0RFUywgTUFYX0JMX0JJVFMpOyAvLyBEZWZsYXRlXG5cbiAgdmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuICB2YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cbiAgZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Lmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gICAgdGhhdC5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICAgIHRoYXQubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgICB0aGF0Lm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgICB0aGF0LmZ1bmMgPSBmdW5jO1xuICB9XG5cbiAgdmFyIFNUT1JFRCA9IDA7XG4gIHZhciBGQVNUID0gMTtcbiAgdmFyIFNMT1cgPSAyO1xuICB2YXIgY29uZmlnX3RhYmxlID0gW25ldyBDb25maWcoMCwgMCwgMCwgMCwgU1RPUkVEKSwgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBGQVNUKSwgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgRkFTVCksIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBGQVNUKSwgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgU0xPVyksIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBTTE9XKSwgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIFNMT1cpLCBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgU0xPVyldO1xuICB2YXIgel9lcnJtc2cgPSBbXCJuZWVkIGRpY3Rpb25hcnlcIiwgLy8gWl9ORUVEX0RJQ1RcbiAgLy8gMlxuICBcInN0cmVhbSBlbmRcIiwgLy8gWl9TVFJFQU1fRU5EIDFcbiAgXCJcIiwgLy8gWl9PSyAwXG4gIFwiXCIsIC8vIFpfRVJSTk8gKC0xKVxuICBcInN0cmVhbSBlcnJvclwiLCAvLyBaX1NUUkVBTV9FUlJPUiAoLTIpXG4gIFwiZGF0YSBlcnJvclwiLCAvLyBaX0RBVEFfRVJST1IgKC0zKVxuICBcIlwiLCAvLyBaX01FTV9FUlJPUiAoLTQpXG4gIFwiYnVmZmVyIGVycm9yXCIsIC8vIFpfQlVGX0VSUk9SICgtNSlcbiAgXCJcIiwgLy8gWl9WRVJTSU9OX0VSUk9SICgtNilcbiAgXCJcIl07IC8vIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dFxuXG4gIHZhciBOZWVkTW9yZSA9IDA7IC8vIGJsb2NrIGZsdXNoIHBlcmZvcm1lZFxuXG4gIHZhciBCbG9ja0RvbmUgPSAxOyAvLyBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZVxuXG4gIHZhciBGaW5pc2hTdGFydGVkID0gMjsgLy8gZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dFxuXG4gIHZhciBGaW5pc2hEb25lID0gMzsgLy8gcHJlc2V0IGRpY3Rpb25hcnkgZmxhZyBpbiB6bGliIGhlYWRlclxuXG4gIHZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG4gIHZhciBJTklUX1NUQVRFID0gNDI7XG4gIHZhciBCVVNZX1NUQVRFID0gMTEzO1xuICB2YXIgRklOSVNIX1NUQVRFID0gNjY2OyAvLyBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2RcblxuICB2YXIgWl9ERUZMQVRFRCA9IDg7XG4gIHZhciBTVE9SRURfQkxPQ0sgPSAwO1xuICB2YXIgU1RBVElDX1RSRUVTID0gMTtcbiAgdmFyIERZTl9UUkVFUyA9IDI7XG4gIHZhciBNSU5fTUFUQ0ggPSAzO1xuICB2YXIgTUFYX01BVENIID0gMjU4O1xuICB2YXIgTUlOX0xPT0tBSEVBRCA9IE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDE7XG5cbiAgZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICAgIHZhciB0bjIgPSB0cmVlW24gKiAyXTtcbiAgICB2YXIgdG0yID0gdHJlZVttICogMl07XG4gICAgcmV0dXJuIHRuMiA8IHRtMiB8fCB0bjIgPT0gdG0yICYmIGRlcHRoW25dIDw9IGRlcHRoW21dO1xuICB9XG5cbiAgZnVuY3Rpb24gRGVmbGF0ZSgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHN0cm07IC8vIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtXG5cbiAgICB2YXIgc3RhdHVzOyAvLyBhcyB0aGUgbmFtZSBpbXBsaWVzXG4gICAgLy8gcGVuZGluZ19idWY7IC8vIG91dHB1dCBzdGlsbCBwZW5kaW5nXG5cbiAgICB2YXIgcGVuZGluZ19idWZfc2l6ZTsgLy8gc2l6ZSBvZiBwZW5kaW5nX2J1ZlxuXG4gICAgdmFyIGxhc3RfZmx1c2g7IC8vIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGxcblxuICAgIHZhciB3X3NpemU7IC8vIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KVxuXG4gICAgdmFyIHdfYml0czsgLy8gbG9nMih3X3NpemUpICg4Li4xNilcblxuICAgIHZhciB3X21hc2s7IC8vIHdfc2l6ZSAtIDFcblxuICAgIHZhciB3aW5kb3c7IC8vIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgIC8vIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAgLy8gYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgIC8vIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgIC8vIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLiBBbHNvLCBpdCBsaW1pdHNcbiAgICAvLyB0aGUgd2luZG93IHNpemUgdG8gNjRLLCB3aGljaCBpcyBxdWl0ZSB1c2VmdWwgb24gTVNET1MuXG4gICAgLy8gVG8gZG86IHVzZSB0aGUgdXNlciBpbnB1dCBidWZmZXIgYXMgc2xpZGluZyB3aW5kb3cuXG5cbiAgICB2YXIgd2luZG93X3NpemU7IC8vIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAgLy8gaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cblxuICAgIHZhciBwcmV2OyAvLyBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgIC8vIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAgLy8gQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG5cbiAgICB2YXIgaGVhZDsgLy8gSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC5cblxuICAgIHZhciBpbnNfaDsgLy8gaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWRcblxuICAgIHZhciBoYXNoX3NpemU7IC8vIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlXG5cbiAgICB2YXIgaGFzaF9iaXRzOyAvLyBsb2cyKGhhc2hfc2l6ZSlcblxuICAgIHZhciBoYXNoX21hc2s7IC8vIGhhc2hfc2l6ZS0xXG4gICAgLy8gTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICAvLyBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICAvLyBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICAvLyBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuXG4gICAgdmFyIGhhc2hfc2hpZnQ7IC8vIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgIC8vIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG5cbiAgICB2YXIgYmxvY2tfc3RhcnQ7XG4gICAgdmFyIG1hdGNoX2xlbmd0aDsgLy8gbGVuZ3RoIG9mIGJlc3QgbWF0Y2hcblxuICAgIHZhciBwcmV2X21hdGNoOyAvLyBwcmV2aW91cyBtYXRjaFxuXG4gICAgdmFyIG1hdGNoX2F2YWlsYWJsZTsgLy8gc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0c1xuXG4gICAgdmFyIHN0cnN0YXJ0OyAvLyBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0XG5cbiAgICB2YXIgbWF0Y2hfc3RhcnQ7IC8vIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZ1xuXG4gICAgdmFyIGxvb2thaGVhZDsgLy8gbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvd1xuICAgIC8vIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgIC8vIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuXG4gICAgdmFyIHByZXZfbGVuZ3RoOyAvLyBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgIC8vIGxlbmd0aC4gQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZSBzcGVlZC5cblxuICAgIHZhciBtYXhfY2hhaW5fbGVuZ3RoOyAvLyBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAgLy8gc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICAvLyBsZXZlbHMgPj0gNC5cblxuICAgIHZhciBtYXhfbGF6eV9tYXRjaDsgLy8gSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICAvLyBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgLy8gbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cblxuICAgIHZhciBsZXZlbDsgLy8gY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpXG5cbiAgICB2YXIgc3RyYXRlZ3k7IC8vIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nXG4gICAgLy8gVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzXG5cbiAgICB2YXIgZ29vZF9tYXRjaDsgLy8gU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpc1xuXG4gICAgdmFyIG5pY2VfbWF0Y2g7XG4gICAgdmFyIGR5bl9sdHJlZTsgLy8gbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWVcblxuICAgIHZhciBkeW5fZHRyZWU7IC8vIGRpc3RhbmNlIHRyZWVcblxuICAgIHZhciBibF90cmVlOyAvLyBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzXG5cbiAgICB2YXIgbF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgbGl0ZXJhbCB0cmVlXG5cbiAgICB2YXIgZF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgZGlzdGFuY2UgdHJlZVxuXG4gICAgdmFyIGJsX2Rlc2MgPSBuZXcgVHJlZSgpOyAvLyBkZXNjIGZvciBiaXQgbGVuZ3RoIHRyZWVcbiAgICAvLyB0aGF0LmhlYXBfbGVuOyAvLyBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXBcbiAgICAvLyB0aGF0LmhlYXBfbWF4OyAvLyBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5XG4gICAgLy8gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICAvLyBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgIC8vIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcblxuICAgIHRoYXQuZGVwdGggPSBbXTtcbiAgICB2YXIgbF9idWY7IC8vIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG4gICAgLy8gU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAgLy8gbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgIC8vIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAgLy8gLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICAvLyBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgIC8vIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICAvLyBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICAvLyAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAgLy8gZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgIC8vIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgIC8vIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAgLy8gYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgIC8vIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgIC8vIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAgLy8gZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAgLy8gdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgIC8vIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG5cbiAgICB2YXIgbGl0X2J1ZnNpemU7XG4gICAgdmFyIGxhc3RfbGl0OyAvLyBydW5uaW5nIGluZGV4IGluIGxfYnVmXG4gICAgLy8gQnVmZmVyIGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgIC8vIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAgLy8gYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuXG4gICAgdmFyIGRfYnVmOyAvLyBpbmRleCBvZiBwZW5kaWdfYnVmXG4gICAgLy8gdGhhdC5vcHRfbGVuOyAvLyBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzXG4gICAgLy8gdGhhdC5zdGF0aWNfbGVuOyAvLyBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXNcblxuICAgIHZhciBtYXRjaGVzOyAvLyBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9ja1xuXG4gICAgdmFyIGxhc3RfZW9iX2xlbjsgLy8gYml0IGxlbmd0aCBvZiBFT0IgY29kZSBmb3IgbGFzdCBibG9ja1xuICAgIC8vIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAgLy8gc2lnbmlmaWNhbnQgYml0cykuXG5cbiAgICB2YXIgYmlfYnVmOyAvLyBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgIC8vIGFyZSBhbHdheXMgemVyby5cblxuICAgIHZhciBiaV92YWxpZDsgLy8gbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlXG5cbiAgICB0aGF0LmJsX2NvdW50ID0gW107IC8vIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlc1xuXG4gICAgdGhhdC5oZWFwID0gW107XG4gICAgZHluX2x0cmVlID0gW107XG4gICAgZHluX2R0cmVlID0gW107XG4gICAgYmxfdHJlZSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gbG1faW5pdCgpIHtcbiAgICAgIHZhciBpO1xuICAgICAgd2luZG93X3NpemUgPSAyICogd19zaXplO1xuICAgICAgaGVhZFtoYXNoX3NpemUgLSAxXSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBoYXNoX3NpemUgLSAxOyBpKyspIHtcbiAgICAgICAgaGVhZFtpXSA9IDA7XG4gICAgICB9IC8vIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG5cblxuICAgICAgbWF4X2xhenlfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9sYXp5O1xuICAgICAgZ29vZF9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0uZ29vZF9sZW5ndGg7XG4gICAgICBuaWNlX21hdGNoID0gY29uZmlnX3RhYmxlW2xldmVsXS5uaWNlX2xlbmd0aDtcbiAgICAgIG1heF9jaGFpbl9sZW5ndGggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9jaGFpbjtcbiAgICAgIHN0cnN0YXJ0ID0gMDtcbiAgICAgIGJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIGxvb2thaGVhZCA9IDA7XG4gICAgICBtYXRjaF9sZW5ndGggPSBwcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBtYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgaW5zX2ggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRfYmxvY2soKSB7XG4gICAgICB2YXIgaTsgLy8gSW5pdGlhbGl6ZSB0aGUgdHJlZXMuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBMX0NPREVTOyBpKyspIHtcbiAgICAgICAgZHluX2x0cmVlW2kgKiAyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBEX0NPREVTOyBpKyspIHtcbiAgICAgICAgZHluX2R0cmVlW2kgKiAyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBCTF9DT0RFUzsgaSsrKSB7XG4gICAgICAgIGJsX3RyZWVbaSAqIDJdID0gMDtcbiAgICAgIH1cblxuICAgICAgZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdID0gMTtcbiAgICAgIHRoYXQub3B0X2xlbiA9IHRoYXQuc3RhdGljX2xlbiA9IDA7XG4gICAgICBsYXN0X2xpdCA9IG1hdGNoZXMgPSAwO1xuICAgIH0gLy8gSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuXG5cbiAgICBmdW5jdGlvbiB0cl9pbml0KCkge1xuICAgICAgbF9kZXNjLmR5bl90cmVlID0gZHluX2x0cmVlO1xuICAgICAgbF9kZXNjLnN0YXRfZGVzYyA9IFN0YXRpY1RyZWUuc3RhdGljX2xfZGVzYztcbiAgICAgIGRfZGVzYy5keW5fdHJlZSA9IGR5bl9kdHJlZTtcbiAgICAgIGRfZGVzYy5zdGF0X2Rlc2MgPSBTdGF0aWNUcmVlLnN0YXRpY19kX2Rlc2M7XG4gICAgICBibF9kZXNjLmR5bl90cmVlID0gYmxfdHJlZTtcbiAgICAgIGJsX2Rlc2Muc3RhdF9kZXNjID0gU3RhdGljVHJlZS5zdGF0aWNfYmxfZGVzYztcbiAgICAgIGJpX2J1ZiA9IDA7XG4gICAgICBiaV92YWxpZCA9IDA7XG4gICAgICBsYXN0X2VvYl9sZW4gPSA4OyAvLyBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlXG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTpcblxuICAgICAgaW5pdF9ibG9jaygpO1xuICAgIH0gLy8gUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gICAgLy8gZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSxcbiAgICAvLyBzdG9wcGluZ1xuICAgIC8vIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAgICAvLyB0d28gc29ucykuXG5cblxuICAgIHRoYXQucHFkb3duaGVhcCA9IGZ1bmN0aW9uICh0cmVlLCAvLyB0aGUgdHJlZSB0byByZXN0b3JlXG4gICAgayAvLyBub2RlIHRvIG1vdmUgZG93blxuICAgICkge1xuICAgICAgdmFyIGhlYXAgPSB0aGF0LmhlYXA7XG4gICAgICB2YXIgdiA9IGhlYXBba107XG4gICAgICB2YXIgaiA9IGsgPDwgMTsgLy8gbGVmdCBzb24gb2Yga1xuXG4gICAgICB3aGlsZSAoaiA8PSB0aGF0LmhlYXBfbGVuKSB7XG4gICAgICAgIC8vIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6XG4gICAgICAgIGlmIChqIDwgdGhhdC5oZWFwX2xlbiAmJiBzbWFsbGVyKHRyZWUsIGhlYXBbaiArIDFdLCBoZWFwW2pdLCB0aGF0LmRlcHRoKSkge1xuICAgICAgICAgIGorKztcbiAgICAgICAgfSAvLyBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29uc1xuXG5cbiAgICAgICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgaGVhcFtqXSwgdGhhdC5kZXB0aCkpIGJyZWFrOyAvLyBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvblxuXG4gICAgICAgIGhlYXBba10gPSBoZWFwW2pdO1xuICAgICAgICBrID0gajsgLy8gQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2Yga1xuXG4gICAgICAgIGogPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIGhlYXBba10gPSB2O1xuICAgIH07IC8vIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAgICAvLyBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuXG5cbiAgICBmdW5jdGlvbiBzY2FuX3RyZWUodHJlZSwgLy8gdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZFxuICAgIG1heF9jb2RlIC8vIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeVxuICAgICkge1xuICAgICAgdmFyIG47IC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHNcblxuICAgICAgdmFyIHByZXZsZW4gPSAtMTsgLy8gbGFzdCBlbWl0dGVkIGxlbmd0aFxuXG4gICAgICB2YXIgY3VybGVuOyAvLyBsZW5ndGggb2YgY3VycmVudCBjb2RlXG5cbiAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOyAvLyBsZW5ndGggb2YgbmV4dCBjb2RlXG5cbiAgICAgIHZhciBjb3VudCA9IDA7IC8vIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlXG5cbiAgICAgIHZhciBtYXhfY291bnQgPSA3OyAvLyBtYXggcmVwZWF0IGNvdW50XG5cbiAgICAgIHZhciBtaW5fY291bnQgPSA0OyAvLyBtaW4gcmVwZWF0IGNvdW50XG5cbiAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgICAgbWluX2NvdW50ID0gMztcbiAgICAgIH1cblxuICAgICAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXSA9IDB4ZmZmZjsgLy8gZ3VhcmRcblxuICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07XG5cbiAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09IG5leHRsZW4pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgICAgIGJsX3RyZWVbY3VybGVuICogMl0gKz0gY291bnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGN1cmxlbiAhPSBwcmV2bGVuKSBibF90cmVlW2N1cmxlbiAqIDJdKys7XG4gICAgICAgICAgYmxfdHJlZVtSRVBfM182ICogMl0rKztcbiAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgICAgIGJsX3RyZWVbUkVQWl8zXzEwICogMl0rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibF90cmVlW1JFUFpfMTFfMTM4ICogMl0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgICAgICBtaW5fY291bnQgPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PSBuZXh0bGVuKSB7XG4gICAgICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgICAgICBtaW5fY291bnQgPSAzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICAgICAgbWluX2NvdW50ID0gNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICAgIC8vIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuXG5cbiAgICBmdW5jdGlvbiBidWlsZF9ibF90cmVlKCkge1xuICAgICAgdmFyIG1heF9ibGluZGV4OyAvLyBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzXG5cbiAgICAgIHNjYW5fdHJlZShkeW5fbHRyZWUsIGxfZGVzYy5tYXhfY29kZSk7XG4gICAgICBzY2FuX3RyZWUoZHluX2R0cmVlLCBkX2Rlc2MubWF4X2NvZGUpOyAvLyBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOlxuXG4gICAgICBibF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7IC8vIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICAgIC8vIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZVxuICAgICAgLy8gY291bnRzLlxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAgICAvLyByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgICAgLy8gMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuXG4gICAgICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgICAgIGlmIChibF90cmVlW1RyZWUuYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdICE9PSAwKSBicmVhaztcbiAgICAgIH0gLy8gVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHNcblxuXG4gICAgICB0aGF0Lm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAgICAgcmV0dXJuIG1heF9ibGluZGV4O1xuICAgIH0gLy8gT3V0cHV0IGEgYnl0ZSBvbiB0aGUgc3RyZWFtLlxuICAgIC8vIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ19idWYuXG5cblxuICAgIGZ1bmN0aW9uIHB1dF9ieXRlKHApIHtcbiAgICAgIHRoYXQucGVuZGluZ19idWZbdGhhdC5wZW5kaW5nKytdID0gcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXRfc2hvcnQodykge1xuICAgICAgcHV0X2J5dGUodyAmIDB4ZmYpO1xuICAgICAgcHV0X2J5dGUodyA+Pj4gOCAmIDB4ZmYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1dFNob3J0TVNCKGIpIHtcbiAgICAgIHB1dF9ieXRlKGIgPj4gOCAmIDB4ZmYpO1xuICAgICAgcHV0X2J5dGUoYiAmIDB4ZmYgJiAweGZmKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZW5kX2JpdHModmFsdWUsIGxlbmd0aCkge1xuICAgICAgdmFyIHZhbCxcbiAgICAgICAgICBsZW4gPSBsZW5ndGg7XG5cbiAgICAgIGlmIChiaV92YWxpZCA+IEJ1Zl9zaXplIC0gbGVuKSB7XG4gICAgICAgIHZhbCA9IHZhbHVlOyAvLyBiaV9idWYgfD0gKHZhbCA8PCBiaV92YWxpZCk7XG5cbiAgICAgICAgYmlfYnVmIHw9IHZhbCA8PCBiaV92YWxpZCAmIDB4ZmZmZjtcbiAgICAgICAgcHV0X3Nob3J0KGJpX2J1Zik7XG4gICAgICAgIGJpX2J1ZiA9IHZhbCA+Pj4gQnVmX3NpemUgLSBiaV92YWxpZDtcbiAgICAgICAgYmlfdmFsaWQgKz0gbGVuIC0gQnVmX3NpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBiaV9idWYgfD0gKHZhbHVlKSA8PCBiaV92YWxpZDtcbiAgICAgICAgYmlfYnVmIHw9IHZhbHVlIDw8IGJpX3ZhbGlkICYgMHhmZmZmO1xuICAgICAgICBiaV92YWxpZCArPSBsZW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VuZF9jb2RlKGMsIHRyZWUpIHtcbiAgICAgIHZhciBjMiA9IGMgKiAyO1xuICAgICAgc2VuZF9iaXRzKHRyZWVbYzJdICYgMHhmZmZmLCB0cmVlW2MyICsgMV0gJiAweGZmZmYpO1xuICAgIH0gLy8gU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICAgIC8vIGJsX3RyZWUuXG5cblxuICAgIGZ1bmN0aW9uIHNlbmRfdHJlZSh0cmVlLCAvLyB0aGUgdHJlZSB0byBiZSBzZW50XG4gICAgbWF4X2NvZGUgLy8gYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5XG4gICAgKSB7XG4gICAgICB2YXIgbjsgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50c1xuXG4gICAgICB2YXIgcHJldmxlbiA9IC0xOyAvLyBsYXN0IGVtaXR0ZWQgbGVuZ3RoXG5cbiAgICAgIHZhciBjdXJsZW47IC8vIGxlbmd0aCBvZiBjdXJyZW50IGNvZGVcblxuICAgICAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07IC8vIGxlbmd0aCBvZiBuZXh0IGNvZGVcblxuICAgICAgdmFyIGNvdW50ID0gMDsgLy8gcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGVcblxuICAgICAgdmFyIG1heF9jb3VudCA9IDc7IC8vIG1heCByZXBlYXQgY291bnRcblxuICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7IC8vIG1pbiByZXBlYXQgY291bnRcblxuICAgICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgICBtaW5fY291bnQgPSAzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICAgICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTtcblxuICAgICAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT0gbmV4dGxlbikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgc2VuZF9jb2RlKGN1cmxlbiwgYmxfdHJlZSk7XG4gICAgICAgICAgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGN1cmxlbiAhPSBwcmV2bGVuKSB7XG4gICAgICAgICAgICBzZW5kX2NvZGUoY3VybGVuLCBibF90cmVlKTtcbiAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VuZF9jb2RlKFJFUF8zXzYsIGJsX3RyZWUpO1xuICAgICAgICAgIHNlbmRfYml0cyhjb3VudCAtIDMsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICAgICAgc2VuZF9jb2RlKFJFUFpfM18xMCwgYmxfdHJlZSk7XG4gICAgICAgICAgc2VuZF9iaXRzKGNvdW50IC0gMywgMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VuZF9jb2RlKFJFUFpfMTFfMTM4LCBibF90cmVlKTtcbiAgICAgICAgICBzZW5kX2JpdHMoY291bnQgLSAxMSwgNyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICAgICAgbWluX2NvdW50ID0gMztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT0gbmV4dGxlbikge1xuICAgICAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICAgICAgbWluX2NvdW50ID0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICAgIC8vIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICAgIC8vIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cblxuXG4gICAgZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMobGNvZGVzLCBkY29kZXMsIGJsY29kZXMpIHtcbiAgICAgIHZhciByYW5rOyAvLyBpbmRleCBpbiBibF9vcmRlclxuXG4gICAgICBzZW5kX2JpdHMobGNvZGVzIC0gMjU3LCA1KTsgLy8gbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0XG5cbiAgICAgIHNlbmRfYml0cyhkY29kZXMgLSAxLCA1KTtcbiAgICAgIHNlbmRfYml0cyhibGNvZGVzIC0gNCwgNCk7IC8vIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHRcblxuICAgICAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgICAgICBzZW5kX2JpdHMoYmxfdHJlZVtUcmVlLmJsX29yZGVyW3JhbmtdICogMiArIDFdLCAzKTtcbiAgICAgIH1cblxuICAgICAgc2VuZF90cmVlKGR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8vIGxpdGVyYWwgdHJlZVxuXG4gICAgICBzZW5kX3RyZWUoZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLy8gZGlzdGFuY2UgdHJlZVxuICAgIH0gLy8gRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG5cblxuICAgIGZ1bmN0aW9uIGJpX2ZsdXNoKCkge1xuICAgICAgaWYgKGJpX3ZhbGlkID09IDE2KSB7XG4gICAgICAgIHB1dF9zaG9ydChiaV9idWYpO1xuICAgICAgICBiaV9idWYgPSAwO1xuICAgICAgICBiaV92YWxpZCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGJpX3ZhbGlkID49IDgpIHtcbiAgICAgICAgcHV0X2J5dGUoYmlfYnVmICYgMHhmZik7XG4gICAgICAgIGJpX2J1ZiA+Pj49IDg7XG4gICAgICAgIGJpX3ZhbGlkIC09IDg7XG4gICAgICB9XG4gICAgfSAvLyBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICAgIC8vIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICAgIC8vIFRoZSBjdXJyZW50IGluZmxhdGUgY29kZSByZXF1aXJlcyA5IGJpdHMgb2YgbG9va2FoZWFkLiBJZiB0aGVcbiAgICAvLyBsYXN0IHR3byBjb2RlcyBmb3IgdGhlIHByZXZpb3VzIGJsb2NrIChyZWFsIGNvZGUgcGx1cyBFT0IpIHdlcmUgY29kZWRcbiAgICAvLyBvbiA1IGJpdHMgb3IgbGVzcywgaW5mbGF0ZSBtYXkgaGF2ZSBvbmx5IDUrMyBiaXRzIG9mIGxvb2thaGVhZCB0byBkZWNvZGVcbiAgICAvLyB0aGUgbGFzdCByZWFsIGNvZGUuIEluIHRoaXMgY2FzZSB3ZSBzZW5kIHR3byBlbXB0eSBzdGF0aWMgYmxvY2tzIGluc3RlYWRcbiAgICAvLyBvZiBvbmUuIChUaGVyZSBhcmUgbm8gcHJvYmxlbXMgaWYgdGhlIHByZXZpb3VzIGJsb2NrIGlzIHN0b3JlZCBvciBmaXhlZC4pXG4gICAgLy8gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIGFzc3VtZSB0aGUgd29yc3QgY2FzZSBvZiBsYXN0IHJlYWwgY29kZSBlbmNvZGVkXG4gICAgLy8gb24gb25lIGJpdCBvbmx5LlxuXG5cbiAgICBmdW5jdGlvbiBfdHJfYWxpZ24oKSB7XG4gICAgICBzZW5kX2JpdHMoU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICAgICAgc2VuZF9jb2RlKEVORF9CTE9DSywgU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUpO1xuICAgICAgYmlfZmx1c2goKTsgLy8gT2YgdGhlIDEwIGJpdHMgZm9yIHRoZSBlbXB0eSBibG9jaywgd2UgaGF2ZSBhbHJlYWR5IHNlbnRcbiAgICAgIC8vICgxMCAtIGJpX3ZhbGlkKSBiaXRzLiBUaGUgbG9va2FoZWFkIGZvciB0aGUgbGFzdCByZWFsIGNvZGUgKGJlZm9yZVxuICAgICAgLy8gdGhlIEVPQiBvZiB0aGUgcHJldmlvdXMgYmxvY2spIHdhcyB0aHVzIGF0IGxlYXN0IG9uZSBwbHVzIHRoZSBsZW5ndGhcbiAgICAgIC8vIG9mIHRoZSBFT0IgcGx1cyB3aGF0IHdlIGhhdmUganVzdCBzZW50IG9mIHRoZSBlbXB0eSBzdGF0aWMgYmxvY2suXG5cbiAgICAgIGlmICgxICsgbGFzdF9lb2JfbGVuICsgMTAgLSBiaV92YWxpZCA8IDkpIHtcbiAgICAgICAgc2VuZF9iaXRzKFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgICAgICAgc2VuZF9jb2RlKEVORF9CTE9DSywgU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUpO1xuICAgICAgICBiaV9mbHVzaCgpO1xuICAgICAgfVxuXG4gICAgICBsYXN0X2VvYl9sZW4gPSA3O1xuICAgIH0gLy8gU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gICAgLy8gdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuXG5cbiAgICBmdW5jdGlvbiBfdHJfdGFsbHkoZGlzdCwgLy8gZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmdcbiAgICBsYyAvLyBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKVxuICAgICkge1xuICAgICAgdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG4gICAgICB0aGF0LnBlbmRpbmdfYnVmW2RfYnVmICsgbGFzdF9saXQgKiAyXSA9IGRpc3QgPj4+IDggJiAweGZmO1xuICAgICAgdGhhdC5wZW5kaW5nX2J1ZltkX2J1ZiArIGxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG4gICAgICB0aGF0LnBlbmRpbmdfYnVmW2xfYnVmICsgbGFzdF9saXRdID0gbGMgJiAweGZmO1xuICAgICAgbGFzdF9saXQrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgLy8gbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyXG4gICAgICAgIGR5bl9sdHJlZVtsYyAqIDJdKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVzKys7IC8vIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0hcblxuICAgICAgICBkaXN0LS07IC8vIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDFcblxuICAgICAgICBkeW5fbHRyZWVbKFRyZWUuX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXSsrO1xuICAgICAgICBkeW5fZHRyZWVbVHJlZS5kX2NvZGUoZGlzdCkgKiAyXSsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBsZXZlbCA+IDIpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoXG4gICAgICAgIG91dF9sZW5ndGggPSBsYXN0X2xpdCAqIDg7XG4gICAgICAgIGluX2xlbmd0aCA9IHN0cnN0YXJ0IC0gYmxvY2tfc3RhcnQ7XG5cbiAgICAgICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuICAgICAgICAgIG91dF9sZW5ndGggKz0gZHluX2R0cmVlW2Rjb2RlICogMl0gKiAoNSArIFRyZWUuZXh0cmFfZGJpdHNbZGNvZGVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dF9sZW5ndGggPj4+PSAzO1xuICAgICAgICBpZiAobWF0Y2hlcyA8IE1hdGguZmxvb3IobGFzdF9saXQgLyAyKSAmJiBvdXRfbGVuZ3RoIDwgTWF0aC5mbG9vcihpbl9sZW5ndGggLyAyKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXN0X2xpdCA9PSBsaXRfYnVmc2l6ZSAtIDE7IC8vIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgICAgLy8gb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICAgIC8vIDY0Sy0xIGJ5dGVzLlxuICAgIH0gLy8gU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG5cblxuICAgIGZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKGx0cmVlLCBkdHJlZSkge1xuICAgICAgdmFyIGRpc3Q7IC8vIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nXG5cbiAgICAgIHZhciBsYzsgLy8gbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09PSAwKVxuXG4gICAgICB2YXIgbHggPSAwOyAvLyBydW5uaW5nIGluZGV4IGluIGxfYnVmXG5cbiAgICAgIHZhciBjb2RlOyAvLyB0aGUgY29kZSB0byBzZW5kXG5cbiAgICAgIHZhciBleHRyYTsgLy8gbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZFxuXG4gICAgICBpZiAobGFzdF9saXQgIT09IDApIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGRpc3QgPSB0aGF0LnBlbmRpbmdfYnVmW2RfYnVmICsgbHggKiAyXSA8PCA4ICYgMHhmZjAwIHwgdGhhdC5wZW5kaW5nX2J1ZltkX2J1ZiArIGx4ICogMiArIDFdICYgMHhmZjtcbiAgICAgICAgICBsYyA9IHRoYXQucGVuZGluZ19idWZbbF9idWYgKyBseF0gJiAweGZmO1xuICAgICAgICAgIGx4Kys7XG5cbiAgICAgICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICAgICAgc2VuZF9jb2RlKGxjLCBsdHJlZSk7IC8vIHNlbmQgYSBsaXRlcmFsIGJ5dGVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSFxuICAgICAgICAgICAgY29kZSA9IFRyZWUuX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgICAgIHNlbmRfY29kZShjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8vIHNlbmQgdGhlIGxlbmd0aFxuICAgICAgICAgICAgLy8gY29kZVxuXG4gICAgICAgICAgICBleHRyYSA9IFRyZWUuZXh0cmFfbGJpdHNbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgICAgICBsYyAtPSBUcmVlLmJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgICAgICBzZW5kX2JpdHMobGMsIGV4dHJhKTsgLy8gc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlzdC0tOyAvLyBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxXG5cbiAgICAgICAgICAgIGNvZGUgPSBUcmVlLmRfY29kZShkaXN0KTtcbiAgICAgICAgICAgIHNlbmRfY29kZShjb2RlLCBkdHJlZSk7IC8vIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGVcblxuICAgICAgICAgICAgZXh0cmEgPSBUcmVlLmV4dHJhX2RiaXRzW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICAgICAgZGlzdCAtPSBUcmVlLmJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICAgICAgc2VuZF9iaXRzKGRpc3QsIGV4dHJhKTsgLy8gc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0c1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gbGl0ZXJhbCBvciBtYXRjaCBwYWlyID9cbiAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzXG4gICAgICAgICAgLy8gb2s6XG5cbiAgICAgICAgfSB3aGlsZSAobHggPCBsYXN0X2xpdCk7XG4gICAgICB9XG5cbiAgICAgIHNlbmRfY29kZShFTkRfQkxPQ0ssIGx0cmVlKTtcbiAgICAgIGxhc3RfZW9iX2xlbiA9IGx0cmVlW0VORF9CTE9DSyAqIDIgKyAxXTtcbiAgICB9IC8vIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuXG5cbiAgICBmdW5jdGlvbiBiaV93aW5kdXAoKSB7XG4gICAgICBpZiAoYmlfdmFsaWQgPiA4KSB7XG4gICAgICAgIHB1dF9zaG9ydChiaV9idWYpO1xuICAgICAgfSBlbHNlIGlmIChiaV92YWxpZCA+IDApIHtcbiAgICAgICAgcHV0X2J5dGUoYmlfYnVmICYgMHhmZik7XG4gICAgICB9XG5cbiAgICAgIGJpX2J1ZiA9IDA7XG4gICAgICBiaV92YWxpZCA9IDA7XG4gICAgfSAvLyBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICAgIC8vIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuXG5cbiAgICBmdW5jdGlvbiBjb3B5X2Jsb2NrKGJ1ZiwgLy8gdGhlIGlucHV0IGRhdGFcbiAgICBsZW4sIC8vIGl0cyBsZW5ndGhcbiAgICBoZWFkZXIgLy8gdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuXG4gICAgKSB7XG4gICAgICBiaV93aW5kdXAoKTsgLy8gYWxpZ24gb24gYnl0ZSBib3VuZGFyeVxuXG4gICAgICBsYXN0X2VvYl9sZW4gPSA4OyAvLyBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlXG5cbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgcHV0X3Nob3J0KGxlbik7XG4gICAgICAgIHB1dF9zaG9ydCh+bGVuKTtcbiAgICAgIH1cblxuICAgICAgdGhhdC5wZW5kaW5nX2J1Zi5zZXQod2luZG93LnN1YmFycmF5KGJ1ZiwgYnVmICsgbGVuKSwgdGhhdC5wZW5kaW5nKTtcbiAgICAgIHRoYXQucGVuZGluZyArPSBsZW47XG4gICAgfSAvLyBTZW5kIGEgc3RvcmVkIGJsb2NrXG5cblxuICAgIGZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2soYnVmLCAvLyBpbnB1dCBibG9ja1xuICAgIHN0b3JlZF9sZW4sIC8vIGxlbmd0aCBvZiBpbnB1dCBibG9ja1xuICAgIGVvZiAvLyB0cnVlIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZVxuICAgICkge1xuICAgICAgc2VuZF9iaXRzKChTVE9SRURfQkxPQ0sgPDwgMSkgKyAoZW9mID8gMSA6IDApLCAzKTsgLy8gc2VuZCBibG9jayB0eXBlXG5cbiAgICAgIGNvcHlfYmxvY2soYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLy8gd2l0aCBoZWFkZXJcbiAgICB9IC8vIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICAgIC8vIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cblxuXG4gICAgZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKGJ1ZiwgLy8gaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZFxuICAgIHN0b3JlZF9sZW4sIC8vIGxlbmd0aCBvZiBpbnB1dCBibG9ja1xuICAgIGVvZiAvLyB0cnVlIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZVxuICAgICkge1xuICAgICAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgLy8gb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlc1xuXG4gICAgICB2YXIgbWF4X2JsaW5kZXggPSAwOyAvLyBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxXG4gICAgICAvLyBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkXG5cbiAgICAgIGlmIChsZXZlbCA+IDApIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlc1xuICAgICAgICBsX2Rlc2MuYnVpbGRfdHJlZSh0aGF0KTtcbiAgICAgICAgZF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7IC8vIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3Roc1xuICAgICAgICAvLyBvZlxuICAgICAgICAvLyB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAgICAvLyBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZVxuICAgICAgICAvLyBpbmRleFxuICAgICAgICAvLyBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cblxuICAgICAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUoKTsgLy8gRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIGZpcnN0IHRoZSBibG9jayBsZW5ndGggaW5cbiAgICAgICAgLy8gYnl0ZXNcblxuICAgICAgICBvcHRfbGVuYiA9IHRoYXQub3B0X2xlbiArIDMgKyA3ID4+PiAzO1xuICAgICAgICBzdGF0aWNfbGVuYiA9IHRoYXQuc3RhdGljX2xlbiArIDMgKyA3ID4+PiAzO1xuICAgICAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIG9wdF9sZW5iID0gc3RhdGljX2xlbmI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8vIGZvcmNlIGEgc3RvcmVkIGJsb2NrXG4gICAgICB9XG5cbiAgICAgIGlmIChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYiAmJiBidWYgIT0gLTEpIHtcbiAgICAgICAgLy8gNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3Roc1xuICAgICAgICAvLyBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzXG4gICAgICAgIC8vIHNpbmNlXG4gICAgICAgIC8vIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAgICAvLyBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgICAgLy8gdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgICAgX3RyX3N0b3JlZF9ibG9jayhidWYsIHN0b3JlZF9sZW4sIGVvZik7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRpY19sZW5iID09IG9wdF9sZW5iKSB7XG4gICAgICAgIHNlbmRfYml0cygoU1RBVElDX1RSRUVTIDw8IDEpICsgKGVvZiA/IDEgOiAwKSwgMyk7XG4gICAgICAgIGNvbXByZXNzX2Jsb2NrKFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlLCBTdGF0aWNUcmVlLnN0YXRpY19kdHJlZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZW5kX2JpdHMoKERZTl9UUkVFUyA8PCAxKSArIChlb2YgPyAxIDogMCksIDMpO1xuICAgICAgICBzZW5kX2FsbF90cmVlcyhsX2Rlc2MubWF4X2NvZGUgKyAxLCBkX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgICAgICBjb21wcmVzc19ibG9jayhkeW5fbHRyZWUsIGR5bl9kdHJlZSk7XG4gICAgICB9IC8vIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAgICAvLyBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cblxuXG4gICAgICBpbml0X2Jsb2NrKCk7XG5cbiAgICAgIGlmIChlb2YpIHtcbiAgICAgICAgYmlfd2luZHVwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShlb2YpIHtcbiAgICAgIF90cl9mbHVzaF9ibG9jayhibG9ja19zdGFydCA+PSAwID8gYmxvY2tfc3RhcnQgOiAtMSwgc3Ryc3RhcnQgLSBibG9ja19zdGFydCwgZW9mKTtcblxuICAgICAgYmxvY2tfc3RhcnQgPSBzdHJzdGFydDtcbiAgICAgIHN0cm0uZmx1c2hfcGVuZGluZygpO1xuICAgIH0gLy8gRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAgICAvLyBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gICAgLy9cbiAgICAvLyBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAgICAvLyBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICAgIC8vIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09PSAwOyByZWFkcyBhcmVcbiAgICAvLyBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICAgIC8vIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuXG5cbiAgICBmdW5jdGlvbiBmaWxsX3dpbmRvdygpIHtcbiAgICAgIHZhciBuLCBtO1xuICAgICAgdmFyIHA7XG4gICAgICB2YXIgbW9yZTsgLy8gQW1vdW50IG9mIGZyZWUgc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgd2luZG93LlxuXG4gICAgICBkbyB7XG4gICAgICAgIG1vcmUgPSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0OyAvLyBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OlxuXG4gICAgICAgIGlmIChtb3JlID09PSAwICYmIHN0cnN0YXJ0ID09PSAwICYmIGxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgIG1vcmUgPSB3X3NpemU7XG4gICAgICAgIH0gZWxzZSBpZiAobW9yZSA9PSAtMSkge1xuICAgICAgICAgIC8vIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZiBzdHJzdGFydCA9PVxuICAgICAgICAgIC8vIDBcbiAgICAgICAgICAvLyBhbmQgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgb25lIGJ5dGUgYXQgdGltZSlcbiAgICAgICAgICBtb3JlLS07IC8vIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudFxuICAgICAgICAgIC8vIGxvb2thaGVhZCxcbiAgICAgICAgICAvLyBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZVxuICAgICAgICAgIC8vIHVwcGVyIGhhbGYuXG4gICAgICAgIH0gZWxzZSBpZiAoc3Ryc3RhcnQgPj0gd19zaXplICsgd19zaXplIC0gTUlOX0xPT0tBSEVBRCkge1xuICAgICAgICAgIHdpbmRvdy5zZXQod2luZG93LnN1YmFycmF5KHdfc2l6ZSwgd19zaXplICsgd19zaXplKSwgMCk7XG4gICAgICAgICAgbWF0Y2hfc3RhcnQgLT0gd19zaXplO1xuICAgICAgICAgIHN0cnN0YXJ0IC09IHdfc2l6ZTsgLy8gd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1RcblxuICAgICAgICAgIGJsb2NrX3N0YXJ0IC09IHdfc2l6ZTsgLy8gU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgICAgLy8gYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09XG4gICAgICAgICAgLy8gMFxuICAgICAgICAgIC8vIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbFxuICAgICAgICAgIC8vID4gMFxuICAgICAgICAgIC8vIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgICAgIC8vIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG5cbiAgICAgICAgICBuID0gaGFzaF9zaXplO1xuICAgICAgICAgIHAgPSBuO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbSA9IGhlYWRbLS1wXSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGhlYWRbcF0gPSBtID49IHdfc2l6ZSA/IG0gLSB3X3NpemUgOiAwO1xuICAgICAgICAgIH0gd2hpbGUgKC0tbiAhPT0gMCk7XG5cbiAgICAgICAgICBuID0gd19zaXplO1xuICAgICAgICAgIHAgPSBuO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbSA9IHByZXZbLS1wXSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIHByZXZbcF0gPSBtID49IHdfc2l6ZSA/IG0gLSB3X3NpemUgOiAwOyAvLyBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgICAgLy8gaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICB9IHdoaWxlICgtLW4gIT09IDApO1xuXG4gICAgICAgICAgbW9yZSArPSB3X3NpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgcmV0dXJuOyAvLyBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgICAgLy8gc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgICAgLy8gbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICAgIC8vID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAgICAvLyA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgICAgLy8gSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICAgIC8vIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICYmXG4gICAgICAgIC8vIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG5cbiAgICAgICAgbiA9IHN0cm0ucmVhZF9idWYod2luZG93LCBzdHJzdGFydCArIGxvb2thaGVhZCwgbW9yZSk7XG4gICAgICAgIGxvb2thaGVhZCArPSBuOyAvLyBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDpcblxuICAgICAgICBpZiAobG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGluc19oID0gd2luZG93W3N0cnN0YXJ0XSAmIDB4ZmY7XG4gICAgICAgICAgaW5zX2ggPSAoaW5zX2ggPDwgaGFzaF9zaGlmdCBeIHdpbmRvd1tzdHJzdGFydCArIDFdICYgMHhmZikgJiBoYXNoX21hc2s7XG4gICAgICAgIH0gLy8gSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpc1xuICAgICAgICAvLyBnYXJiYWdlLFxuICAgICAgICAvLyBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlXG4gICAgICAgIC8vIGVtaXR0ZWQuXG5cbiAgICAgIH0gd2hpbGUgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCk7XG4gICAgfSAvLyBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sXG4gICAgLy8gcmV0dXJuXG4gICAgLy8gdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAgICAvLyB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICAgIC8vIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAgICAvLyBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gICAgLy8gd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuXG5cbiAgICBmdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChmbHVzaCkge1xuICAgICAgLy8gU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICAgIC8vIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgICAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuICAgICAgdmFyIG1heF9zdGFydDtcblxuICAgICAgaWYgKG1heF9ibG9ja19zaXplID4gcGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICAgICAgbWF4X2Jsb2NrX3NpemUgPSBwZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgICAgIH0gLy8gQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OlxuXG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOlxuICAgICAgICBpZiAobG9va2FoZWFkIDw9IDEpIHtcbiAgICAgICAgICBmaWxsX3dpbmRvdygpO1xuICAgICAgICAgIGlmIChsb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT0gWl9OT19GTFVTSCkgcmV0dXJuIE5lZWRNb3JlO1xuICAgICAgICAgIGlmIChsb29rYWhlYWQgPT09IDApIGJyZWFrOyAvLyBmbHVzaCB0aGUgY3VycmVudCBibG9ja1xuICAgICAgICB9XG5cbiAgICAgICAgc3Ryc3RhcnQgKz0gbG9va2FoZWFkO1xuICAgICAgICBsb29rYWhlYWQgPSAwOyAvLyBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDpcblxuICAgICAgICBtYXhfc3RhcnQgPSBibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgICAgIGlmIChzdHJzdGFydCA9PT0gMCB8fCBzdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgICAgICAvLyBzdHJzdGFydCA9PT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmVcbiAgICAgICAgICBsb29rYWhlYWQgPSBzdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgICAgICBzdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcbiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHJldHVybiBOZWVkTW9yZTtcbiAgICAgICAgfSAvLyBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgICAgLy8gbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcblxuXG4gICAgICAgIGlmIChzdHJzdGFydCAtIGJsb2NrX3N0YXJ0ID49IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcbiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcbiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHJldHVybiBOZWVkTW9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KGZsdXNoID09IFpfRklOSVNIKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgcmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoU3RhcnRlZCA6IE5lZWRNb3JlO1xuICAgICAgcmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb25nZXN0X21hdGNoKGN1cl9tYXRjaCkge1xuICAgICAgdmFyIGNoYWluX2xlbmd0aCA9IG1heF9jaGFpbl9sZW5ndGg7IC8vIG1heCBoYXNoIGNoYWluIGxlbmd0aFxuXG4gICAgICB2YXIgc2NhbiA9IHN0cnN0YXJ0OyAvLyBjdXJyZW50IHN0cmluZ1xuXG4gICAgICB2YXIgbWF0Y2g7IC8vIG1hdGNoZWQgc3RyaW5nXG5cbiAgICAgIHZhciBsZW47IC8vIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoXG5cbiAgICAgIHZhciBiZXN0X2xlbiA9IHByZXZfbGVuZ3RoOyAvLyBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXJcblxuICAgICAgdmFyIGxpbWl0ID0gc3Ryc3RhcnQgPiB3X3NpemUgLSBNSU5fTE9PS0FIRUFEID8gc3Ryc3RhcnQgLSAod19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwO1xuICAgICAgdmFyIF9uaWNlX21hdGNoID0gbmljZV9tYXRjaDsgLy8gU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICAgIC8vIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG5cbiAgICAgIHZhciB3bWFzayA9IHdfbWFzaztcbiAgICAgIHZhciBzdHJlbmQgPSBzdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgIHZhciBzY2FuX2VuZDEgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICB2YXIgc2Nhbl9lbmQgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuXTsgLy8gVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2ZcbiAgICAgIC8vIDE2LlxuICAgICAgLy8gSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICAgIC8vIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6XG5cbiAgICAgIGlmIChwcmV2X2xlbmd0aCA+PSBnb29kX21hdGNoKSB7XG4gICAgICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgICAgIH0gLy8gRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzXG4gICAgICAvLyBuZWNlc3NhcnlcbiAgICAgIC8vIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuXG5cbiAgICAgIGlmIChfbmljZV9tYXRjaCA+IGxvb2thaGVhZCkgX25pY2VfbWF0Y2ggPSBsb29rYWhlYWQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbWF0Y2ggPSBjdXJfbWF0Y2g7IC8vIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAgICAvLyBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyOlxuXG4gICAgICAgIGlmICh3aW5kb3dbbWF0Y2ggKyBiZXN0X2xlbl0gIT0gc2Nhbl9lbmQgfHwgd2luZG93W21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPSBzY2FuX2VuZDEgfHwgd2luZG93W21hdGNoXSAhPSB3aW5kb3dbc2Nhbl0gfHwgd2luZG93WysrbWF0Y2hdICE9IHdpbmRvd1tzY2FuICsgMV0pIGNvbnRpbnVlOyAvLyBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAgICAvLyBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAgICAvLyBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAgICAvLyBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICAgIC8vIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuXG4gICAgICAgIHNjYW4gKz0gMjtcbiAgICAgICAgbWF0Y2grKzsgLy8gV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgICAgLy8gdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG5cbiAgICAgICAgZG8ge30gd2hpbGUgKHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAgICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgICAgIG1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgICAgIGlmIChsZW4gPj0gX25pY2VfbWF0Y2gpIGJyZWFrO1xuICAgICAgICAgIHNjYW5fZW5kMSA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgICAgICBzY2FuX2VuZCA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW5dO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10gJiAweGZmZmYpID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gICAgICBpZiAoYmVzdF9sZW4gPD0gbG9va2FoZWFkKSByZXR1cm4gYmVzdF9sZW47XG4gICAgICByZXR1cm4gbG9va2FoZWFkO1xuICAgIH0gLy8gQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICAgIC8vIGJsb2NrIHN0YXRlLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICAgIC8vIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICAgIC8vIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cblxuXG4gICAgZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KGZsdXNoKSB7XG4gICAgICAvLyBzaG9ydCBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIHRoZSBoYXNoIGNoYWluXG4gICAgICB2YXIgaGFzaF9oZWFkID0gMDsgLy8gaGVhZCBvZiB0aGUgaGFzaCBjaGFpblxuXG4gICAgICB2YXIgYmZsdXNoOyAvLyBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWRcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICAgIC8vIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAgICAvLyBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAgICBpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgICAgIGZpbGxfd2luZG93KCk7XG5cbiAgICAgICAgICBpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvb2thaGVhZCA9PT0gMCkgYnJlYWs7IC8vIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrXG4gICAgICAgIH0gLy8gSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAgICAvLyBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcblxuXG4gICAgICAgIGlmIChsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgICAgaW5zX2ggPSAoaW5zX2ggPDwgaGFzaF9zaGlmdCBeIHdpbmRvd1tzdHJzdGFydCArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSAmIGhhc2hfbWFzazsgLy8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcblxuICAgICAgICAgIGhhc2hfaGVhZCA9IGhlYWRbaW5zX2hdICYgMHhmZmZmO1xuICAgICAgICAgIHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XG4gICAgICAgICAgaGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcbiAgICAgICAgfSAvLyBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuXG5cbiAgICAgICAgaWYgKGhhc2hfaGVhZCAhPT0gMCAmJiAoc3Ryc3RhcnQgLSBoYXNoX2hlYWQgJiAweGZmZmYpIDw9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcbiAgICAgICAgICAvLyBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICAgIC8vIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICAgIC8vIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAgICBpZiAoc3RyYXRlZ3kgIT0gWl9IVUZGTUFOX09OTFkpIHtcbiAgICAgICAgICAgIG1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2goaGFzaF9oZWFkKTtcbiAgICAgICAgICB9IC8vIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAgICAgLy8gY2hlY2tfbWF0Y2goc3Ryc3RhcnQsIG1hdGNoX3N0YXJ0LCBtYXRjaF9sZW5ndGgpO1xuICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseShzdHJzdGFydCAtIG1hdGNoX3N0YXJ0LCBtYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgICAgIGxvb2thaGVhZCAtPSBtYXRjaF9sZW5ndGg7IC8vIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAgICAvLyBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuXG4gICAgICAgICAgaWYgKG1hdGNoX2xlbmd0aCA8PSBtYXhfbGF6eV9tYXRjaCAmJiBsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgICAgICBtYXRjaF9sZW5ndGgtLTsgLy8gc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gaGFzaCB0YWJsZVxuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHN0cnN0YXJ0Kys7XG4gICAgICAgICAgICAgIGluc19oID0gKGluc19oIDw8IGhhc2hfc2hpZnQgXiB3aW5kb3dbc3Ryc3RhcnQgKyAoTUlOX01BVENIIC0gMSldICYgMHhmZikgJiBoYXNoX21hc2s7IC8vIHByZXZbc3Ryc3RhcnQmd19tYXNrXT1oYXNoX2hlYWQ9aGVhZFtpbnNfaF07XG5cbiAgICAgICAgICAgICAgaGFzaF9oZWFkID0gaGVhZFtpbnNfaF0gJiAweGZmZmY7XG4gICAgICAgICAgICAgIHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XG4gICAgICAgICAgICAgIGhlYWRbaW5zX2hdID0gc3Ryc3RhcnQ7IC8vIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgICAgLy8gYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgIH0gd2hpbGUgKC0tbWF0Y2hfbGVuZ3RoICE9PSAwKTtcblxuICAgICAgICAgICAgc3Ryc3RhcnQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Ryc3RhcnQgKz0gbWF0Y2hfbGVuZ3RoO1xuICAgICAgICAgICAgbWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGluc19oID0gd2luZG93W3N0cnN0YXJ0XSAmIDB4ZmY7XG4gICAgICAgICAgICBpbnNfaCA9IChpbnNfaCA8PCBoYXNoX3NoaWZ0IF4gd2luZG93W3N0cnN0YXJ0ICsgMV0gJiAweGZmKSAmIGhhc2hfbWFzazsgLy8gSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lc1xuICAgICAgICAgICAgLy8gbm90XG4gICAgICAgICAgICAvLyBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlXG4gICAgICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KDAsIHdpbmRvd1tzdHJzdGFydF0gJiAweGZmKTtcbiAgICAgICAgICBsb29rYWhlYWQtLTtcbiAgICAgICAgICBzdHJzdGFydCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xuICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgcmV0dXJuIE5lZWRNb3JlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkoZmx1c2ggPT0gWl9GSU5JU0gpO1xuXG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09IFpfRklOSVNIKSByZXR1cm4gRmluaXNoU3RhcnRlZDtlbHNlIHJldHVybiBOZWVkTW9yZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcbiAgICB9IC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAgICAvLyBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gICAgLy8gbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cblxuXG4gICAgZnVuY3Rpb24gZGVmbGF0ZV9zbG93KGZsdXNoKSB7XG4gICAgICAvLyBzaG9ydCBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIGhhc2ggY2hhaW5cbiAgICAgIHZhciBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIGhhc2ggY2hhaW5cblxuICAgICAgdmFyIGJmbHVzaDsgLy8gc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkXG5cbiAgICAgIHZhciBtYXhfaW5zZXJ0OyAvLyBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay5cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICAgIC8vIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAgICAvLyBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAgICBpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgICAgIGZpbGxfd2luZG93KCk7XG5cbiAgICAgICAgICBpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvb2thaGVhZCA9PT0gMCkgYnJlYWs7IC8vIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrXG4gICAgICAgIH0gLy8gSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAgICAvLyBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcblxuXG4gICAgICAgIGlmIChsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgICAgaW5zX2ggPSAoaW5zX2ggPDwgaGFzaF9zaGlmdCBeIHdpbmRvd1tzdHJzdGFydCArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSAmIGhhc2hfbWFzazsgLy8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcblxuICAgICAgICAgIGhhc2hfaGVhZCA9IGhlYWRbaW5zX2hdICYgMHhmZmZmO1xuICAgICAgICAgIHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XG4gICAgICAgICAgaGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcbiAgICAgICAgfSAvLyBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuXG5cbiAgICAgICAgcHJldl9sZW5ndGggPSBtYXRjaF9sZW5ndGg7XG4gICAgICAgIHByZXZfbWF0Y2ggPSBtYXRjaF9zdGFydDtcbiAgICAgICAgbWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHByZXZfbGVuZ3RoIDwgbWF4X2xhenlfbWF0Y2ggJiYgKHN0cnN0YXJ0IC0gaGFzaF9oZWFkICYgMHhmZmZmKSA8PSB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICAgICAgLy8gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAgICAvLyBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAgICAvLyBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgICAgaWYgKHN0cmF0ZWd5ICE9IFpfSFVGRk1BTl9PTkxZKSB7XG4gICAgICAgICAgICBtYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKGhhc2hfaGVhZCk7XG4gICAgICAgICAgfSAvLyBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydFxuXG5cbiAgICAgICAgICBpZiAobWF0Y2hfbGVuZ3RoIDw9IDUgJiYgKHN0cmF0ZWd5ID09IFpfRklMVEVSRUQgfHwgbWF0Y2hfbGVuZ3RoID09IE1JTl9NQVRDSCAmJiBzdHJzdGFydCAtIG1hdGNoX3N0YXJ0ID4gNDA5NikpIHtcbiAgICAgICAgICAgIC8vIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAgICBtYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcblxuXG4gICAgICAgIGlmIChwcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgbWF0Y2hfbGVuZ3RoIDw9IHByZXZfbGVuZ3RoKSB7XG4gICAgICAgICAgbWF4X2luc2VydCA9IHN0cnN0YXJ0ICsgbG9va2FoZWFkIC0gTUlOX01BVENIOyAvLyBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy5cbiAgICAgICAgICAvLyBjaGVja19tYXRjaChzdHJzdGFydC0xLCBwcmV2X21hdGNoLCBwcmV2X2xlbmd0aCk7XG5cbiAgICAgICAgICBiZmx1c2ggPSBfdHJfdGFsbHkoc3Ryc3RhcnQgLSAxIC0gcHJldl9tYXRjaCwgcHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpOyAvLyBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAgICAvLyBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgICAgLy8gZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICAgIC8vIHRoZSBoYXNoIHRhYmxlLlxuXG4gICAgICAgICAgbG9va2FoZWFkIC09IHByZXZfbGVuZ3RoIC0gMTtcbiAgICAgICAgICBwcmV2X2xlbmd0aCAtPSAyO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKCsrc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgICAgICBpbnNfaCA9IChpbnNfaCA8PCBoYXNoX3NoaWZ0IF4gd2luZG93W3N0cnN0YXJ0ICsgKE1JTl9NQVRDSCAtIDEpXSAmIDB4ZmYpICYgaGFzaF9tYXNrOyAvLyBwcmV2W3N0cnN0YXJ0JndfbWFza109aGFzaF9oZWFkPWhlYWRbaW5zX2hdO1xuXG4gICAgICAgICAgICAgIGhhc2hfaGVhZCA9IGhlYWRbaW5zX2hdICYgMHhmZmZmO1xuICAgICAgICAgICAgICBwcmV2W3N0cnN0YXJ0ICYgd19tYXNrXSA9IGhlYWRbaW5zX2hdO1xuICAgICAgICAgICAgICBoZWFkW2luc19oXSA9IHN0cnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKC0tcHJldl9sZW5ndGggIT09IDApO1xuXG4gICAgICAgICAgbWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgICAgICBtYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgICAgIHN0cnN0YXJ0Kys7XG5cbiAgICAgICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgcmV0dXJuIE5lZWRNb3JlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaF9hdmFpbGFibGUgIT09IDApIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICAgIC8vIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAgICAvLyBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseSgwLCB3aW5kb3dbc3Ryc3RhcnQgLSAxXSAmIDB4ZmYpO1xuXG4gICAgICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3Ryc3RhcnQrKztcbiAgICAgICAgICBsb29rYWhlYWQtLTtcbiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHJldHVybiBOZWVkTW9yZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgICAgLy8gdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgICAgbWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgICAgICBzdHJzdGFydCsrO1xuICAgICAgICAgIGxvb2thaGVhZC0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaF9hdmFpbGFibGUgIT09IDApIHtcbiAgICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KDAsIHdpbmRvd1tzdHJzdGFydCAtIDFdICYgMHhmZik7XG4gICAgICAgIG1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkoZmx1c2ggPT0gWl9GSU5JU0gpO1xuXG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09IFpfRklOSVNIKSByZXR1cm4gRmluaXNoU3RhcnRlZDtlbHNlIHJldHVybiBOZWVkTW9yZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgICAgIHN0cm0ubXNnID0gbnVsbDsgLy9cblxuICAgICAgdGhhdC5wZW5kaW5nID0gMDtcbiAgICAgIHRoYXQucGVuZGluZ19vdXQgPSAwO1xuICAgICAgc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIGxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICAgICAgdHJfaW5pdCgpO1xuICAgICAgbG1faW5pdCgpO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgdGhhdC5kZWZsYXRlSW5pdCA9IGZ1bmN0aW9uIChzdHJtLCBfbGV2ZWwsIGJpdHMsIF9tZXRob2QsIG1lbUxldmVsLCBfc3RyYXRlZ3kpIHtcbiAgICAgIGlmICghX21ldGhvZCkgX21ldGhvZCA9IFpfREVGTEFURUQ7XG4gICAgICBpZiAoIW1lbUxldmVsKSBtZW1MZXZlbCA9IERFRl9NRU1fTEVWRUw7XG4gICAgICBpZiAoIV9zdHJhdGVneSkgX3N0cmF0ZWd5ID0gWl9ERUZBVUxUX1NUUkFURUdZOyAvLyBieXRlW10gbXlfdmVyc2lvbj1aTElCX1ZFUlNJT047XG4gICAgICAvL1xuICAgICAgLy8gaWYgKCF2ZXJzaW9uIHx8IHZlcnNpb25bMF0gIT0gbXlfdmVyc2lvblswXVxuICAgICAgLy8gfHwgc3RyZWFtX3NpemUgIT0gc2l6ZW9mKHpfc3RyZWFtKSkge1xuICAgICAgLy8gcmV0dXJuIFpfVkVSU0lPTl9FUlJPUjtcbiAgICAgIC8vIH1cblxuICAgICAgc3RybS5tc2cgPSBudWxsO1xuICAgICAgaWYgKF9sZXZlbCA9PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIF9sZXZlbCA9IDY7XG5cbiAgICAgIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IF9tZXRob2QgIT0gWl9ERUZMQVRFRCB8fCBiaXRzIDwgOSB8fCBiaXRzID4gMTUgfHwgX2xldmVsIDwgMCB8fCBfbGV2ZWwgPiA5IHx8IF9zdHJhdGVneSA8IDAgfHwgX3N0cmF0ZWd5ID4gWl9IVUZGTUFOX09OTFkpIHtcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgICAgfVxuXG4gICAgICBzdHJtLmRzdGF0ZSA9IHRoYXQ7XG4gICAgICB3X2JpdHMgPSBiaXRzO1xuICAgICAgd19zaXplID0gMSA8PCB3X2JpdHM7XG4gICAgICB3X21hc2sgPSB3X3NpemUgLSAxO1xuICAgICAgaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICAgICAgaGFzaF9zaXplID0gMSA8PCBoYXNoX2JpdHM7XG4gICAgICBoYXNoX21hc2sgPSBoYXNoX3NpemUgLSAxO1xuICAgICAgaGFzaF9zaGlmdCA9IE1hdGguZmxvb3IoKGhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcbiAgICAgIHdpbmRvdyA9IG5ldyBVaW50OEFycmF5KHdfc2l6ZSAqIDIpO1xuICAgICAgcHJldiA9IFtdO1xuICAgICAgaGVhZCA9IFtdO1xuICAgICAgbGl0X2J1ZnNpemUgPSAxIDw8IG1lbUxldmVsICsgNjsgLy8gMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHRcbiAgICAgIC8vIFdlIG92ZXJsYXkgcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmLiBUaGlzIHdvcmtzIHNpbmNlIHRoZSBhdmVyYWdlXG4gICAgICAvLyBvdXRwdXQgc2l6ZSBmb3IgKGxlbmd0aCxkaXN0YW5jZSkgY29kZXMgaXMgPD0gMjQgYml0cy5cblxuICAgICAgdGhhdC5wZW5kaW5nX2J1ZiA9IG5ldyBVaW50OEFycmF5KGxpdF9idWZzaXplICogNCk7XG4gICAgICBwZW5kaW5nX2J1Zl9zaXplID0gbGl0X2J1ZnNpemUgKiA0O1xuICAgICAgZF9idWYgPSBNYXRoLmZsb29yKGxpdF9idWZzaXplIC8gMik7XG4gICAgICBsX2J1ZiA9ICgxICsgMikgKiBsaXRfYnVmc2l6ZTtcbiAgICAgIGxldmVsID0gX2xldmVsO1xuICAgICAgc3RyYXRlZ3kgPSBfc3RyYXRlZ3k7XG4gICAgICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xuICAgIH07XG5cbiAgICB0aGF0LmRlZmxhdGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3RhdHVzICE9IElOSVRfU1RBVEUgJiYgc3RhdHVzICE9IEJVU1lfU1RBVEUgJiYgc3RhdHVzICE9IEZJTklTSF9TVEFURSkge1xuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgICB9IC8vIERlYWxsb2NhdGUgaW4gcmV2ZXJzZSBvcmRlciBvZiBhbGxvY2F0aW9uczpcblxuXG4gICAgICB0aGF0LnBlbmRpbmdfYnVmID0gbnVsbDtcbiAgICAgIGhlYWQgPSBudWxsO1xuICAgICAgcHJldiA9IG51bGw7XG4gICAgICB3aW5kb3cgPSBudWxsOyAvLyBmcmVlXG5cbiAgICAgIHRoYXQuZHN0YXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBzdGF0dXMgPT0gQlVTWV9TVEFURSA/IFpfREFUQV9FUlJPUiA6IFpfT0s7XG4gICAgfTtcblxuICAgIHRoYXQuZGVmbGF0ZVBhcmFtcyA9IGZ1bmN0aW9uIChzdHJtLCBfbGV2ZWwsIF9zdHJhdGVneSkge1xuICAgICAgdmFyIGVyciA9IFpfT0s7XG5cbiAgICAgIGlmIChfbGV2ZWwgPT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgICAgIF9sZXZlbCA9IDY7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbGV2ZWwgPCAwIHx8IF9sZXZlbCA+IDkgfHwgX3N0cmF0ZWd5IDwgMCB8fCBfc3RyYXRlZ3kgPiBaX0hVRkZNQU5fT05MWSkge1xuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWdfdGFibGVbbGV2ZWxdLmZ1bmMgIT0gY29uZmlnX3RhYmxlW19sZXZlbF0uZnVuYyAmJiBzdHJtLnRvdGFsX2luICE9PSAwKSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBsYXN0IGJ1ZmZlcjpcbiAgICAgICAgZXJyID0gc3RybS5kZWZsYXRlKFpfUEFSVElBTF9GTFVTSCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZXZlbCAhPSBfbGV2ZWwpIHtcbiAgICAgICAgbGV2ZWwgPSBfbGV2ZWw7XG4gICAgICAgIG1heF9sYXp5X21hdGNoID0gY29uZmlnX3RhYmxlW2xldmVsXS5tYXhfbGF6eTtcbiAgICAgICAgZ29vZF9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0uZ29vZF9sZW5ndGg7XG4gICAgICAgIG5pY2VfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICAgICAgICBtYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlnX3RhYmxlW2xldmVsXS5tYXhfY2hhaW47XG4gICAgICB9XG5cbiAgICAgIHN0cmF0ZWd5ID0gX3N0cmF0ZWd5O1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9O1xuXG4gICAgdGhhdC5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uIChzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcbiAgICAgIHZhciBuLFxuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgIGlmICghZGljdGlvbmFyeSB8fCBzdGF0dXMgIT0gSU5JVF9TVEFURSkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgICAgaWYgKGxlbmd0aCA8IE1JTl9NQVRDSCkgcmV0dXJuIFpfT0s7XG5cbiAgICAgIGlmIChsZW5ndGggPiB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICAgIGxlbmd0aCA9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQ7XG4gICAgICAgIGluZGV4ID0gZGljdExlbmd0aCAtIGxlbmd0aDsgLy8gdXNlIHRoZSB0YWlsIG9mIHRoZSBkaWN0aW9uYXJ5XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5zZXQoZGljdGlvbmFyeS5zdWJhcnJheShpbmRleCwgaW5kZXggKyBsZW5ndGgpLCAwKTtcbiAgICAgIHN0cnN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgYmxvY2tfc3RhcnQgPSBsZW5ndGg7IC8vIEluc2VydCBhbGwgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSAoZXhjZXB0IGZvciB0aGUgbGFzdCB0d28gYnl0ZXMpLlxuICAgICAgLy8gcy0+bG9va2FoZWFkIHN0YXlzIG51bGwsIHNvIHMtPmluc19oIHdpbGwgYmUgcmVjb21wdXRlZCBhdCB0aGUgbmV4dFxuICAgICAgLy8gY2FsbCBvZiBmaWxsX3dpbmRvdy5cblxuICAgICAgaW5zX2ggPSB3aW5kb3dbMF0gJiAweGZmO1xuICAgICAgaW5zX2ggPSAoaW5zX2ggPDwgaGFzaF9zaGlmdCBeIHdpbmRvd1sxXSAmIDB4ZmYpICYgaGFzaF9tYXNrO1xuXG4gICAgICBmb3IgKG4gPSAwOyBuIDw9IGxlbmd0aCAtIE1JTl9NQVRDSDsgbisrKSB7XG4gICAgICAgIGluc19oID0gKGluc19oIDw8IGhhc2hfc2hpZnQgXiB3aW5kb3dbbiArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSAmIGhhc2hfbWFzaztcbiAgICAgICAgcHJldltuICYgd19tYXNrXSA9IGhlYWRbaW5zX2hdO1xuICAgICAgICBoZWFkW2luc19oXSA9IG47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBaX09LO1xuICAgIH07XG5cbiAgICB0aGF0LmRlZmxhdGUgPSBmdW5jdGlvbiAoX3N0cm0sIGZsdXNoKSB7XG4gICAgICB2YXIgaSwgaGVhZGVyLCBsZXZlbF9mbGFncywgb2xkX2ZsdXNoLCBic3RhdGU7XG5cbiAgICAgIGlmIChmbHVzaCA+IFpfRklOSVNIIHx8IGZsdXNoIDwgMCkge1xuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3N0cm0ubmV4dF9vdXQgfHwgIV9zdHJtLm5leHRfaW4gJiYgX3N0cm0uYXZhaWxfaW4gIT09IDAgfHwgc3RhdHVzID09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPSBaX0ZJTklTSCkge1xuICAgICAgICBfc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIFpfU1RSRUFNX0VSUk9SXTtcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3N0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIF9zdHJtLm1zZyA9IHpfZXJybXNnW1pfTkVFRF9ESUNUIC0gWl9CVUZfRVJST1JdO1xuICAgICAgICByZXR1cm4gWl9CVUZfRVJST1I7XG4gICAgICB9XG5cbiAgICAgIHN0cm0gPSBfc3RybTsgLy8ganVzdCBpbiBjYXNlXG5cbiAgICAgIG9sZF9mbHVzaCA9IGxhc3RfZmx1c2g7XG4gICAgICBsYXN0X2ZsdXNoID0gZmx1c2g7IC8vIFdyaXRlIHRoZSB6bGliIGhlYWRlclxuXG4gICAgICBpZiAoc3RhdHVzID09IElOSVRfU1RBVEUpIHtcbiAgICAgICAgaGVhZGVyID0gWl9ERUZMQVRFRCArICh3X2JpdHMgLSA4IDw8IDQpIDw8IDg7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gKGxldmVsIC0gMSAmIDB4ZmYpID4+IDE7XG4gICAgICAgIGlmIChsZXZlbF9mbGFncyA+IDMpIGxldmVsX2ZsYWdzID0gMztcbiAgICAgICAgaGVhZGVyIHw9IGxldmVsX2ZsYWdzIDw8IDY7XG4gICAgICAgIGlmIChzdHJzdGFydCAhPT0gMCkgaGVhZGVyIHw9IFBSRVNFVF9ESUNUO1xuICAgICAgICBoZWFkZXIgKz0gMzEgLSBoZWFkZXIgJSAzMTtcbiAgICAgICAgc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgICAgcHV0U2hvcnRNU0IoaGVhZGVyKTtcbiAgICAgIH0gLy8gRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZVxuXG5cbiAgICAgIGlmICh0aGF0LnBlbmRpbmcgIT09IDApIHtcbiAgICAgICAgc3RybS5mbHVzaF9wZW5kaW5nKCk7XG5cbiAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCIgYXZhaWxfb3V0PT0wXCIpO1xuICAgICAgICAgIC8vIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAgICAvLyBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICAgIC8vIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICAgIC8vIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgICAgLy8gcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICAgIGxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgICAgfSAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGVcbiAgICAgICAgLy8gY29uc2VjdXRpdmVcbiAgICAgICAgLy8gZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgICAgLy8gcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGRl9FUlJPUi5cblxuICAgICAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIGZsdXNoIDw9IG9sZF9mbHVzaCAmJiBmbHVzaCAhPSBaX0ZJTklTSCkge1xuICAgICAgICBzdHJtLm1zZyA9IHpfZXJybXNnW1pfTkVFRF9ESUNUIC0gWl9CVUZfRVJST1JdO1xuICAgICAgICByZXR1cm4gWl9CVUZfRVJST1I7XG4gICAgICB9IC8vIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6XG5cblxuICAgICAgaWYgKHN0YXR1cyA9PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgICAgICBfc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIFpfQlVGX0VSUk9SXTtcbiAgICAgICAgcmV0dXJuIFpfQlVGX0VSUk9SO1xuICAgICAgfSAvLyBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG5cblxuICAgICAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgbG9va2FoZWFkICE9PSAwIHx8IGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgc3RhdHVzICE9IEZJTklTSF9TVEFURSkge1xuICAgICAgICBic3RhdGUgPSAtMTtcblxuICAgICAgICBzd2l0Y2ggKGNvbmZpZ190YWJsZVtsZXZlbF0uZnVuYykge1xuICAgICAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAgICAgYnN0YXRlID0gZGVmbGF0ZV9zdG9yZWQoZmx1c2gpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIEZBU1Q6XG4gICAgICAgICAgICBic3RhdGUgPSBkZWZsYXRlX2Zhc3QoZmx1c2gpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFNMT1c6XG4gICAgICAgICAgICBic3RhdGUgPSBkZWZsYXRlX3Nsb3coZmx1c2gpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJzdGF0ZSA9PSBGaW5pc2hTdGFydGVkIHx8IGJzdGF0ZSA9PSBGaW5pc2hEb25lKSB7XG4gICAgICAgICAgc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJzdGF0ZSA9PSBOZWVkTW9yZSB8fCBic3RhdGUgPT0gRmluaXNoU3RhcnRlZCkge1xuICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgICAgbGFzdF9mbHVzaCA9IC0xOyAvLyBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gWl9PSzsgLy8gSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAgICAvLyBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICAgIC8vIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgICAgLy8gZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgICAgLy8gb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJzdGF0ZSA9PSBCbG9ja0RvbmUpIHtcbiAgICAgICAgICBpZiAoZmx1c2ggPT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgICAgICBfdHJfYWxpZ24oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIXG4gICAgICAgICAgICBfdHJfc3RvcmVkX2Jsb2NrKDAsIDAsIGZhbHNlKTsgLy8gRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICAgIC8vIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG5cblxuICAgICAgICAgICAgaWYgKGZsdXNoID09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgICAgICAvLyBzdGF0ZS5oZWFkW3MuaGFzaF9zaXplLTFdPTA7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoYXNoX3NpemVcbiAgICAgICAgICAgICAgLyotMSovXG4gICAgICAgICAgICAgIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yZ2V0IGhpc3RvcnlcbiAgICAgICAgICAgICAgICBoZWFkW2ldID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0cm0uZmx1c2hfcGVuZGluZygpO1xuXG4gICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgICBsYXN0X2ZsdXNoID0gLTE7IC8vIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZVxuXG4gICAgICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZsdXNoICE9IFpfRklOSVNIKSByZXR1cm4gWl9PSztcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FTkQ7XG4gICAgfTtcbiAgfSAvLyBaU3RyZWFtXG5cblxuICBmdW5jdGlvbiBaU3RyZWFtKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Lm5leHRfaW5faW5kZXggPSAwO1xuICAgIHRoYXQubmV4dF9vdXRfaW5kZXggPSAwOyAvLyB0aGF0Lm5leHRfaW47IC8vIG5leHQgaW5wdXQgYnl0ZVxuXG4gICAgdGhhdC5hdmFpbF9pbiA9IDA7IC8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgbmV4dF9pblxuXG4gICAgdGhhdC50b3RhbF9pbiA9IDA7IC8vIHRvdGFsIG5iIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyXG4gICAgLy8gdGhhdC5uZXh0X291dDsgLy8gbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlXG5cbiAgICB0aGF0LmF2YWlsX291dCA9IDA7IC8vIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG5leHRfb3V0XG5cbiAgICB0aGF0LnRvdGFsX291dCA9IDA7IC8vIHRvdGFsIG5iIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXJcbiAgICAvLyB0aGF0Lm1zZztcbiAgICAvLyB0aGF0LmRzdGF0ZTtcbiAgfVxuXG4gIFpTdHJlYW0ucHJvdG90eXBlID0ge1xuICAgIGRlZmxhdGVJbml0OiBmdW5jdGlvbiBkZWZsYXRlSW5pdChsZXZlbCwgYml0cykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdGhhdC5kc3RhdGUgPSBuZXcgRGVmbGF0ZSgpO1xuICAgICAgaWYgKCFiaXRzKSBiaXRzID0gTUFYX0JJVFM7XG4gICAgICByZXR1cm4gdGhhdC5kc3RhdGUuZGVmbGF0ZUluaXQodGhhdCwgbGV2ZWwsIGJpdHMpO1xuICAgIH0sXG4gICAgZGVmbGF0ZTogZnVuY3Rpb24gZGVmbGF0ZShmbHVzaCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoYXQuZHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoYXQuZHN0YXRlLmRlZmxhdGUodGhhdCwgZmx1c2gpO1xuICAgIH0sXG4gICAgZGVmbGF0ZUVuZDogZnVuY3Rpb24gZGVmbGF0ZUVuZCgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGlmICghdGhhdC5kc3RhdGUpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICAgIHZhciByZXQgPSB0aGF0LmRzdGF0ZS5kZWZsYXRlRW5kKCk7XG4gICAgICB0aGF0LmRzdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgZGVmbGF0ZVBhcmFtczogZnVuY3Rpb24gZGVmbGF0ZVBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGlmICghdGhhdC5kc3RhdGUpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICAgIHJldHVybiB0aGF0LmRzdGF0ZS5kZWZsYXRlUGFyYW1zKHRoYXQsIGxldmVsLCBzdHJhdGVneSk7XG4gICAgfSxcbiAgICBkZWZsYXRlU2V0RGljdGlvbmFyeTogZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgaWYgKCF0aGF0LmRzdGF0ZSkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgICAgcmV0dXJuIHRoYXQuZHN0YXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoYXQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xuICAgIH0sXG4gICAgLy8gUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGVcbiAgICAvLyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICAgIC8vIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5uZXh0X2luIGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICAgIC8vIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICAgIHJlYWRfYnVmOiBmdW5jdGlvbiByZWFkX2J1ZihidWYsIHN0YXJ0LCBzaXplKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuID0gdGhhdC5hdmFpbF9pbjtcbiAgICAgIGlmIChsZW4gPiBzaXplKSBsZW4gPSBzaXplO1xuICAgICAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICB0aGF0LmF2YWlsX2luIC09IGxlbjtcbiAgICAgIGJ1Zi5zZXQodGhhdC5uZXh0X2luLnN1YmFycmF5KHRoYXQubmV4dF9pbl9pbmRleCwgdGhhdC5uZXh0X2luX2luZGV4ICsgbGVuKSwgc3RhcnQpO1xuICAgICAgdGhhdC5uZXh0X2luX2luZGV4ICs9IGxlbjtcbiAgICAgIHRoYXQudG90YWxfaW4gKz0gbGVuO1xuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9LFxuICAgIC8vIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAgICAvLyB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gICAgLy8gdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfb3V0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICAgIC8vIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAgICBmbHVzaF9wZW5kaW5nOiBmdW5jdGlvbiBmbHVzaF9wZW5kaW5nKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGxlbiA9IHRoYXQuZHN0YXRlLnBlbmRpbmc7XG4gICAgICBpZiAobGVuID4gdGhhdC5hdmFpbF9vdXQpIGxlbiA9IHRoYXQuYXZhaWxfb3V0O1xuICAgICAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuOyAvLyBpZiAodGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoIDw9IHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0IHx8IHRoYXQubmV4dF9vdXQubGVuZ3RoIDw9IHRoYXQubmV4dF9vdXRfaW5kZXhcbiAgICAgIC8vIHx8IHRoYXQuZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aCA8ICh0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCArIGxlbikgfHwgdGhhdC5uZXh0X291dC5sZW5ndGggPCAodGhhdC5uZXh0X291dF9pbmRleCArXG4gICAgICAvLyBsZW4pKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGF0LmRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGggKyBcIiwgXCIgKyB0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCArIFwiLCBcIiArIHRoYXQubmV4dF9vdXQubGVuZ3RoICsgXCIsIFwiICtcbiAgICAgIC8vIHRoYXQubmV4dF9vdXRfaW5kZXggKyBcIiwgXCIgKyBsZW4pO1xuICAgICAgLy8gY29uc29sZS5sb2coXCJhdmFpbF9vdXQ9XCIgKyB0aGF0LmF2YWlsX291dCk7XG4gICAgICAvLyB9XG5cbiAgICAgIHRoYXQubmV4dF9vdXQuc2V0KHRoYXQuZHN0YXRlLnBlbmRpbmdfYnVmLnN1YmFycmF5KHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0LCB0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCArIGxlbiksIHRoYXQubmV4dF9vdXRfaW5kZXgpO1xuICAgICAgdGhhdC5uZXh0X291dF9pbmRleCArPSBsZW47XG4gICAgICB0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCArPSBsZW47XG4gICAgICB0aGF0LnRvdGFsX291dCArPSBsZW47XG4gICAgICB0aGF0LmF2YWlsX291dCAtPSBsZW47XG4gICAgICB0aGF0LmRzdGF0ZS5wZW5kaW5nIC09IGxlbjtcblxuICAgICAgaWYgKHRoYXQuZHN0YXRlLnBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgdGhhdC5kc3RhdGUucGVuZGluZ19vdXQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gRGVmbGF0ZXJcblxuICBmdW5jdGlvbiBEZWZsYXRlcihvcHRpb25zKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB6ID0gbmV3IFpTdHJlYW0oKTtcbiAgICB2YXIgYnVmc2l6ZSA9IDUxMjtcbiAgICB2YXIgZmx1c2ggPSBaX05PX0ZMVVNIO1xuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShidWZzaXplKTtcbiAgICB2YXIgbGV2ZWwgPSBvcHRpb25zID8gb3B0aW9ucy5sZXZlbCA6IFpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgICBpZiAodHlwZW9mIGxldmVsID09IFwidW5kZWZpbmVkXCIpIGxldmVsID0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xuICAgIHouZGVmbGF0ZUluaXQobGV2ZWwpO1xuICAgIHoubmV4dF9vdXQgPSBidWY7XG5cbiAgICB0aGF0LmFwcGVuZCA9IGZ1bmN0aW9uIChkYXRhLCBvbnByb2dyZXNzKSB7XG4gICAgICB2YXIgZXJyLFxuICAgICAgICAgIGJ1ZmZlcnMgPSBbXSxcbiAgICAgICAgICBsYXN0SW5kZXggPSAwLFxuICAgICAgICAgIGJ1ZmZlckluZGV4ID0gMCxcbiAgICAgICAgICBidWZmZXJTaXplID0gMCxcbiAgICAgICAgICBhcnJheTtcbiAgICAgIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjtcbiAgICAgIHoubmV4dF9pbl9pbmRleCA9IDA7XG4gICAgICB6Lm5leHRfaW4gPSBkYXRhO1xuICAgICAgei5hdmFpbF9pbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xuICAgICAgICB6LmF2YWlsX291dCA9IGJ1ZnNpemU7XG4gICAgICAgIGVyciA9IHouZGVmbGF0ZShmbHVzaCk7XG4gICAgICAgIGlmIChlcnIgIT0gWl9PSykgdGhyb3cgbmV3IEVycm9yKFwiZGVmbGF0aW5nOiBcIiArIHoubXNnKTtcbiAgICAgICAgaWYgKHoubmV4dF9vdXRfaW5kZXgpIGlmICh6Lm5leHRfb3V0X2luZGV4ID09IGJ1ZnNpemUpIGJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShidWYpKTtlbHNlIGJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShidWYuc3ViYXJyYXkoMCwgei5uZXh0X291dF9pbmRleCkpKTtcbiAgICAgICAgYnVmZmVyU2l6ZSArPSB6Lm5leHRfb3V0X2luZGV4O1xuXG4gICAgICAgIGlmIChvbnByb2dyZXNzICYmIHoubmV4dF9pbl9pbmRleCA+IDAgJiYgei5uZXh0X2luX2luZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIG9ucHJvZ3Jlc3Moei5uZXh0X2luX2luZGV4KTtcbiAgICAgICAgICBsYXN0SW5kZXggPSB6Lm5leHRfaW5faW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHouYXZhaWxfaW4gPiAwIHx8IHouYXZhaWxfb3V0ID09PSAwKTtcblxuICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJTaXplKTtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgYXJyYXkuc2V0KGNodW5rLCBidWZmZXJJbmRleCk7XG4gICAgICAgIGJ1ZmZlckluZGV4ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG5cbiAgICB0aGF0LmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVycixcbiAgICAgICAgICBidWZmZXJzID0gW10sXG4gICAgICAgICAgYnVmZmVySW5kZXggPSAwLFxuICAgICAgICAgIGJ1ZmZlclNpemUgPSAwLFxuICAgICAgICAgIGFycmF5O1xuXG4gICAgICBkbyB7XG4gICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xuICAgICAgICB6LmF2YWlsX291dCA9IGJ1ZnNpemU7XG4gICAgICAgIGVyciA9IHouZGVmbGF0ZShaX0ZJTklTSCk7XG4gICAgICAgIGlmIChlcnIgIT0gWl9TVFJFQU1fRU5EICYmIGVyciAhPSBaX09LKSB0aHJvdyBuZXcgRXJyb3IoXCJkZWZsYXRpbmc6IFwiICsgei5tc2cpO1xuICAgICAgICBpZiAoYnVmc2l6ZSAtIHouYXZhaWxfb3V0ID4gMCkgYnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1Zi5zdWJhcnJheSgwLCB6Lm5leHRfb3V0X2luZGV4KSkpO1xuICAgICAgICBidWZmZXJTaXplICs9IHoubmV4dF9vdXRfaW5kZXg7XG4gICAgICB9IHdoaWxlICh6LmF2YWlsX2luID4gMCB8fCB6LmF2YWlsX291dCA9PT0gMCk7XG5cbiAgICAgIHouZGVmbGF0ZUVuZCgpO1xuICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJTaXplKTtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgYXJyYXkuc2V0KGNodW5rLCBidWZmZXJJbmRleCk7XG4gICAgICAgIGJ1ZmZlckluZGV4ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG4gIH0gLy8gJ3ppcCcgbWF5IG5vdCBiZSBkZWZpbmVkIGluIHotd29ya2VyIGFuZCBzb21lIHRlc3RzXG5cblxuICB2YXIgZW52ID0gZ2xvYmFsLnppcCB8fCBnbG9iYWw7XG4gIGVudi5EZWZsYXRlciA9IGVudi5fanpsaWJfRGVmbGF0ZXIgPSBEZWZsYXRlcjtcbn0pKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLmNvbnRlbnQnKSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkpOyAvLyBgc2VsZmAgaXMgdW5kZWZpbmVkIGluIEZpcmVmb3ggZm9yIEFuZHJvaWQgY29udGVudCBzY3JpcHQgY29udGV4dFxuLy8gd2hpbGUgYHRoaXNgIGlzIG5zSUNvbnRlbnRGcmFtZU1lc3NhZ2VNYW5hZ2VyXG4vLyB3aXRoIGFuIGF0dHJpYnV0ZSBgY29udGVudGAgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgd2luZG93XG5cbi8qKlxuICogQSBjbGFzcyB0byBwYXJzZSBjb2xvciB2YWx1ZXNcbiAqIEBhdXRob3IgU3RveWFuIFN0ZWZhbm92IDxzc3Rvb0BnbWFpbC5jb20+XG4gKiB7QGxpbmsgICBodHRwOi8vd3d3LnBocGllZC5jb20vcmdiLWNvbG9yLXBhcnNlci1pbi1qYXZhc2NyaXB0L31cbiAqIEBsaWNlbnNlIFVzZSBpdCBpZiB5b3UgbGlrZSBpdFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xuXG4gIGZ1bmN0aW9uIFJHQkNvbG9yKGNvbG9yX3N0cmluZykge1xuICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZyB8fCAnJztcbiAgICB0aGlzLm9rID0gZmFsc2U7IC8vIHN0cmlwIGFueSBsZWFkaW5nICNcblxuICAgIGlmIChjb2xvcl9zdHJpbmcuY2hhckF0KDApID09ICcjJykge1xuICAgICAgLy8gcmVtb3ZlICMgaWYgYW55XG4gICAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcuc3Vic3RyKDEsIDYpO1xuICAgIH1cblxuICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy5yZXBsYWNlKC8gL2csICcnKTtcbiAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY2hhbm5lbHM7IC8vIGJlZm9yZSBnZXR0aW5nIGludG8gcmVnZXhwcywgdHJ5IHNpbXBsZSBtYXRjaGVzXG4gICAgLy8gYW5kIG92ZXJ3cml0ZSB0aGUgaW5wdXRcblxuICAgIHZhciBzaW1wbGVfY29sb3JzID0ge1xuICAgICAgYWxpY2VibHVlOiAnZjBmOGZmJyxcbiAgICAgIGFudGlxdWV3aGl0ZTogJ2ZhZWJkNycsXG4gICAgICBhcXVhOiAnMDBmZmZmJyxcbiAgICAgIGFxdWFtYXJpbmU6ICc3ZmZmZDQnLFxuICAgICAgYXp1cmU6ICdmMGZmZmYnLFxuICAgICAgYmVpZ2U6ICdmNWY1ZGMnLFxuICAgICAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgICAgIGJsYWNrOiAnMDAwMDAwJyxcbiAgICAgIGJsYW5jaGVkYWxtb25kOiAnZmZlYmNkJyxcbiAgICAgIGJsdWU6ICcwMDAwZmYnLFxuICAgICAgYmx1ZXZpb2xldDogJzhhMmJlMicsXG4gICAgICBicm93bjogJ2E1MmEyYScsXG4gICAgICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICAgICAgY2FkZXRibHVlOiAnNWY5ZWEwJyxcbiAgICAgIGNoYXJ0cmV1c2U6ICc3ZmZmMDAnLFxuICAgICAgY2hvY29sYXRlOiAnZDI2OTFlJyxcbiAgICAgIGNvcmFsOiAnZmY3ZjUwJyxcbiAgICAgIGNvcm5mbG93ZXJibHVlOiAnNjQ5NWVkJyxcbiAgICAgIGNvcm5zaWxrOiAnZmZmOGRjJyxcbiAgICAgIGNyaW1zb246ICdkYzE0M2MnLFxuICAgICAgY3lhbjogJzAwZmZmZicsXG4gICAgICBkYXJrYmx1ZTogJzAwMDA4YicsXG4gICAgICBkYXJrY3lhbjogJzAwOGI4YicsXG4gICAgICBkYXJrZ29sZGVucm9kOiAnYjg4NjBiJyxcbiAgICAgIGRhcmtncmF5OiAnYTlhOWE5JyxcbiAgICAgIGRhcmtncmVlbjogJzAwNjQwMCcsXG4gICAgICBkYXJra2hha2k6ICdiZGI3NmInLFxuICAgICAgZGFya21hZ2VudGE6ICc4YjAwOGInLFxuICAgICAgZGFya29saXZlZ3JlZW46ICc1NTZiMmYnLFxuICAgICAgZGFya29yYW5nZTogJ2ZmOGMwMCcsXG4gICAgICBkYXJrb3JjaGlkOiAnOTkzMmNjJyxcbiAgICAgIGRhcmtyZWQ6ICc4YjAwMDAnLFxuICAgICAgZGFya3NhbG1vbjogJ2U5OTY3YScsXG4gICAgICBkYXJrc2VhZ3JlZW46ICc4ZmJjOGYnLFxuICAgICAgZGFya3NsYXRlYmx1ZTogJzQ4M2Q4YicsXG4gICAgICBkYXJrc2xhdGVncmF5OiAnMmY0ZjRmJyxcbiAgICAgIGRhcmt0dXJxdW9pc2U6ICcwMGNlZDEnLFxuICAgICAgZGFya3Zpb2xldDogJzk0MDBkMycsXG4gICAgICBkZWVwcGluazogJ2ZmMTQ5MycsXG4gICAgICBkZWVwc2t5Ymx1ZTogJzAwYmZmZicsXG4gICAgICBkaW1ncmF5OiAnNjk2OTY5JyxcbiAgICAgIGRvZGdlcmJsdWU6ICcxZTkwZmYnLFxuICAgICAgZmVsZHNwYXI6ICdkMTkyNzUnLFxuICAgICAgZmlyZWJyaWNrOiAnYjIyMjIyJyxcbiAgICAgIGZsb3JhbHdoaXRlOiAnZmZmYWYwJyxcbiAgICAgIGZvcmVzdGdyZWVuOiAnMjI4YjIyJyxcbiAgICAgIGZ1Y2hzaWE6ICdmZjAwZmYnLFxuICAgICAgZ2FpbnNib3JvOiAnZGNkY2RjJyxcbiAgICAgIGdob3N0d2hpdGU6ICdmOGY4ZmYnLFxuICAgICAgZ29sZDogJ2ZmZDcwMCcsXG4gICAgICBnb2xkZW5yb2Q6ICdkYWE1MjAnLFxuICAgICAgZ3JheTogJzgwODA4MCcsXG4gICAgICBncmVlbjogJzAwODAwMCcsXG4gICAgICBncmVlbnllbGxvdzogJ2FkZmYyZicsXG4gICAgICBob25leWRldzogJ2YwZmZmMCcsXG4gICAgICBob3RwaW5rOiAnZmY2OWI0JyxcbiAgICAgIGluZGlhbnJlZDogJ2NkNWM1YycsXG4gICAgICBpbmRpZ286ICc0YjAwODInLFxuICAgICAgaXZvcnk6ICdmZmZmZjAnLFxuICAgICAga2hha2k6ICdmMGU2OGMnLFxuICAgICAgbGF2ZW5kZXI6ICdlNmU2ZmEnLFxuICAgICAgbGF2ZW5kZXJibHVzaDogJ2ZmZjBmNScsXG4gICAgICBsYXduZ3JlZW46ICc3Y2ZjMDAnLFxuICAgICAgbGVtb25jaGlmZm9uOiAnZmZmYWNkJyxcbiAgICAgIGxpZ2h0Ymx1ZTogJ2FkZDhlNicsXG4gICAgICBsaWdodGNvcmFsOiAnZjA4MDgwJyxcbiAgICAgIGxpZ2h0Y3lhbjogJ2UwZmZmZicsXG4gICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJ2ZhZmFkMicsXG4gICAgICBsaWdodGdyZXk6ICdkM2QzZDMnLFxuICAgICAgbGlnaHRncmVlbjogJzkwZWU5MCcsXG4gICAgICBsaWdodHBpbms6ICdmZmI2YzEnLFxuICAgICAgbGlnaHRzYWxtb246ICdmZmEwN2EnLFxuICAgICAgbGlnaHRzZWFncmVlbjogJzIwYjJhYScsXG4gICAgICBsaWdodHNreWJsdWU6ICc4N2NlZmEnLFxuICAgICAgbGlnaHRzbGF0ZWJsdWU6ICc4NDcwZmYnLFxuICAgICAgbGlnaHRzbGF0ZWdyYXk6ICc3Nzg4OTknLFxuICAgICAgbGlnaHRzdGVlbGJsdWU6ICdiMGM0ZGUnLFxuICAgICAgbGlnaHR5ZWxsb3c6ICdmZmZmZTAnLFxuICAgICAgbGltZTogJzAwZmYwMCcsXG4gICAgICBsaW1lZ3JlZW46ICczMmNkMzInLFxuICAgICAgbGluZW46ICdmYWYwZTYnLFxuICAgICAgbWFnZW50YTogJ2ZmMDBmZicsXG4gICAgICBtYXJvb246ICc4MDAwMDAnLFxuICAgICAgbWVkaXVtYXF1YW1hcmluZTogJzY2Y2RhYScsXG4gICAgICBtZWRpdW1ibHVlOiAnMDAwMGNkJyxcbiAgICAgIG1lZGl1bW9yY2hpZDogJ2JhNTVkMycsXG4gICAgICBtZWRpdW1wdXJwbGU6ICc5MzcwZDgnLFxuICAgICAgbWVkaXVtc2VhZ3JlZW46ICczY2IzNzEnLFxuICAgICAgbWVkaXVtc2xhdGVibHVlOiAnN2I2OGVlJyxcbiAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnMDBmYTlhJyxcbiAgICAgIG1lZGl1bXR1cnF1b2lzZTogJzQ4ZDFjYycsXG4gICAgICBtZWRpdW12aW9sZXRyZWQ6ICdjNzE1ODUnLFxuICAgICAgbWlkbmlnaHRibHVlOiAnMTkxOTcwJyxcbiAgICAgIG1pbnRjcmVhbTogJ2Y1ZmZmYScsXG4gICAgICBtaXN0eXJvc2U6ICdmZmU0ZTEnLFxuICAgICAgbW9jY2FzaW46ICdmZmU0YjUnLFxuICAgICAgbmF2YWpvd2hpdGU6ICdmZmRlYWQnLFxuICAgICAgbmF2eTogJzAwMDA4MCcsXG4gICAgICBvbGRsYWNlOiAnZmRmNWU2JyxcbiAgICAgIG9saXZlOiAnODA4MDAwJyxcbiAgICAgIG9saXZlZHJhYjogJzZiOGUyMycsXG4gICAgICBvcmFuZ2U6ICdmZmE1MDAnLFxuICAgICAgb3JhbmdlcmVkOiAnZmY0NTAwJyxcbiAgICAgIG9yY2hpZDogJ2RhNzBkNicsXG4gICAgICBwYWxlZ29sZGVucm9kOiAnZWVlOGFhJyxcbiAgICAgIHBhbGVncmVlbjogJzk4ZmI5OCcsXG4gICAgICBwYWxldHVycXVvaXNlOiAnYWZlZWVlJyxcbiAgICAgIHBhbGV2aW9sZXRyZWQ6ICdkODcwOTMnLFxuICAgICAgcGFwYXlhd2hpcDogJ2ZmZWZkNScsXG4gICAgICBwZWFjaHB1ZmY6ICdmZmRhYjknLFxuICAgICAgcGVydTogJ2NkODUzZicsXG4gICAgICBwaW5rOiAnZmZjMGNiJyxcbiAgICAgIHBsdW06ICdkZGEwZGQnLFxuICAgICAgcG93ZGVyYmx1ZTogJ2IwZTBlNicsXG4gICAgICBwdXJwbGU6ICc4MDAwODAnLFxuICAgICAgcmVkOiAnZmYwMDAwJyxcbiAgICAgIHJvc3licm93bjogJ2JjOGY4ZicsXG4gICAgICByb3lhbGJsdWU6ICc0MTY5ZTEnLFxuICAgICAgc2FkZGxlYnJvd246ICc4YjQ1MTMnLFxuICAgICAgc2FsbW9uOiAnZmE4MDcyJyxcbiAgICAgIHNhbmR5YnJvd246ICdmNGE0NjAnLFxuICAgICAgc2VhZ3JlZW46ICcyZThiNTcnLFxuICAgICAgc2Vhc2hlbGw6ICdmZmY1ZWUnLFxuICAgICAgc2llbm5hOiAnYTA1MjJkJyxcbiAgICAgIHNpbHZlcjogJ2MwYzBjMCcsXG4gICAgICBza3libHVlOiAnODdjZWViJyxcbiAgICAgIHNsYXRlYmx1ZTogJzZhNWFjZCcsXG4gICAgICBzbGF0ZWdyYXk6ICc3MDgwOTAnLFxuICAgICAgc25vdzogJ2ZmZmFmYScsXG4gICAgICBzcHJpbmdncmVlbjogJzAwZmY3ZicsXG4gICAgICBzdGVlbGJsdWU6ICc0NjgyYjQnLFxuICAgICAgdGFuOiAnZDJiNDhjJyxcbiAgICAgIHRlYWw6ICcwMDgwODAnLFxuICAgICAgdGhpc3RsZTogJ2Q4YmZkOCcsXG4gICAgICB0b21hdG86ICdmZjYzNDcnLFxuICAgICAgdHVycXVvaXNlOiAnNDBlMGQwJyxcbiAgICAgIHZpb2xldDogJ2VlODJlZScsXG4gICAgICB2aW9sZXRyZWQ6ICdkMDIwOTAnLFxuICAgICAgd2hlYXQ6ICdmNWRlYjMnLFxuICAgICAgd2hpdGU6ICdmZmZmZmYnLFxuICAgICAgd2hpdGVzbW9rZTogJ2Y1ZjVmNScsXG4gICAgICB5ZWxsb3c6ICdmZmZmMDAnLFxuICAgICAgeWVsbG93Z3JlZW46ICc5YWNkMzInXG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzaW1wbGVfY29sb3JzKSB7XG4gICAgICBpZiAoY29sb3Jfc3RyaW5nID09IGtleSkge1xuICAgICAgICBjb2xvcl9zdHJpbmcgPSBzaW1wbGVfY29sb3JzW2tleV07XG4gICAgICB9XG4gICAgfSAvLyBlbWQgb2Ygc2ltcGxlIHR5cGUtaW4gY29sb3JzXG4gICAgLy8gYXJyYXkgb2YgY29sb3IgZGVmaW5pdGlvbiBvYmplY3RzXG5cblxuICAgIHZhciBjb2xvcl9kZWZzID0gW3tcbiAgICAgIHJlOiAvXnJnYlxcKChcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKihcXGR7MSwzfSlcXCkkLyxcbiAgICAgIGV4YW1wbGU6IFsncmdiKDEyMywgMjM0LCA0NSknLCAncmdiKDI1NSwyMzQsMjQ1KSddLFxuICAgICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcyhiaXRzKSB7XG4gICAgICAgIHJldHVybiBbcGFyc2VJbnQoYml0c1sxXSksIHBhcnNlSW50KGJpdHNbMl0pLCBwYXJzZUludChiaXRzWzNdKV07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcmU6IC9eKFxcd3syfSkoXFx3ezJ9KShcXHd7Mn0pJC8sXG4gICAgICBleGFtcGxlOiBbJyMwMGZmMDAnLCAnMzM2Njk5J10sXG4gICAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKGJpdHMpIHtcbiAgICAgICAgcmV0dXJuIFtwYXJzZUludChiaXRzWzFdLCAxNiksIHBhcnNlSW50KGJpdHNbMl0sIDE2KSwgcGFyc2VJbnQoYml0c1szXSwgMTYpXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICByZTogL14oXFx3ezF9KShcXHd7MX0pKFxcd3sxfSkkLyxcbiAgICAgIGV4YW1wbGU6IFsnI2ZiMCcsICdmMGYnXSxcbiAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoYml0cykge1xuICAgICAgICByZXR1cm4gW3BhcnNlSW50KGJpdHNbMV0gKyBiaXRzWzFdLCAxNiksIHBhcnNlSW50KGJpdHNbMl0gKyBiaXRzWzJdLCAxNiksIHBhcnNlSW50KGJpdHNbM10gKyBiaXRzWzNdLCAxNildO1xuICAgICAgfVxuICAgIH1dOyAvLyBzZWFyY2ggdGhyb3VnaCB0aGUgZGVmaW5pdGlvbnMgdG8gZmluZCBhIG1hdGNoXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yX2RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZSA9IGNvbG9yX2RlZnNbaV0ucmU7XG4gICAgICB2YXIgcHJvY2Vzc29yID0gY29sb3JfZGVmc1tpXS5wcm9jZXNzO1xuICAgICAgdmFyIGJpdHMgPSByZS5leGVjKGNvbG9yX3N0cmluZyk7XG5cbiAgICAgIGlmIChiaXRzKSB7XG4gICAgICAgIGNoYW5uZWxzID0gcHJvY2Vzc29yKGJpdHMpO1xuICAgICAgICB0aGlzLnIgPSBjaGFubmVsc1swXTtcbiAgICAgICAgdGhpcy5nID0gY2hhbm5lbHNbMV07XG4gICAgICAgIHRoaXMuYiA9IGNoYW5uZWxzWzJdO1xuICAgICAgICB0aGlzLm9rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIHZhbGlkYXRlL2NsZWFudXAgdmFsdWVzXG5cblxuICAgIHRoaXMuciA9IHRoaXMuciA8IDAgfHwgaXNOYU4odGhpcy5yKSA/IDAgOiB0aGlzLnIgPiAyNTUgPyAyNTUgOiB0aGlzLnI7XG4gICAgdGhpcy5nID0gdGhpcy5nIDwgMCB8fCBpc05hTih0aGlzLmcpID8gMCA6IHRoaXMuZyA+IDI1NSA/IDI1NSA6IHRoaXMuZztcbiAgICB0aGlzLmIgPSB0aGlzLmIgPCAwIHx8IGlzTmFOKHRoaXMuYikgPyAwIDogdGhpcy5iID4gMjU1ID8gMjU1IDogdGhpcy5iOyAvLyBzb21lIGdldHRlcnNcblxuICAgIHRoaXMudG9SR0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ3JnYignICsgdGhpcy5yICsgJywgJyArIHRoaXMuZyArICcsICcgKyB0aGlzLmIgKyAnKSc7XG4gICAgfTtcblxuICAgIHRoaXMudG9IZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgciA9IHRoaXMuci50b1N0cmluZygxNik7XG4gICAgICB2YXIgZyA9IHRoaXMuZy50b1N0cmluZygxNik7XG4gICAgICB2YXIgYiA9IHRoaXMuYi50b1N0cmluZygxNik7XG4gICAgICBpZiAoci5sZW5ndGggPT0gMSkgciA9ICcwJyArIHI7XG4gICAgICBpZiAoZy5sZW5ndGggPT0gMSkgZyA9ICcwJyArIGc7XG4gICAgICBpZiAoYi5sZW5ndGggPT0gMSkgYiA9ICcwJyArIGI7XG4gICAgICByZXR1cm4gJyMnICsgciArIGcgKyBiO1xuICAgIH07XG4gIH1cblxuICBnbG9iYWwuUkdCQ29sb3IgPSBSR0JDb2xvcjtcbn0pKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLmNvbnRlbnQnKSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkpOyAvLyBgc2VsZmAgaXMgdW5kZWZpbmVkIGluIEZpcmVmb3ggZm9yIEFuZHJvaWQgY29udGVudCBzY3JpcHQgY29udGV4dFxuLy8gd2hpbGUgYHRoaXNgIGlzIG5zSUNvbnRlbnRGcmFtZU1lc3NhZ2VNYW5hZ2VyXG4vLyB3aXRoIGFuIGF0dHJpYnV0ZSBgY29udGVudGAgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgd2luZG93XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRpdGxlIDogY3VzdG9tIGZvbnQgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIFN0YXJ0IERhdGEgOiAyMDE3LiAwMS4gMjIuICAgICAgICAgICAgICAgICAgICpcbiAqIENvbW1lbnQgOiBURVhUIEFQSSAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIGpzUERGIGV4dGVuc2lvbiBBUEkgRGVzaWduICpcbiAqICoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4oZnVuY3Rpb24gKGpzUERGKSB7XG5cbiAgdmFyIFBMVVMgPSAnKycuY2hhckNvZGVBdCgwKTtcbiAgdmFyIFNMQVNIID0gJy8nLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgdmFyIExPV0VSID0gJ2EnLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBVUFBFUiA9ICdBJy5jaGFyQ29kZUF0KDApO1xuICB2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApO1xuICB2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qIGZ1bmN0aW9uIDogYjY0VG9CeXRlQXJyYXkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAvKiBjb21tZW50IDogQmFzZTY0IGVuY29kZWQgVFRGIGZpbGUgY29udGVudHMgKGI2NCkgYXJlIGRlY29kZWQgICovXG5cbiAgLyogICAgIGJ5IEJ5dGUgYXJyYXkgYW5kIHN0b3JlZC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICB2YXIgYjY0VG9CeXRlQXJyYXkgPSBmdW5jdGlvbiBiNjRUb0J5dGVBcnJheShiNjQpIHtcbiAgICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcblxuICAgIGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpO1xuICAgIH0gLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gICAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gICAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXG5cbiAgICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcbiAgICBwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDA7IC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXG4gICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKTsgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXG4gICAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGg7XG4gICAgdmFyIEwgPSAwO1xuXG4gICAgZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICBhcnJbTCsrXSA9IHY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgICAgdG1wID0gZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4IHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMiB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNiB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSk7XG4gICAgICBwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpO1xuICAgICAgcHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcbiAgICAgIHB1c2godG1wICYgMHhGRik7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgICAgdG1wID0gZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQ7XG4gICAgICBwdXNoKHRtcCAmIDB4RkYpO1xuICAgIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgICB0bXAgPSBkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTAgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDI7XG4gICAgICBwdXNoKHRtcCA+PiA4ICYgMHhGRik7XG4gICAgICBwdXNoKHRtcCAmIDB4RkYpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH07XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyogZnVuY3Rpb24gOiBkZWNvZGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAvKiBjb21tZW50IDogQ2hhbmdlIHRoZSBiYXNlNjQgZW5jb2RlZCBmb250J3MgY29udGVudCB0byBtYXRjaCAqL1xuXG4gIC8qICAgdGhlIGJhc2U2NCBpbmRleCB2YWx1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gIHZhciBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoZWx0KSB7XG4gICAgdmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoY29kZSA9PT0gUExVUyB8fCBjb2RlID09PSBQTFVTX1VSTF9TQUZFKSByZXR1cm4gNjI7IC8vICcrJ1xuXG4gICAgaWYgKGNvZGUgPT09IFNMQVNIIHx8IGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKSByZXR1cm4gNjM7IC8vICcvJ1xuXG4gICAgaWYgKGNvZGUgPCBOVU1CRVIpIHJldHVybiAtMTsgLy9ubyBtYXRjaFxuXG4gICAgaWYgKGNvZGUgPCBOVU1CRVIgKyAxMCkgcmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2O1xuICAgIGlmIChjb2RlIDwgVVBQRVIgKyAyNikgcmV0dXJuIGNvZGUgLSBVUFBFUjtcbiAgICBpZiAoY29kZSA8IExPV0VSICsgMjYpIHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNjtcbiAgfTtcblxuICBqc1BERi5BUEkuVFRGRm9udCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyogZnVuY3Rpb24gOiBvcGVuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAvKiBjb21tZW50IDogRGVjb2RlIHRoZSBlbmNvZGVkIHR0ZiBjb250ZW50IGFuZCBjcmVhdGUgYSBUVEZGb250IG9iamVjdC4gKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgVFRGRm9udC5vcGVuID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBuYW1lLCB2ZnMsIGVuY29kaW5nKSB7XG4gICAgICB2YXIgY29udGVudHM7XG5cbiAgICAgIGlmICh0eXBlb2YgdmZzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCBpbiBUVEZGb250Lm9wZW4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGVudHMgPSBiNjRUb0J5dGVBcnJheSh2ZnMpO1xuICAgICAgcmV0dXJuIG5ldyBUVEZGb250KGNvbnRlbnRzLCBuYW1lLCBlbmNvZGluZyk7XG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyogZnVuY3Rpb24gOiBUVEZGb250IGdlcm5lcmF0b3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qIGNvbW1lbnQgOiBEZWNvZGUgVFRGIGNvbnRlbnRzIGFyZSBwYXJzZWQsIERhdGEsICAgICAgICAgICAgICovXG5cbiAgICAvKiBTdWJzZXQgb2JqZWN0IGlzIGNyZWF0ZWQsIGFuZCByZWdpc3RlclRURiBmdW5jdGlvbiBpcyBjYWxsZWQuKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGZ1bmN0aW9uIFRURkZvbnQocmF3RGF0YSwgbmFtZSwgZW5jb2RpbmcpIHtcbiAgICAgIHZhciBkYXRhO1xuXG4gICAgICB0aGlzLnJhd0RhdGEgPSByYXdEYXRhO1xuICAgICAgZGF0YSA9IHRoaXMuY29udGVudHMgPSBuZXcgRGF0YShyYXdEYXRhKTtcbiAgICAgIHRoaXMuY29udGVudHMucG9zID0gNDtcblxuICAgICAgaWYgKGRhdGEucmVhZFN0cmluZyg0KSA9PT0gJ3R0Y2YnKSB7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3BlY2lmeSBhIGZvbnQgbmFtZSBmb3IgVFRDIGZpbGVzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IFwiICsgbmFtZSArIFwiIG5vdCBmb3VuZCBpbiBUVEMgZmlsZS5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICAgICAgdGhpcy5zdWJzZXQgPSBuZXcgU3Vic2V0KHRoaXMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVFRGKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qIGZ1bmN0aW9uIDogcGFyc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qIGNvbW1lbnQgOiBUVEYgUGFyc2VzIHRoZSBmaWxlIGNvbnRlbnRzIGJ5IGVhY2ggdGFibGUuKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgVFRGRm9udC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRpcmVjdG9yeSA9IG5ldyBEaXJlY3RvcnkodGhpcy5jb250ZW50cyk7XG4gICAgICB0aGlzLmhlYWQgPSBuZXcgSGVhZFRhYmxlKHRoaXMpO1xuICAgICAgdGhpcy5uYW1lID0gbmV3IE5hbWVUYWJsZSh0aGlzKTtcbiAgICAgIHRoaXMuY21hcCA9IG5ldyBDbWFwVGFibGUodGhpcyk7XG4gICAgICB0aGlzLnRvVW5pY29kZSA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaGhlYSA9IG5ldyBIaGVhVGFibGUodGhpcyk7XG4gICAgICB0aGlzLm1heHAgPSBuZXcgTWF4cFRhYmxlKHRoaXMpO1xuICAgICAgdGhpcy5obXR4ID0gbmV3IEhtdHhUYWJsZSh0aGlzKTtcbiAgICAgIHRoaXMucG9zdCA9IG5ldyBQb3N0VGFibGUodGhpcyk7XG4gICAgICB0aGlzLm9zMiA9IG5ldyBPUzJUYWJsZSh0aGlzKTtcbiAgICAgIHRoaXMubG9jYSA9IG5ldyBMb2NhVGFibGUodGhpcyk7XG4gICAgICB0aGlzLmdseWYgPSBuZXcgR2x5ZlRhYmxlKHRoaXMpO1xuICAgICAgdGhpcy5hc2NlbmRlciA9IHRoaXMub3MyLmV4aXN0cyAmJiB0aGlzLm9zMi5hc2NlbmRlciB8fCB0aGlzLmhoZWEuYXNjZW5kZXI7XG4gICAgICB0aGlzLmRlY2VuZGVyID0gdGhpcy5vczIuZXhpc3RzICYmIHRoaXMub3MyLmRlY2VuZGVyIHx8IHRoaXMuaGhlYS5kZWNlbmRlcjtcbiAgICAgIHRoaXMubGluZUdhcCA9IHRoaXMub3MyLmV4aXN0cyAmJiB0aGlzLm9zMi5saW5lR2FwIHx8IHRoaXMuaGhlYS5saW5lR2FwO1xuICAgICAgcmV0dXJuIHRoaXMuYmJveCA9IFt0aGlzLmhlYWQueE1pbiwgdGhpcy5oZWFkLnlNaW4sIHRoaXMuaGVhZC54TWF4LCB0aGlzLmhlYWQueU1heF07XG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyogZnVuY3Rpb24gOiByZWdpc3RlclRURiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qIGNvbW1lbnQgOiBHZXQgdGhlIHZhbHVlIHRvIGFzc2lnbiBwZGYgZm9udCBkZXNjcmlwdG9ycy4gICAgICovXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBUVEZGb250LnByb3RvdHlwZS5yZWdpc3RlclRURiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlLCBoaSwgbG93LCByYXcsIF9yZWY7XG5cbiAgICAgIHRoaXMuc2NhbGVGYWN0b3IgPSAxMDAwLjAgLyB0aGlzLmhlYWQudW5pdHNQZXJFbTtcblxuICAgICAgdGhpcy5iYm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuXG4gICAgICAgIF9yZWYgPSB0aGlzLmJib3g7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgZSA9IF9yZWZbX2ldO1xuXG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChNYXRoLnJvdW5kKGUgKiB0aGlzLnNjYWxlRmFjdG9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9LmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMuc3RlbVYgPSAwO1xuXG4gICAgICBpZiAodGhpcy5wb3N0LmV4aXN0cykge1xuICAgICAgICByYXcgPSB0aGlzLnBvc3QuaXRhbGljX2FuZ2xlO1xuICAgICAgICBoaSA9IHJhdyA+PiAxNjtcbiAgICAgICAgbG93ID0gcmF3ICYgMHhGRjtcblxuICAgICAgICBpZiAoaGkgJiAweDgwMDAgIT09IDApIHtcbiAgICAgICAgICBoaSA9IC0oKGhpIF4gMHhGRkZGKSArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pdGFsaWNBbmdsZSA9ICsoXCJcIiArIGhpICsgXCIuXCIgKyBsb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pdGFsaWNBbmdsZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXNjZW5kZXIgPSBNYXRoLnJvdW5kKHRoaXMuYXNjZW5kZXIgKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICAgIHRoaXMuZGVjZW5kZXIgPSBNYXRoLnJvdW5kKHRoaXMuZGVjZW5kZXIgKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICAgIHRoaXMubGluZUdhcCA9IE1hdGgucm91bmQodGhpcy5saW5lR2FwICogdGhpcy5zY2FsZUZhY3Rvcik7XG4gICAgICB0aGlzLmNhcEhlaWdodCA9IHRoaXMub3MyLmV4aXN0cyAmJiB0aGlzLm9zMi5jYXBIZWlnaHQgfHwgdGhpcy5hc2NlbmRlcjtcbiAgICAgIHRoaXMueEhlaWdodCA9IHRoaXMub3MyLmV4aXN0cyAmJiB0aGlzLm9zMi54SGVpZ2h0IHx8IDA7XG4gICAgICB0aGlzLmZhbWlseUNsYXNzID0gKHRoaXMub3MyLmV4aXN0cyAmJiB0aGlzLm9zMi5mYW1pbHlDbGFzcyB8fCAwKSA+PiA4O1xuICAgICAgdGhpcy5pc1NlcmlmID0gKF9yZWYgPSB0aGlzLmZhbWlseUNsYXNzKSA9PT0gMSB8fCBfcmVmID09PSAyIHx8IF9yZWYgPT09IDMgfHwgX3JlZiA9PT0gNCB8fCBfcmVmID09PSA1IHx8IF9yZWYgPT09IDc7XG4gICAgICB0aGlzLmlzU2NyaXB0ID0gdGhpcy5mYW1pbHlDbGFzcyA9PT0gMTA7XG4gICAgICB0aGlzLmZsYWdzID0gMDtcblxuICAgICAgaWYgKHRoaXMucG9zdC5pc0ZpeGVkUGl0Y2gpIHtcbiAgICAgICAgdGhpcy5mbGFncyB8PSAxIDw8IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzU2VyaWYpIHtcbiAgICAgICAgdGhpcy5mbGFncyB8PSAxIDw8IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzU2NyaXB0KSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgfD0gMSA8PCAzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pdGFsaWNBbmdsZSAhPT0gMCkge1xuICAgICAgICB0aGlzLmZsYWdzIHw9IDEgPDwgNjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mbGFncyB8PSAxIDw8IDU7XG5cbiAgICAgIGlmICghdGhpcy5jbWFwLnVuaWNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB1bmljb2RlIGNtYXAgZm9yIGZvbnQnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVFRGRm9udC5wcm90b3R5cGUuY2hhcmFjdGVyVG9HbHlwaCA9IGZ1bmN0aW9uIChjaGFyYWN0ZXIpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gKChfcmVmID0gdGhpcy5jbWFwLnVuaWNvZGUpICE9IG51bGwgPyBfcmVmLmNvZGVNYXBbY2hhcmFjdGVyXSA6IHZvaWQgMCkgfHwgMDtcbiAgICB9O1xuXG4gICAgVFRGRm9udC5wcm90b3R5cGUud2lkdGhPZkdseXBoID0gZnVuY3Rpb24gKGdseXBoKSB7XG4gICAgICB2YXIgc2NhbGU7XG4gICAgICBzY2FsZSA9IDEwMDAuMCAvIHRoaXMuaGVhZC51bml0c1BlckVtO1xuICAgICAgcmV0dXJuIHRoaXMuaG10eC5mb3JHbHlwaChnbHlwaCkuYWR2YW5jZSAqIHNjYWxlO1xuICAgIH07XG5cbiAgICBUVEZGb250LnByb3RvdHlwZS53aWR0aE9mU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZywgc2l6ZSwgY2hhclNwYWNlKSB7XG4gICAgICB2YXIgY2hhckNvZGUsIGksIHNjYWxlLCB3aWR0aCwgX2ksIF9yZWYsIGNoYXJTcGFjZTtcblxuICAgICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gICAgICB3aWR0aCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZiA9IHN0cmluZy5sZW5ndGg7IDAgPD0gX3JlZiA/IF9pIDwgX3JlZiA6IF9pID4gX3JlZjsgaSA9IDAgPD0gX3JlZiA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgIGNoYXJDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHdpZHRoICs9IHRoaXMud2lkdGhPZkdseXBoKHRoaXMuY2hhcmFjdGVyVG9HbHlwaChjaGFyQ29kZSkpICsgY2hhclNwYWNlICogKDEwMDAgLyBzaXplKSB8fCAwO1xuICAgICAgfVxuXG4gICAgICBzY2FsZSA9IHNpemUgLyAxMDAwO1xuICAgICAgcmV0dXJuIHdpZHRoICogc2NhbGU7XG4gICAgfTtcblxuICAgIFRURkZvbnQucHJvdG90eXBlLmxpbmVIZWlnaHQgPSBmdW5jdGlvbiAoc2l6ZSwgaW5jbHVkZUdhcCkge1xuICAgICAgdmFyIGdhcDtcblxuICAgICAgaWYgKGluY2x1ZGVHYXAgPT0gbnVsbCkge1xuICAgICAgICBpbmNsdWRlR2FwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGdhcCA9IGluY2x1ZGVHYXAgPyB0aGlzLmxpbmVHYXAgOiAwO1xuICAgICAgcmV0dXJuICh0aGlzLmFzY2VuZGVyICsgZ2FwIC0gdGhpcy5kZWNlbmRlcikgLyAxMDAwICogc2l6ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRURkZvbnQ7XG4gIH0oKTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiBmdW5jdGlvbiA6IERhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gIC8qIGNvbW1lbnQgOiBUaGUgdHRmIGRhdGEgZGVjb2RlZCBhbmQgc3RvcmVkIGluIGFuIGFycmF5IGlzIHJlYWQgYW5kIHdyaXR0ZW4gdG8gdGhlIERhdGEgb2JqZWN0LiovXG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gIHZhciBEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGEoZGF0YSkge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YSAhPSBudWxsID8gZGF0YSA6IFtdO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIERhdGEucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICB9O1xuXG4gICAgRGF0YS5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24gKGJ5dGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSBieXRlO1xuICAgIH07XG5cbiAgICBEYXRhLnByb3RvdHlwZS5yZWFkVUludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGIxLCBiMiwgYjMsIGI0O1xuICAgICAgYjEgPSB0aGlzLnJlYWRCeXRlKCkgKiAweDEwMDAwMDA7XG4gICAgICBiMiA9IHRoaXMucmVhZEJ5dGUoKSA8PCAxNjtcbiAgICAgIGIzID0gdGhpcy5yZWFkQnl0ZSgpIDw8IDg7XG4gICAgICBiNCA9IHRoaXMucmVhZEJ5dGUoKTtcbiAgICAgIHJldHVybiBiMSArIGIyICsgYjMgKyBiNDtcbiAgICB9O1xuXG4gICAgRGF0YS5wcm90b3R5cGUud3JpdGVVSW50MzIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLndyaXRlQnl0ZSh2YWwgPj4+IDI0ICYgMHhmZik7XG4gICAgICB0aGlzLndyaXRlQnl0ZSh2YWwgPj4gMTYgJiAweGZmKTtcbiAgICAgIHRoaXMud3JpdGVCeXRlKHZhbCA+PiA4ICYgMHhmZik7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZUJ5dGUodmFsICYgMHhmZik7XG4gICAgfTtcblxuICAgIERhdGEucHJvdG90eXBlLnJlYWRJbnQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnQ7XG4gICAgICBpbnQgPSB0aGlzLnJlYWRVSW50MzIoKTtcblxuICAgICAgaWYgKGludCA+PSAweDgwMDAwMDAwKSB7XG4gICAgICAgIHJldHVybiBpbnQgLSAweDEwMDAwMDAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIERhdGEucHJvdG90eXBlLndyaXRlSW50MzIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICB2YWwgKz0gMHgxMDAwMDAwMDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndyaXRlVUludDMyKHZhbCk7XG4gICAgfTtcblxuICAgIERhdGEucHJvdG90eXBlLnJlYWRVSW50MTYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYjEsIGIyO1xuICAgICAgYjEgPSB0aGlzLnJlYWRCeXRlKCkgPDwgODtcbiAgICAgIGIyID0gdGhpcy5yZWFkQnl0ZSgpO1xuICAgICAgcmV0dXJuIGIxIHwgYjI7XG4gICAgfTtcblxuICAgIERhdGEucHJvdG90eXBlLndyaXRlVUludDE2ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy53cml0ZUJ5dGUodmFsID4+IDggJiAweGZmKTtcbiAgICAgIHJldHVybiB0aGlzLndyaXRlQnl0ZSh2YWwgJiAweGZmKTtcbiAgICB9O1xuXG4gICAgRGF0YS5wcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGludDtcbiAgICAgIGludCA9IHRoaXMucmVhZFVJbnQxNigpO1xuXG4gICAgICBpZiAoaW50ID49IDB4ODAwMCkge1xuICAgICAgICByZXR1cm4gaW50IC0gMHgxMDAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIERhdGEucHJvdG90eXBlLndyaXRlSW50MTYgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICB2YWwgKz0gMHgxMDAwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMud3JpdGVVSW50MTYodmFsKTtcbiAgICB9O1xuXG4gICAgRGF0YS5wcm90b3R5cGUucmVhZFN0cmluZyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgIHZhciBpLCByZXQsIF9pO1xuXG4gICAgICByZXQgPSBbXTtcblxuICAgICAgZm9yIChpID0gX2kgPSAwOyAwIDw9IGxlbmd0aCA/IF9pIDwgbGVuZ3RoIDogX2kgPiBsZW5ndGg7IGkgPSAwIDw9IGxlbmd0aCA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgIHJldFtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkQnl0ZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgRGF0YS5wcm90b3R5cGUud3JpdGVTdHJpbmcgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB2YXIgaSwgX2ksIF9yZWYsIF9yZXN1bHRzO1xuXG4gICAgICBfcmVzdWx0cyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYgPSB2YWwubGVuZ3RoOyAwIDw9IF9yZWYgPyBfaSA8IF9yZWYgOiBfaSA+IF9yZWY7IGkgPSAwIDw9IF9yZWYgPyArK19pIDogLS1faSkge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMud3JpdGVCeXRlKHZhbC5jaGFyQ29kZUF0KGkpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICAgIC8qRGF0YS5wcm90b3R5cGUuc3RyaW5nQXQgPSBmdW5jdGlvbiAocG9zLCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcobGVuZ3RoKTtcbiAgICB9OyovXG5cblxuICAgIERhdGEucHJvdG90eXBlLnJlYWRTaG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRJbnQxNigpO1xuICAgIH07XG5cbiAgICBEYXRhLnByb3RvdHlwZS53cml0ZVNob3J0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnQxNih2YWwpO1xuICAgIH07XG5cbiAgICBEYXRhLnByb3RvdHlwZS5yZWFkTG9uZ0xvbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4O1xuICAgICAgYjEgPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICBiMiA9IHRoaXMucmVhZEJ5dGUoKTtcbiAgICAgIGIzID0gdGhpcy5yZWFkQnl0ZSgpO1xuICAgICAgYjQgPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICBiNSA9IHRoaXMucmVhZEJ5dGUoKTtcbiAgICAgIGI2ID0gdGhpcy5yZWFkQnl0ZSgpO1xuICAgICAgYjcgPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgICBiOCA9IHRoaXMucmVhZEJ5dGUoKTtcblxuICAgICAgaWYgKGIxICYgMHg4MCkge1xuICAgICAgICByZXR1cm4gKChiMSBeIDB4ZmYpICogMHgxMDAwMDAwMDAwMDAwMDAgKyAoYjIgXiAweGZmKSAqIDB4MTAwMDAwMDAwMDAwMCArIChiMyBeIDB4ZmYpICogMHgxMDAwMDAwMDAwMCArIChiNCBeIDB4ZmYpICogMHgxMDAwMDAwMDAgKyAoYjUgXiAweGZmKSAqIDB4MTAwMDAwMCArIChiNiBeIDB4ZmYpICogMHgxMDAwMCArIChiNyBeIDB4ZmYpICogMHgxMDAgKyAoYjggXiAweGZmKSArIDEpICogLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiMSAqIDB4MTAwMDAwMDAwMDAwMDAwICsgYjIgKiAweDEwMDAwMDAwMDAwMDAgKyBiMyAqIDB4MTAwMDAwMDAwMDAgKyBiNCAqIDB4MTAwMDAwMDAwICsgYjUgKiAweDEwMDAwMDAgKyBiNiAqIDB4MTAwMDAgKyBiNyAqIDB4MTAwICsgYjg7XG4gICAgfTtcblxuICAgIERhdGEucHJvdG90eXBlLndyaXRlTG9uZ0xvbmcgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB2YXIgaGlnaCwgbG93O1xuICAgICAgaGlnaCA9IE1hdGguZmxvb3IodmFsIC8gMHgxMDAwMDAwMDApO1xuICAgICAgbG93ID0gdmFsICYgMHhmZmZmZmZmZjtcbiAgICAgIHRoaXMud3JpdGVCeXRlKGhpZ2ggPj4gMjQgJiAweGZmKTtcbiAgICAgIHRoaXMud3JpdGVCeXRlKGhpZ2ggPj4gMTYgJiAweGZmKTtcbiAgICAgIHRoaXMud3JpdGVCeXRlKGhpZ2ggPj4gOCAmIDB4ZmYpO1xuICAgICAgdGhpcy53cml0ZUJ5dGUoaGlnaCAmIDB4ZmYpO1xuICAgICAgdGhpcy53cml0ZUJ5dGUobG93ID4+IDI0ICYgMHhmZik7XG4gICAgICB0aGlzLndyaXRlQnl0ZShsb3cgPj4gMTYgJiAweGZmKTtcbiAgICAgIHRoaXMud3JpdGVCeXRlKGxvdyA+PiA4ICYgMHhmZik7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZUJ5dGUobG93ICYgMHhmZik7XG4gICAgfTtcblxuICAgIERhdGEucHJvdG90eXBlLnJlYWRJbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkSW50MzIoKTtcbiAgICB9O1xuXG4gICAgRGF0YS5wcm90b3R5cGUud3JpdGVJbnQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZUludDMyKHZhbCk7XG4gICAgfTtcbiAgICAvKkRhdGEucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9OyovXG5cblxuICAgIERhdGEucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgIHZhciBidWYsIGksIF9pO1xuXG4gICAgICBidWYgPSBbXTtcblxuICAgICAgZm9yIChpID0gX2kgPSAwOyAwIDw9IGJ5dGVzID8gX2kgPCBieXRlcyA6IF9pID4gYnl0ZXM7IGkgPSAwIDw9IGJ5dGVzID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgYnVmLnB1c2godGhpcy5yZWFkQnl0ZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9O1xuXG4gICAgRGF0YS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgIHZhciBieXRlLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG5cbiAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYnl0ZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgYnl0ZSA9IGJ5dGVzW19pXTtcblxuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMud3JpdGVCeXRlKGJ5dGUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGF0YTtcbiAgfSgpO1xuXG4gIHZhciBEaXJlY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoZWNrc3VtO1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qIGZ1bmN0aW9uIDogRGlyZWN0b3J5IGdlbmVyYXRvciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qIGNvbW1lbnQgOiBJbml0aWFsaXplIHRoZSBvZmZzZXQsIHRhZywgbGVuZ3RoLCBhbmQgY2hlY2tzdW0gZm9yIGVhY2ggdGFibGUgZm9yIHRoZSBmb250IHRvIGJlIHVzZWQuKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIERpcmVjdG9yeShkYXRhKSB7XG4gICAgICB2YXIgZW50cnksIGksIF9pLCBfcmVmO1xuXG4gICAgICB0aGlzLnNjYWxhclR5cGUgPSBkYXRhLnJlYWRJbnQoKTtcbiAgICAgIHRoaXMudGFibGVDb3VudCA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLnNlYXJjaFJhbmdlID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMuZW50cnlTZWxlY3RvciA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLnJhbmdlU2hpZnQgPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgdGhpcy50YWJsZXMgPSB7fTtcblxuICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmID0gdGhpcy50YWJsZUNvdW50OyAwIDw9IF9yZWYgPyBfaSA8IF9yZWYgOiBfaSA+IF9yZWY7IGkgPSAwIDw9IF9yZWYgPyArK19pIDogLS1faSkge1xuICAgICAgICBlbnRyeSA9IHtcbiAgICAgICAgICB0YWc6IGRhdGEucmVhZFN0cmluZyg0KSxcbiAgICAgICAgICBjaGVja3N1bTogZGF0YS5yZWFkSW50KCksXG4gICAgICAgICAgb2Zmc2V0OiBkYXRhLnJlYWRJbnQoKSxcbiAgICAgICAgICBsZW5ndGg6IGRhdGEucmVhZEludCgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGFibGVzW2VudHJ5LnRhZ10gPSBlbnRyeTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyogZnVuY3Rpb24gOiBlbmNvZGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgLyogY29tbWVudCA6IEl0IGVuY29kZXMgYW5kIHN0b3JlcyB0aGUgZm9udCB0YWJsZSBvYmplY3QgYW5kIGluZm9ybWF0aW9uIHVzZWQgZm9yIHRoZSBkaXJlY3Rvcnkgb2JqZWN0LiAqL1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBEaXJlY3RvcnkucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh0YWJsZXMpIHtcbiAgICAgIHZhciBhZGp1c3RtZW50LCBkaXJlY3RvcnksIGRpcmVjdG9yeUxlbmd0aCwgZW50cnlTZWxlY3RvciwgaGVhZE9mZnNldCwgbG9nMiwgb2Zmc2V0LCByYW5nZVNoaWZ0LCBzZWFyY2hSYW5nZSwgc3VtLCB0YWJsZSwgdGFibGVDb3VudCwgdGFibGVEYXRhLCB0YWc7XG4gICAgICB0YWJsZUNvdW50ID0gT2JqZWN0LmtleXModGFibGVzKS5sZW5ndGg7XG4gICAgICBsb2cyID0gTWF0aC5sb2coMik7XG4gICAgICBzZWFyY2hSYW5nZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codGFibGVDb3VudCkgLyBsb2cyKSAqIDE2O1xuICAgICAgZW50cnlTZWxlY3RvciA9IE1hdGguZmxvb3Ioc2VhcmNoUmFuZ2UgLyBsb2cyKTtcbiAgICAgIHJhbmdlU2hpZnQgPSB0YWJsZUNvdW50ICogMTYgLSBzZWFyY2hSYW5nZTtcbiAgICAgIGRpcmVjdG9yeSA9IG5ldyBEYXRhKCk7XG4gICAgICBkaXJlY3Rvcnkud3JpdGVJbnQodGhpcy5zY2FsYXJUeXBlKTtcbiAgICAgIGRpcmVjdG9yeS53cml0ZVNob3J0KHRhYmxlQ291bnQpO1xuICAgICAgZGlyZWN0b3J5LndyaXRlU2hvcnQoc2VhcmNoUmFuZ2UpO1xuICAgICAgZGlyZWN0b3J5LndyaXRlU2hvcnQoZW50cnlTZWxlY3Rvcik7XG4gICAgICBkaXJlY3Rvcnkud3JpdGVTaG9ydChyYW5nZVNoaWZ0KTtcbiAgICAgIGRpcmVjdG9yeUxlbmd0aCA9IHRhYmxlQ291bnQgKiAxNjtcbiAgICAgIG9mZnNldCA9IGRpcmVjdG9yeS5wb3MgKyBkaXJlY3RvcnlMZW5ndGg7XG4gICAgICBoZWFkT2Zmc2V0ID0gbnVsbDtcbiAgICAgIHRhYmxlRGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKHRhZyBpbiB0YWJsZXMpIHtcbiAgICAgICAgdGFibGUgPSB0YWJsZXNbdGFnXTtcbiAgICAgICAgZGlyZWN0b3J5LndyaXRlU3RyaW5nKHRhZyk7XG4gICAgICAgIGRpcmVjdG9yeS53cml0ZUludChjaGVja3N1bSh0YWJsZSkpO1xuICAgICAgICBkaXJlY3Rvcnkud3JpdGVJbnQob2Zmc2V0KTtcbiAgICAgICAgZGlyZWN0b3J5LndyaXRlSW50KHRhYmxlLmxlbmd0aCk7XG4gICAgICAgIHRhYmxlRGF0YSA9IHRhYmxlRGF0YS5jb25jYXQodGFibGUpO1xuXG4gICAgICAgIGlmICh0YWcgPT09ICdoZWFkJykge1xuICAgICAgICAgIGhlYWRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQgKz0gdGFibGUubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgJSA0KSB7XG4gICAgICAgICAgdGFibGVEYXRhLnB1c2goMCk7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlyZWN0b3J5LndyaXRlKHRhYmxlRGF0YSk7XG4gICAgICBzdW0gPSBjaGVja3N1bShkaXJlY3RvcnkuZGF0YSk7XG4gICAgICBhZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIHN1bTtcbiAgICAgIGRpcmVjdG9yeS5wb3MgPSBoZWFkT2Zmc2V0ICsgODtcbiAgICAgIGRpcmVjdG9yeS53cml0ZVVJbnQzMihhZGp1c3RtZW50KTtcbiAgICAgIHJldHVybiBkaXJlY3RvcnkuZGF0YTtcbiAgICB9O1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKiBmdW5jdGlvbiA6IGNoZWNrc3VtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgLyogY29tbWVudCA6IER1cGxpY2F0ZSB0aGUgdGFibGUgZm9yIHRoZSB0YWcuICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGNoZWNrc3VtID0gZnVuY3Rpb24gY2hlY2tzdW0oZGF0YSkge1xuICAgICAgdmFyIGksIHN1bSwgdG1wLCBfaSwgX3JlZjtcblxuICAgICAgZGF0YSA9IF9fc2xpY2UuY2FsbChkYXRhKTtcblxuICAgICAgd2hpbGUgKGRhdGEubGVuZ3RoICUgNCkge1xuICAgICAgICBkYXRhLnB1c2goMCk7XG4gICAgICB9XG5cbiAgICAgIHRtcCA9IG5ldyBEYXRhKGRhdGEpO1xuICAgICAgc3VtID0gMDtcblxuICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmID0gZGF0YS5sZW5ndGg7IF9pIDwgX3JlZjsgaSA9IF9pICs9IDQpIHtcbiAgICAgICAgc3VtICs9IHRtcC5yZWFkVUludDMyKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdW0gJiAweEZGRkZGRkZGO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGlyZWN0b3J5O1xuICB9KCk7XG5cbiAgdmFyIFRhYmxlLFxuICAgICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiBfX2V4dGVuZHMoY2hpbGQsIHBhcmVudCkge1xuICAgIGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICAgIGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdG9yKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgIH1cblxuICAgIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xuICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qIGZ1bmN0aW9uIDogVGFibGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLyogY29tbWVudCA6IFNhdmUgaW5mbyBmb3IgZWFjaCB0YWJsZSwgYW5kIHBhcnNlIHRoZSB0YWJsZS4gICAgKi9cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhYmxlKGZpbGUpIHtcbiAgICAgIHZhciBpbmZvO1xuICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICAgIGluZm8gPSB0aGlzLmZpbGUuZGlyZWN0b3J5LnRhYmxlc1t0aGlzLnRhZ107XG4gICAgICB0aGlzLmV4aXN0cyA9ICEhaW5mbztcblxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBpbmZvLm9mZnNldCwgdGhpcy5sZW5ndGggPSBpbmZvLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wYXJzZSh0aGlzLmZpbGUuY29udGVudHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFRhYmxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5leGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlsZS5jb250ZW50cy5wb3MgPSB0aGlzLm9mZnNldDtcbiAgICAgIHJldHVybiB0aGlzLmZpbGUuY29udGVudHMucmVhZCh0aGlzLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYWJsZTtcbiAgfSgpO1xuXG4gIHZhciBIZWFkVGFibGUgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRUYWJsZSwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEhlYWRUYWJsZSgpIHtcbiAgICAgIHJldHVybiBIZWFkVGFibGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgSGVhZFRhYmxlLnByb3RvdHlwZS50YWcgPSAnaGVhZCc7XG5cbiAgICBIZWFkVGFibGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGRhdGEucG9zID0gdGhpcy5vZmZzZXQ7XG4gICAgICB0aGlzLnZlcnNpb24gPSBkYXRhLnJlYWRJbnQoKTtcbiAgICAgIHRoaXMucmV2aXNpb24gPSBkYXRhLnJlYWRJbnQoKTtcbiAgICAgIHRoaXMuY2hlY2tTdW1BZGp1c3RtZW50ID0gZGF0YS5yZWFkSW50KCk7XG4gICAgICB0aGlzLm1hZ2ljTnVtYmVyID0gZGF0YS5yZWFkSW50KCk7XG4gICAgICB0aGlzLmZsYWdzID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMudW5pdHNQZXJFbSA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLmNyZWF0ZWQgPSBkYXRhLnJlYWRMb25nTG9uZygpO1xuICAgICAgdGhpcy5tb2RpZmllZCA9IGRhdGEucmVhZExvbmdMb25nKCk7XG4gICAgICB0aGlzLnhNaW4gPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgdGhpcy55TWluID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMueE1heCA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLnlNYXggPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgdGhpcy5tYWNTdHlsZSA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLmxvd2VzdFJlY1BQRU0gPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgdGhpcy5mb250RGlyZWN0aW9uSGludCA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLmluZGV4VG9Mb2NGb3JtYXQgPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2x5cGhEYXRhRm9ybWF0ID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICB9O1xuXG4gICAgSGVhZFRhYmxlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoaW5kZXhUb0xvY0Zvcm1hdCkge1xuICAgICAgdmFyIHRhYmxlO1xuICAgICAgdGFibGUgPSBuZXcgRGF0YSgpO1xuICAgICAgdGFibGUud3JpdGVJbnQodGhpcy52ZXJzaW9uKTtcbiAgICAgIHRhYmxlLndyaXRlSW50KHRoaXMucmV2aXNpb24pO1xuICAgICAgdGFibGUud3JpdGVJbnQodGhpcy5jaGVja1N1bUFkanVzdG1lbnQpO1xuICAgICAgdGFibGUud3JpdGVJbnQodGhpcy5tYWdpY051bWJlcik7XG4gICAgICB0YWJsZS53cml0ZVNob3J0KHRoaXMuZmxhZ3MpO1xuICAgICAgdGFibGUud3JpdGVTaG9ydCh0aGlzLnVuaXRzUGVyRW0pO1xuICAgICAgdGFibGUud3JpdGVMb25nTG9uZyh0aGlzLmNyZWF0ZWQpO1xuICAgICAgdGFibGUud3JpdGVMb25nTG9uZyh0aGlzLm1vZGlmaWVkKTtcbiAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy54TWluKTtcbiAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy55TWluKTtcbiAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy54TWF4KTtcbiAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy55TWF4KTtcbiAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy5tYWNTdHlsZSk7XG4gICAgICB0YWJsZS53cml0ZVNob3J0KHRoaXMubG93ZXN0UmVjUFBFTSk7XG4gICAgICB0YWJsZS53cml0ZVNob3J0KHRoaXMuZm9udERpcmVjdGlvbkhpbnQpO1xuICAgICAgdGFibGUud3JpdGVTaG9ydChpbmRleFRvTG9jRm9ybWF0KTtcbiAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy5nbHlwaERhdGFGb3JtYXQpO1xuICAgICAgcmV0dXJuIHRhYmxlLmRhdGE7XG4gICAgfTtcblxuICAgIHJldHVybiBIZWFkVGFibGU7XG4gIH0oVGFibGUpO1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qIGZ1bmN0aW9uIDogQ21hcEVudHJ5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLyogY29tbWVudCA6IENtYXAgSW5pdGlhbGl6ZXMgYW5kIGVuY29kZXMgb2JqZWN0IGluZm9ybWF0aW9uIChyZXF1aXJlZCBieSBwZGYgc3BlYykuKi9cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIENtYXBFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbWFwRW50cnkoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgY29kZSwgY291bnQsIGVuZENvZGUsIGdseXBoSWQsIGdseXBoSWRzLCBpLCBpZERlbHRhLCBpZFJhbmdlT2Zmc2V0LCBpbmRleCwgc2F2ZU9mZnNldCwgc2VnQ291bnQsIHNlZ0NvdW50WDIsIHN0YXJ0LCBzdGFydENvZGUsIHRhaWwsIF9pLCBfaiwgX2ssIF9sZW47XG5cbiAgICAgIHRoaXMucGxhdGZvcm1JRCA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy5lbmNvZGluZ0lEID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0ICsgZGF0YS5yZWFkSW50KCk7XG4gICAgICBzYXZlT2Zmc2V0ID0gZGF0YS5wb3M7XG4gICAgICBkYXRhLnBvcyA9IHRoaXMub2Zmc2V0O1xuICAgICAgdGhpcy5mb3JtYXQgPSBkYXRhLnJlYWRVSW50MTYoKTtcbiAgICAgIHRoaXMubGVuZ3RoID0gZGF0YS5yZWFkVUludDE2KCk7XG4gICAgICB0aGlzLmxhbmd1YWdlID0gZGF0YS5yZWFkVUludDE2KCk7XG4gICAgICB0aGlzLmlzVW5pY29kZSA9IHRoaXMucGxhdGZvcm1JRCA9PT0gMyAmJiB0aGlzLmVuY29kaW5nSUQgPT09IDEgJiYgdGhpcy5mb3JtYXQgPT09IDQgfHwgdGhpcy5wbGF0Zm9ybUlEID09PSAwICYmIHRoaXMuZm9ybWF0ID09PSA0O1xuICAgICAgdGhpcy5jb2RlTWFwID0ge307XG5cbiAgICAgIHN3aXRjaCAodGhpcy5mb3JtYXQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPCAyNTY7IGkgPSArK19pKSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVNYXBbaV0gPSBkYXRhLnJlYWRCeXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlZ0NvdW50WDIgPSBkYXRhLnJlYWRVSW50MTYoKTtcbiAgICAgICAgICBzZWdDb3VudCA9IHNlZ0NvdW50WDIgLyAyO1xuICAgICAgICAgIGRhdGEucG9zICs9IDY7XG5cbiAgICAgICAgICBlbmRDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfcmVzdWx0cztcblxuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gX2ogPSAwOyAwIDw9IHNlZ0NvdW50ID8gX2ogPCBzZWdDb3VudCA6IF9qID4gc2VnQ291bnQ7IGkgPSAwIDw9IHNlZ0NvdW50ID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnJlYWRVSW50MTYoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBkYXRhLnBvcyArPSAyO1xuXG4gICAgICAgICAgc3RhcnRDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfcmVzdWx0cztcblxuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gX2ogPSAwOyAwIDw9IHNlZ0NvdW50ID8gX2ogPCBzZWdDb3VudCA6IF9qID4gc2VnQ291bnQ7IGkgPSAwIDw9IHNlZ0NvdW50ID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnJlYWRVSW50MTYoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBpZERlbHRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfcmVzdWx0cztcblxuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gX2ogPSAwOyAwIDw9IHNlZ0NvdW50ID8gX2ogPCBzZWdDb3VudCA6IF9qID4gc2VnQ291bnQ7IGkgPSAwIDw9IHNlZ0NvdW50ID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnJlYWRVSW50MTYoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBpZFJhbmdlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfcmVzdWx0cztcblxuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gX2ogPSAwOyAwIDw9IHNlZ0NvdW50ID8gX2ogPCBzZWdDb3VudCA6IF9qID4gc2VnQ291bnQ7IGkgPSAwIDw9IHNlZ0NvdW50ID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnJlYWRVSW50MTYoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBjb3VudCA9ICh0aGlzLmxlbmd0aCAtIGRhdGEucG9zICsgdGhpcy5vZmZzZXQpIC8gMjtcblxuICAgICAgICAgIGdseXBoSWRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfcmVzdWx0cztcblxuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gX2ogPSAwOyAwIDw9IGNvdW50ID8gX2ogPCBjb3VudCA6IF9qID4gY291bnQ7IGkgPSAwIDw9IGNvdW50ID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnJlYWRVSW50MTYoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBmb3IgKGkgPSBfaiA9IDAsIF9sZW4gPSBlbmRDb2RlLmxlbmd0aDsgX2ogPCBfbGVuOyBpID0gKytfaikge1xuICAgICAgICAgICAgdGFpbCA9IGVuZENvZGVbaV07XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0Q29kZVtpXTtcblxuICAgICAgICAgICAgZm9yIChjb2RlID0gX2sgPSBzdGFydDsgc3RhcnQgPD0gdGFpbCA/IF9rIDw9IHRhaWwgOiBfayA+PSB0YWlsOyBjb2RlID0gc3RhcnQgPD0gdGFpbCA/ICsrX2sgOiAtLV9rKSB7XG4gICAgICAgICAgICAgIGlmIChpZFJhbmdlT2Zmc2V0W2ldID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJZCA9IGNvZGUgKyBpZERlbHRhW2ldO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaWRSYW5nZU9mZnNldFtpXSAvIDIgKyAoY29kZSAtIHN0YXJ0KSAtIChzZWdDb3VudCAtIGkpO1xuICAgICAgICAgICAgICAgIGdseXBoSWQgPSBnbHlwaElkc1tpbmRleF0gfHwgMDtcblxuICAgICAgICAgICAgICAgIGlmIChnbHlwaElkICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBnbHlwaElkICs9IGlkRGVsdGFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5jb2RlTWFwW2NvZGVdID0gZ2x5cGhJZCAmIDB4RkZGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgZGF0YS5wb3MgPSBzYXZlT2Zmc2V0O1xuICAgIH1cblxuICAgIENtYXBFbnRyeS5lbmNvZGUgPSBmdW5jdGlvbiAoY2hhcm1hcCwgZW5jb2RpbmcpIHtcbiAgICAgIHZhciBjaGFyTWFwLCBjb2RlLCBjb2RlTWFwLCBjb2RlcywgZGVsdGEsIGRlbHRhcywgZGlmZiwgZW5kQ29kZSwgZW5kQ29kZXMsIGVudHJ5U2VsZWN0b3IsIGdseXBoSURzLCBpLCBpZCwgaW5kZXhlcywgbGFzdCwgbWFwLCBuZXh0SUQsIG9mZnNldCwgb2xkLCByYW5nZU9mZnNldHMsIHJhbmdlU2hpZnQsIHJlc3VsdCwgc2VhcmNoUmFuZ2UsIHNlZ0NvdW50LCBzZWdDb3VudFgyLCBzdGFydENvZGUsIHN0YXJ0Q29kZXMsIHN0YXJ0R2x5cGgsIHN1YnRhYmxlLCBfaSwgX2osIF9rLCBfbCwgX2xlbiwgX2xlbjEsIF9sZW4yLCBfbGVuMywgX2xlbjQsIF9sZW41LCBfbGVuNiwgX2xlbjcsIF9tLCBfbiwgX25hbWUsIF9vLCBfcCwgX3E7XG5cbiAgICAgIHN1YnRhYmxlID0gbmV3IERhdGEoKTtcbiAgICAgIGNvZGVzID0gT2JqZWN0LmtleXMoY2hhcm1hcCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9KTtcblxuICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlICdtYWNyb21hbic6XG4gICAgICAgICAgaWQgPSAwO1xuXG4gICAgICAgICAgaW5kZXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfaSwgX3Jlc3VsdHM7XG5cbiAgICAgICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPCAyNTY7IGkgPSArK19pKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICAwOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb2RlTWFwID0ge307XG5cbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGNvZGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gY29kZXNbX2ldO1xuXG4gICAgICAgICAgICBpZiAobWFwW19uYW1lID0gY2hhcm1hcFtjb2RlXV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBbX25hbWVdID0gKytpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29kZU1hcFtjb2RlXSA9IHtcbiAgICAgICAgICAgICAgb2xkOiBjaGFybWFwW2NvZGVdLFxuICAgICAgICAgICAgICBcIm5ld1wiOiBtYXBbY2hhcm1hcFtjb2RlXV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbmRleGVzW2NvZGVdID0gbWFwW2NoYXJtYXBbY29kZV1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN1YnRhYmxlLndyaXRlVUludDE2KDEpO1xuICAgICAgICAgIHN1YnRhYmxlLndyaXRlVUludDE2KDApO1xuICAgICAgICAgIHN1YnRhYmxlLndyaXRlVUludDMyKDEyKTtcbiAgICAgICAgICBzdWJ0YWJsZS53cml0ZVVJbnQxNigwKTtcbiAgICAgICAgICBzdWJ0YWJsZS53cml0ZVVJbnQxNigyNjIpO1xuICAgICAgICAgIHN1YnRhYmxlLndyaXRlVUludDE2KDApO1xuICAgICAgICAgIHN1YnRhYmxlLndyaXRlKGluZGV4ZXMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgPSB7XG4gICAgICAgICAgICBjaGFyTWFwOiBjb2RlTWFwLFxuICAgICAgICAgICAgc3VidGFibGU6IHN1YnRhYmxlLmRhdGEsXG4gICAgICAgICAgICBtYXhHbHlwaElEOiBpZCArIDFcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ3VuaWNvZGUnOlxuICAgICAgICAgIHN0YXJ0Q29kZXMgPSBbXTtcbiAgICAgICAgICBlbmRDb2RlcyA9IFtdO1xuICAgICAgICAgIG5leHRJRCA9IDA7XG4gICAgICAgICAgbWFwID0ge307XG4gICAgICAgICAgY2hhck1hcCA9IHt9O1xuICAgICAgICAgIGxhc3QgPSBkaWZmID0gbnVsbDtcblxuICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IGNvZGVzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgY29kZSA9IGNvZGVzW19qXTtcbiAgICAgICAgICAgIG9sZCA9IGNoYXJtYXBbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChtYXBbb2xkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcFtvbGRdID0gKytuZXh0SUQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYXJNYXBbY29kZV0gPSB7XG4gICAgICAgICAgICAgIG9sZDogb2xkLFxuICAgICAgICAgICAgICBcIm5ld1wiOiBtYXBbb2xkXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlbHRhID0gbWFwW29sZF0gLSBjb2RlO1xuXG4gICAgICAgICAgICBpZiAobGFzdCA9PSBudWxsIHx8IGRlbHRhICE9PSBkaWZmKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgZW5kQ29kZXMucHVzaChsYXN0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0YXJ0Q29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgICAgZGlmZiA9IGRlbHRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0ID0gY29kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgZW5kQ29kZXMucHVzaChsYXN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbmRDb2Rlcy5wdXNoKDB4RkZGRik7XG4gICAgICAgICAgc3RhcnRDb2Rlcy5wdXNoKDB4RkZGRik7XG4gICAgICAgICAgc2VnQ291bnQgPSBzdGFydENvZGVzLmxlbmd0aDtcbiAgICAgICAgICBzZWdDb3VudFgyID0gc2VnQ291bnQgKiAyO1xuICAgICAgICAgIHNlYXJjaFJhbmdlID0gMiAqIE1hdGgucG93KE1hdGgubG9nKHNlZ0NvdW50KSAvIE1hdGguTE4yLCAyKTtcbiAgICAgICAgICBlbnRyeVNlbGVjdG9yID0gTWF0aC5sb2coc2VhcmNoUmFuZ2UgLyAyKSAvIE1hdGguTE4yO1xuICAgICAgICAgIHJhbmdlU2hpZnQgPSAyICogc2VnQ291bnQgLSBzZWFyY2hSYW5nZTtcbiAgICAgICAgICBkZWx0YXMgPSBbXTtcbiAgICAgICAgICByYW5nZU9mZnNldHMgPSBbXTtcbiAgICAgICAgICBnbHlwaElEcyA9IFtdO1xuXG4gICAgICAgICAgZm9yIChpID0gX2sgPSAwLCBfbGVuMiA9IHN0YXJ0Q29kZXMubGVuZ3RoOyBfayA8IF9sZW4yOyBpID0gKytfaykge1xuICAgICAgICAgICAgc3RhcnRDb2RlID0gc3RhcnRDb2Rlc1tpXTtcbiAgICAgICAgICAgIGVuZENvZGUgPSBlbmRDb2Rlc1tpXTtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0Q29kZSA9PT0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgIGRlbHRhcy5wdXNoKDApO1xuICAgICAgICAgICAgICByYW5nZU9mZnNldHMucHVzaCgwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXJ0R2x5cGggPSBjaGFyTWFwW3N0YXJ0Q29kZV1bXCJuZXdcIl07XG5cbiAgICAgICAgICAgIGlmIChzdGFydENvZGUgLSBzdGFydEdseXBoID49IDB4ODAwMCkge1xuICAgICAgICAgICAgICBkZWx0YXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgcmFuZ2VPZmZzZXRzLnB1c2goMiAqIChnbHlwaElEcy5sZW5ndGggKyBzZWdDb3VudCAtIGkpKTtcblxuICAgICAgICAgICAgICBmb3IgKGNvZGUgPSBfbCA9IHN0YXJ0Q29kZTsgc3RhcnRDb2RlIDw9IGVuZENvZGUgPyBfbCA8PSBlbmRDb2RlIDogX2wgPj0gZW5kQ29kZTsgY29kZSA9IHN0YXJ0Q29kZSA8PSBlbmRDb2RlID8gKytfbCA6IC0tX2wpIHtcbiAgICAgICAgICAgICAgICBnbHlwaElEcy5wdXNoKGNoYXJNYXBbY29kZV1bXCJuZXdcIl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWx0YXMucHVzaChzdGFydEdseXBoIC0gc3RhcnRDb2RlKTtcbiAgICAgICAgICAgICAgcmFuZ2VPZmZzZXRzLnB1c2goMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MTYoMyk7XG4gICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MTYoMSk7XG4gICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MzIoMTIpO1xuICAgICAgICAgIHN1YnRhYmxlLndyaXRlVUludDE2KDQpO1xuICAgICAgICAgIHN1YnRhYmxlLndyaXRlVUludDE2KDE2ICsgc2VnQ291bnQgKiA4ICsgZ2x5cGhJRHMubGVuZ3RoICogMik7XG4gICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MTYoMCk7XG4gICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MTYoc2VnQ291bnRYMik7XG4gICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MTYoc2VhcmNoUmFuZ2UpO1xuICAgICAgICAgIHN1YnRhYmxlLndyaXRlVUludDE2KGVudHJ5U2VsZWN0b3IpO1xuICAgICAgICAgIHN1YnRhYmxlLndyaXRlVUludDE2KHJhbmdlU2hpZnQpO1xuXG4gICAgICAgICAgZm9yIChfbSA9IDAsIF9sZW4zID0gZW5kQ29kZXMubGVuZ3RoOyBfbSA8IF9sZW4zOyBfbSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gZW5kQ29kZXNbX21dO1xuICAgICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MTYoY29kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MTYoMCk7XG5cbiAgICAgICAgICBmb3IgKF9uID0gMCwgX2xlbjQgPSBzdGFydENvZGVzLmxlbmd0aDsgX24gPCBfbGVuNDsgX24rKykge1xuICAgICAgICAgICAgY29kZSA9IHN0YXJ0Q29kZXNbX25dO1xuICAgICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MTYoY29kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChfbyA9IDAsIF9sZW41ID0gZGVsdGFzLmxlbmd0aDsgX28gPCBfbGVuNTsgX28rKykge1xuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YXNbX29dO1xuICAgICAgICAgICAgc3VidGFibGUud3JpdGVVSW50MTYoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoX3AgPSAwLCBfbGVuNiA9IHJhbmdlT2Zmc2V0cy5sZW5ndGg7IF9wIDwgX2xlbjY7IF9wKyspIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHJhbmdlT2Zmc2V0c1tfcF07XG4gICAgICAgICAgICBzdWJ0YWJsZS53cml0ZVVJbnQxNihvZmZzZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoX3EgPSAwLCBfbGVuNyA9IGdseXBoSURzLmxlbmd0aDsgX3EgPCBfbGVuNzsgX3ErKykge1xuICAgICAgICAgICAgaWQgPSBnbHlwaElEc1tfcV07XG4gICAgICAgICAgICBzdWJ0YWJsZS53cml0ZVVJbnQxNihpZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGNoYXJNYXA6IGNoYXJNYXAsXG4gICAgICAgICAgICBzdWJ0YWJsZTogc3VidGFibGUuZGF0YSxcbiAgICAgICAgICAgIG1heEdseXBoSUQ6IG5leHRJRCArIDFcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ21hcEVudHJ5O1xuICB9KCk7XG5cbiAgdmFyIENtYXBUYWJsZSA9IGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ21hcFRhYmxlLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ21hcFRhYmxlKCkge1xuICAgICAgcmV0dXJuIENtYXBUYWJsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBDbWFwVGFibGUucHJvdG90eXBlLnRhZyA9ICdjbWFwJztcblxuICAgIENtYXBUYWJsZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGVudHJ5LCBpLCB0YWJsZUNvdW50LCBfaTtcblxuICAgICAgZGF0YS5wb3MgPSB0aGlzLm9mZnNldDtcbiAgICAgIHRoaXMudmVyc2lvbiA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGFibGVDb3VudCA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy50YWJsZXMgPSBbXTtcbiAgICAgIHRoaXMudW5pY29kZSA9IG51bGw7XG5cbiAgICAgIGZvciAoaSA9IF9pID0gMDsgMCA8PSB0YWJsZUNvdW50ID8gX2kgPCB0YWJsZUNvdW50IDogX2kgPiB0YWJsZUNvdW50OyBpID0gMCA8PSB0YWJsZUNvdW50ID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgZW50cnkgPSBuZXcgQ21hcEVudHJ5KGRhdGEsIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy50YWJsZXMucHVzaChlbnRyeSk7XG5cbiAgICAgICAgaWYgKGVudHJ5LmlzVW5pY29kZSkge1xuICAgICAgICAgIGlmICh0aGlzLnVuaWNvZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51bmljb2RlID0gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKiBmdW5jdGlvbiA6IGVuY29kZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qIGNvbW1lbnQgOiBFbmNvZGUgdGhlIGNtYXAgdGFibGUgY29ycmVzcG9uZGluZyB0byB0aGUgaW5wdXQgY2hhcmFjdGVyLiAqL1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIENtYXBUYWJsZS5lbmNvZGUgPSBmdW5jdGlvbiAoY2hhcm1hcCwgZW5jb2RpbmcpIHtcbiAgICAgIHZhciByZXN1bHQsIHRhYmxlO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT0gbnVsbCkge1xuICAgICAgICBlbmNvZGluZyA9ICdtYWNyb21hbic7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IENtYXBFbnRyeS5lbmNvZGUoY2hhcm1hcCwgZW5jb2RpbmcpO1xuICAgICAgdGFibGUgPSBuZXcgRGF0YSgpO1xuICAgICAgdGFibGUud3JpdGVVSW50MTYoMCk7XG4gICAgICB0YWJsZS53cml0ZVVJbnQxNigxKTtcbiAgICAgIHJlc3VsdC50YWJsZSA9IHRhYmxlLmRhdGEuY29uY2F0KHJlc3VsdC5zdWJ0YWJsZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICByZXR1cm4gQ21hcFRhYmxlO1xuICB9KFRhYmxlKTtcblxuICB2YXIgSGhlYVRhYmxlID0gZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIaGVhVGFibGUsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBIaGVhVGFibGUoKSB7XG4gICAgICByZXR1cm4gSGhlYVRhYmxlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIEhoZWFUYWJsZS5wcm90b3R5cGUudGFnID0gJ2hoZWEnO1xuXG4gICAgSGhlYVRhYmxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBkYXRhLnBvcyA9IHRoaXMub2Zmc2V0O1xuICAgICAgdGhpcy52ZXJzaW9uID0gZGF0YS5yZWFkSW50KCk7XG4gICAgICB0aGlzLmFzY2VuZGVyID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMuZGVjZW5kZXIgPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgdGhpcy5saW5lR2FwID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMuYWR2YW5jZVdpZHRoTWF4ID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMubWluTGVmdFNpZGVCZWFyaW5nID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMubWluUmlnaHRTaWRlQmVhcmluZyA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLnhNYXhFeHRlbnQgPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgdGhpcy5jYXJldFNsb3BlUmlzZSA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLmNhcmV0U2xvcGVSdW4gPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgdGhpcy5jYXJldE9mZnNldCA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICBkYXRhLnBvcyArPSA0ICogMjtcbiAgICAgIHRoaXMubWV0cmljRGF0YUZvcm1hdCA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXJPZk1ldHJpY3MgPSBkYXRhLnJlYWRVSW50MTYoKTtcbiAgICB9O1xuICAgIC8qSGhlYVRhYmxlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICAgIHZhciBpLCB0YWJsZSwgX2ksIF9yZWY7XG4gICAgICAgIHRhYmxlID0gbmV3IERhdGE7XG4gICAgICAgIHRhYmxlLndyaXRlSW50KHRoaXMudmVyc2lvbik7XG4gICAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy5hc2NlbmRlcik7XG4gICAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy5kZWNlbmRlcik7XG4gICAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy5saW5lR2FwKTtcbiAgICAgICAgdGFibGUud3JpdGVTaG9ydCh0aGlzLmFkdmFuY2VXaWR0aE1heCk7XG4gICAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy5taW5MZWZ0U2lkZUJlYXJpbmcpO1xuICAgICAgICB0YWJsZS53cml0ZVNob3J0KHRoaXMubWluUmlnaHRTaWRlQmVhcmluZyk7XG4gICAgICAgIHRhYmxlLndyaXRlU2hvcnQodGhpcy54TWF4RXh0ZW50KTtcbiAgICAgICAgdGFibGUud3JpdGVTaG9ydCh0aGlzLmNhcmV0U2xvcGVSaXNlKTtcbiAgICAgICAgdGFibGUud3JpdGVTaG9ydCh0aGlzLmNhcmV0U2xvcGVSdW4pO1xuICAgICAgICB0YWJsZS53cml0ZVNob3J0KHRoaXMuY2FyZXRPZmZzZXQpO1xuICAgICAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYgPSA0ICogMjsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyBpID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgICAgIHRhYmxlLndyaXRlQnl0ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZS53cml0ZVNob3J0KHRoaXMubWV0cmljRGF0YUZvcm1hdCk7XG4gICAgICAgIHRhYmxlLndyaXRlVUludDE2KGlkcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGFibGUuZGF0YTtcbiAgICB9OyovXG5cblxuICAgIHJldHVybiBIaGVhVGFibGU7XG4gIH0oVGFibGUpO1xuXG4gIHZhciBPUzJUYWJsZSA9IGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT1MyVGFibGUsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBPUzJUYWJsZSgpIHtcbiAgICAgIHJldHVybiBPUzJUYWJsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBPUzJUYWJsZS5wcm90b3R5cGUudGFnID0gJ09TLzInO1xuXG4gICAgT1MyVGFibGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBpO1xuICAgICAgZGF0YS5wb3MgPSB0aGlzLm9mZnNldDtcbiAgICAgIHRoaXMudmVyc2lvbiA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy5hdmVyYWdlQ2hhcldpZHRoID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMud2VpZ2h0Q2xhc3MgPSBkYXRhLnJlYWRVSW50MTYoKTtcbiAgICAgIHRoaXMud2lkdGhDbGFzcyA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy50eXBlID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMueVN1YnNjcmlwdFhTaXplID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMueVN1YnNjcmlwdFlTaXplID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMueVN1YnNjcmlwdFhPZmZzZXQgPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgdGhpcy55U3Vic2NyaXB0WU9mZnNldCA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLnlTdXBlcnNjcmlwdFhTaXplID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMueVN1cGVyc2NyaXB0WVNpemUgPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgdGhpcy55U3VwZXJzY3JpcHRYT2Zmc2V0ID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMueVN1cGVyc2NyaXB0WU9mZnNldCA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLnlTdHJpa2VvdXRTaXplID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMueVN0cmlrZW91dFBvc2l0aW9uID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMuZmFtaWx5Q2xhc3MgPSBkYXRhLnJlYWRTaG9ydCgpO1xuXG4gICAgICB0aGlzLnBhbm9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9pLCBfcmVzdWx0cztcblxuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPCAxMDsgaSA9ICsrX2kpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGRhdGEucmVhZEJ5dGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KCk7XG5cbiAgICAgIHRoaXMuY2hhclJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2ksIF9yZXN1bHRzO1xuXG4gICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDQ7IGkgPSArK19pKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnJlYWRJbnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KCk7XG5cbiAgICAgIHRoaXMudmVuZG9ySUQgPSBkYXRhLnJlYWRTdHJpbmcoNCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbiA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICB0aGlzLmZpcnN0Q2hhckluZGV4ID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMubGFzdENoYXJJbmRleCA9IGRhdGEucmVhZFNob3J0KCk7XG5cbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPiAwKSB7XG4gICAgICAgIHRoaXMuYXNjZW50ID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgICAgdGhpcy5kZXNjZW50ID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgICAgdGhpcy5saW5lR2FwID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgICAgdGhpcy53aW5Bc2NlbnQgPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgICB0aGlzLndpbkRlc2NlbnQgPSBkYXRhLnJlYWRTaG9ydCgpO1xuXG4gICAgICAgIHRoaXMuY29kZVBhZ2VSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX2ksIF9yZXN1bHRzO1xuXG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcblxuICAgICAgICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPCAyOyBpID0gKytfaSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnJlYWRJbnQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICB0aGlzLnhIZWlnaHQgPSBkYXRhLnJlYWRTaG9ydCgpO1xuICAgICAgICAgIHRoaXMuY2FwSGVpZ2h0ID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgICAgICB0aGlzLmRlZmF1bHRDaGFyID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgICAgICB0aGlzLmJyZWFrQ2hhciA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWF4Q29udGV4dCA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8qT1MyVGFibGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KCk7XG4gICAgfTsqL1xuXG5cbiAgICByZXR1cm4gT1MyVGFibGU7XG4gIH0oVGFibGUpO1xuXG4gIHZhciBQb3N0VGFibGUgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XG5cbiAgICBfX2V4dGVuZHMoUG9zdFRhYmxlLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gUG9zdFRhYmxlKCkge1xuICAgICAgcmV0dXJuIFBvc3RUYWJsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBQb3N0VGFibGUucHJvdG90eXBlLnRhZyA9ICdwb3N0JztcblxuICAgIFBvc3RUYWJsZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGksIGxlbmd0aCwgbnVtYmVyT2ZHbHlwaHMsIF9pLCBfcmVzdWx0cztcblxuICAgICAgZGF0YS5wb3MgPSB0aGlzLm9mZnNldDtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZGF0YS5yZWFkSW50KCk7XG4gICAgICB0aGlzLml0YWxpY0FuZ2xlID0gZGF0YS5yZWFkSW50KCk7XG4gICAgICB0aGlzLnVuZGVybGluZVBvc2l0aW9uID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHRoaXMuaXNGaXhlZFBpdGNoID0gZGF0YS5yZWFkSW50KCk7XG4gICAgICB0aGlzLm1pbk1lbVR5cGU0MiA9IGRhdGEucmVhZEludCgpO1xuICAgICAgdGhpcy5tYXhNZW1UeXBlNDIgPSBkYXRhLnJlYWRJbnQoKTtcbiAgICAgIHRoaXMubWluTWVtVHlwZTEgPSBkYXRhLnJlYWRJbnQoKTtcbiAgICAgIHRoaXMubWF4TWVtVHlwZTEgPSBkYXRhLnJlYWRJbnQoKTtcblxuICAgICAgc3dpdGNoICh0aGlzLmZvcm1hdCkge1xuICAgICAgICBjYXNlIDB4MDAwMTAwMDA6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAweDAwMDIwMDAwOlxuICAgICAgICAgIG51bWJlck9mR2x5cGhzID0gZGF0YS5yZWFkVUludDE2KCk7XG4gICAgICAgICAgdGhpcy5nbHlwaE5hbWVJbmRleCA9IFtdO1xuXG4gICAgICAgICAgZm9yIChpID0gX2kgPSAwOyAwIDw9IG51bWJlck9mR2x5cGhzID8gX2kgPCBudW1iZXJPZkdseXBocyA6IF9pID4gbnVtYmVyT2ZHbHlwaHM7IGkgPSAwIDw9IG51bWJlck9mR2x5cGhzID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhOYW1lSW5kZXgucHVzaChkYXRhLnJlYWRVSW50MTYoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5uYW1lcyA9IFtdO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgICB3aGlsZSAoZGF0YS5wb3MgPCB0aGlzLm9mZnNldCArIHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBkYXRhLnJlYWRCeXRlKCk7XG5cbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5uYW1lcy5wdXNoKGRhdGEucmVhZFN0cmluZyhsZW5ndGgpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMHgwMDAyNTAwMDpcbiAgICAgICAgICBudW1iZXJPZkdseXBocyA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgICAgIHJldHVybiB0aGlzLm9mZnNldHMgPSBkYXRhLnJlYWQobnVtYmVyT2ZHbHlwaHMpO1xuXG4gICAgICAgIGNhc2UgMHgwMDAzMDAwMDpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDB4MDAwNDAwMDA6XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfcmVmLCBfcmVzdWx0czE7XG5cbiAgICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYgPSB0aGlzLmZpbGUubWF4cC5udW1HbHlwaHM7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgaSA9IDAgPD0gX3JlZiA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKGRhdGEucmVhZFVJbnQzMigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUG9zdFRhYmxlO1xuICB9KFRhYmxlKTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiBmdW5jdGlvbiA6IE5hbWVFbnRyeSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gIC8qIGNvbW1lbnQgOiBTdG9yZSBjb3B5cmlnaHQgaW5mb3JtYXRpb24sIHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGFuZCBsYW5ndWFnZUlEIGluIHRoZSBOYW1lRW50cnkgb2JqZWN0LiovXG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gIHZhciBOYW1lRW50cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmFtZUVudHJ5KHJhdywgZW50cnkpIHtcbiAgICAgIHRoaXMucmF3ID0gcmF3O1xuICAgICAgdGhpcy5sZW5ndGggPSByYXcubGVuZ3RoO1xuICAgICAgdGhpcy5wbGF0Zm9ybUlEID0gZW50cnkucGxhdGZvcm1JRDtcbiAgICAgIHRoaXMuZW5jb2RpbmdJRCA9IGVudHJ5LmVuY29kaW5nSUQ7XG4gICAgICB0aGlzLmxhbmd1YWdlSUQgPSBlbnRyeS5sYW5ndWFnZUlEO1xuICAgIH1cblxuICAgIHJldHVybiBOYW1lRW50cnk7XG4gIH0oKTtcblxuICB2YXIgTmFtZVRhYmxlID0gZnVuY3Rpb24gKF9zdXBlcikge1xuXG4gICAgX19leHRlbmRzKE5hbWVUYWJsZSwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIE5hbWVUYWJsZSgpIHtcbiAgICAgIHJldHVybiBOYW1lVGFibGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgTmFtZVRhYmxlLnByb3RvdHlwZS50YWcgPSAnbmFtZSc7XG5cbiAgICBOYW1lVGFibGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBjb3VudCwgZW50cmllcywgZW50cnksIGZvcm1hdCwgaSwgbmFtZSwgc3RyaW5nT2Zmc2V0LCBzdHJpbmdzLCB0ZXh0LCBfaSwgX2osIF9sZW4sIF9uYW1lO1xuXG4gICAgICBkYXRhLnBvcyA9IHRoaXMub2Zmc2V0O1xuICAgICAgZm9ybWF0ID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIGNvdW50ID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgIHN0cmluZ09mZnNldCA9IGRhdGEucmVhZFNob3J0KCk7XG4gICAgICBlbnRyaWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IF9pID0gMDsgMCA8PSBjb3VudCA/IF9pIDwgY291bnQgOiBfaSA+IGNvdW50OyBpID0gMCA8PSBjb3VudCA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgcGxhdGZvcm1JRDogZGF0YS5yZWFkU2hvcnQoKSxcbiAgICAgICAgICBlbmNvZGluZ0lEOiBkYXRhLnJlYWRTaG9ydCgpLFxuICAgICAgICAgIGxhbmd1YWdlSUQ6IGRhdGEucmVhZFNob3J0KCksXG4gICAgICAgICAgbmFtZUlEOiBkYXRhLnJlYWRTaG9ydCgpLFxuICAgICAgICAgIGxlbmd0aDogZGF0YS5yZWFkU2hvcnQoKSxcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0ICsgc3RyaW5nT2Zmc2V0ICsgZGF0YS5yZWFkU2hvcnQoKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5ncyA9IHt9O1xuXG4gICAgICBmb3IgKGkgPSBfaiA9IDAsIF9sZW4gPSBlbnRyaWVzLmxlbmd0aDsgX2ogPCBfbGVuOyBpID0gKytfaikge1xuICAgICAgICBlbnRyeSA9IGVudHJpZXNbaV07XG4gICAgICAgIGRhdGEucG9zID0gZW50cnkub2Zmc2V0O1xuICAgICAgICB0ZXh0ID0gZGF0YS5yZWFkU3RyaW5nKGVudHJ5Lmxlbmd0aCk7XG4gICAgICAgIG5hbWUgPSBuZXcgTmFtZUVudHJ5KHRleHQsIGVudHJ5KTtcblxuICAgICAgICBpZiAoc3RyaW5nc1tfbmFtZSA9IGVudHJ5Lm5hbWVJRF0gPT0gbnVsbCkge1xuICAgICAgICAgIHN0cmluZ3NbX25hbWVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpbmdzW2VudHJ5Lm5hbWVJRF0ucHVzaChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgIHRoaXMuY29weXJpZ2h0ID0gc3RyaW5nc1swXTtcbiAgICAgIHRoaXMuZm9udEZhbWlseSA9IHN0cmluZ3NbMV07XG4gICAgICB0aGlzLmZvbnRTdWJmYW1pbHkgPSBzdHJpbmdzWzJdO1xuICAgICAgdGhpcy51bmlxdWVTdWJmYW1pbHkgPSBzdHJpbmdzWzNdO1xuICAgICAgdGhpcy5mb250TmFtZSA9IHN0cmluZ3NbNF07XG4gICAgICB0aGlzLnZlcnNpb24gPSBzdHJpbmdzWzVdO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnBvc3RzY3JpcHROYW1lID0gc3RyaW5nc1s2XVswXS5yYXcucmVwbGFjZSgvW1xceDAwLVxceDE5XFx4ODAtXFx4ZmZdL2csIFwiXCIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnBvc3RzY3JpcHROYW1lID0gc3RyaW5nc1s0XVswXS5yYXcucmVwbGFjZSgvW1xceDAwLVxceDE5XFx4ODAtXFx4ZmZdL2csIFwiXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYWRlbWFyayA9IHN0cmluZ3NbN107XG4gICAgICB0aGlzLm1hbnVmYWN0dXJlciA9IHN0cmluZ3NbOF07XG4gICAgICB0aGlzLmRlc2lnbmVyID0gc3RyaW5nc1s5XTtcbiAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBzdHJpbmdzWzEwXTtcbiAgICAgIHRoaXMudmVuZG9yVXJsID0gc3RyaW5nc1sxMV07XG4gICAgICB0aGlzLmRlc2lnbmVyVXJsID0gc3RyaW5nc1sxMl07XG4gICAgICB0aGlzLmxpY2Vuc2UgPSBzdHJpbmdzWzEzXTtcbiAgICAgIHRoaXMubGljZW5zZVVybCA9IHN0cmluZ3NbMTRdO1xuICAgICAgdGhpcy5wcmVmZXJyZWRGYW1pbHkgPSBzdHJpbmdzWzE1XTtcbiAgICAgIHRoaXMucHJlZmVycmVkU3ViZmFtaWx5ID0gc3RyaW5nc1sxN107XG4gICAgICB0aGlzLmNvbXBhdGlibGVGdWxsID0gc3RyaW5nc1sxOF07XG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVUZXh0ID0gc3RyaW5nc1sxOV07XG4gICAgfTtcbiAgICAvKk5hbWVUYWJsZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQsIGxpc3QsIG5hbWVJRCwgbmFtZVRhYmxlLCBwb3N0c2NyaXB0TmFtZSwgc3RyQ291bnQsIHN0clRhYmxlLCBzdHJpbmcsIHN0cmluZ3MsIHRhYmxlLCB2YWwsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgICBzdHJpbmdzID0ge307XG4gICAgICAgIF9yZWYgPSB0aGlzLnN0cmluZ3M7XG4gICAgICAgIGZvciAoaWQgaW4gX3JlZikge1xuICAgICAgICAgICAgdmFsID0gX3JlZltpZF07XG4gICAgICAgICAgICBzdHJpbmdzW2lkXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBwb3N0c2NyaXB0TmFtZSA9IG5ldyBOYW1lRW50cnkoXCJcIiArIHN1YnNldFRhZyArIFwiK1wiICsgdGhpcy5wb3N0c2NyaXB0TmFtZSwge1xuICAgICAgICAgICAgcGxhdGZvcm1JRDogMVxuICAgICAgICAgICAgLCBlbmNvZGluZ0lEOiAwXG4gICAgICAgICAgICAsIGxhbmd1YWdlSUQ6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmluZ3NbNl0gPSBbcG9zdHNjcmlwdE5hbWVdO1xuICAgICAgICBzdWJzZXRUYWcgPSBzdWNjZXNzb3JPZihzdWJzZXRUYWcpO1xuICAgICAgICBzdHJDb3VudCA9IDA7XG4gICAgICAgIGZvciAoaWQgaW4gc3RyaW5ncykge1xuICAgICAgICAgICAgbGlzdCA9IHN0cmluZ3NbaWRdO1xuICAgICAgICAgICAgaWYgKGxpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0ckNvdW50ICs9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhYmxlID0gbmV3IERhdGE7XG4gICAgICAgIHN0clRhYmxlID0gbmV3IERhdGE7XG4gICAgICAgIHRhYmxlLndyaXRlU2hvcnQoMCk7XG4gICAgICAgIHRhYmxlLndyaXRlU2hvcnQoc3RyQ291bnQpO1xuICAgICAgICB0YWJsZS53cml0ZVNob3J0KDYgKyAxMiAqIHN0ckNvdW50KTtcbiAgICAgICAgZm9yIChuYW1lSUQgaW4gc3RyaW5ncykge1xuICAgICAgICAgICAgbGlzdCA9IHN0cmluZ3NbbmFtZUlEXTtcbiAgICAgICAgICAgIGlmIChsaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGxpc3QubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gbGlzdFtfaV07XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlLndyaXRlU2hvcnQoc3RyaW5nLnBsYXRmb3JtSUQpO1xuICAgICAgICAgICAgICAgICAgICB0YWJsZS53cml0ZVNob3J0KHN0cmluZy5lbmNvZGluZ0lEKTtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUud3JpdGVTaG9ydChzdHJpbmcubGFuZ3VhZ2VJRCk7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlLndyaXRlU2hvcnQobmFtZUlEKTtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUud3JpdGVTaG9ydChzdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUud3JpdGVTaG9ydChzdHJUYWJsZS5wb3MpO1xuICAgICAgICAgICAgICAgICAgICBzdHJUYWJsZS53cml0ZVN0cmluZyhzdHJpbmcucmF3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWVUYWJsZSA9IHtcbiAgICAgICAgICAgIHBvc3RzY3JpcHROYW1lOiBwb3N0c2NyaXB0TmFtZS5yYXdcbiAgICAgICAgICAgICwgdGFibGU6IHRhYmxlLmRhdGEuY29uY2F0KHN0clRhYmxlLmRhdGEpXG4gICAgICAgIH07XG4gICAgfTsqL1xuXG4gICAgcmV0dXJuIE5hbWVUYWJsZTtcbiAgfShUYWJsZSk7XG5cbiAgdmFyIE1heHBUYWJsZSA9IGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF4cFRhYmxlLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gTWF4cFRhYmxlKCkge1xuICAgICAgcmV0dXJuIE1heHBUYWJsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBNYXhwVGFibGUucHJvdG90eXBlLnRhZyA9ICdtYXhwJztcblxuICAgIE1heHBUYWJsZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgZGF0YS5wb3MgPSB0aGlzLm9mZnNldDtcbiAgICAgIHRoaXMudmVyc2lvbiA9IGRhdGEucmVhZEludCgpO1xuICAgICAgdGhpcy5udW1HbHlwaHMgPSBkYXRhLnJlYWRVSW50MTYoKTtcbiAgICAgIHRoaXMubWF4UG9pbnRzID0gZGF0YS5yZWFkVUludDE2KCk7XG4gICAgICB0aGlzLm1heENvbnRvdXJzID0gZGF0YS5yZWFkVUludDE2KCk7XG4gICAgICB0aGlzLm1heENvbXBvc2l0ZVBvaW50cyA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy5tYXhDb21wb25lbnRDb250b3VycyA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy5tYXhab25lcyA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy5tYXhUd2lsaWdodFBvaW50cyA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy5tYXhTdG9yYWdlID0gZGF0YS5yZWFkVUludDE2KCk7XG4gICAgICB0aGlzLm1heEZ1bmN0aW9uRGVmcyA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy5tYXhJbnN0cnVjdGlvbkRlZnMgPSBkYXRhLnJlYWRVSW50MTYoKTtcbiAgICAgIHRoaXMubWF4U3RhY2tFbGVtZW50cyA9IGRhdGEucmVhZFVJbnQxNigpO1xuICAgICAgdGhpcy5tYXhTaXplT2ZJbnN0cnVjdGlvbnMgPSBkYXRhLnJlYWRVSW50MTYoKTtcbiAgICAgIHRoaXMubWF4Q29tcG9uZW50RWxlbWVudHMgPSBkYXRhLnJlYWRVSW50MTYoKTtcbiAgICAgIHJldHVybiB0aGlzLm1heENvbXBvbmVudERlcHRoID0gZGF0YS5yZWFkVUludDE2KCk7XG4gICAgfTtcbiAgICAvKk1heHBUYWJsZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgICB2YXIgdGFibGU7XG4gICAgICAgIHRhYmxlID0gbmV3IERhdGE7XG4gICAgICAgIHRhYmxlLndyaXRlSW50KHRoaXMudmVyc2lvbik7XG4gICAgICAgIHRhYmxlLndyaXRlVUludDE2KGlkcy5sZW5ndGgpO1xuICAgICAgICB0YWJsZS53cml0ZVVJbnQxNih0aGlzLm1heFBvaW50cyk7XG4gICAgICAgIHRhYmxlLndyaXRlVUludDE2KHRoaXMubWF4Q29udG91cnMpO1xuICAgICAgICB0YWJsZS53cml0ZVVJbnQxNih0aGlzLm1heENvbXBvc2l0ZVBvaW50cyk7XG4gICAgICAgIHRhYmxlLndyaXRlVUludDE2KHRoaXMubWF4Q29tcG9uZW50Q29udG91cnMpO1xuICAgICAgICB0YWJsZS53cml0ZVVJbnQxNih0aGlzLm1heFpvbmVzKTtcbiAgICAgICAgdGFibGUud3JpdGVVSW50MTYodGhpcy5tYXhUd2lsaWdodFBvaW50cyk7XG4gICAgICAgIHRhYmxlLndyaXRlVUludDE2KHRoaXMubWF4U3RvcmFnZSk7XG4gICAgICAgIHRhYmxlLndyaXRlVUludDE2KHRoaXMubWF4RnVuY3Rpb25EZWZzKTtcbiAgICAgICAgdGFibGUud3JpdGVVSW50MTYodGhpcy5tYXhJbnN0cnVjdGlvbkRlZnMpO1xuICAgICAgICB0YWJsZS53cml0ZVVJbnQxNih0aGlzLm1heFN0YWNrRWxlbWVudHMpO1xuICAgICAgICB0YWJsZS53cml0ZVVJbnQxNih0aGlzLm1heFNpemVPZkluc3RydWN0aW9ucyk7XG4gICAgICAgIHRhYmxlLndyaXRlVUludDE2KHRoaXMubWF4Q29tcG9uZW50RWxlbWVudHMpO1xuICAgICAgICB0YWJsZS53cml0ZVVJbnQxNih0aGlzLm1heENvbXBvbmVudERlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmRhdGE7XG4gICAgfTsqL1xuXG5cbiAgICByZXR1cm4gTWF4cFRhYmxlO1xuICB9KFRhYmxlKTtcblxuICB2YXIgSG10eFRhYmxlID0gZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIbXR4VGFibGUsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBIbXR4VGFibGUoKSB7XG4gICAgICByZXR1cm4gSG10eFRhYmxlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIEhtdHhUYWJsZS5wcm90b3R5cGUudGFnID0gJ2htdHgnO1xuXG4gICAgSG10eFRhYmxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgaSwgbGFzdCwgbHNiQ291bnQsIG0sIF9pLCBfaiwgX3JlZiwgX3Jlc3VsdHM7XG5cbiAgICAgIGRhdGEucG9zID0gdGhpcy5vZmZzZXQ7XG4gICAgICB0aGlzLm1ldHJpY3MgPSBbXTtcblxuICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmID0gdGhpcy5maWxlLmhoZWEubnVtYmVyT2ZNZXRyaWNzOyAwIDw9IF9yZWYgPyBfaSA8IF9yZWYgOiBfaSA+IF9yZWY7IGkgPSAwIDw9IF9yZWYgPyArK19pIDogLS1faSkge1xuICAgICAgICB0aGlzLm1ldHJpY3MucHVzaCh7XG4gICAgICAgICAgYWR2YW5jZTogZGF0YS5yZWFkVUludDE2KCksXG4gICAgICAgICAgbHNiOiBkYXRhLnJlYWRJbnQxNigpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBsc2JDb3VudCA9IHRoaXMuZmlsZS5tYXhwLm51bUdseXBocyAtIHRoaXMuZmlsZS5oaGVhLm51bWJlck9mTWV0cmljcztcblxuICAgICAgdGhpcy5sZWZ0U2lkZUJlYXJpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2osIF9yZXN1bHRzO1xuXG4gICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gX2ogPSAwOyAwIDw9IGxzYkNvdW50ID8gX2ogPCBsc2JDb3VudCA6IF9qID4gbHNiQ291bnQ7IGkgPSAwIDw9IGxzYkNvdW50ID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGRhdGEucmVhZEludDE2KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSgpO1xuXG4gICAgICB0aGlzLndpZHRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9qLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG5cbiAgICAgICAgX3JlZjEgPSB0aGlzLm1ldHJpY3M7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjsgX2orKykge1xuICAgICAgICAgIG0gPSBfcmVmMVtfal07XG5cbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKG0uYWR2YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9LmNhbGwodGhpcyk7XG5cbiAgICAgIGxhc3QgPSB0aGlzLndpZHRoc1t0aGlzLndpZHRocy5sZW5ndGggLSAxXTtcbiAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAoaSA9IF9qID0gMDsgMCA8PSBsc2JDb3VudCA/IF9qIDwgbHNiQ291bnQgOiBfaiA+IGxzYkNvdW50OyBpID0gMCA8PSBsc2JDb3VudCA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy53aWR0aHMucHVzaChsYXN0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKiBmdW5jdGlvbiA6IGZvckdseXBoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgLyogY29tbWVudCA6IFJldHVybnMgdGhlIGFkdmFuY2Ugd2lkdGggYW5kIGxzYiBmb3IgdGhpcyBnbHlwaC4gKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIEhtdHhUYWJsZS5wcm90b3R5cGUuZm9yR2x5cGggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciBtZXRyaWNzO1xuXG4gICAgICBpZiAoaWQgaW4gdGhpcy5tZXRyaWNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldHJpY3NbaWRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWV0cmljcyA9IHtcbiAgICAgICAgYWR2YW5jZTogdGhpcy5tZXRyaWNzW3RoaXMubWV0cmljcy5sZW5ndGggLSAxXS5hZHZhbmNlLFxuICAgICAgICBsc2I6IHRoaXMubGVmdFNpZGVCZWFyaW5nc1tpZCAtIHRoaXMubWV0cmljcy5sZW5ndGhdXG4gICAgICB9O1xuICAgIH07XG4gICAgLypIbXR4VGFibGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBpZCwgbWV0cmljLCB0YWJsZSwgX2ksIF9sZW47XG4gICAgICAgIHRhYmxlID0gbmV3IERhdGE7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gbWFwcGluZy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgaWQgPSBtYXBwaW5nW19pXTtcbiAgICAgICAgICAgIG1ldHJpYyA9IHRoaXMuZm9yR2x5cGgoaWQpO1xuICAgICAgICAgICAgdGFibGUud3JpdGVVSW50MTYobWV0cmljLmFkdmFuY2UpO1xuICAgICAgICAgICAgdGFibGUud3JpdGVVSW50MTYobWV0cmljLmxzYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhYmxlLmRhdGE7XG4gICAgfTsqL1xuXG5cbiAgICByZXR1cm4gSG10eFRhYmxlO1xuICB9KFRhYmxlKTtcblxuICB2YXIgX19zbGljZSA9IFtdLnNsaWNlO1xuXG4gIHZhciBHbHlmVGFibGUgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdseWZUYWJsZSwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEdseWZUYWJsZSgpIHtcbiAgICAgIHJldHVybiBHbHlmVGFibGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgR2x5ZlRhYmxlLnByb3RvdHlwZS50YWcgPSAnZ2x5Zic7XG5cbiAgICBHbHlmVGFibGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlID0ge307XG4gICAgfTtcblxuICAgIEdseWZUYWJsZS5wcm90b3R5cGUuZ2x5cGhGb3IgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlkID0gaWQ7XG4gICAgICB2YXIgZGF0YSwgaW5kZXgsIGxlbmd0aCwgbG9jYSwgbnVtYmVyT2ZDb250b3VycywgcmF3LCB4TWF4LCB4TWluLCB5TWF4LCB5TWluO1xuXG4gICAgICBpZiAoaWQgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVtpZF07XG4gICAgICB9XG5cbiAgICAgIGxvY2EgPSB0aGlzLmZpbGUubG9jYTtcbiAgICAgIGRhdGEgPSB0aGlzLmZpbGUuY29udGVudHM7XG4gICAgICBpbmRleCA9IGxvY2EuaW5kZXhPZihpZCk7XG4gICAgICBsZW5ndGggPSBsb2NhLmxlbmd0aE9mKGlkKTtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVtpZF0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBvcyA9IHRoaXMub2Zmc2V0ICsgaW5kZXg7XG4gICAgICByYXcgPSBuZXcgRGF0YShkYXRhLnJlYWQobGVuZ3RoKSk7XG4gICAgICBudW1iZXJPZkNvbnRvdXJzID0gcmF3LnJlYWRTaG9ydCgpO1xuICAgICAgeE1pbiA9IHJhdy5yZWFkU2hvcnQoKTtcbiAgICAgIHlNaW4gPSByYXcucmVhZFNob3J0KCk7XG4gICAgICB4TWF4ID0gcmF3LnJlYWRTaG9ydCgpO1xuICAgICAgeU1heCA9IHJhdy5yZWFkU2hvcnQoKTtcblxuICAgICAgaWYgKG51bWJlck9mQ29udG91cnMgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY2FjaGVbaWRdID0gbmV3IENvbXBvdW5kR2x5cGgocmF3LCB4TWluLCB5TWluLCB4TWF4LCB5TWF4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVbaWRdID0gbmV3IFNpbXBsZUdseXBoKHJhdywgbnVtYmVyT2ZDb250b3VycywgeE1pbiwgeU1pbiwgeE1heCwgeU1heCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlW2lkXTtcbiAgICB9O1xuXG4gICAgR2x5ZlRhYmxlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoZ2x5cGhzLCBtYXBwaW5nLCBvbGQybmV3KSB7XG4gICAgICB2YXIgZ2x5cGgsIGlkLCBvZmZzZXRzLCB0YWJsZSwgX2ksIF9sZW47XG5cbiAgICAgIHRhYmxlID0gW107XG4gICAgICBvZmZzZXRzID0gW107XG5cbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gbWFwcGluZy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBpZCA9IG1hcHBpbmdbX2ldO1xuICAgICAgICBnbHlwaCA9IGdseXBoc1tpZF07XG4gICAgICAgIG9mZnNldHMucHVzaCh0YWJsZS5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChnbHlwaCkge1xuICAgICAgICAgIHRhYmxlID0gdGFibGUuY29uY2F0KGdseXBoLmVuY29kZShvbGQybmV3KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb2Zmc2V0cy5wdXNoKHRhYmxlLmxlbmd0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgIG9mZnNldHM6IG9mZnNldHNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBHbHlmVGFibGU7XG4gIH0oVGFibGUpO1xuXG4gIHZhciBTaW1wbGVHbHlwaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKiBmdW5jdGlvbiA6IFNpbXBsZUdseXBoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAvKiBjb21tZW50IDogU3RvcmVzIHJhdywgeE1pbiwgeU1pbiwgeE1heCwgYW5kIHlNYXggdmFsdWVzIGZvciB0aGlzIGdseXBoLiovXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgZnVuY3Rpb24gU2ltcGxlR2x5cGgocmF3LCBudW1iZXJPZkNvbnRvdXJzLCB4TWluLCB5TWluLCB4TWF4LCB5TWF4KSB7XG4gICAgICB0aGlzLnJhdyA9IHJhdztcbiAgICAgIHRoaXMubnVtYmVyT2ZDb250b3VycyA9IG51bWJlck9mQ29udG91cnM7XG4gICAgICB0aGlzLnhNaW4gPSB4TWluO1xuICAgICAgdGhpcy55TWluID0geU1pbjtcbiAgICAgIHRoaXMueE1heCA9IHhNYXg7XG4gICAgICB0aGlzLnlNYXggPSB5TWF4O1xuICAgICAgdGhpcy5jb21wb3VuZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIFNpbXBsZUdseXBoLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYXcuZGF0YTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNpbXBsZUdseXBoO1xuICB9KCk7XG5cbiAgdmFyIENvbXBvdW5kR2x5cGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEFSR18xX0FORF8yX0FSRV9XT1JEUywgTU9SRV9DT01QT05FTlRTLCBXRV9IQVZFX0FOX1hfQU5EX1lfU0NBTEUsIFdFX0hBVkVfQV9TQ0FMRSwgV0VfSEFWRV9BX1RXT19CWV9UV087XG4gICAgQVJHXzFfQU5EXzJfQVJFX1dPUkRTID0gMHgwMDAxO1xuICAgIFdFX0hBVkVfQV9TQ0FMRSA9IDB4MDAwODtcbiAgICBNT1JFX0NPTVBPTkVOVFMgPSAweDAwMjA7XG4gICAgV0VfSEFWRV9BTl9YX0FORF9ZX1NDQUxFID0gMHgwMDQwO1xuICAgIFdFX0hBVkVfQV9UV09fQllfVFdPID0gMHgwMDgwO1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qIGZ1bmN0aW9uIDogQ29tcG91bmRHbHlwZyBnZW5lcmF0b3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qIGNvbW1lbnQgOiBJdCBzdG9yZXMgcmF3LCB4TWluLCB5TWluLCB4TWF4LCB5TWF4LCBnbHlwaCBpZCwgYW5kIGdseXBoIG9mZnNldCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgY29tcG91bmQgZ2x5cGguKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIENvbXBvdW5kR2x5cGgocmF3LCB4TWluLCB5TWluLCB4TWF4LCB5TWF4KSB7XG4gICAgICB2YXIgZGF0YSwgZmxhZ3M7XG4gICAgICB0aGlzLnJhdyA9IHJhdztcbiAgICAgIHRoaXMueE1pbiA9IHhNaW47XG4gICAgICB0aGlzLnlNaW4gPSB5TWluO1xuICAgICAgdGhpcy54TWF4ID0geE1heDtcbiAgICAgIHRoaXMueU1heCA9IHlNYXg7XG4gICAgICB0aGlzLmNvbXBvdW5kID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ2x5cGhJRHMgPSBbXTtcbiAgICAgIHRoaXMuZ2x5cGhPZmZzZXRzID0gW107XG4gICAgICBkYXRhID0gdGhpcy5yYXc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGZsYWdzID0gZGF0YS5yZWFkU2hvcnQoKTtcbiAgICAgICAgdGhpcy5nbHlwaE9mZnNldHMucHVzaChkYXRhLnBvcyk7XG4gICAgICAgIHRoaXMuZ2x5cGhJRHMucHVzaChkYXRhLnJlYWRTaG9ydCgpKTtcblxuICAgICAgICBpZiAoIShmbGFncyAmIE1PUkVfQ09NUE9ORU5UUykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIEFSR18xX0FORF8yX0FSRV9XT1JEUykge1xuICAgICAgICAgIGRhdGEucG9zICs9IDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YS5wb3MgKz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFdFX0hBVkVfQV9UV09fQllfVFdPKSB7XG4gICAgICAgICAgZGF0YS5wb3MgKz0gODtcbiAgICAgICAgfSBlbHNlIGlmIChmbGFncyAmIFdFX0hBVkVfQU5fWF9BTkRfWV9TQ0FMRSkge1xuICAgICAgICAgIGRhdGEucG9zICs9IDQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgJiBXRV9IQVZFX0FfU0NBTEUpIHtcbiAgICAgICAgICBkYXRhLnBvcyArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyogZnVuY3Rpb24gOiBDb21wb3VuZEdseXBnIGVuY29kZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAvKiBjb21tZW50IDogQWZ0ZXIgY3JlYXRpbmcgYSB0YWJsZSBmb3IgdGhlIGNoYXJhY3RlcnMgeW91IHR5cGVkLCB5b3UgY2FsbCBkaXJlY3RvcnkuZW5jb2RlIHRvIGVuY29kZSB0aGUgdGFibGUuKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBDb21wb3VuZEdseXBoLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIGksIGlkLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0YShfX3NsaWNlLmNhbGwodGhpcy5yYXcuZGF0YSkpO1xuICAgICAgX3JlZiA9IHRoaXMuZ2x5cGhJRHM7XG5cbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gICAgICAgIGlkID0gX3JlZltpXTtcbiAgICAgICAgcmVzdWx0LnBvcyA9IHRoaXMuZ2x5cGhPZmZzZXRzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgfTtcblxuICAgIHJldHVybiBDb21wb3VuZEdseXBoO1xuICB9KCk7XG5cbiAgdmFyIExvY2FUYWJsZSA9IGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYVRhYmxlLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gTG9jYVRhYmxlKCkge1xuICAgICAgcmV0dXJuIExvY2FUYWJsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBMb2NhVGFibGUucHJvdG90eXBlLnRhZyA9ICdsb2NhJztcblxuICAgIExvY2FUYWJsZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGZvcm1hdCwgaTtcbiAgICAgIGRhdGEucG9zID0gdGhpcy5vZmZzZXQ7XG4gICAgICBmb3JtYXQgPSB0aGlzLmZpbGUuaGVhZC5pbmRleFRvTG9jRm9ybWF0O1xuXG4gICAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9pLCBfcmVmLCBfcmVzdWx0cztcblxuICAgICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYgPSB0aGlzLmxlbmd0aDsgX2kgPCBfcmVmOyBpID0gX2kgKz0gMikge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnJlYWRVSW50MTYoKSAqIDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfS5jYWxsKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX2ksIF9yZWYsIF9yZXN1bHRzO1xuXG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcblxuICAgICAgICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZiA9IHRoaXMubGVuZ3RoOyBfaSA8IF9yZWY7IGkgPSBfaSArPSA0KSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGRhdGEucmVhZFVJbnQzMigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0uY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTG9jYVRhYmxlLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXRzW2lkXTtcbiAgICB9O1xuXG4gICAgTG9jYVRhYmxlLnByb3RvdHlwZS5sZW5ndGhPZiA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0c1tpZCArIDFdIC0gdGhpcy5vZmZzZXRzW2lkXTtcbiAgICB9O1xuXG4gICAgTG9jYVRhYmxlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAob2Zmc2V0cywgYWN0aXZlR2x5cGhzKSB7XG4gICAgICB2YXIgTG9jYVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KHRoaXMub2Zmc2V0cy5sZW5ndGgpO1xuICAgICAgdmFyIGdseWZQdHIgPSAwO1xuICAgICAgdmFyIGxpc3RHbHlmID0gMDtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBMb2NhVGFibGUubGVuZ3RoOyArK2spIHtcbiAgICAgICAgTG9jYVRhYmxlW2tdID0gZ2x5ZlB0cjtcblxuICAgICAgICBpZiAobGlzdEdseWYgPCBhY3RpdmVHbHlwaHMubGVuZ3RoICYmIGFjdGl2ZUdseXBoc1tsaXN0R2x5Zl0gPT0gaykge1xuICAgICAgICAgICsrbGlzdEdseWY7XG4gICAgICAgICAgTG9jYVRhYmxlW2tdID0gZ2x5ZlB0cjtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldHNba107XG4gICAgICAgICAgdmFyIGxlbiA9IHRoaXMub2Zmc2V0c1trICsgMV0gLSBzdGFydDtcblxuICAgICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBnbHlmUHRyICs9IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0xvY2FUYWJsZSA9IG5ldyBBcnJheShMb2NhVGFibGUubGVuZ3RoICogNCk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgTG9jYVRhYmxlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIG5ld0xvY2FUYWJsZVs0ICogaiArIDNdID0gTG9jYVRhYmxlW2pdICYgMHgwMDAwMDBmZjtcbiAgICAgICAgbmV3TG9jYVRhYmxlWzQgKiBqICsgMl0gPSAoTG9jYVRhYmxlW2pdICYgMHgwMDAwZmYwMCkgPj4gODtcbiAgICAgICAgbmV3TG9jYVRhYmxlWzQgKiBqICsgMV0gPSAoTG9jYVRhYmxlW2pdICYgMHgwMGZmMDAwMCkgPj4gMTY7XG4gICAgICAgIG5ld0xvY2FUYWJsZVs0ICogal0gPSAoTG9jYVRhYmxlW2pdICYgMHhmZjAwMDAwMCkgPj4gMjQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdMb2NhVGFibGU7XG4gICAgfTtcblxuICAgIHJldHVybiBMb2NhVGFibGU7XG4gIH0oVGFibGUpO1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qIGZ1bmN0aW9uIDogaW52ZXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLyogY29tbWVudCA6IENoYW5nZSB0aGUgb2JqZWN0J3MgKGtleTogdmFsdWUpIHRvIGNyZWF0ZSBhbiBvYmplY3Qgd2l0aCAodmFsdWU6IGtleSkuKi9cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIGludmVydCA9IGZ1bmN0aW9uIGludmVydChvYmplY3QpIHtcbiAgICB2YXIga2V5LCByZXQsIHZhbDtcbiAgICByZXQgPSB7fTtcblxuICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgdmFsID0gb2JqZWN0W2tleV07XG4gICAgICByZXRbdmFsXSA9IGtleTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICAvKnZhciBzdWNjZXNzb3JPZiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdmFyIGFkZGVkLCBhbHBoYWJldCwgY2FycnksIGksIGluZGV4LCBpc1VwcGVyQ2FzZSwgbGFzdCwgbGVuZ3RoLCBuZXh0LCByZXN1bHQ7XG4gICAgICBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XG4gICAgICBsZW5ndGggPSBhbHBoYWJldC5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBpbnB1dDtcbiAgICAgIGkgPSBpbnB1dC5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgbGFzdCA9IGlucHV0LmNoYXJBdCgtLWkpO1xuICAgICAgICAgIGlmIChpc05hTihsYXN0KSkge1xuICAgICAgICAgICAgICBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGFzdC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgbmV4dCA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXh0ID0gYWxwaGFiZXQuY2hhckF0KChpbmRleCArIDEpICUgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIGlzVXBwZXJDYXNlID0gbGFzdCA9PT0gbGFzdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVXBwZXJDYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gaW5kZXggKyAxID49IGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGlmIChjYXJyeSAmJiBpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkZWQgPSBpc1VwcGVyQ2FzZSA/ICdBJyA6ICdhJztcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhZGRlZCArIG5leHQgKyByZXN1bHQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG5leHQgPSArbGFzdCArIDE7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gbmV4dCA+IDk7XG4gICAgICAgICAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICAgICAgICAgICAgbmV4dCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhcnJ5ICYmIGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcxJyArIG5leHQgKyByZXN1bHQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaSkgKyBuZXh0ICsgcmVzdWx0LnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICBpZiAoIWNhcnJ5KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gIH07Ki9cblxuXG4gIHZhciBTdWJzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3Vic2V0KGZvbnQpIHtcbiAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgICB0aGlzLnN1YnNldCA9IHt9O1xuICAgICAgdGhpcy51bmljb2RlcyA9IHt9O1xuICAgICAgdGhpcy5uZXh0ID0gMzM7XG4gICAgfVxuICAgIC8qU3Vic2V0LnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgICAgIHZhciBpLCBfaSwgX3JlZjtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFyYWN0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYgPSBjaGFyYWN0ZXIubGVuZ3RoOyAwIDw9IF9yZWYgPyBfaSA8IF9yZWYgOiBfaSA+IF9yZWY7IGkgPSAwIDw9IF9yZWYgPyArK19pIDogLS1faSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlKGNoYXJhY3Rlci5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudW5pY29kZXNbY2hhcmFjdGVyXSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzZXRbdGhpcy5uZXh0XSA9IGNoYXJhY3RlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWNvZGVzW2NoYXJhY3Rlcl0gPSB0aGlzLm5leHQrKztcbiAgICAgICAgfVxuICAgIH07Ki9cblxuICAgIC8qU3Vic2V0LnByb3RvdHlwZS5lbmNvZGVUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIGNoYXIsIGksIHN0cmluZywgX2ksIF9yZWY7XG4gICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYgPSB0ZXh0Lmxlbmd0aDsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyBpID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgICAgIGNoYXIgPSB0aGlzLnVuaWNvZGVzW3RleHQuY2hhckNvZGVBdChpKV07XG4gICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07Ki9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKiBmdW5jdGlvbiA6IGdlbmVyYXRlQ21hcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgLyogY29tbWVudCA6IFJldHVybnMgdGhlIHVuaWNvZGUgY21hcCBmb3IgdGhpcyBmb250LiAgICAgICAgICovXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBTdWJzZXQucHJvdG90eXBlLmdlbmVyYXRlQ21hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXBwaW5nLCByb21hbiwgdW5pY29kZSwgdW5pY29kZUNtYXAsIF9yZWY7XG5cbiAgICAgIHVuaWNvZGVDbWFwID0gdGhpcy5mb250LmNtYXAudGFibGVzWzBdLmNvZGVNYXA7XG4gICAgICBtYXBwaW5nID0ge307XG4gICAgICBfcmVmID0gdGhpcy5zdWJzZXQ7XG5cbiAgICAgIGZvciAocm9tYW4gaW4gX3JlZikge1xuICAgICAgICB1bmljb2RlID0gX3JlZltyb21hbl07XG4gICAgICAgIG1hcHBpbmdbcm9tYW5dID0gdW5pY29kZUNtYXBbdW5pY29kZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXBwaW5nO1xuICAgIH07XG4gICAgLypTdWJzZXQucHJvdG90eXBlLmdseXBoSURzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0LCByb21hbiwgdW5pY29kZSwgdW5pY29kZUNtYXAsIHZhbCwgX3JlZjtcbiAgICAgICAgdW5pY29kZUNtYXAgPSB0aGlzLmZvbnQuY21hcC50YWJsZXNbMF0uY29kZU1hcDtcbiAgICAgICAgcmV0ID0gWzBdO1xuICAgICAgICBfcmVmID0gdGhpcy5zdWJzZXQ7XG4gICAgICAgIGZvciAocm9tYW4gaW4gX3JlZikge1xuICAgICAgICAgICAgdW5pY29kZSA9IF9yZWZbcm9tYW5dO1xuICAgICAgICAgICAgdmFsID0gdW5pY29kZUNtYXBbdW5pY29kZV07XG4gICAgICAgICAgICBpZiAoKHZhbCAhPSBudWxsKSAmJiBfX2luZGV4T2YuY2FsbChyZXQsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0LnNvcnQoKTtcbiAgICB9OyovXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyogZnVuY3Rpb24gOiBnbHlwaHNGb3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qIGNvbW1lbnQgOiBSZXR1cm5zIHNpbXBsZSBnbHlwaCBvYmplY3RzIGZvciB0aGUgaW5wdXQgY2hhcmFjdGVyLiovXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBTdWJzZXQucHJvdG90eXBlLmdseXBoc0ZvciA9IGZ1bmN0aW9uIChnbHlwaElEcykge1xuICAgICAgdmFyIGFkZGl0aW9uYWxJRHMsIGdseXBoLCBnbHlwaHMsIGlkLCBfaSwgX2xlbiwgX3JlZjtcblxuICAgICAgZ2x5cGhzID0ge307XG5cbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZ2x5cGhJRHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgaWQgPSBnbHlwaElEc1tfaV07XG4gICAgICAgIGdseXBoc1tpZF0gPSB0aGlzLmZvbnQuZ2x5Zi5nbHlwaEZvcihpZCk7XG4gICAgICB9XG5cbiAgICAgIGFkZGl0aW9uYWxJRHMgPSBbXTtcblxuICAgICAgZm9yIChpZCBpbiBnbHlwaHMpIHtcbiAgICAgICAgZ2x5cGggPSBnbHlwaHNbaWRdO1xuXG4gICAgICAgIGlmIChnbHlwaCAhPSBudWxsID8gZ2x5cGguY29tcG91bmQgOiB2b2lkIDApIHtcbiAgICAgICAgICBhZGRpdGlvbmFsSURzLnB1c2guYXBwbHkoYWRkaXRpb25hbElEcywgZ2x5cGguZ2x5cGhJRHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRpdGlvbmFsSURzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX3JlZiA9IHRoaXMuZ2x5cGhzRm9yKGFkZGl0aW9uYWxJRHMpO1xuXG4gICAgICAgIGZvciAoaWQgaW4gX3JlZikge1xuICAgICAgICAgIGdseXBoID0gX3JlZltpZF07XG4gICAgICAgICAgZ2x5cGhzW2lkXSA9IGdseXBoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnbHlwaHM7XG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyogZnVuY3Rpb24gOiBlbmNvZGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qIGNvbW1lbnQgOiBFbmNvZGUgdmFyaW91cyB0YWJsZXMgZm9yIHRoZSBjaGFyYWN0ZXJzIHlvdSB1c2UuICovXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBTdWJzZXQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChnbHlJRCwgaW5kZXhUb0xvY0Zvcm1hdCkge1xuICAgICAgdmFyIGNtYXAsIGNvZGUsIGdseWYsIGdseXBocywgaWQsIGlkcywgbG9jYSwgbmV3Mm9sZCwgbmV3SURzLCBuZXh0R2x5cGhJRCwgb2xkMm5ldywgb2xkSUQsIG9sZElEcywgdGFibGVzLCBfcmVmO1xuXG4gICAgICBjbWFwID0gQ21hcFRhYmxlLmVuY29kZSh0aGlzLmdlbmVyYXRlQ21hcCgpLCAndW5pY29kZScpO1xuICAgICAgZ2x5cGhzID0gdGhpcy5nbHlwaHNGb3IoZ2x5SUQpO1xuICAgICAgb2xkMm5ldyA9IHtcbiAgICAgICAgMDogMFxuICAgICAgfTtcbiAgICAgIF9yZWYgPSBjbWFwLmNoYXJNYXA7XG5cbiAgICAgIGZvciAoY29kZSBpbiBfcmVmKSB7XG4gICAgICAgIGlkcyA9IF9yZWZbY29kZV07XG4gICAgICAgIG9sZDJuZXdbaWRzLm9sZF0gPSBpZHNbXCJuZXdcIl07XG4gICAgICB9XG5cbiAgICAgIG5leHRHbHlwaElEID0gY21hcC5tYXhHbHlwaElEO1xuXG4gICAgICBmb3IgKG9sZElEIGluIGdseXBocykge1xuICAgICAgICBpZiAoIShvbGRJRCBpbiBvbGQybmV3KSkge1xuICAgICAgICAgIG9sZDJuZXdbb2xkSURdID0gbmV4dEdseXBoSUQrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXcyb2xkID0gaW52ZXJ0KG9sZDJuZXcpO1xuICAgICAgbmV3SURzID0gT2JqZWN0LmtleXMobmV3Mm9sZCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9KTtcblxuICAgICAgb2xkSURzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuXG4gICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBuZXdJRHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBpZCA9IG5ld0lEc1tfaV07XG5cbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKG5ldzJvbGRbaWRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0oKTtcblxuICAgICAgZ2x5ZiA9IHRoaXMuZm9udC5nbHlmLmVuY29kZShnbHlwaHMsIG9sZElEcywgb2xkMm5ldyk7XG4gICAgICBsb2NhID0gdGhpcy5mb250LmxvY2EuZW5jb2RlKGdseWYub2Zmc2V0cywgb2xkSURzKTtcbiAgICAgIHRhYmxlcyA9IHtcbiAgICAgICAgY21hcDogdGhpcy5mb250LmNtYXAucmF3KCksXG4gICAgICAgIGdseWY6IGdseWYudGFibGUsXG4gICAgICAgIGxvY2E6IGxvY2EsXG4gICAgICAgIGhtdHg6IHRoaXMuZm9udC5obXR4LnJhdygpLFxuICAgICAgICBoaGVhOiB0aGlzLmZvbnQuaGhlYS5yYXcoKSxcbiAgICAgICAgbWF4cDogdGhpcy5mb250Lm1heHAucmF3KCksXG4gICAgICAgIHBvc3Q6IHRoaXMuZm9udC5wb3N0LnJhdygpLFxuICAgICAgICBuYW1lOiB0aGlzLmZvbnQubmFtZS5yYXcoKSxcbiAgICAgICAgaGVhZDogdGhpcy5mb250LmhlYWQuZW5jb2RlKGluZGV4VG9Mb2NGb3JtYXQpXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5mb250Lm9zMi5leGlzdHMpIHtcbiAgICAgICAgdGFibGVzWydPUy8yJ10gPSB0aGlzLmZvbnQub3MyLnJhdygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5mb250LmRpcmVjdG9yeS5lbmNvZGUodGFibGVzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1YnNldDtcbiAgfSgpO1xuXG4gIGpzUERGLkFQSS5QREZPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhZDtcblxuICAgIGZ1bmN0aW9uIFBERk9iamVjdCgpIHt9XG5cbiAgICBwYWQgPSBmdW5jdGlvbiBwYWQoc3RyLCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiAoQXJyYXkobGVuZ3RoICsgMSkuam9pbignMCcpICsgc3RyKS5zbGljZSgtbGVuZ3RoKTtcbiAgICB9O1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qIGZ1bmN0aW9uIDogY29udmVydCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgIC8qIGNvbW1lbnQgOkNvbnZlcnRzIHBkZiB0YWcncyAvIEZvbnRCQm94IGFuZCBhcnJheSB2YWx1ZXMgaW4gLyBXIHRvIHN0cmluZ3MgKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgUERGT2JqZWN0LmNvbnZlcnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICB2YXIgZSwgaXRlbXMsIGtleSwgb3V0LCB2YWw7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgaXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcblxuICAgICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9iamVjdC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZSA9IG9iamVjdFtfaV07XG5cbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goUERGT2JqZWN0LmNvbnZlcnQoZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSgpLmpvaW4oJyAnKTtcblxuICAgICAgICByZXR1cm4gJ1snICsgaXRlbXMgKyAnXSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnLycgKyBvYmplY3Q7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdCAhPSBudWxsID8gb2JqZWN0LmlzU3RyaW5nIDogdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiAnKCcgKyBvYmplY3QgKyAnKSc7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICcoRDonICsgcGFkKG9iamVjdC5nZXRVVENGdWxsWWVhcigpLCA0KSArIHBhZChvYmplY3QuZ2V0VVRDTW9udGgoKSwgMikgKyBwYWQob2JqZWN0LmdldFVUQ0RhdGUoKSwgMikgKyBwYWQob2JqZWN0LmdldFVUQ0hvdXJzKCksIDIpICsgcGFkKG9iamVjdC5nZXRVVENNaW51dGVzKCksIDIpICsgcGFkKG9iamVjdC5nZXRVVENTZWNvbmRzKCksIDIpICsgJ1opJztcbiAgICAgIH0gZWxzZSBpZiAoe30udG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBvdXQgPSBbJzw8J107XG5cbiAgICAgICAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgdmFsID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgb3V0LnB1c2goJy8nICsga2V5ICsgJyAnICsgUERGT2JqZWN0LmNvbnZlcnQodmFsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQucHVzaCgnPj4nKTtcbiAgICAgICAgcmV0dXJuIG91dC5qb2luKCdcXG4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJyArIG9iamVjdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFBERk9iamVjdDtcbiAgfSgpO1xufSkoanNQREYpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNC4wXG5cbi8qXG4jIFBORy5qc1xuIyBDb3B5cmlnaHQgKGMpIDIwMTEgRGV2b24gR292ZXR0XG4jIE1JVCBMSUNFTlNFXG4jIFxuIyBcbiovXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xuICB2YXIgUE5HO1xuXG4gIFBORyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgQVBOR19CTEVORF9PUF9TT1VSQ0UsIEFQTkdfRElTUE9TRV9PUF9CQUNLR1JPVU5ELCBBUE5HX0RJU1BPU0VfT1BfUFJFVklPVVMsIG1ha2VJbWFnZSwgc2NyYXRjaENhbnZhcywgc2NyYXRjaEN0eDtcblxuICAgIFBORy5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FudmFzLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHhocjtcblxuICAgICAgaWYgKHR5cGVvZiBjYW52YXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYW52YXM7XG4gICAgICB9XG5cbiAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhLCBwbmc7XG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UgfHwgeGhyLm1velJlc3BvbnNlQXJyYXlCdWZmZXIpO1xuICAgICAgICBwbmcgPSBuZXcgUE5HKGRhdGEpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgKGNhbnZhcyAhPSBudWxsID8gY2FudmFzLmdldENvbnRleHQgOiB2b2lkIDApID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcG5nLnJlbmRlcihjYW52YXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gY2FsbGJhY2socG5nKSA6IHZvaWQgMDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB4aHIuc2VuZChudWxsKTtcbiAgICB9O1xuICAgIEFQTkdfRElTUE9TRV9PUF9CQUNLR1JPVU5EID0gMTtcbiAgICBBUE5HX0RJU1BPU0VfT1BfUFJFVklPVVMgPSAyO1xuICAgIEFQTkdfQkxFTkRfT1BfU09VUkNFID0gMDtcblxuICAgIGZ1bmN0aW9uIFBORyhkYXRhKSB7XG4gICAgICB2YXIgY2h1bmtTaXplLCBjb2xvcnMsIHBhbExlbiwgZGVsYXlEZW4sIGRlbGF5TnVtLCBmcmFtZSwgaSwgaW5kZXgsIGtleSwgc2VjdGlvbiwgcGFsU2hvcnQsIHRleHQsIF9pLCBfaiwgX3JlZjtcblxuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMucG9zID0gODtcbiAgICAgIHRoaXMucGFsZXR0ZSA9IFtdO1xuICAgICAgdGhpcy5pbWdEYXRhID0gW107XG4gICAgICB0aGlzLnRyYW5zcGFyZW5jeSA9IHt9O1xuICAgICAgdGhpcy5hbmltYXRpb24gPSBudWxsO1xuICAgICAgdGhpcy50ZXh0ID0ge307XG4gICAgICBmcmFtZSA9IG51bGw7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNodW5rU2l6ZSA9IHRoaXMucmVhZFVJbnQzMigpO1xuXG4gICAgICAgIHNlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9pLCBfcmVzdWx0cztcblxuICAgICAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgICAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgNDsgaSA9ICsrX2kpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmRhdGFbdGhpcy5wb3MrK10pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0uY2FsbCh0aGlzKS5qb2luKCcnKTtcblxuICAgICAgICBzd2l0Y2ggKHNlY3Rpb24pIHtcbiAgICAgICAgICBjYXNlICdJSERSJzpcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnJlYWRVSW50MzIoKTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5yZWFkVUludDMyKCk7XG4gICAgICAgICAgICB0aGlzLmJpdHMgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgICB0aGlzLmNvbG9yVHlwZSA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgICAgICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgICB0aGlzLmZpbHRlck1ldGhvZCA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJsYWNlTWV0aG9kID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhY1RMJzpcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0ge1xuICAgICAgICAgICAgICBudW1GcmFtZXM6IHRoaXMucmVhZFVJbnQzMigpLFxuICAgICAgICAgICAgICBudW1QbGF5czogdGhpcy5yZWFkVUludDMyKCkgfHwgSW5maW5pdHksXG4gICAgICAgICAgICAgIGZyYW1lczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1BMVEUnOlxuICAgICAgICAgICAgdGhpcy5wYWxldHRlID0gdGhpcy5yZWFkKGNodW5rU2l6ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2ZjVEwnOlxuICAgICAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgICAgIGZyYW1lID0ge1xuICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWFkVUludDMyKCksXG4gICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWFkVUludDMyKCksXG4gICAgICAgICAgICAgIHhPZmZzZXQ6IHRoaXMucmVhZFVJbnQzMigpLFxuICAgICAgICAgICAgICB5T2Zmc2V0OiB0aGlzLnJlYWRVSW50MzIoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlbGF5TnVtID0gdGhpcy5yZWFkVUludDE2KCk7XG4gICAgICAgICAgICBkZWxheURlbiA9IHRoaXMucmVhZFVJbnQxNigpIHx8IDEwMDtcbiAgICAgICAgICAgIGZyYW1lLmRlbGF5ID0gMTAwMCAqIGRlbGF5TnVtIC8gZGVsYXlEZW47XG4gICAgICAgICAgICBmcmFtZS5kaXNwb3NlT3AgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgICBmcmFtZS5ibGVuZE9wID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgICAgICAgICAgZnJhbWUuZGF0YSA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdJREFUJzpcbiAgICAgICAgICBjYXNlICdmZEFUJzpcbiAgICAgICAgICAgIGlmIChzZWN0aW9uID09PSAnZmRBVCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgICAgICAgY2h1bmtTaXplIC09IDQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEgPSAoZnJhbWUgIT0gbnVsbCA/IGZyYW1lLmRhdGEgOiB2b2lkIDApIHx8IHRoaXMuaW1nRGF0YTtcblxuICAgICAgICAgICAgZm9yIChpID0gX2kgPSAwOyAwIDw9IGNodW5rU2l6ZSA/IF9pIDwgY2h1bmtTaXplIDogX2kgPiBjaHVua1NpemU7IGkgPSAwIDw9IGNodW5rU2l6ZSA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgICAgICAgIGRhdGEucHVzaCh0aGlzLmRhdGFbdGhpcy5wb3MrK10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RSTlMnOlxuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3kgPSB7fTtcblxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmNvbG9yVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcGFsTGVuID0gdGhpcy5wYWxldHRlLmxlbmd0aCAvIDM7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZCA9IHRoaXMucmVhZChjaHVua1NpemUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcGFyZW5jeS5pbmRleGVkLmxlbmd0aCA+IHBhbExlbikgdGhyb3cgbmV3IEVycm9yKCdNb3JlIHRyYW5zcGFyZW50IGNvbG9ycyB0aGFuIHBhbGV0dGUgc2l6ZScpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogQWNjb3JkaW5nIHRvIHRoZSBQTkcgc3BlYyB0cm5zIHNob3VsZCBiZSBpbmNyZWFzZWQgdG8gdGhlIHNhbWUgc2l6ZSBhcyBwYWxldHRlIGlmIHNob3J0ZXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvL3BhbFNob3J0ID0gMjU1IC0gdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBwYWxTaG9ydCA9IHBhbExlbiAtIHRoaXMudHJhbnNwYXJlbmN5LmluZGV4ZWQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhbFNob3J0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gX2ogPSAwOyAwIDw9IHBhbFNob3J0ID8gX2ogPCBwYWxTaG9ydCA6IF9qID4gcGFsU2hvcnQ7IGkgPSAwIDw9IHBhbFNob3J0ID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZC5wdXNoKDI1NSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5LmdyYXlzY2FsZSA9IHRoaXMucmVhZChjaHVua1NpemUpWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeS5yZ2IgPSB0aGlzLnJlYWQoY2h1bmtTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0RVh0JzpcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnJlYWQoY2h1bmtTaXplKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGV4dC5pbmRleE9mKDApO1xuICAgICAgICAgICAga2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHRleHQuc2xpY2UoMCwgaW5kZXgpKTtcbiAgICAgICAgICAgIHRoaXMudGV4dFtrZXldID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHRleHQuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0lFTkQnOlxuICAgICAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5jb2xvclR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuaGFzQWxwaGFDaGFubmVsID0gKF9yZWYgPSB0aGlzLmNvbG9yVHlwZSkgPT09IDQgfHwgX3JlZiA9PT0gNjtcbiAgICAgICAgICAgIGNvbG9ycyA9IHRoaXMuY29sb3JzICsgKHRoaXMuaGFzQWxwaGFDaGFubmVsID8gMSA6IDApO1xuICAgICAgICAgICAgdGhpcy5waXhlbEJpdGxlbmd0aCA9IHRoaXMuYml0cyAqIGNvbG9ycztcblxuICAgICAgICAgICAgdGhpcy5jb2xvclNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuY29sb3JzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICdEZXZpY2VHcmF5JztcblxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnRGV2aWNlUkdCJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmltZ0RhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLmltZ0RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMucG9zICs9IGNodW5rU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG5cbiAgICAgICAgaWYgKHRoaXMucG9zID4gdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgb3IgY29ycnVwdCBQTkcgZmlsZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgUE5HLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICB2YXIgaSwgX2ksIF9yZXN1bHRzO1xuXG4gICAgICBfcmVzdWx0cyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSBfaSA9IDA7IDAgPD0gYnl0ZXMgPyBfaSA8IGJ5dGVzIDogX2kgPiBieXRlczsgaSA9IDAgPD0gYnl0ZXMgPyArK19pIDogLS1faSkge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuZGF0YVt0aGlzLnBvcysrXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgUE5HLnByb3RvdHlwZS5yZWFkVUludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGIxLCBiMiwgYjMsIGI0O1xuICAgICAgYjEgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPDwgMjQ7XG4gICAgICBiMiA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCAxNjtcbiAgICAgIGIzID0gdGhpcy5kYXRhW3RoaXMucG9zKytdIDw8IDg7XG4gICAgICBiNCA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgIHJldHVybiBiMSB8IGIyIHwgYjMgfCBiNDtcbiAgICB9O1xuXG4gICAgUE5HLnByb3RvdHlwZS5yZWFkVUludDE2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGIxLCBiMjtcbiAgICAgIGIxID0gdGhpcy5kYXRhW3RoaXMucG9zKytdIDw8IDg7XG4gICAgICBiMiA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgIHJldHVybiBiMSB8IGIyO1xuICAgIH07XG5cbiAgICBQTkcucHJvdG90eXBlLmRlY29kZVBpeGVscyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgcGl4ZWxCeXRlcyA9IHRoaXMucGl4ZWxCaXRsZW5ndGggLyA4O1xuICAgICAgdmFyIGZ1bGxQaXhlbHMgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiBwaXhlbEJ5dGVzKTtcbiAgICAgIHZhciBwb3MgPSAwO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLmltZ0RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSBuZXcgRmxhdGVTdHJlYW0oZGF0YSk7XG4gICAgICBkYXRhID0gZGF0YS5nZXRCeXRlcygpO1xuXG4gICAgICBmdW5jdGlvbiBwYXNzKHgwLCB5MCwgZHgsIGR5KSB7XG4gICAgICAgIHZhciBhYnl0ZSwgYywgY29sLCBpLCBsZWZ0LCBsZW5ndGgsIHAsIHBhLCBwYWV0aCwgcGIsIHBjLCBwaXhlbHMsIHJvdywgc2NhbmxpbmVMZW5ndGgsIHVwcGVyLCB1cHBlckxlZnQsIF9pLCBfaiwgX2ssIF9sLCBfbTtcblxuICAgICAgICB2YXIgdyA9IE1hdGguY2VpbCgoX3RoaXMud2lkdGggLSB4MCkgLyBkeCksXG4gICAgICAgICAgICBoID0gTWF0aC5jZWlsKChfdGhpcy5oZWlnaHQgLSB5MCkgLyBkeSk7XG4gICAgICAgIHZhciBpc0Z1bGwgPSBfdGhpcy53aWR0aCA9PSB3ICYmIF90aGlzLmhlaWdodCA9PSBoO1xuICAgICAgICBzY2FubGluZUxlbmd0aCA9IHBpeGVsQnl0ZXMgKiB3O1xuICAgICAgICBwaXhlbHMgPSBpc0Z1bGwgPyBmdWxsUGl4ZWxzIDogbmV3IFVpbnQ4QXJyYXkoc2NhbmxpbmVMZW5ndGggKiBoKTtcbiAgICAgICAgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHJvdyA9IDA7XG4gICAgICAgIGMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChyb3cgPCBoICYmIHBvcyA8IGxlbmd0aCkge1xuICAgICAgICAgIHN3aXRjaCAoZGF0YVtwb3MrK10pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IHNjYW5saW5lTGVuZ3RoOyBpID0gX2kgKz0gMSkge1xuICAgICAgICAgICAgICAgIHBpeGVsc1tjKytdID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBmb3IgKGkgPSBfaiA9IDA7IF9qIDwgc2NhbmxpbmVMZW5ndGg7IGkgPSBfaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgYWJ5dGUgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gaSA8IHBpeGVsQnl0ZXMgPyAwIDogcGl4ZWxzW2MgLSBwaXhlbEJ5dGVzXTtcbiAgICAgICAgICAgICAgICBwaXhlbHNbYysrXSA9IChhYnl0ZSArIGxlZnQpICUgMjU2O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgZm9yIChpID0gX2sgPSAwOyBfayA8IHNjYW5saW5lTGVuZ3RoOyBpID0gX2sgKz0gMSkge1xuICAgICAgICAgICAgICAgIGFieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgY29sID0gKGkgLSBpICUgcGl4ZWxCeXRlcykgLyBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgICAgIHVwcGVyID0gcm93ICYmIHBpeGVsc1socm93IC0gMSkgKiBzY2FubGluZUxlbmd0aCArIGNvbCAqIHBpeGVsQnl0ZXMgKyBpICUgcGl4ZWxCeXRlc107XG4gICAgICAgICAgICAgICAgcGl4ZWxzW2MrK10gPSAodXBwZXIgKyBhYnl0ZSkgJSAyNTY7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBmb3IgKGkgPSBfbCA9IDA7IF9sIDwgc2NhbmxpbmVMZW5ndGg7IGkgPSBfbCArPSAxKSB7XG4gICAgICAgICAgICAgICAgYWJ5dGUgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgICBjb2wgPSAoaSAtIGkgJSBwaXhlbEJ5dGVzKSAvIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGkgPCBwaXhlbEJ5dGVzID8gMCA6IHBpeGVsc1tjIC0gcGl4ZWxCeXRlc107XG4gICAgICAgICAgICAgICAgdXBwZXIgPSByb3cgJiYgcGl4ZWxzWyhyb3cgLSAxKSAqIHNjYW5saW5lTGVuZ3RoICsgY29sICogcGl4ZWxCeXRlcyArIGkgJSBwaXhlbEJ5dGVzXTtcbiAgICAgICAgICAgICAgICBwaXhlbHNbYysrXSA9IChhYnl0ZSArIE1hdGguZmxvb3IoKGxlZnQgKyB1cHBlcikgLyAyKSkgJSAyNTY7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBmb3IgKGkgPSBfbSA9IDA7IF9tIDwgc2NhbmxpbmVMZW5ndGg7IGkgPSBfbSArPSAxKSB7XG4gICAgICAgICAgICAgICAgYWJ5dGUgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgICBjb2wgPSAoaSAtIGkgJSBwaXhlbEJ5dGVzKSAvIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGkgPCBwaXhlbEJ5dGVzID8gMCA6IHBpeGVsc1tjIC0gcGl4ZWxCeXRlc107XG5cbiAgICAgICAgICAgICAgICBpZiAocm93ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICB1cHBlciA9IHVwcGVyTGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHVwcGVyID0gcGl4ZWxzWyhyb3cgLSAxKSAqIHNjYW5saW5lTGVuZ3RoICsgY29sICogcGl4ZWxCeXRlcyArIGkgJSBwaXhlbEJ5dGVzXTtcbiAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdCA9IGNvbCAmJiBwaXhlbHNbKHJvdyAtIDEpICogc2NhbmxpbmVMZW5ndGggKyAoY29sIC0gMSkgKiBwaXhlbEJ5dGVzICsgaSAlIHBpeGVsQnl0ZXNdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAgPSBsZWZ0ICsgdXBwZXIgLSB1cHBlckxlZnQ7XG4gICAgICAgICAgICAgICAgcGEgPSBNYXRoLmFicyhwIC0gbGVmdCk7XG4gICAgICAgICAgICAgICAgcGIgPSBNYXRoLmFicyhwIC0gdXBwZXIpO1xuICAgICAgICAgICAgICAgIHBjID0gTWF0aC5hYnMocCAtIHVwcGVyTGVmdCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGEgPD0gcGIgJiYgcGEgPD0gcGMpIHtcbiAgICAgICAgICAgICAgICAgIHBhZXRoID0gbGVmdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBiIDw9IHBjKSB7XG4gICAgICAgICAgICAgICAgICBwYWV0aCA9IHVwcGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYWV0aCA9IHVwcGVyTGVmdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwaXhlbHNbYysrXSA9IChhYnl0ZSArIHBhZXRoKSAlIDI1NjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZpbHRlciBhbGdvcml0aG06IFwiICsgZGF0YVtwb3MgLSAxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0Z1bGwpIHtcbiAgICAgICAgICAgIHZhciBmdWxsUG9zID0gKCh5MCArIHJvdyAqIGR5KSAqIF90aGlzLndpZHRoICsgeDApICogcGl4ZWxCeXRlcztcbiAgICAgICAgICAgIHZhciBwYXJ0UG9zID0gcm93ICogc2NhbmxpbmVMZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB3OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwaXhlbEJ5dGVzOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBmdWxsUGl4ZWxzW2Z1bGxQb3MrK10gPSBwaXhlbHNbcGFydFBvcysrXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZ1bGxQb3MgKz0gKGR4IC0gMSkgKiBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5pbnRlcmxhY2VNZXRob2QgPT0gMSkge1xuICAgICAgICAvKlxuICAgICAgICAgIDEgNiA0IDYgMiA2IDQgNlxuICAgICAgICAgIDcgNyA3IDcgNyA3IDcgN1xuICAgICAgICAgIDUgNiA1IDYgNSA2IDUgNlxuICAgICAgICAgIDcgNyA3IDcgNyA3IDcgN1xuICAgICAgICAgIDMgNiA0IDYgMyA2IDQgNlxuICAgICAgICAgIDcgNyA3IDcgNyA3IDcgN1xuICAgICAgICAgIDUgNiA1IDYgNSA2IDUgNlxuICAgICAgICAgIDcgNyA3IDcgNyA3IDcgN1xuICAgICAgICAqL1xuICAgICAgICBwYXNzKDAsIDAsIDgsIDgpOyAvLyAxXG5cbiAgICAgICAgLyogTk9URSB0aGVzZSBzZWVtIHRvIGZvbGxvdyB0aGUgcGF0dGVybjpcbiAgICAgICAgICogcGFzcyh4LCAwLCAyKngsIDIqeCk7XG4gICAgICAgICAqIHBhc3MoMCwgeCwgICB4LCAyKngpO1xuICAgICAgICAgKiB3aXRoIHggYmVpbmcgNCwgMiwgMS5cbiAgICAgICAgICovXG5cbiAgICAgICAgcGFzcyg0LCAwLCA4LCA4KTsgLy8gMlxuXG4gICAgICAgIHBhc3MoMCwgNCwgNCwgOCk7IC8vIDNcblxuICAgICAgICBwYXNzKDIsIDAsIDQsIDQpOyAvLyA0XG5cbiAgICAgICAgcGFzcygwLCAyLCAyLCA0KTsgLy8gNVxuXG4gICAgICAgIHBhc3MoMSwgMCwgMiwgMik7IC8vIDZcblxuICAgICAgICBwYXNzKDAsIDEsIDEsIDIpOyAvLyA3XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXNzKDAsIDAsIDEsIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVsbFBpeGVscztcbiAgICB9O1xuXG4gICAgUE5HLnByb3RvdHlwZS5kZWNvZGVQYWxldHRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGMsIGksIGxlbmd0aCwgcGFsZXR0ZSwgcG9zLCByZXQsIHRyYW5zcGFyZW5jeSwgX2ksIF9yZWYsIF9yZWYxO1xuXG4gICAgICBwYWxldHRlID0gdGhpcy5wYWxldHRlO1xuICAgICAgdHJhbnNwYXJlbmN5ID0gdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZCB8fCBbXTtcbiAgICAgIHJldCA9IG5ldyBVaW50OEFycmF5KCh0cmFuc3BhcmVuY3kubGVuZ3RoIHx8IDApICsgcGFsZXR0ZS5sZW5ndGgpO1xuICAgICAgcG9zID0gMDtcbiAgICAgIGxlbmd0aCA9IHBhbGV0dGUubGVuZ3RoO1xuICAgICAgYyA9IDA7XG5cbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZiA9IHBhbGV0dGUubGVuZ3RoOyBfaSA8IF9yZWY7IGkgPSBfaSArPSAzKSB7XG4gICAgICAgIHJldFtwb3MrK10gPSBwYWxldHRlW2ldO1xuICAgICAgICByZXRbcG9zKytdID0gcGFsZXR0ZVtpICsgMV07XG4gICAgICAgIHJldFtwb3MrK10gPSBwYWxldHRlW2kgKyAyXTtcbiAgICAgICAgcmV0W3BvcysrXSA9IChfcmVmMSA9IHRyYW5zcGFyZW5jeVtjKytdKSAhPSBudWxsID8gX3JlZjEgOiAyNTU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIFBORy5wcm90b3R5cGUuY29weVRvSW1hZ2VEYXRhID0gZnVuY3Rpb24gKGltYWdlRGF0YSwgcGl4ZWxzKSB7XG4gICAgICB2YXIgYWxwaGEsIGNvbG9ycywgZGF0YSwgaSwgaW5wdXQsIGosIGssIGxlbmd0aCwgcGFsZXR0ZSwgdiwgX3JlZjtcblxuICAgICAgY29sb3JzID0gdGhpcy5jb2xvcnM7XG4gICAgICBwYWxldHRlID0gbnVsbDtcbiAgICAgIGFscGhhID0gdGhpcy5oYXNBbHBoYUNoYW5uZWw7XG5cbiAgICAgIGlmICh0aGlzLnBhbGV0dGUubGVuZ3RoKSB7XG4gICAgICAgIHBhbGV0dGUgPSAoX3JlZiA9IHRoaXMuX2RlY29kZWRQYWxldHRlKSAhPSBudWxsID8gX3JlZiA6IHRoaXMuX2RlY29kZWRQYWxldHRlID0gdGhpcy5kZWNvZGVQYWxldHRlKCk7XG4gICAgICAgIGNvbG9ycyA9IDQ7XG4gICAgICAgIGFscGhhID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhIHx8IGltYWdlRGF0YTtcbiAgICAgIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgaW5wdXQgPSBwYWxldHRlIHx8IHBpeGVscztcbiAgICAgIGkgPSBqID0gMDtcblxuICAgICAgaWYgKGNvbG9ycyA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgIGsgPSBwYWxldHRlID8gcGl4ZWxzW2kgLyA0XSAqIDQgOiBqO1xuICAgICAgICAgIHYgPSBpbnB1dFtrKytdO1xuICAgICAgICAgIGRhdGFbaSsrXSA9IHY7XG4gICAgICAgICAgZGF0YVtpKytdID0gdjtcbiAgICAgICAgICBkYXRhW2krK10gPSB2O1xuICAgICAgICAgIGRhdGFbaSsrXSA9IGFscGhhID8gaW5wdXRbaysrXSA6IDI1NTtcbiAgICAgICAgICBqID0gaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBrID0gcGFsZXR0ZSA/IHBpeGVsc1tpIC8gNF0gKiA0IDogajtcbiAgICAgICAgICBkYXRhW2krK10gPSBpbnB1dFtrKytdO1xuICAgICAgICAgIGRhdGFbaSsrXSA9IGlucHV0W2srK107XG4gICAgICAgICAgZGF0YVtpKytdID0gaW5wdXRbaysrXTtcbiAgICAgICAgICBkYXRhW2krK10gPSBhbHBoYSA/IGlucHV0W2srK10gOiAyNTU7XG4gICAgICAgICAgaiA9IGs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUE5HLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmV0O1xuICAgICAgcmV0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogNCk7XG4gICAgICB0aGlzLmNvcHlUb0ltYWdlRGF0YShyZXQsIHRoaXMuZGVjb2RlUGl4ZWxzKCkpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNjcmF0Y2hDYW52YXMgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBzY3JhdGNoQ3R4ID0gc2NyYXRjaENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBtYWtlSW1hZ2UgPSBmdW5jdGlvbiBtYWtlSW1hZ2UoaW1hZ2VEYXRhKSB7XG4gICAgICB2YXIgaW1nO1xuICAgICAgc2NyYXRjaEN0eC53aWR0aCA9IGltYWdlRGF0YS53aWR0aDtcbiAgICAgIHNjcmF0Y2hDdHguaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcbiAgICAgIHNjcmF0Y2hDdHguY2xlYXJSZWN0KDAsIDAsIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG4gICAgICBzY3JhdGNoQ3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuc3JjID0gc2NyYXRjaENhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgIHJldHVybiBpbWc7XG4gICAgfTtcblxuICAgIFBORy5wcm90b3R5cGUuZGVjb2RlRnJhbWVzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgdmFyIGZyYW1lLCBpLCBpbWFnZURhdGEsIHBpeGVscywgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuXG4gICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3JlZiA9IHRoaXMuYW5pbWF0aW9uLmZyYW1lcztcbiAgICAgIF9yZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gICAgICAgIGZyYW1lID0gX3JlZltpXTtcbiAgICAgICAgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YShmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgcGl4ZWxzID0gdGhpcy5kZWNvZGVQaXhlbHMobmV3IFVpbnQ4QXJyYXkoZnJhbWUuZGF0YSkpO1xuICAgICAgICB0aGlzLmNvcHlUb0ltYWdlRGF0YShpbWFnZURhdGEsIHBpeGVscyk7XG4gICAgICAgIGZyYW1lLmltYWdlRGF0YSA9IGltYWdlRGF0YTtcblxuICAgICAgICBfcmVzdWx0cy5wdXNoKGZyYW1lLmltYWdlID0gbWFrZUltYWdlKGltYWdlRGF0YSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFBORy5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoY3R4LCBudW1iZXIpIHtcbiAgICAgIHZhciBmcmFtZSwgZnJhbWVzLCBwcmV2O1xuICAgICAgZnJhbWVzID0gdGhpcy5hbmltYXRpb24uZnJhbWVzO1xuICAgICAgZnJhbWUgPSBmcmFtZXNbbnVtYmVyXTtcbiAgICAgIHByZXYgPSBmcmFtZXNbbnVtYmVyIC0gMV07XG5cbiAgICAgIGlmIChudW1iZXIgPT09IDApIHtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgocHJldiAhPSBudWxsID8gcHJldi5kaXNwb3NlT3AgOiB2b2lkIDApID09PSBBUE5HX0RJU1BPU0VfT1BfQkFDS0dST1VORCkge1xuICAgICAgICBjdHguY2xlYXJSZWN0KHByZXYueE9mZnNldCwgcHJldi55T2Zmc2V0LCBwcmV2LndpZHRoLCBwcmV2LmhlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKChwcmV2ICE9IG51bGwgPyBwcmV2LmRpc3Bvc2VPcCA6IHZvaWQgMCkgPT09IEFQTkdfRElTUE9TRV9PUF9QUkVWSU9VUykge1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKHByZXYuaW1hZ2VEYXRhLCBwcmV2LnhPZmZzZXQsIHByZXYueU9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFtZS5ibGVuZE9wID09PSBBUE5HX0JMRU5EX09QX1NPVVJDRSkge1xuICAgICAgICBjdHguY2xlYXJSZWN0KGZyYW1lLnhPZmZzZXQsIGZyYW1lLnlPZmZzZXQsIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3R4LmRyYXdJbWFnZShmcmFtZS5pbWFnZSwgZnJhbWUueE9mZnNldCwgZnJhbWUueU9mZnNldCk7XG4gICAgfTtcblxuICAgIFBORy5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIHZhciBfZG9GcmFtZSxcbiAgICAgICAgICBmcmFtZU51bWJlcixcbiAgICAgICAgICBmcmFtZXMsXG4gICAgICAgICAgbnVtRnJhbWVzLFxuICAgICAgICAgIG51bVBsYXlzLFxuICAgICAgICAgIF9yZWYsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBmcmFtZU51bWJlciA9IDA7XG4gICAgICBfcmVmID0gdGhpcy5hbmltYXRpb24sIG51bUZyYW1lcyA9IF9yZWYubnVtRnJhbWVzLCBmcmFtZXMgPSBfcmVmLmZyYW1lcywgbnVtUGxheXMgPSBfcmVmLm51bVBsYXlzO1xuICAgICAgcmV0dXJuIChfZG9GcmFtZSA9IGZ1bmN0aW9uIGRvRnJhbWUoKSB7XG4gICAgICAgIHZhciBmLCBmcmFtZTtcbiAgICAgICAgZiA9IGZyYW1lTnVtYmVyKysgJSBudW1GcmFtZXM7XG4gICAgICAgIGZyYW1lID0gZnJhbWVzW2ZdO1xuXG4gICAgICAgIF90aGlzLnJlbmRlckZyYW1lKGN0eCwgZik7XG5cbiAgICAgICAgaWYgKG51bUZyYW1lcyA+IDEgJiYgZnJhbWVOdW1iZXIgLyBudW1GcmFtZXMgPCBudW1QbGF5cykge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5hbmltYXRpb24uX3RpbWVvdXQgPSBzZXRUaW1lb3V0KF9kb0ZyYW1lLCBmcmFtZS5kZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfTtcblxuICAgIFBORy5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KChfcmVmID0gdGhpcy5hbmltYXRpb24pICE9IG51bGwgPyBfcmVmLl90aW1lb3V0IDogdm9pZCAwKTtcbiAgICB9O1xuXG4gICAgUE5HLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICB2YXIgY3R4LCBkYXRhO1xuXG4gICAgICBpZiAoY2FudmFzLl9wbmcpIHtcbiAgICAgICAgY2FudmFzLl9wbmcuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBjYW52YXMuX3BuZyA9IHRoaXM7XG4gICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlRnJhbWVzKGN0eCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jb3B5VG9JbWFnZURhdGEoZGF0YSwgdGhpcy5kZWNvZGVQaXhlbHMoKSk7XG4gICAgICAgIHJldHVybiBjdHgucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUE5HO1xuICB9KCk7XG5cbiAgZ2xvYmFsLlBORyA9IFBORztcbn0pKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLmNvbnRlbnQnKSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkpOyAvLyBgc2VsZmAgaXMgdW5kZWZpbmVkIGluIEZpcmVmb3ggZm9yIEFuZHJvaWQgY29udGVudCBzY3JpcHQgY29udGV4dFxuLy8gd2hpbGUgYHRoaXNgIGlzIG5zSUNvbnRlbnRGcmFtZU1lc3NhZ2VNYW5hZ2VyXG4vLyB3aXRoIGFuIGF0dHJpYnV0ZSBgY29udGVudGAgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgd2luZG93XG5cbi8qXG4gKiBFeHRyYWN0ZWQgZnJvbSBwZGYuanNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyZWFzZ2FsL3BkZi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBDb250cmlidXRvcnM6IEFuZHJlYXMgR2FsIDxnYWxAbW96aWxsYS5jb20+XG4gKiAgICAgICAgICAgICAgIENocmlzIEcgSm9uZXMgPGNqb25lc0Btb3ppbGxhLmNvbT5cbiAqICAgICAgICAgICAgICAgU2hhb24gQmFybWFuIDxzaGFvbi5iYXJtYW5AZ21haWwuY29tPlxuICogICAgICAgICAgICAgICBWaXZpZW4gTmljb2xhcyA8MjFAdmluZ3RldHVuLm9yZz5cbiAqICAgICAgICAgICAgICAgSnVzdGluIEQnQXJjYW5nZWxvIDxqdXN0aW5kYXJjQGdtYWlsLmNvbT5cbiAqICAgICAgICAgICAgICAgWXVyeSBEZWxlbmRpa1xuICpcbiAqIFxuICovXG52YXIgRGVjb2RlU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5idWZmZXJMZW5ndGggPSAwO1xuICAgIHRoaXMuZW9mID0gZmFsc2U7XG4gICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICB9XG5cbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0ge1xuICAgIGVuc3VyZUJ1ZmZlcjogZnVuY3Rpb24gZGVjb2Rlc3RyZWFtX2Vuc3VyZUJ1ZmZlcihyZXF1ZXN0ZWQpIHtcbiAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgIHZhciBjdXJyZW50ID0gYnVmZmVyID8gYnVmZmVyLmJ5dGVMZW5ndGggOiAwO1xuICAgICAgaWYgKHJlcXVlc3RlZCA8IGN1cnJlbnQpIHJldHVybiBidWZmZXI7XG4gICAgICB2YXIgc2l6ZSA9IDUxMjtcblxuICAgICAgd2hpbGUgKHNpemUgPCByZXF1ZXN0ZWQpIHtcbiAgICAgICAgc2l6ZSA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1ZmZlcjIgPSBuZXcgVWludDhBcnJheShzaXplKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50OyArK2kpIHtcbiAgICAgICAgYnVmZmVyMltpXSA9IGJ1ZmZlcltpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID0gYnVmZmVyMjtcbiAgICB9LFxuICAgIGdldEJ5dGU6IGZ1bmN0aW9uIGRlY29kZXN0cmVhbV9nZXRCeXRlKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuXG4gICAgICB3aGlsZSAodGhpcy5idWZmZXJMZW5ndGggPD0gcG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmVvZikgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMucmVhZEJsb2NrKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXTtcbiAgICB9LFxuICAgIGdldEJ5dGVzOiBmdW5jdGlvbiBkZWNvZGVzdHJlYW1fZ2V0Qnl0ZXMobGVuZ3RoKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3M7XG5cbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVCdWZmZXIocG9zICsgbGVuZ3RoKTtcbiAgICAgICAgdmFyIGVuZCA9IHBvcyArIGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoIXRoaXMuZW9mICYmIHRoaXMuYnVmZmVyTGVuZ3RoIDwgZW5kKSB7XG4gICAgICAgICAgdGhpcy5yZWFkQmxvY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWZFbmQgPSB0aGlzLmJ1ZmZlckxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA+IGJ1ZkVuZCkgZW5kID0gYnVmRW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmVvZikge1xuICAgICAgICAgIHRoaXMucmVhZEJsb2NrKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5kID0gdGhpcy5idWZmZXJMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcywgZW5kKTtcbiAgICB9LFxuICAgIGxvb2tDaGFyOiBmdW5jdGlvbiBkZWNvZGVzdHJlYW1fbG9va0NoYXIoKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3M7XG5cbiAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlckxlbmd0aCA8PSBwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZW9mKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkQmxvY2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5idWZmZXJbdGhpcy5wb3NdKTtcbiAgICB9LFxuICAgIGdldENoYXI6IGZ1bmN0aW9uIGRlY29kZXN0cmVhbV9nZXRDaGFyKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuXG4gICAgICB3aGlsZSAodGhpcy5idWZmZXJMZW5ndGggPD0gcG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmVvZikgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMucmVhZEJsb2NrKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuYnVmZmVyW3RoaXMucG9zKytdKTtcbiAgICB9LFxuICAgIG1ha2VTdWJTdHJlYW06IGZ1bmN0aW9uIGRlY29kZXN0cmVhbV9tYWtlU3Vic3RyZWFtKHN0YXJ0LCBsZW5ndGgsIGRpY3QpIHtcbiAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgd2hpbGUgKHRoaXMuYnVmZmVyTGVuZ3RoIDw9IGVuZCAmJiAhdGhpcy5lb2YpIHtcbiAgICAgICAgdGhpcy5yZWFkQmxvY2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBTdHJlYW0odGhpcy5idWZmZXIsIHN0YXJ0LCBsZW5ndGgsIGRpY3QpO1xuICAgIH0sXG4gICAgc2tpcDogZnVuY3Rpb24gZGVjb2Rlc3RyZWFtX3NraXAobikge1xuICAgICAgaWYgKCFuKSBuID0gMTtcbiAgICAgIHRoaXMucG9zICs9IG47XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gZGVjb2Rlc3RyZWFtX3Jlc2V0KCkge1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGNvbnN0cnVjdG9yO1xufSgpO1xuXG52YXIgRmxhdGVTdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBjb2RlTGVuQ29kZU1hcCA9IG5ldyBVaW50MzJBcnJheShbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV0pO1xuICB2YXIgbGVuZ3RoRGVjb2RlID0gbmV3IFVpbnQzMkFycmF5KFsweDAwMDAzLCAweDAwMDA0LCAweDAwMDA1LCAweDAwMDA2LCAweDAwMDA3LCAweDAwMDA4LCAweDAwMDA5LCAweDAwMDBhLCAweDEwMDBiLCAweDEwMDBkLCAweDEwMDBmLCAweDEwMDExLCAweDIwMDEzLCAweDIwMDE3LCAweDIwMDFiLCAweDIwMDFmLCAweDMwMDIzLCAweDMwMDJiLCAweDMwMDMzLCAweDMwMDNiLCAweDQwMDQzLCAweDQwMDUzLCAweDQwMDYzLCAweDQwMDczLCAweDUwMDgzLCAweDUwMGEzLCAweDUwMGMzLCAweDUwMGUzLCAweDAwMTAyLCAweDAwMTAyLCAweDAwMTAyXSk7XG4gIHZhciBkaXN0RGVjb2RlID0gbmV3IFVpbnQzMkFycmF5KFsweDAwMDAxLCAweDAwMDAyLCAweDAwMDAzLCAweDAwMDA0LCAweDEwMDA1LCAweDEwMDA3LCAweDIwMDA5LCAweDIwMDBkLCAweDMwMDExLCAweDMwMDE5LCAweDQwMDIxLCAweDQwMDMxLCAweDUwMDQxLCAweDUwMDYxLCAweDYwMDgxLCAweDYwMGMxLCAweDcwMTAxLCAweDcwMTgxLCAweDgwMjAxLCAweDgwMzAxLCAweDkwNDAxLCAweDkwNjAxLCAweGEwODAxLCAweGEwYzAxLCAweGIxMDAxLCAweGIxODAxLCAweGMyMDAxLCAweGMzMDAxLCAweGQ0MDAxLCAweGQ2MDAxXSk7XG4gIHZhciBmaXhlZExpdENvZGVUYWIgPSBbbmV3IFVpbnQzMkFycmF5KFsweDcwMTAwLCAweDgwMDUwLCAweDgwMDEwLCAweDgwMTE4LCAweDcwMTEwLCAweDgwMDcwLCAweDgwMDMwLCAweDkwMGMwLCAweDcwMTA4LCAweDgwMDYwLCAweDgwMDIwLCAweDkwMGEwLCAweDgwMDAwLCAweDgwMDgwLCAweDgwMDQwLCAweDkwMGUwLCAweDcwMTA0LCAweDgwMDU4LCAweDgwMDE4LCAweDkwMDkwLCAweDcwMTE0LCAweDgwMDc4LCAweDgwMDM4LCAweDkwMGQwLCAweDcwMTBjLCAweDgwMDY4LCAweDgwMDI4LCAweDkwMGIwLCAweDgwMDA4LCAweDgwMDg4LCAweDgwMDQ4LCAweDkwMGYwLCAweDcwMTAyLCAweDgwMDU0LCAweDgwMDE0LCAweDgwMTFjLCAweDcwMTEyLCAweDgwMDc0LCAweDgwMDM0LCAweDkwMGM4LCAweDcwMTBhLCAweDgwMDY0LCAweDgwMDI0LCAweDkwMGE4LCAweDgwMDA0LCAweDgwMDg0LCAweDgwMDQ0LCAweDkwMGU4LCAweDcwMTA2LCAweDgwMDVjLCAweDgwMDFjLCAweDkwMDk4LCAweDcwMTE2LCAweDgwMDdjLCAweDgwMDNjLCAweDkwMGQ4LCAweDcwMTBlLCAweDgwMDZjLCAweDgwMDJjLCAweDkwMGI4LCAweDgwMDBjLCAweDgwMDhjLCAweDgwMDRjLCAweDkwMGY4LCAweDcwMTAxLCAweDgwMDUyLCAweDgwMDEyLCAweDgwMTFhLCAweDcwMTExLCAweDgwMDcyLCAweDgwMDMyLCAweDkwMGM0LCAweDcwMTA5LCAweDgwMDYyLCAweDgwMDIyLCAweDkwMGE0LCAweDgwMDAyLCAweDgwMDgyLCAweDgwMDQyLCAweDkwMGU0LCAweDcwMTA1LCAweDgwMDVhLCAweDgwMDFhLCAweDkwMDk0LCAweDcwMTE1LCAweDgwMDdhLCAweDgwMDNhLCAweDkwMGQ0LCAweDcwMTBkLCAweDgwMDZhLCAweDgwMDJhLCAweDkwMGI0LCAweDgwMDBhLCAweDgwMDhhLCAweDgwMDRhLCAweDkwMGY0LCAweDcwMTAzLCAweDgwMDU2LCAweDgwMDE2LCAweDgwMTFlLCAweDcwMTEzLCAweDgwMDc2LCAweDgwMDM2LCAweDkwMGNjLCAweDcwMTBiLCAweDgwMDY2LCAweDgwMDI2LCAweDkwMGFjLCAweDgwMDA2LCAweDgwMDg2LCAweDgwMDQ2LCAweDkwMGVjLCAweDcwMTA3LCAweDgwMDVlLCAweDgwMDFlLCAweDkwMDljLCAweDcwMTE3LCAweDgwMDdlLCAweDgwMDNlLCAweDkwMGRjLCAweDcwMTBmLCAweDgwMDZlLCAweDgwMDJlLCAweDkwMGJjLCAweDgwMDBlLCAweDgwMDhlLCAweDgwMDRlLCAweDkwMGZjLCAweDcwMTAwLCAweDgwMDUxLCAweDgwMDExLCAweDgwMTE5LCAweDcwMTEwLCAweDgwMDcxLCAweDgwMDMxLCAweDkwMGMyLCAweDcwMTA4LCAweDgwMDYxLCAweDgwMDIxLCAweDkwMGEyLCAweDgwMDAxLCAweDgwMDgxLCAweDgwMDQxLCAweDkwMGUyLCAweDcwMTA0LCAweDgwMDU5LCAweDgwMDE5LCAweDkwMDkyLCAweDcwMTE0LCAweDgwMDc5LCAweDgwMDM5LCAweDkwMGQyLCAweDcwMTBjLCAweDgwMDY5LCAweDgwMDI5LCAweDkwMGIyLCAweDgwMDA5LCAweDgwMDg5LCAweDgwMDQ5LCAweDkwMGYyLCAweDcwMTAyLCAweDgwMDU1LCAweDgwMDE1LCAweDgwMTFkLCAweDcwMTEyLCAweDgwMDc1LCAweDgwMDM1LCAweDkwMGNhLCAweDcwMTBhLCAweDgwMDY1LCAweDgwMDI1LCAweDkwMGFhLCAweDgwMDA1LCAweDgwMDg1LCAweDgwMDQ1LCAweDkwMGVhLCAweDcwMTA2LCAweDgwMDVkLCAweDgwMDFkLCAweDkwMDlhLCAweDcwMTE2LCAweDgwMDdkLCAweDgwMDNkLCAweDkwMGRhLCAweDcwMTBlLCAweDgwMDZkLCAweDgwMDJkLCAweDkwMGJhLCAweDgwMDBkLCAweDgwMDhkLCAweDgwMDRkLCAweDkwMGZhLCAweDcwMTAxLCAweDgwMDUzLCAweDgwMDEzLCAweDgwMTFiLCAweDcwMTExLCAweDgwMDczLCAweDgwMDMzLCAweDkwMGM2LCAweDcwMTA5LCAweDgwMDYzLCAweDgwMDIzLCAweDkwMGE2LCAweDgwMDAzLCAweDgwMDgzLCAweDgwMDQzLCAweDkwMGU2LCAweDcwMTA1LCAweDgwMDViLCAweDgwMDFiLCAweDkwMDk2LCAweDcwMTE1LCAweDgwMDdiLCAweDgwMDNiLCAweDkwMGQ2LCAweDcwMTBkLCAweDgwMDZiLCAweDgwMDJiLCAweDkwMGI2LCAweDgwMDBiLCAweDgwMDhiLCAweDgwMDRiLCAweDkwMGY2LCAweDcwMTAzLCAweDgwMDU3LCAweDgwMDE3LCAweDgwMTFmLCAweDcwMTEzLCAweDgwMDc3LCAweDgwMDM3LCAweDkwMGNlLCAweDcwMTBiLCAweDgwMDY3LCAweDgwMDI3LCAweDkwMGFlLCAweDgwMDA3LCAweDgwMDg3LCAweDgwMDQ3LCAweDkwMGVlLCAweDcwMTA3LCAweDgwMDVmLCAweDgwMDFmLCAweDkwMDllLCAweDcwMTE3LCAweDgwMDdmLCAweDgwMDNmLCAweDkwMGRlLCAweDcwMTBmLCAweDgwMDZmLCAweDgwMDJmLCAweDkwMGJlLCAweDgwMDBmLCAweDgwMDhmLCAweDgwMDRmLCAweDkwMGZlLCAweDcwMTAwLCAweDgwMDUwLCAweDgwMDEwLCAweDgwMTE4LCAweDcwMTEwLCAweDgwMDcwLCAweDgwMDMwLCAweDkwMGMxLCAweDcwMTA4LCAweDgwMDYwLCAweDgwMDIwLCAweDkwMGExLCAweDgwMDAwLCAweDgwMDgwLCAweDgwMDQwLCAweDkwMGUxLCAweDcwMTA0LCAweDgwMDU4LCAweDgwMDE4LCAweDkwMDkxLCAweDcwMTE0LCAweDgwMDc4LCAweDgwMDM4LCAweDkwMGQxLCAweDcwMTBjLCAweDgwMDY4LCAweDgwMDI4LCAweDkwMGIxLCAweDgwMDA4LCAweDgwMDg4LCAweDgwMDQ4LCAweDkwMGYxLCAweDcwMTAyLCAweDgwMDU0LCAweDgwMDE0LCAweDgwMTFjLCAweDcwMTEyLCAweDgwMDc0LCAweDgwMDM0LCAweDkwMGM5LCAweDcwMTBhLCAweDgwMDY0LCAweDgwMDI0LCAweDkwMGE5LCAweDgwMDA0LCAweDgwMDg0LCAweDgwMDQ0LCAweDkwMGU5LCAweDcwMTA2LCAweDgwMDVjLCAweDgwMDFjLCAweDkwMDk5LCAweDcwMTE2LCAweDgwMDdjLCAweDgwMDNjLCAweDkwMGQ5LCAweDcwMTBlLCAweDgwMDZjLCAweDgwMDJjLCAweDkwMGI5LCAweDgwMDBjLCAweDgwMDhjLCAweDgwMDRjLCAweDkwMGY5LCAweDcwMTAxLCAweDgwMDUyLCAweDgwMDEyLCAweDgwMTFhLCAweDcwMTExLCAweDgwMDcyLCAweDgwMDMyLCAweDkwMGM1LCAweDcwMTA5LCAweDgwMDYyLCAweDgwMDIyLCAweDkwMGE1LCAweDgwMDAyLCAweDgwMDgyLCAweDgwMDQyLCAweDkwMGU1LCAweDcwMTA1LCAweDgwMDVhLCAweDgwMDFhLCAweDkwMDk1LCAweDcwMTE1LCAweDgwMDdhLCAweDgwMDNhLCAweDkwMGQ1LCAweDcwMTBkLCAweDgwMDZhLCAweDgwMDJhLCAweDkwMGI1LCAweDgwMDBhLCAweDgwMDhhLCAweDgwMDRhLCAweDkwMGY1LCAweDcwMTAzLCAweDgwMDU2LCAweDgwMDE2LCAweDgwMTFlLCAweDcwMTEzLCAweDgwMDc2LCAweDgwMDM2LCAweDkwMGNkLCAweDcwMTBiLCAweDgwMDY2LCAweDgwMDI2LCAweDkwMGFkLCAweDgwMDA2LCAweDgwMDg2LCAweDgwMDQ2LCAweDkwMGVkLCAweDcwMTA3LCAweDgwMDVlLCAweDgwMDFlLCAweDkwMDlkLCAweDcwMTE3LCAweDgwMDdlLCAweDgwMDNlLCAweDkwMGRkLCAweDcwMTBmLCAweDgwMDZlLCAweDgwMDJlLCAweDkwMGJkLCAweDgwMDBlLCAweDgwMDhlLCAweDgwMDRlLCAweDkwMGZkLCAweDcwMTAwLCAweDgwMDUxLCAweDgwMDExLCAweDgwMTE5LCAweDcwMTEwLCAweDgwMDcxLCAweDgwMDMxLCAweDkwMGMzLCAweDcwMTA4LCAweDgwMDYxLCAweDgwMDIxLCAweDkwMGEzLCAweDgwMDAxLCAweDgwMDgxLCAweDgwMDQxLCAweDkwMGUzLCAweDcwMTA0LCAweDgwMDU5LCAweDgwMDE5LCAweDkwMDkzLCAweDcwMTE0LCAweDgwMDc5LCAweDgwMDM5LCAweDkwMGQzLCAweDcwMTBjLCAweDgwMDY5LCAweDgwMDI5LCAweDkwMGIzLCAweDgwMDA5LCAweDgwMDg5LCAweDgwMDQ5LCAweDkwMGYzLCAweDcwMTAyLCAweDgwMDU1LCAweDgwMDE1LCAweDgwMTFkLCAweDcwMTEyLCAweDgwMDc1LCAweDgwMDM1LCAweDkwMGNiLCAweDcwMTBhLCAweDgwMDY1LCAweDgwMDI1LCAweDkwMGFiLCAweDgwMDA1LCAweDgwMDg1LCAweDgwMDQ1LCAweDkwMGViLCAweDcwMTA2LCAweDgwMDVkLCAweDgwMDFkLCAweDkwMDliLCAweDcwMTE2LCAweDgwMDdkLCAweDgwMDNkLCAweDkwMGRiLCAweDcwMTBlLCAweDgwMDZkLCAweDgwMDJkLCAweDkwMGJiLCAweDgwMDBkLCAweDgwMDhkLCAweDgwMDRkLCAweDkwMGZiLCAweDcwMTAxLCAweDgwMDUzLCAweDgwMDEzLCAweDgwMTFiLCAweDcwMTExLCAweDgwMDczLCAweDgwMDMzLCAweDkwMGM3LCAweDcwMTA5LCAweDgwMDYzLCAweDgwMDIzLCAweDkwMGE3LCAweDgwMDAzLCAweDgwMDgzLCAweDgwMDQzLCAweDkwMGU3LCAweDcwMTA1LCAweDgwMDViLCAweDgwMDFiLCAweDkwMDk3LCAweDcwMTE1LCAweDgwMDdiLCAweDgwMDNiLCAweDkwMGQ3LCAweDcwMTBkLCAweDgwMDZiLCAweDgwMDJiLCAweDkwMGI3LCAweDgwMDBiLCAweDgwMDhiLCAweDgwMDRiLCAweDkwMGY3LCAweDcwMTAzLCAweDgwMDU3LCAweDgwMDE3LCAweDgwMTFmLCAweDcwMTEzLCAweDgwMDc3LCAweDgwMDM3LCAweDkwMGNmLCAweDcwMTBiLCAweDgwMDY3LCAweDgwMDI3LCAweDkwMGFmLCAweDgwMDA3LCAweDgwMDg3LCAweDgwMDQ3LCAweDkwMGVmLCAweDcwMTA3LCAweDgwMDVmLCAweDgwMDFmLCAweDkwMDlmLCAweDcwMTE3LCAweDgwMDdmLCAweDgwMDNmLCAweDkwMGRmLCAweDcwMTBmLCAweDgwMDZmLCAweDgwMDJmLCAweDkwMGJmLCAweDgwMDBmLCAweDgwMDhmLCAweDgwMDRmLCAweDkwMGZmXSksIDldO1xuICB2YXIgZml4ZWREaXN0Q29kZVRhYiA9IFtuZXcgVWludDMyQXJyYXkoWzB4NTAwMDAsIDB4NTAwMTAsIDB4NTAwMDgsIDB4NTAwMTgsIDB4NTAwMDQsIDB4NTAwMTQsIDB4NTAwMGMsIDB4NTAwMWMsIDB4NTAwMDIsIDB4NTAwMTIsIDB4NTAwMGEsIDB4NTAwMWEsIDB4NTAwMDYsIDB4NTAwMTYsIDB4NTAwMGUsIDB4MDAwMDAsIDB4NTAwMDEsIDB4NTAwMTEsIDB4NTAwMDksIDB4NTAwMTksIDB4NTAwMDUsIDB4NTAwMTUsIDB4NTAwMGQsIDB4NTAwMWQsIDB4NTAwMDMsIDB4NTAwMTMsIDB4NTAwMGIsIDB4NTAwMWIsIDB4NTAwMDcsIDB4NTAwMTcsIDB4NTAwMGYsIDB4MDAwMDBdKSwgNV07XG5cbiAgZnVuY3Rpb24gZXJyb3IoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgLy92YXIgYnl0ZXMgPSBzdHJlYW0uZ2V0Qnl0ZXMoKTtcbiAgICB2YXIgYnl0ZXNQb3MgPSAwO1xuICAgIHZhciBjbWYgPSBieXRlc1tieXRlc1BvcysrXTtcbiAgICB2YXIgZmxnID0gYnl0ZXNbYnl0ZXNQb3MrK107XG4gICAgaWYgKGNtZiA9PSAtMSB8fCBmbGcgPT0gLTEpIGVycm9yKCdJbnZhbGlkIGhlYWRlciBpbiBmbGF0ZSBzdHJlYW0nKTtcbiAgICBpZiAoKGNtZiAmIDB4MGYpICE9IDB4MDgpIGVycm9yKCdVbmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCBpbiBmbGF0ZSBzdHJlYW0nKTtcbiAgICBpZiAoKChjbWYgPDwgOCkgKyBmbGcpICUgMzEgIT0gMCkgZXJyb3IoJ0JhZCBGQ0hFQ0sgaW4gZmxhdGUgc3RyZWFtJyk7XG4gICAgaWYgKGZsZyAmIDB4MjApIGVycm9yKCdGRElDVCBiaXQgc2V0IGluIGZsYXRlIHN0cmVhbScpO1xuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICB0aGlzLmJ5dGVzUG9zID0gYnl0ZXNQb3M7XG4gICAgdGhpcy5jb2RlU2l6ZSA9IDA7XG4gICAgdGhpcy5jb2RlQnVmID0gMDtcbiAgICBEZWNvZGVTdHJlYW0uY2FsbCh0aGlzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGVjb2RlU3RyZWFtLnByb3RvdHlwZSk7XG5cbiAgY29uc3RydWN0b3IucHJvdG90eXBlLmdldEJpdHMgPSBmdW5jdGlvbiAoYml0cykge1xuICAgIHZhciBjb2RlU2l6ZSA9IHRoaXMuY29kZVNpemU7XG4gICAgdmFyIGNvZGVCdWYgPSB0aGlzLmNvZGVCdWY7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcztcbiAgICB2YXIgYnl0ZXNQb3MgPSB0aGlzLmJ5dGVzUG9zO1xuICAgIHZhciBiO1xuXG4gICAgd2hpbGUgKGNvZGVTaXplIDwgYml0cykge1xuICAgICAgaWYgKHR5cGVvZiAoYiA9IGJ5dGVzW2J5dGVzUG9zKytdKSA9PSAndW5kZWZpbmVkJykgZXJyb3IoJ0JhZCBlbmNvZGluZyBpbiBmbGF0ZSBzdHJlYW0nKTtcbiAgICAgIGNvZGVCdWYgfD0gYiA8PCBjb2RlU2l6ZTtcbiAgICAgIGNvZGVTaXplICs9IDg7XG4gICAgfVxuXG4gICAgYiA9IGNvZGVCdWYgJiAoMSA8PCBiaXRzKSAtIDE7XG4gICAgdGhpcy5jb2RlQnVmID0gY29kZUJ1ZiA+PiBiaXRzO1xuICAgIHRoaXMuY29kZVNpemUgPSBjb2RlU2l6ZSAtPSBiaXRzO1xuICAgIHRoaXMuYnl0ZXNQb3MgPSBieXRlc1BvcztcbiAgICByZXR1cm4gYjtcbiAgfTtcblxuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0Q29kZSA9IGZ1bmN0aW9uICh0YWJsZSkge1xuICAgIHZhciBjb2RlcyA9IHRhYmxlWzBdO1xuICAgIHZhciBtYXhMZW4gPSB0YWJsZVsxXTtcbiAgICB2YXIgY29kZVNpemUgPSB0aGlzLmNvZGVTaXplO1xuICAgIHZhciBjb2RlQnVmID0gdGhpcy5jb2RlQnVmO1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXM7XG4gICAgdmFyIGJ5dGVzUG9zID0gdGhpcy5ieXRlc1BvcztcblxuICAgIHdoaWxlIChjb2RlU2l6ZSA8IG1heExlbikge1xuICAgICAgdmFyIGI7XG4gICAgICBpZiAodHlwZW9mIChiID0gYnl0ZXNbYnl0ZXNQb3MrK10pID09ICd1bmRlZmluZWQnKSBlcnJvcignQmFkIGVuY29kaW5nIGluIGZsYXRlIHN0cmVhbScpO1xuICAgICAgY29kZUJ1ZiB8PSBiIDw8IGNvZGVTaXplO1xuICAgICAgY29kZVNpemUgKz0gODtcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IGNvZGVzW2NvZGVCdWYgJiAoMSA8PCBtYXhMZW4pIC0gMV07XG4gICAgdmFyIGNvZGVMZW4gPSBjb2RlID4+IDE2O1xuICAgIHZhciBjb2RlVmFsID0gY29kZSAmIDB4ZmZmZjtcbiAgICBpZiAoY29kZVNpemUgPT0gMCB8fCBjb2RlU2l6ZSA8IGNvZGVMZW4gfHwgY29kZUxlbiA9PSAwKSBlcnJvcignQmFkIGVuY29kaW5nIGluIGZsYXRlIHN0cmVhbScpO1xuICAgIHRoaXMuY29kZUJ1ZiA9IGNvZGVCdWYgPj4gY29kZUxlbjtcbiAgICB0aGlzLmNvZGVTaXplID0gY29kZVNpemUgLSBjb2RlTGVuO1xuICAgIHRoaXMuYnl0ZXNQb3MgPSBieXRlc1BvcztcbiAgICByZXR1cm4gY29kZVZhbDtcbiAgfTtcblxuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2VuZXJhdGVIdWZmbWFuVGFibGUgPSBmdW5jdGlvbiAobGVuZ3Rocykge1xuICAgIHZhciBuID0gbGVuZ3Rocy5sZW5ndGg7IC8vIGZpbmQgbWF4IGNvZGUgbGVuZ3RoXG5cbiAgICB2YXIgbWF4TGVuID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobGVuZ3Roc1tpXSA+IG1heExlbikgbWF4TGVuID0gbGVuZ3Roc1tpXTtcbiAgICB9IC8vIGJ1aWxkIHRoZSB0YWJsZVxuXG5cbiAgICB2YXIgc2l6ZSA9IDEgPDwgbWF4TGVuO1xuICAgIHZhciBjb2RlcyA9IG5ldyBVaW50MzJBcnJheShzaXplKTtcblxuICAgIGZvciAodmFyIGxlbiA9IDEsIGNvZGUgPSAwLCBza2lwID0gMjsgbGVuIDw9IG1heExlbjsgKytsZW4sIGNvZGUgPDw9IDEsIHNraXAgPDw9IDEpIHtcbiAgICAgIGZvciAodmFyIHZhbCA9IDA7IHZhbCA8IG47ICsrdmFsKSB7XG4gICAgICAgIGlmIChsZW5ndGhzW3ZhbF0gPT0gbGVuKSB7XG4gICAgICAgICAgLy8gYml0LXJldmVyc2UgdGhlIGNvZGVcbiAgICAgICAgICB2YXIgY29kZTIgPSAwO1xuICAgICAgICAgIHZhciB0ID0gY29kZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUyID0gY29kZTIgPDwgMSB8IHQgJiAxO1xuICAgICAgICAgICAgdCA+Pj0gMTtcbiAgICAgICAgICB9IC8vIGZpbGwgdGhlIHRhYmxlIGVudHJpZXNcblxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IGNvZGUyOyBpIDwgc2l6ZTsgaSArPSBza2lwKSB7XG4gICAgICAgICAgICBjb2Rlc1tpXSA9IGxlbiA8PCAxNiB8IHZhbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICArK2NvZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2NvZGVzLCBtYXhMZW5dO1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZWFkQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0cmVhbSwgYXJyYXksIGxlbiwgb2Zmc2V0LCB3aGF0KSB7XG4gICAgICB2YXIgcmVwZWF0ID0gc3RyZWFtLmdldEJpdHMobGVuKSArIG9mZnNldDtcblxuICAgICAgd2hpbGUgKHJlcGVhdC0tID4gMCkge1xuICAgICAgICBhcnJheVtpKytdID0gd2hhdDtcbiAgICAgIH1cbiAgICB9IC8vIHJlYWQgYmxvY2sgaGVhZGVyXG5cblxuICAgIHZhciBoZHIgPSB0aGlzLmdldEJpdHMoMyk7XG4gICAgaWYgKGhkciAmIDEpIHRoaXMuZW9mID0gdHJ1ZTtcbiAgICBoZHIgPj49IDE7XG5cbiAgICBpZiAoaGRyID09IDApIHtcbiAgICAgIC8vIHVuY29tcHJlc3NlZCBibG9ja1xuICAgICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcztcbiAgICAgIHZhciBieXRlc1BvcyA9IHRoaXMuYnl0ZXNQb3M7XG4gICAgICB2YXIgYjtcbiAgICAgIGlmICh0eXBlb2YgKGIgPSBieXRlc1tieXRlc1BvcysrXSkgPT0gJ3VuZGVmaW5lZCcpIGVycm9yKCdCYWQgYmxvY2sgaGVhZGVyIGluIGZsYXRlIHN0cmVhbScpO1xuICAgICAgdmFyIGJsb2NrTGVuID0gYjtcbiAgICAgIGlmICh0eXBlb2YgKGIgPSBieXRlc1tieXRlc1BvcysrXSkgPT0gJ3VuZGVmaW5lZCcpIGVycm9yKCdCYWQgYmxvY2sgaGVhZGVyIGluIGZsYXRlIHN0cmVhbScpO1xuICAgICAgYmxvY2tMZW4gfD0gYiA8PCA4O1xuICAgICAgaWYgKHR5cGVvZiAoYiA9IGJ5dGVzW2J5dGVzUG9zKytdKSA9PSAndW5kZWZpbmVkJykgZXJyb3IoJ0JhZCBibG9jayBoZWFkZXIgaW4gZmxhdGUgc3RyZWFtJyk7XG4gICAgICB2YXIgY2hlY2sgPSBiO1xuICAgICAgaWYgKHR5cGVvZiAoYiA9IGJ5dGVzW2J5dGVzUG9zKytdKSA9PSAndW5kZWZpbmVkJykgZXJyb3IoJ0JhZCBibG9jayBoZWFkZXIgaW4gZmxhdGUgc3RyZWFtJyk7XG4gICAgICBjaGVjayB8PSBiIDw8IDg7XG4gICAgICBpZiAoY2hlY2sgIT0gKH5ibG9ja0xlbiAmIDB4ZmZmZikpIGVycm9yKCdCYWQgdW5jb21wcmVzc2VkIGJsb2NrIGxlbmd0aCBpbiBmbGF0ZSBzdHJlYW0nKTtcbiAgICAgIHRoaXMuY29kZUJ1ZiA9IDA7XG4gICAgICB0aGlzLmNvZGVTaXplID0gMDtcbiAgICAgIHZhciBidWZmZXJMZW5ndGggPSB0aGlzLmJ1ZmZlckxlbmd0aDtcbiAgICAgIHZhciBidWZmZXIgPSB0aGlzLmVuc3VyZUJ1ZmZlcihidWZmZXJMZW5ndGggKyBibG9ja0xlbik7XG4gICAgICB2YXIgZW5kID0gYnVmZmVyTGVuZ3RoICsgYmxvY2tMZW47XG4gICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IGVuZDtcblxuICAgICAgZm9yICh2YXIgbiA9IGJ1ZmZlckxlbmd0aDsgbiA8IGVuZDsgKytuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGIgPSBieXRlc1tieXRlc1BvcysrXSkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLmVvZiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXJbbl0gPSBiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ5dGVzUG9zID0gYnl0ZXNQb3M7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpdENvZGVUYWJsZTtcbiAgICB2YXIgZGlzdENvZGVUYWJsZTtcblxuICAgIGlmIChoZHIgPT0gMSkge1xuICAgICAgLy8gY29tcHJlc3NlZCBibG9jaywgZml4ZWQgY29kZXNcbiAgICAgIGxpdENvZGVUYWJsZSA9IGZpeGVkTGl0Q29kZVRhYjtcbiAgICAgIGRpc3RDb2RlVGFibGUgPSBmaXhlZERpc3RDb2RlVGFiO1xuICAgIH0gZWxzZSBpZiAoaGRyID09IDIpIHtcbiAgICAgIC8vIGNvbXByZXNzZWQgYmxvY2ssIGR5bmFtaWMgY29kZXNcbiAgICAgIHZhciBudW1MaXRDb2RlcyA9IHRoaXMuZ2V0Qml0cyg1KSArIDI1NztcbiAgICAgIHZhciBudW1EaXN0Q29kZXMgPSB0aGlzLmdldEJpdHMoNSkgKyAxO1xuICAgICAgdmFyIG51bUNvZGVMZW5Db2RlcyA9IHRoaXMuZ2V0Qml0cyg0KSArIDQ7IC8vIGJ1aWxkIHRoZSBjb2RlIGxlbmd0aHMgY29kZSB0YWJsZVxuXG4gICAgICB2YXIgY29kZUxlbkNvZGVMZW5ndGhzID0gQXJyYXkoY29kZUxlbkNvZGVNYXAubGVuZ3RoKTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCBudW1Db2RlTGVuQ29kZXMpIHtcbiAgICAgICAgY29kZUxlbkNvZGVMZW5ndGhzW2NvZGVMZW5Db2RlTWFwW2krK11dID0gdGhpcy5nZXRCaXRzKDMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29kZUxlbkNvZGVUYWIgPSB0aGlzLmdlbmVyYXRlSHVmZm1hblRhYmxlKGNvZGVMZW5Db2RlTGVuZ3Rocyk7IC8vIGJ1aWxkIHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSBjb2RlIHRhYmxlc1xuXG4gICAgICB2YXIgbGVuID0gMDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBjb2RlcyA9IG51bUxpdENvZGVzICsgbnVtRGlzdENvZGVzO1xuICAgICAgdmFyIGNvZGVMZW5ndGhzID0gbmV3IEFycmF5KGNvZGVzKTtcblxuICAgICAgd2hpbGUgKGkgPCBjb2Rlcykge1xuICAgICAgICB2YXIgY29kZSA9IHRoaXMuZ2V0Q29kZShjb2RlTGVuQ29kZVRhYik7XG5cbiAgICAgICAgaWYgKGNvZGUgPT0gMTYpIHtcbiAgICAgICAgICByZXBlYXQodGhpcywgY29kZUxlbmd0aHMsIDIsIDMsIGxlbik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PSAxNykge1xuICAgICAgICAgIHJlcGVhdCh0aGlzLCBjb2RlTGVuZ3RocywgMywgMywgbGVuID0gMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PSAxOCkge1xuICAgICAgICAgIHJlcGVhdCh0aGlzLCBjb2RlTGVuZ3RocywgNywgMTEsIGxlbiA9IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGVMZW5ndGhzW2krK10gPSBsZW4gPSBjb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpdENvZGVUYWJsZSA9IHRoaXMuZ2VuZXJhdGVIdWZmbWFuVGFibGUoY29kZUxlbmd0aHMuc2xpY2UoMCwgbnVtTGl0Q29kZXMpKTtcbiAgICAgIGRpc3RDb2RlVGFibGUgPSB0aGlzLmdlbmVyYXRlSHVmZm1hblRhYmxlKGNvZGVMZW5ndGhzLnNsaWNlKG51bUxpdENvZGVzLCBjb2RlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcignVW5rbm93biBibG9jayB0eXBlIGluIGZsYXRlIHN0cmVhbScpO1xuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICB2YXIgbGltaXQgPSBidWZmZXIgPyBidWZmZXIubGVuZ3RoIDogMDtcbiAgICB2YXIgcG9zID0gdGhpcy5idWZmZXJMZW5ndGg7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGNvZGUxID0gdGhpcy5nZXRDb2RlKGxpdENvZGVUYWJsZSk7XG5cbiAgICAgIGlmIChjb2RlMSA8IDI1Nikge1xuICAgICAgICBpZiAocG9zICsgMSA+PSBsaW1pdCkge1xuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuZW5zdXJlQnVmZmVyKHBvcyArIDEpO1xuICAgICAgICAgIGxpbWl0ID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSBjb2RlMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlMSA9PSAyNTYpIHtcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBwb3M7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29kZTEgLT0gMjU3O1xuICAgICAgY29kZTEgPSBsZW5ndGhEZWNvZGVbY29kZTFdO1xuICAgICAgdmFyIGNvZGUyID0gY29kZTEgPj4gMTY7XG4gICAgICBpZiAoY29kZTIgPiAwKSBjb2RlMiA9IHRoaXMuZ2V0Qml0cyhjb2RlMik7XG4gICAgICB2YXIgbGVuID0gKGNvZGUxICYgMHhmZmZmKSArIGNvZGUyO1xuICAgICAgY29kZTEgPSB0aGlzLmdldENvZGUoZGlzdENvZGVUYWJsZSk7XG4gICAgICBjb2RlMSA9IGRpc3REZWNvZGVbY29kZTFdO1xuICAgICAgY29kZTIgPSBjb2RlMSA+PiAxNjtcbiAgICAgIGlmIChjb2RlMiA+IDApIGNvZGUyID0gdGhpcy5nZXRCaXRzKGNvZGUyKTtcbiAgICAgIHZhciBkaXN0ID0gKGNvZGUxICYgMHhmZmZmKSArIGNvZGUyO1xuXG4gICAgICBpZiAocG9zICsgbGVuID49IGxpbWl0KSB7XG4gICAgICAgIGJ1ZmZlciA9IHRoaXMuZW5zdXJlQnVmZmVyKHBvcyArIGxlbik7XG4gICAgICAgIGxpbWl0ID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47ICsraywgKytwb3MpIHtcbiAgICAgICAgYnVmZmVyW3Bvc10gPSBidWZmZXJbcG9zIC0gZGlzdF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjb25zdHJ1Y3Rvcjtcbn0oKTtcbi8qcm9sbHVwLWtlZXBlci1zdGFydCovXG5cblxud2luZG93LnRtcCA9IEZsYXRlU3RyZWFtO1xuLypyb2xsdXAta2VlcGVyLWVuZCovXG5cbnRyeSB7XG5tb2R1bGUuZXhwb3J0cyA9IGpzUERGO1xufVxuY2F0Y2ggKGUpIHt9XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jspdf/dist/jspdf.node.debug.js\n");

/***/ })

}]);